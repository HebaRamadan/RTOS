
FreeRTOS_CreateQueue.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000065fc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001a  00800060  000065fc  00006690  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006ae  0080007a  0080007a  000066aa  2**0
                  ALLOC
  3 .stab         00009630  00000000  00000000  000066ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000047a6  00000000  00000000  0000fcdc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 88 16 	jmp	0x2d10	; 0x2d10 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec ef       	ldi	r30, 0xFC	; 252
      68:	f5 e6       	ldi	r31, 0x65	; 101
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 37       	cpi	r26, 0x7A	; 122
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	aa e7       	ldi	r26, 0x7A	; 122
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 32       	cpi	r26, 0x28	; 40
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 01 13 	call	0x2602	; 0x2602 <main>
      8a:	0c 94 fc 32 	jmp	0x65f8	; 0x65f8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Dio_vidSetPinDir>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	66 97       	sbiw	r28, 0x16	; 22
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	8b 83       	std	Y+3, r24	; 0x03
      a8:	6c 83       	std	Y+4, r22	; 0x04
      aa:	8b 81       	ldd	r24, Y+3	; 0x03
      ac:	86 95       	lsr	r24
      ae:	86 95       	lsr	r24
      b0:	86 95       	lsr	r24
      b2:	8a 83       	std	Y+2, r24	; 0x02
      b4:	8b 81       	ldd	r24, Y+3	; 0x03
      b6:	87 70       	andi	r24, 0x07	; 7
      b8:	89 83       	std	Y+1, r24	; 0x01
      ba:	8a 81       	ldd	r24, Y+2	; 0x02
      bc:	28 2f       	mov	r18, r24
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	3e 8b       	std	Y+22, r19	; 0x16
      c2:	2d 8b       	std	Y+21, r18	; 0x15
      c4:	8d 89       	ldd	r24, Y+21	; 0x15
      c6:	9e 89       	ldd	r25, Y+22	; 0x16
      c8:	81 30       	cpi	r24, 0x01	; 1
      ca:	91 05       	cpc	r25, r1
      cc:	09 f4       	brne	.+2      	; 0xd0 <Dio_vidSetPinDir+0x3e>
      ce:	e1 c0       	rjmp	.+450    	; 0x292 <Dio_vidSetPinDir+0x200>
      d0:	2d 89       	ldd	r18, Y+21	; 0x15
      d2:	3e 89       	ldd	r19, Y+22	; 0x16
      d4:	22 30       	cpi	r18, 0x02	; 2
      d6:	31 05       	cpc	r19, r1
      d8:	2c f4       	brge	.+10     	; 0xe4 <Dio_vidSetPinDir+0x52>
      da:	8d 89       	ldd	r24, Y+21	; 0x15
      dc:	9e 89       	ldd	r25, Y+22	; 0x16
      de:	00 97       	sbiw	r24, 0x00	; 0
      e0:	71 f0       	breq	.+28     	; 0xfe <Dio_vidSetPinDir+0x6c>
      e2:	34 c3       	rjmp	.+1640   	; 0x74c <Dio_vidSetPinDir+0x6ba>
      e4:	2d 89       	ldd	r18, Y+21	; 0x15
      e6:	3e 89       	ldd	r19, Y+22	; 0x16
      e8:	22 30       	cpi	r18, 0x02	; 2
      ea:	31 05       	cpc	r19, r1
      ec:	09 f4       	brne	.+2      	; 0xf0 <Dio_vidSetPinDir+0x5e>
      ee:	9b c1       	rjmp	.+822    	; 0x426 <Dio_vidSetPinDir+0x394>
      f0:	8d 89       	ldd	r24, Y+21	; 0x15
      f2:	9e 89       	ldd	r25, Y+22	; 0x16
      f4:	83 30       	cpi	r24, 0x03	; 3
      f6:	91 05       	cpc	r25, r1
      f8:	09 f4       	brne	.+2      	; 0xfc <Dio_vidSetPinDir+0x6a>
      fa:	5f c2       	rjmp	.+1214   	; 0x5ba <Dio_vidSetPinDir+0x528>
      fc:	27 c3       	rjmp	.+1614   	; 0x74c <Dio_vidSetPinDir+0x6ba>
      fe:	8c 81       	ldd	r24, Y+4	; 0x04
     100:	81 30       	cpi	r24, 0x01	; 1
     102:	09 f0       	breq	.+2      	; 0x106 <Dio_vidSetPinDir+0x74>
     104:	63 c0       	rjmp	.+198    	; 0x1cc <Dio_vidSetPinDir+0x13a>
     106:	89 81       	ldd	r24, Y+1	; 0x01
     108:	28 2f       	mov	r18, r24
     10a:	30 e0       	ldi	r19, 0x00	; 0
     10c:	3c 8b       	std	Y+20, r19	; 0x14
     10e:	2b 8b       	std	Y+19, r18	; 0x13
     110:	8b 89       	ldd	r24, Y+19	; 0x13
     112:	9c 89       	ldd	r25, Y+20	; 0x14
     114:	83 30       	cpi	r24, 0x03	; 3
     116:	91 05       	cpc	r25, r1
     118:	d9 f1       	breq	.+118    	; 0x190 <Dio_vidSetPinDir+0xfe>
     11a:	2b 89       	ldd	r18, Y+19	; 0x13
     11c:	3c 89       	ldd	r19, Y+20	; 0x14
     11e:	24 30       	cpi	r18, 0x04	; 4
     120:	31 05       	cpc	r19, r1
     122:	7c f4       	brge	.+30     	; 0x142 <Dio_vidSetPinDir+0xb0>
     124:	8b 89       	ldd	r24, Y+19	; 0x13
     126:	9c 89       	ldd	r25, Y+20	; 0x14
     128:	81 30       	cpi	r24, 0x01	; 1
     12a:	91 05       	cpc	r25, r1
     12c:	29 f1       	breq	.+74     	; 0x178 <Dio_vidSetPinDir+0xe6>
     12e:	2b 89       	ldd	r18, Y+19	; 0x13
     130:	3c 89       	ldd	r19, Y+20	; 0x14
     132:	22 30       	cpi	r18, 0x02	; 2
     134:	31 05       	cpc	r19, r1
     136:	34 f5       	brge	.+76     	; 0x184 <Dio_vidSetPinDir+0xf2>
     138:	8b 89       	ldd	r24, Y+19	; 0x13
     13a:	9c 89       	ldd	r25, Y+20	; 0x14
     13c:	00 97       	sbiw	r24, 0x00	; 0
     13e:	b1 f0       	breq	.+44     	; 0x16c <Dio_vidSetPinDir+0xda>
     140:	05 c3       	rjmp	.+1546   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     142:	2b 89       	ldd	r18, Y+19	; 0x13
     144:	3c 89       	ldd	r19, Y+20	; 0x14
     146:	25 30       	cpi	r18, 0x05	; 5
     148:	31 05       	cpc	r19, r1
     14a:	71 f1       	breq	.+92     	; 0x1a8 <Dio_vidSetPinDir+0x116>
     14c:	8b 89       	ldd	r24, Y+19	; 0x13
     14e:	9c 89       	ldd	r25, Y+20	; 0x14
     150:	85 30       	cpi	r24, 0x05	; 5
     152:	91 05       	cpc	r25, r1
     154:	1c f1       	brlt	.+70     	; 0x19c <Dio_vidSetPinDir+0x10a>
     156:	2b 89       	ldd	r18, Y+19	; 0x13
     158:	3c 89       	ldd	r19, Y+20	; 0x14
     15a:	26 30       	cpi	r18, 0x06	; 6
     15c:	31 05       	cpc	r19, r1
     15e:	51 f1       	breq	.+84     	; 0x1b4 <Dio_vidSetPinDir+0x122>
     160:	8b 89       	ldd	r24, Y+19	; 0x13
     162:	9c 89       	ldd	r25, Y+20	; 0x14
     164:	87 30       	cpi	r24, 0x07	; 7
     166:	91 05       	cpc	r25, r1
     168:	59 f1       	breq	.+86     	; 0x1c0 <Dio_vidSetPinDir+0x12e>
     16a:	f0 c2       	rjmp	.+1504   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     16c:	ea e3       	ldi	r30, 0x3A	; 58
     16e:	f0 e0       	ldi	r31, 0x00	; 0
     170:	80 81       	ld	r24, Z
     172:	81 60       	ori	r24, 0x01	; 1
     174:	80 83       	st	Z, r24
     176:	ea c2       	rjmp	.+1492   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     178:	ea e3       	ldi	r30, 0x3A	; 58
     17a:	f0 e0       	ldi	r31, 0x00	; 0
     17c:	80 81       	ld	r24, Z
     17e:	82 60       	ori	r24, 0x02	; 2
     180:	80 83       	st	Z, r24
     182:	e4 c2       	rjmp	.+1480   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     184:	ea e3       	ldi	r30, 0x3A	; 58
     186:	f0 e0       	ldi	r31, 0x00	; 0
     188:	80 81       	ld	r24, Z
     18a:	84 60       	ori	r24, 0x04	; 4
     18c:	80 83       	st	Z, r24
     18e:	de c2       	rjmp	.+1468   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     190:	ea e3       	ldi	r30, 0x3A	; 58
     192:	f0 e0       	ldi	r31, 0x00	; 0
     194:	80 81       	ld	r24, Z
     196:	88 60       	ori	r24, 0x08	; 8
     198:	80 83       	st	Z, r24
     19a:	d8 c2       	rjmp	.+1456   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     19c:	ea e3       	ldi	r30, 0x3A	; 58
     19e:	f0 e0       	ldi	r31, 0x00	; 0
     1a0:	80 81       	ld	r24, Z
     1a2:	80 61       	ori	r24, 0x10	; 16
     1a4:	80 83       	st	Z, r24
     1a6:	d2 c2       	rjmp	.+1444   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     1a8:	ea e3       	ldi	r30, 0x3A	; 58
     1aa:	f0 e0       	ldi	r31, 0x00	; 0
     1ac:	80 81       	ld	r24, Z
     1ae:	80 62       	ori	r24, 0x20	; 32
     1b0:	80 83       	st	Z, r24
     1b2:	cc c2       	rjmp	.+1432   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     1b4:	ea e3       	ldi	r30, 0x3A	; 58
     1b6:	f0 e0       	ldi	r31, 0x00	; 0
     1b8:	80 81       	ld	r24, Z
     1ba:	80 64       	ori	r24, 0x40	; 64
     1bc:	80 83       	st	Z, r24
     1be:	c6 c2       	rjmp	.+1420   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     1c0:	ea e3       	ldi	r30, 0x3A	; 58
     1c2:	f0 e0       	ldi	r31, 0x00	; 0
     1c4:	80 81       	ld	r24, Z
     1c6:	80 68       	ori	r24, 0x80	; 128
     1c8:	80 83       	st	Z, r24
     1ca:	c0 c2       	rjmp	.+1408   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     1cc:	89 81       	ldd	r24, Y+1	; 0x01
     1ce:	28 2f       	mov	r18, r24
     1d0:	30 e0       	ldi	r19, 0x00	; 0
     1d2:	3a 8b       	std	Y+18, r19	; 0x12
     1d4:	29 8b       	std	Y+17, r18	; 0x11
     1d6:	89 89       	ldd	r24, Y+17	; 0x11
     1d8:	9a 89       	ldd	r25, Y+18	; 0x12
     1da:	83 30       	cpi	r24, 0x03	; 3
     1dc:	91 05       	cpc	r25, r1
     1de:	d9 f1       	breq	.+118    	; 0x256 <Dio_vidSetPinDir+0x1c4>
     1e0:	29 89       	ldd	r18, Y+17	; 0x11
     1e2:	3a 89       	ldd	r19, Y+18	; 0x12
     1e4:	24 30       	cpi	r18, 0x04	; 4
     1e6:	31 05       	cpc	r19, r1
     1e8:	7c f4       	brge	.+30     	; 0x208 <Dio_vidSetPinDir+0x176>
     1ea:	89 89       	ldd	r24, Y+17	; 0x11
     1ec:	9a 89       	ldd	r25, Y+18	; 0x12
     1ee:	81 30       	cpi	r24, 0x01	; 1
     1f0:	91 05       	cpc	r25, r1
     1f2:	29 f1       	breq	.+74     	; 0x23e <Dio_vidSetPinDir+0x1ac>
     1f4:	29 89       	ldd	r18, Y+17	; 0x11
     1f6:	3a 89       	ldd	r19, Y+18	; 0x12
     1f8:	22 30       	cpi	r18, 0x02	; 2
     1fa:	31 05       	cpc	r19, r1
     1fc:	34 f5       	brge	.+76     	; 0x24a <Dio_vidSetPinDir+0x1b8>
     1fe:	89 89       	ldd	r24, Y+17	; 0x11
     200:	9a 89       	ldd	r25, Y+18	; 0x12
     202:	00 97       	sbiw	r24, 0x00	; 0
     204:	b1 f0       	breq	.+44     	; 0x232 <Dio_vidSetPinDir+0x1a0>
     206:	a2 c2       	rjmp	.+1348   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     208:	29 89       	ldd	r18, Y+17	; 0x11
     20a:	3a 89       	ldd	r19, Y+18	; 0x12
     20c:	25 30       	cpi	r18, 0x05	; 5
     20e:	31 05       	cpc	r19, r1
     210:	71 f1       	breq	.+92     	; 0x26e <Dio_vidSetPinDir+0x1dc>
     212:	89 89       	ldd	r24, Y+17	; 0x11
     214:	9a 89       	ldd	r25, Y+18	; 0x12
     216:	85 30       	cpi	r24, 0x05	; 5
     218:	91 05       	cpc	r25, r1
     21a:	1c f1       	brlt	.+70     	; 0x262 <Dio_vidSetPinDir+0x1d0>
     21c:	29 89       	ldd	r18, Y+17	; 0x11
     21e:	3a 89       	ldd	r19, Y+18	; 0x12
     220:	26 30       	cpi	r18, 0x06	; 6
     222:	31 05       	cpc	r19, r1
     224:	51 f1       	breq	.+84     	; 0x27a <Dio_vidSetPinDir+0x1e8>
     226:	89 89       	ldd	r24, Y+17	; 0x11
     228:	9a 89       	ldd	r25, Y+18	; 0x12
     22a:	87 30       	cpi	r24, 0x07	; 7
     22c:	91 05       	cpc	r25, r1
     22e:	59 f1       	breq	.+86     	; 0x286 <Dio_vidSetPinDir+0x1f4>
     230:	8d c2       	rjmp	.+1306   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     232:	ea e3       	ldi	r30, 0x3A	; 58
     234:	f0 e0       	ldi	r31, 0x00	; 0
     236:	80 81       	ld	r24, Z
     238:	8e 7f       	andi	r24, 0xFE	; 254
     23a:	80 83       	st	Z, r24
     23c:	87 c2       	rjmp	.+1294   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     23e:	ea e3       	ldi	r30, 0x3A	; 58
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	80 81       	ld	r24, Z
     244:	8d 7f       	andi	r24, 0xFD	; 253
     246:	80 83       	st	Z, r24
     248:	81 c2       	rjmp	.+1282   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     24a:	ea e3       	ldi	r30, 0x3A	; 58
     24c:	f0 e0       	ldi	r31, 0x00	; 0
     24e:	80 81       	ld	r24, Z
     250:	8b 7f       	andi	r24, 0xFB	; 251
     252:	80 83       	st	Z, r24
     254:	7b c2       	rjmp	.+1270   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     256:	ea e3       	ldi	r30, 0x3A	; 58
     258:	f0 e0       	ldi	r31, 0x00	; 0
     25a:	80 81       	ld	r24, Z
     25c:	87 7f       	andi	r24, 0xF7	; 247
     25e:	80 83       	st	Z, r24
     260:	75 c2       	rjmp	.+1258   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     262:	ea e3       	ldi	r30, 0x3A	; 58
     264:	f0 e0       	ldi	r31, 0x00	; 0
     266:	80 81       	ld	r24, Z
     268:	8f 7e       	andi	r24, 0xEF	; 239
     26a:	80 83       	st	Z, r24
     26c:	6f c2       	rjmp	.+1246   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     26e:	ea e3       	ldi	r30, 0x3A	; 58
     270:	f0 e0       	ldi	r31, 0x00	; 0
     272:	80 81       	ld	r24, Z
     274:	8f 7d       	andi	r24, 0xDF	; 223
     276:	80 83       	st	Z, r24
     278:	69 c2       	rjmp	.+1234   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     27a:	ea e3       	ldi	r30, 0x3A	; 58
     27c:	f0 e0       	ldi	r31, 0x00	; 0
     27e:	80 81       	ld	r24, Z
     280:	8f 7b       	andi	r24, 0xBF	; 191
     282:	80 83       	st	Z, r24
     284:	63 c2       	rjmp	.+1222   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     286:	ea e3       	ldi	r30, 0x3A	; 58
     288:	f0 e0       	ldi	r31, 0x00	; 0
     28a:	80 81       	ld	r24, Z
     28c:	8f 77       	andi	r24, 0x7F	; 127
     28e:	80 83       	st	Z, r24
     290:	5d c2       	rjmp	.+1210   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     292:	8c 81       	ldd	r24, Y+4	; 0x04
     294:	81 30       	cpi	r24, 0x01	; 1
     296:	09 f0       	breq	.+2      	; 0x29a <Dio_vidSetPinDir+0x208>
     298:	63 c0       	rjmp	.+198    	; 0x360 <Dio_vidSetPinDir+0x2ce>
     29a:	89 81       	ldd	r24, Y+1	; 0x01
     29c:	28 2f       	mov	r18, r24
     29e:	30 e0       	ldi	r19, 0x00	; 0
     2a0:	38 8b       	std	Y+16, r19	; 0x10
     2a2:	2f 87       	std	Y+15, r18	; 0x0f
     2a4:	8f 85       	ldd	r24, Y+15	; 0x0f
     2a6:	98 89       	ldd	r25, Y+16	; 0x10
     2a8:	83 30       	cpi	r24, 0x03	; 3
     2aa:	91 05       	cpc	r25, r1
     2ac:	d9 f1       	breq	.+118    	; 0x324 <Dio_vidSetPinDir+0x292>
     2ae:	2f 85       	ldd	r18, Y+15	; 0x0f
     2b0:	38 89       	ldd	r19, Y+16	; 0x10
     2b2:	24 30       	cpi	r18, 0x04	; 4
     2b4:	31 05       	cpc	r19, r1
     2b6:	7c f4       	brge	.+30     	; 0x2d6 <Dio_vidSetPinDir+0x244>
     2b8:	8f 85       	ldd	r24, Y+15	; 0x0f
     2ba:	98 89       	ldd	r25, Y+16	; 0x10
     2bc:	81 30       	cpi	r24, 0x01	; 1
     2be:	91 05       	cpc	r25, r1
     2c0:	29 f1       	breq	.+74     	; 0x30c <Dio_vidSetPinDir+0x27a>
     2c2:	2f 85       	ldd	r18, Y+15	; 0x0f
     2c4:	38 89       	ldd	r19, Y+16	; 0x10
     2c6:	22 30       	cpi	r18, 0x02	; 2
     2c8:	31 05       	cpc	r19, r1
     2ca:	34 f5       	brge	.+76     	; 0x318 <Dio_vidSetPinDir+0x286>
     2cc:	8f 85       	ldd	r24, Y+15	; 0x0f
     2ce:	98 89       	ldd	r25, Y+16	; 0x10
     2d0:	00 97       	sbiw	r24, 0x00	; 0
     2d2:	b1 f0       	breq	.+44     	; 0x300 <Dio_vidSetPinDir+0x26e>
     2d4:	3b c2       	rjmp	.+1142   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     2d6:	2f 85       	ldd	r18, Y+15	; 0x0f
     2d8:	38 89       	ldd	r19, Y+16	; 0x10
     2da:	25 30       	cpi	r18, 0x05	; 5
     2dc:	31 05       	cpc	r19, r1
     2de:	71 f1       	breq	.+92     	; 0x33c <Dio_vidSetPinDir+0x2aa>
     2e0:	8f 85       	ldd	r24, Y+15	; 0x0f
     2e2:	98 89       	ldd	r25, Y+16	; 0x10
     2e4:	85 30       	cpi	r24, 0x05	; 5
     2e6:	91 05       	cpc	r25, r1
     2e8:	1c f1       	brlt	.+70     	; 0x330 <Dio_vidSetPinDir+0x29e>
     2ea:	2f 85       	ldd	r18, Y+15	; 0x0f
     2ec:	38 89       	ldd	r19, Y+16	; 0x10
     2ee:	26 30       	cpi	r18, 0x06	; 6
     2f0:	31 05       	cpc	r19, r1
     2f2:	51 f1       	breq	.+84     	; 0x348 <Dio_vidSetPinDir+0x2b6>
     2f4:	8f 85       	ldd	r24, Y+15	; 0x0f
     2f6:	98 89       	ldd	r25, Y+16	; 0x10
     2f8:	87 30       	cpi	r24, 0x07	; 7
     2fa:	91 05       	cpc	r25, r1
     2fc:	59 f1       	breq	.+86     	; 0x354 <Dio_vidSetPinDir+0x2c2>
     2fe:	26 c2       	rjmp	.+1100   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     300:	e7 e3       	ldi	r30, 0x37	; 55
     302:	f0 e0       	ldi	r31, 0x00	; 0
     304:	80 81       	ld	r24, Z
     306:	81 60       	ori	r24, 0x01	; 1
     308:	80 83       	st	Z, r24
     30a:	20 c2       	rjmp	.+1088   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     30c:	e7 e3       	ldi	r30, 0x37	; 55
     30e:	f0 e0       	ldi	r31, 0x00	; 0
     310:	80 81       	ld	r24, Z
     312:	82 60       	ori	r24, 0x02	; 2
     314:	80 83       	st	Z, r24
     316:	1a c2       	rjmp	.+1076   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     318:	e7 e3       	ldi	r30, 0x37	; 55
     31a:	f0 e0       	ldi	r31, 0x00	; 0
     31c:	80 81       	ld	r24, Z
     31e:	84 60       	ori	r24, 0x04	; 4
     320:	80 83       	st	Z, r24
     322:	14 c2       	rjmp	.+1064   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     324:	e7 e3       	ldi	r30, 0x37	; 55
     326:	f0 e0       	ldi	r31, 0x00	; 0
     328:	80 81       	ld	r24, Z
     32a:	88 60       	ori	r24, 0x08	; 8
     32c:	80 83       	st	Z, r24
     32e:	0e c2       	rjmp	.+1052   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     330:	e7 e3       	ldi	r30, 0x37	; 55
     332:	f0 e0       	ldi	r31, 0x00	; 0
     334:	80 81       	ld	r24, Z
     336:	80 61       	ori	r24, 0x10	; 16
     338:	80 83       	st	Z, r24
     33a:	08 c2       	rjmp	.+1040   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     33c:	e7 e3       	ldi	r30, 0x37	; 55
     33e:	f0 e0       	ldi	r31, 0x00	; 0
     340:	80 81       	ld	r24, Z
     342:	80 62       	ori	r24, 0x20	; 32
     344:	80 83       	st	Z, r24
     346:	02 c2       	rjmp	.+1028   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     348:	e7 e3       	ldi	r30, 0x37	; 55
     34a:	f0 e0       	ldi	r31, 0x00	; 0
     34c:	80 81       	ld	r24, Z
     34e:	80 64       	ori	r24, 0x40	; 64
     350:	80 83       	st	Z, r24
     352:	fc c1       	rjmp	.+1016   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     354:	e7 e3       	ldi	r30, 0x37	; 55
     356:	f0 e0       	ldi	r31, 0x00	; 0
     358:	80 81       	ld	r24, Z
     35a:	80 68       	ori	r24, 0x80	; 128
     35c:	80 83       	st	Z, r24
     35e:	f6 c1       	rjmp	.+1004   	; 0x74c <Dio_vidSetPinDir+0x6ba>
     360:	89 81       	ldd	r24, Y+1	; 0x01
     362:	28 2f       	mov	r18, r24
     364:	30 e0       	ldi	r19, 0x00	; 0
     366:	3e 87       	std	Y+14, r19	; 0x0e
     368:	2d 87       	std	Y+13, r18	; 0x0d
     36a:	8d 85       	ldd	r24, Y+13	; 0x0d
     36c:	9e 85       	ldd	r25, Y+14	; 0x0e
     36e:	83 30       	cpi	r24, 0x03	; 3
     370:	91 05       	cpc	r25, r1
     372:	d9 f1       	breq	.+118    	; 0x3ea <Dio_vidSetPinDir+0x358>
     374:	2d 85       	ldd	r18, Y+13	; 0x0d
     376:	3e 85       	ldd	r19, Y+14	; 0x0e
     378:	24 30       	cpi	r18, 0x04	; 4
     37a:	31 05       	cpc	r19, r1
     37c:	7c f4       	brge	.+30     	; 0x39c <Dio_vidSetPinDir+0x30a>
     37e:	8d 85       	ldd	r24, Y+13	; 0x0d
     380:	9e 85       	ldd	r25, Y+14	; 0x0e
     382:	81 30       	cpi	r24, 0x01	; 1
     384:	91 05       	cpc	r25, r1
     386:	29 f1       	breq	.+74     	; 0x3d2 <Dio_vidSetPinDir+0x340>
     388:	2d 85       	ldd	r18, Y+13	; 0x0d
     38a:	3e 85       	ldd	r19, Y+14	; 0x0e
     38c:	22 30       	cpi	r18, 0x02	; 2
     38e:	31 05       	cpc	r19, r1
     390:	34 f5       	brge	.+76     	; 0x3de <Dio_vidSetPinDir+0x34c>
     392:	8d 85       	ldd	r24, Y+13	; 0x0d
     394:	9e 85       	ldd	r25, Y+14	; 0x0e
     396:	00 97       	sbiw	r24, 0x00	; 0
     398:	b1 f0       	breq	.+44     	; 0x3c6 <Dio_vidSetPinDir+0x334>
     39a:	d8 c1       	rjmp	.+944    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     39c:	2d 85       	ldd	r18, Y+13	; 0x0d
     39e:	3e 85       	ldd	r19, Y+14	; 0x0e
     3a0:	25 30       	cpi	r18, 0x05	; 5
     3a2:	31 05       	cpc	r19, r1
     3a4:	71 f1       	breq	.+92     	; 0x402 <Dio_vidSetPinDir+0x370>
     3a6:	8d 85       	ldd	r24, Y+13	; 0x0d
     3a8:	9e 85       	ldd	r25, Y+14	; 0x0e
     3aa:	85 30       	cpi	r24, 0x05	; 5
     3ac:	91 05       	cpc	r25, r1
     3ae:	1c f1       	brlt	.+70     	; 0x3f6 <Dio_vidSetPinDir+0x364>
     3b0:	2d 85       	ldd	r18, Y+13	; 0x0d
     3b2:	3e 85       	ldd	r19, Y+14	; 0x0e
     3b4:	26 30       	cpi	r18, 0x06	; 6
     3b6:	31 05       	cpc	r19, r1
     3b8:	51 f1       	breq	.+84     	; 0x40e <Dio_vidSetPinDir+0x37c>
     3ba:	8d 85       	ldd	r24, Y+13	; 0x0d
     3bc:	9e 85       	ldd	r25, Y+14	; 0x0e
     3be:	87 30       	cpi	r24, 0x07	; 7
     3c0:	91 05       	cpc	r25, r1
     3c2:	59 f1       	breq	.+86     	; 0x41a <Dio_vidSetPinDir+0x388>
     3c4:	c3 c1       	rjmp	.+902    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     3c6:	e7 e3       	ldi	r30, 0x37	; 55
     3c8:	f0 e0       	ldi	r31, 0x00	; 0
     3ca:	80 81       	ld	r24, Z
     3cc:	8e 7f       	andi	r24, 0xFE	; 254
     3ce:	80 83       	st	Z, r24
     3d0:	bd c1       	rjmp	.+890    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     3d2:	e7 e3       	ldi	r30, 0x37	; 55
     3d4:	f0 e0       	ldi	r31, 0x00	; 0
     3d6:	80 81       	ld	r24, Z
     3d8:	8d 7f       	andi	r24, 0xFD	; 253
     3da:	80 83       	st	Z, r24
     3dc:	b7 c1       	rjmp	.+878    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     3de:	e7 e3       	ldi	r30, 0x37	; 55
     3e0:	f0 e0       	ldi	r31, 0x00	; 0
     3e2:	80 81       	ld	r24, Z
     3e4:	8b 7f       	andi	r24, 0xFB	; 251
     3e6:	80 83       	st	Z, r24
     3e8:	b1 c1       	rjmp	.+866    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     3ea:	e7 e3       	ldi	r30, 0x37	; 55
     3ec:	f0 e0       	ldi	r31, 0x00	; 0
     3ee:	80 81       	ld	r24, Z
     3f0:	87 7f       	andi	r24, 0xF7	; 247
     3f2:	80 83       	st	Z, r24
     3f4:	ab c1       	rjmp	.+854    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     3f6:	e7 e3       	ldi	r30, 0x37	; 55
     3f8:	f0 e0       	ldi	r31, 0x00	; 0
     3fa:	80 81       	ld	r24, Z
     3fc:	8f 7e       	andi	r24, 0xEF	; 239
     3fe:	80 83       	st	Z, r24
     400:	a5 c1       	rjmp	.+842    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     402:	e7 e3       	ldi	r30, 0x37	; 55
     404:	f0 e0       	ldi	r31, 0x00	; 0
     406:	80 81       	ld	r24, Z
     408:	8f 7d       	andi	r24, 0xDF	; 223
     40a:	80 83       	st	Z, r24
     40c:	9f c1       	rjmp	.+830    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     40e:	e7 e3       	ldi	r30, 0x37	; 55
     410:	f0 e0       	ldi	r31, 0x00	; 0
     412:	80 81       	ld	r24, Z
     414:	8f 7b       	andi	r24, 0xBF	; 191
     416:	80 83       	st	Z, r24
     418:	99 c1       	rjmp	.+818    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     41a:	e7 e3       	ldi	r30, 0x37	; 55
     41c:	f0 e0       	ldi	r31, 0x00	; 0
     41e:	80 81       	ld	r24, Z
     420:	8f 77       	andi	r24, 0x7F	; 127
     422:	80 83       	st	Z, r24
     424:	93 c1       	rjmp	.+806    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     426:	8c 81       	ldd	r24, Y+4	; 0x04
     428:	81 30       	cpi	r24, 0x01	; 1
     42a:	09 f0       	breq	.+2      	; 0x42e <Dio_vidSetPinDir+0x39c>
     42c:	63 c0       	rjmp	.+198    	; 0x4f4 <Dio_vidSetPinDir+0x462>
     42e:	89 81       	ldd	r24, Y+1	; 0x01
     430:	28 2f       	mov	r18, r24
     432:	30 e0       	ldi	r19, 0x00	; 0
     434:	3c 87       	std	Y+12, r19	; 0x0c
     436:	2b 87       	std	Y+11, r18	; 0x0b
     438:	8b 85       	ldd	r24, Y+11	; 0x0b
     43a:	9c 85       	ldd	r25, Y+12	; 0x0c
     43c:	83 30       	cpi	r24, 0x03	; 3
     43e:	91 05       	cpc	r25, r1
     440:	d9 f1       	breq	.+118    	; 0x4b8 <Dio_vidSetPinDir+0x426>
     442:	2b 85       	ldd	r18, Y+11	; 0x0b
     444:	3c 85       	ldd	r19, Y+12	; 0x0c
     446:	24 30       	cpi	r18, 0x04	; 4
     448:	31 05       	cpc	r19, r1
     44a:	7c f4       	brge	.+30     	; 0x46a <Dio_vidSetPinDir+0x3d8>
     44c:	8b 85       	ldd	r24, Y+11	; 0x0b
     44e:	9c 85       	ldd	r25, Y+12	; 0x0c
     450:	81 30       	cpi	r24, 0x01	; 1
     452:	91 05       	cpc	r25, r1
     454:	29 f1       	breq	.+74     	; 0x4a0 <Dio_vidSetPinDir+0x40e>
     456:	2b 85       	ldd	r18, Y+11	; 0x0b
     458:	3c 85       	ldd	r19, Y+12	; 0x0c
     45a:	22 30       	cpi	r18, 0x02	; 2
     45c:	31 05       	cpc	r19, r1
     45e:	34 f5       	brge	.+76     	; 0x4ac <Dio_vidSetPinDir+0x41a>
     460:	8b 85       	ldd	r24, Y+11	; 0x0b
     462:	9c 85       	ldd	r25, Y+12	; 0x0c
     464:	00 97       	sbiw	r24, 0x00	; 0
     466:	b1 f0       	breq	.+44     	; 0x494 <Dio_vidSetPinDir+0x402>
     468:	71 c1       	rjmp	.+738    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     46a:	2b 85       	ldd	r18, Y+11	; 0x0b
     46c:	3c 85       	ldd	r19, Y+12	; 0x0c
     46e:	25 30       	cpi	r18, 0x05	; 5
     470:	31 05       	cpc	r19, r1
     472:	71 f1       	breq	.+92     	; 0x4d0 <Dio_vidSetPinDir+0x43e>
     474:	8b 85       	ldd	r24, Y+11	; 0x0b
     476:	9c 85       	ldd	r25, Y+12	; 0x0c
     478:	85 30       	cpi	r24, 0x05	; 5
     47a:	91 05       	cpc	r25, r1
     47c:	1c f1       	brlt	.+70     	; 0x4c4 <Dio_vidSetPinDir+0x432>
     47e:	2b 85       	ldd	r18, Y+11	; 0x0b
     480:	3c 85       	ldd	r19, Y+12	; 0x0c
     482:	26 30       	cpi	r18, 0x06	; 6
     484:	31 05       	cpc	r19, r1
     486:	51 f1       	breq	.+84     	; 0x4dc <Dio_vidSetPinDir+0x44a>
     488:	8b 85       	ldd	r24, Y+11	; 0x0b
     48a:	9c 85       	ldd	r25, Y+12	; 0x0c
     48c:	87 30       	cpi	r24, 0x07	; 7
     48e:	91 05       	cpc	r25, r1
     490:	59 f1       	breq	.+86     	; 0x4e8 <Dio_vidSetPinDir+0x456>
     492:	5c c1       	rjmp	.+696    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     494:	e4 e3       	ldi	r30, 0x34	; 52
     496:	f0 e0       	ldi	r31, 0x00	; 0
     498:	80 81       	ld	r24, Z
     49a:	81 60       	ori	r24, 0x01	; 1
     49c:	80 83       	st	Z, r24
     49e:	56 c1       	rjmp	.+684    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     4a0:	e4 e3       	ldi	r30, 0x34	; 52
     4a2:	f0 e0       	ldi	r31, 0x00	; 0
     4a4:	80 81       	ld	r24, Z
     4a6:	82 60       	ori	r24, 0x02	; 2
     4a8:	80 83       	st	Z, r24
     4aa:	50 c1       	rjmp	.+672    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     4ac:	e4 e3       	ldi	r30, 0x34	; 52
     4ae:	f0 e0       	ldi	r31, 0x00	; 0
     4b0:	80 81       	ld	r24, Z
     4b2:	84 60       	ori	r24, 0x04	; 4
     4b4:	80 83       	st	Z, r24
     4b6:	4a c1       	rjmp	.+660    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     4b8:	e4 e3       	ldi	r30, 0x34	; 52
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	80 81       	ld	r24, Z
     4be:	88 60       	ori	r24, 0x08	; 8
     4c0:	80 83       	st	Z, r24
     4c2:	44 c1       	rjmp	.+648    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     4c4:	e4 e3       	ldi	r30, 0x34	; 52
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	80 81       	ld	r24, Z
     4ca:	80 61       	ori	r24, 0x10	; 16
     4cc:	80 83       	st	Z, r24
     4ce:	3e c1       	rjmp	.+636    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     4d0:	e4 e3       	ldi	r30, 0x34	; 52
     4d2:	f0 e0       	ldi	r31, 0x00	; 0
     4d4:	80 81       	ld	r24, Z
     4d6:	80 62       	ori	r24, 0x20	; 32
     4d8:	80 83       	st	Z, r24
     4da:	38 c1       	rjmp	.+624    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     4dc:	e4 e3       	ldi	r30, 0x34	; 52
     4de:	f0 e0       	ldi	r31, 0x00	; 0
     4e0:	80 81       	ld	r24, Z
     4e2:	80 64       	ori	r24, 0x40	; 64
     4e4:	80 83       	st	Z, r24
     4e6:	32 c1       	rjmp	.+612    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     4e8:	e4 e3       	ldi	r30, 0x34	; 52
     4ea:	f0 e0       	ldi	r31, 0x00	; 0
     4ec:	80 81       	ld	r24, Z
     4ee:	80 68       	ori	r24, 0x80	; 128
     4f0:	80 83       	st	Z, r24
     4f2:	2c c1       	rjmp	.+600    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     4f4:	89 81       	ldd	r24, Y+1	; 0x01
     4f6:	28 2f       	mov	r18, r24
     4f8:	30 e0       	ldi	r19, 0x00	; 0
     4fa:	3a 87       	std	Y+10, r19	; 0x0a
     4fc:	29 87       	std	Y+9, r18	; 0x09
     4fe:	89 85       	ldd	r24, Y+9	; 0x09
     500:	9a 85       	ldd	r25, Y+10	; 0x0a
     502:	83 30       	cpi	r24, 0x03	; 3
     504:	91 05       	cpc	r25, r1
     506:	d9 f1       	breq	.+118    	; 0x57e <Dio_vidSetPinDir+0x4ec>
     508:	29 85       	ldd	r18, Y+9	; 0x09
     50a:	3a 85       	ldd	r19, Y+10	; 0x0a
     50c:	24 30       	cpi	r18, 0x04	; 4
     50e:	31 05       	cpc	r19, r1
     510:	7c f4       	brge	.+30     	; 0x530 <Dio_vidSetPinDir+0x49e>
     512:	89 85       	ldd	r24, Y+9	; 0x09
     514:	9a 85       	ldd	r25, Y+10	; 0x0a
     516:	81 30       	cpi	r24, 0x01	; 1
     518:	91 05       	cpc	r25, r1
     51a:	29 f1       	breq	.+74     	; 0x566 <Dio_vidSetPinDir+0x4d4>
     51c:	29 85       	ldd	r18, Y+9	; 0x09
     51e:	3a 85       	ldd	r19, Y+10	; 0x0a
     520:	22 30       	cpi	r18, 0x02	; 2
     522:	31 05       	cpc	r19, r1
     524:	34 f5       	brge	.+76     	; 0x572 <Dio_vidSetPinDir+0x4e0>
     526:	89 85       	ldd	r24, Y+9	; 0x09
     528:	9a 85       	ldd	r25, Y+10	; 0x0a
     52a:	00 97       	sbiw	r24, 0x00	; 0
     52c:	b1 f0       	breq	.+44     	; 0x55a <Dio_vidSetPinDir+0x4c8>
     52e:	0e c1       	rjmp	.+540    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     530:	29 85       	ldd	r18, Y+9	; 0x09
     532:	3a 85       	ldd	r19, Y+10	; 0x0a
     534:	25 30       	cpi	r18, 0x05	; 5
     536:	31 05       	cpc	r19, r1
     538:	71 f1       	breq	.+92     	; 0x596 <Dio_vidSetPinDir+0x504>
     53a:	89 85       	ldd	r24, Y+9	; 0x09
     53c:	9a 85       	ldd	r25, Y+10	; 0x0a
     53e:	85 30       	cpi	r24, 0x05	; 5
     540:	91 05       	cpc	r25, r1
     542:	1c f1       	brlt	.+70     	; 0x58a <Dio_vidSetPinDir+0x4f8>
     544:	29 85       	ldd	r18, Y+9	; 0x09
     546:	3a 85       	ldd	r19, Y+10	; 0x0a
     548:	26 30       	cpi	r18, 0x06	; 6
     54a:	31 05       	cpc	r19, r1
     54c:	51 f1       	breq	.+84     	; 0x5a2 <Dio_vidSetPinDir+0x510>
     54e:	89 85       	ldd	r24, Y+9	; 0x09
     550:	9a 85       	ldd	r25, Y+10	; 0x0a
     552:	87 30       	cpi	r24, 0x07	; 7
     554:	91 05       	cpc	r25, r1
     556:	59 f1       	breq	.+86     	; 0x5ae <Dio_vidSetPinDir+0x51c>
     558:	f9 c0       	rjmp	.+498    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     55a:	e4 e3       	ldi	r30, 0x34	; 52
     55c:	f0 e0       	ldi	r31, 0x00	; 0
     55e:	80 81       	ld	r24, Z
     560:	8e 7f       	andi	r24, 0xFE	; 254
     562:	80 83       	st	Z, r24
     564:	f3 c0       	rjmp	.+486    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     566:	e4 e3       	ldi	r30, 0x34	; 52
     568:	f0 e0       	ldi	r31, 0x00	; 0
     56a:	80 81       	ld	r24, Z
     56c:	8d 7f       	andi	r24, 0xFD	; 253
     56e:	80 83       	st	Z, r24
     570:	ed c0       	rjmp	.+474    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     572:	e4 e3       	ldi	r30, 0x34	; 52
     574:	f0 e0       	ldi	r31, 0x00	; 0
     576:	80 81       	ld	r24, Z
     578:	8b 7f       	andi	r24, 0xFB	; 251
     57a:	80 83       	st	Z, r24
     57c:	e7 c0       	rjmp	.+462    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     57e:	e4 e3       	ldi	r30, 0x34	; 52
     580:	f0 e0       	ldi	r31, 0x00	; 0
     582:	80 81       	ld	r24, Z
     584:	87 7f       	andi	r24, 0xF7	; 247
     586:	80 83       	st	Z, r24
     588:	e1 c0       	rjmp	.+450    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     58a:	e4 e3       	ldi	r30, 0x34	; 52
     58c:	f0 e0       	ldi	r31, 0x00	; 0
     58e:	80 81       	ld	r24, Z
     590:	8f 7e       	andi	r24, 0xEF	; 239
     592:	80 83       	st	Z, r24
     594:	db c0       	rjmp	.+438    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     596:	e4 e3       	ldi	r30, 0x34	; 52
     598:	f0 e0       	ldi	r31, 0x00	; 0
     59a:	80 81       	ld	r24, Z
     59c:	8f 7d       	andi	r24, 0xDF	; 223
     59e:	80 83       	st	Z, r24
     5a0:	d5 c0       	rjmp	.+426    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     5a2:	e4 e3       	ldi	r30, 0x34	; 52
     5a4:	f0 e0       	ldi	r31, 0x00	; 0
     5a6:	80 81       	ld	r24, Z
     5a8:	8f 7b       	andi	r24, 0xBF	; 191
     5aa:	80 83       	st	Z, r24
     5ac:	cf c0       	rjmp	.+414    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     5ae:	e4 e3       	ldi	r30, 0x34	; 52
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
     5b2:	80 81       	ld	r24, Z
     5b4:	8f 77       	andi	r24, 0x7F	; 127
     5b6:	80 83       	st	Z, r24
     5b8:	c9 c0       	rjmp	.+402    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     5ba:	8c 81       	ldd	r24, Y+4	; 0x04
     5bc:	81 30       	cpi	r24, 0x01	; 1
     5be:	09 f0       	breq	.+2      	; 0x5c2 <Dio_vidSetPinDir+0x530>
     5c0:	63 c0       	rjmp	.+198    	; 0x688 <Dio_vidSetPinDir+0x5f6>
     5c2:	89 81       	ldd	r24, Y+1	; 0x01
     5c4:	28 2f       	mov	r18, r24
     5c6:	30 e0       	ldi	r19, 0x00	; 0
     5c8:	38 87       	std	Y+8, r19	; 0x08
     5ca:	2f 83       	std	Y+7, r18	; 0x07
     5cc:	8f 81       	ldd	r24, Y+7	; 0x07
     5ce:	98 85       	ldd	r25, Y+8	; 0x08
     5d0:	83 30       	cpi	r24, 0x03	; 3
     5d2:	91 05       	cpc	r25, r1
     5d4:	d9 f1       	breq	.+118    	; 0x64c <Dio_vidSetPinDir+0x5ba>
     5d6:	2f 81       	ldd	r18, Y+7	; 0x07
     5d8:	38 85       	ldd	r19, Y+8	; 0x08
     5da:	24 30       	cpi	r18, 0x04	; 4
     5dc:	31 05       	cpc	r19, r1
     5de:	7c f4       	brge	.+30     	; 0x5fe <Dio_vidSetPinDir+0x56c>
     5e0:	8f 81       	ldd	r24, Y+7	; 0x07
     5e2:	98 85       	ldd	r25, Y+8	; 0x08
     5e4:	81 30       	cpi	r24, 0x01	; 1
     5e6:	91 05       	cpc	r25, r1
     5e8:	29 f1       	breq	.+74     	; 0x634 <Dio_vidSetPinDir+0x5a2>
     5ea:	2f 81       	ldd	r18, Y+7	; 0x07
     5ec:	38 85       	ldd	r19, Y+8	; 0x08
     5ee:	22 30       	cpi	r18, 0x02	; 2
     5f0:	31 05       	cpc	r19, r1
     5f2:	34 f5       	brge	.+76     	; 0x640 <Dio_vidSetPinDir+0x5ae>
     5f4:	8f 81       	ldd	r24, Y+7	; 0x07
     5f6:	98 85       	ldd	r25, Y+8	; 0x08
     5f8:	00 97       	sbiw	r24, 0x00	; 0
     5fa:	b1 f0       	breq	.+44     	; 0x628 <Dio_vidSetPinDir+0x596>
     5fc:	a7 c0       	rjmp	.+334    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     5fe:	2f 81       	ldd	r18, Y+7	; 0x07
     600:	38 85       	ldd	r19, Y+8	; 0x08
     602:	25 30       	cpi	r18, 0x05	; 5
     604:	31 05       	cpc	r19, r1
     606:	71 f1       	breq	.+92     	; 0x664 <Dio_vidSetPinDir+0x5d2>
     608:	8f 81       	ldd	r24, Y+7	; 0x07
     60a:	98 85       	ldd	r25, Y+8	; 0x08
     60c:	85 30       	cpi	r24, 0x05	; 5
     60e:	91 05       	cpc	r25, r1
     610:	1c f1       	brlt	.+70     	; 0x658 <Dio_vidSetPinDir+0x5c6>
     612:	2f 81       	ldd	r18, Y+7	; 0x07
     614:	38 85       	ldd	r19, Y+8	; 0x08
     616:	26 30       	cpi	r18, 0x06	; 6
     618:	31 05       	cpc	r19, r1
     61a:	51 f1       	breq	.+84     	; 0x670 <Dio_vidSetPinDir+0x5de>
     61c:	8f 81       	ldd	r24, Y+7	; 0x07
     61e:	98 85       	ldd	r25, Y+8	; 0x08
     620:	87 30       	cpi	r24, 0x07	; 7
     622:	91 05       	cpc	r25, r1
     624:	59 f1       	breq	.+86     	; 0x67c <Dio_vidSetPinDir+0x5ea>
     626:	92 c0       	rjmp	.+292    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     628:	e1 e3       	ldi	r30, 0x31	; 49
     62a:	f0 e0       	ldi	r31, 0x00	; 0
     62c:	80 81       	ld	r24, Z
     62e:	81 60       	ori	r24, 0x01	; 1
     630:	80 83       	st	Z, r24
     632:	8c c0       	rjmp	.+280    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     634:	e1 e3       	ldi	r30, 0x31	; 49
     636:	f0 e0       	ldi	r31, 0x00	; 0
     638:	80 81       	ld	r24, Z
     63a:	82 60       	ori	r24, 0x02	; 2
     63c:	80 83       	st	Z, r24
     63e:	86 c0       	rjmp	.+268    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     640:	e1 e3       	ldi	r30, 0x31	; 49
     642:	f0 e0       	ldi	r31, 0x00	; 0
     644:	80 81       	ld	r24, Z
     646:	84 60       	ori	r24, 0x04	; 4
     648:	80 83       	st	Z, r24
     64a:	80 c0       	rjmp	.+256    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     64c:	e1 e3       	ldi	r30, 0x31	; 49
     64e:	f0 e0       	ldi	r31, 0x00	; 0
     650:	80 81       	ld	r24, Z
     652:	88 60       	ori	r24, 0x08	; 8
     654:	80 83       	st	Z, r24
     656:	7a c0       	rjmp	.+244    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     658:	e1 e3       	ldi	r30, 0x31	; 49
     65a:	f0 e0       	ldi	r31, 0x00	; 0
     65c:	80 81       	ld	r24, Z
     65e:	80 61       	ori	r24, 0x10	; 16
     660:	80 83       	st	Z, r24
     662:	74 c0       	rjmp	.+232    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     664:	e1 e3       	ldi	r30, 0x31	; 49
     666:	f0 e0       	ldi	r31, 0x00	; 0
     668:	80 81       	ld	r24, Z
     66a:	80 62       	ori	r24, 0x20	; 32
     66c:	80 83       	st	Z, r24
     66e:	6e c0       	rjmp	.+220    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     670:	e1 e3       	ldi	r30, 0x31	; 49
     672:	f0 e0       	ldi	r31, 0x00	; 0
     674:	80 81       	ld	r24, Z
     676:	80 64       	ori	r24, 0x40	; 64
     678:	80 83       	st	Z, r24
     67a:	68 c0       	rjmp	.+208    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     67c:	e1 e3       	ldi	r30, 0x31	; 49
     67e:	f0 e0       	ldi	r31, 0x00	; 0
     680:	80 81       	ld	r24, Z
     682:	80 68       	ori	r24, 0x80	; 128
     684:	80 83       	st	Z, r24
     686:	62 c0       	rjmp	.+196    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     688:	89 81       	ldd	r24, Y+1	; 0x01
     68a:	28 2f       	mov	r18, r24
     68c:	30 e0       	ldi	r19, 0x00	; 0
     68e:	3e 83       	std	Y+6, r19	; 0x06
     690:	2d 83       	std	Y+5, r18	; 0x05
     692:	8d 81       	ldd	r24, Y+5	; 0x05
     694:	9e 81       	ldd	r25, Y+6	; 0x06
     696:	83 30       	cpi	r24, 0x03	; 3
     698:	91 05       	cpc	r25, r1
     69a:	d9 f1       	breq	.+118    	; 0x712 <Dio_vidSetPinDir+0x680>
     69c:	2d 81       	ldd	r18, Y+5	; 0x05
     69e:	3e 81       	ldd	r19, Y+6	; 0x06
     6a0:	24 30       	cpi	r18, 0x04	; 4
     6a2:	31 05       	cpc	r19, r1
     6a4:	7c f4       	brge	.+30     	; 0x6c4 <Dio_vidSetPinDir+0x632>
     6a6:	8d 81       	ldd	r24, Y+5	; 0x05
     6a8:	9e 81       	ldd	r25, Y+6	; 0x06
     6aa:	81 30       	cpi	r24, 0x01	; 1
     6ac:	91 05       	cpc	r25, r1
     6ae:	29 f1       	breq	.+74     	; 0x6fa <Dio_vidSetPinDir+0x668>
     6b0:	2d 81       	ldd	r18, Y+5	; 0x05
     6b2:	3e 81       	ldd	r19, Y+6	; 0x06
     6b4:	22 30       	cpi	r18, 0x02	; 2
     6b6:	31 05       	cpc	r19, r1
     6b8:	34 f5       	brge	.+76     	; 0x706 <Dio_vidSetPinDir+0x674>
     6ba:	8d 81       	ldd	r24, Y+5	; 0x05
     6bc:	9e 81       	ldd	r25, Y+6	; 0x06
     6be:	00 97       	sbiw	r24, 0x00	; 0
     6c0:	b1 f0       	breq	.+44     	; 0x6ee <Dio_vidSetPinDir+0x65c>
     6c2:	44 c0       	rjmp	.+136    	; 0x74c <Dio_vidSetPinDir+0x6ba>
     6c4:	2d 81       	ldd	r18, Y+5	; 0x05
     6c6:	3e 81       	ldd	r19, Y+6	; 0x06
     6c8:	25 30       	cpi	r18, 0x05	; 5
     6ca:	31 05       	cpc	r19, r1
     6cc:	71 f1       	breq	.+92     	; 0x72a <Dio_vidSetPinDir+0x698>
     6ce:	8d 81       	ldd	r24, Y+5	; 0x05
     6d0:	9e 81       	ldd	r25, Y+6	; 0x06
     6d2:	85 30       	cpi	r24, 0x05	; 5
     6d4:	91 05       	cpc	r25, r1
     6d6:	1c f1       	brlt	.+70     	; 0x71e <Dio_vidSetPinDir+0x68c>
     6d8:	2d 81       	ldd	r18, Y+5	; 0x05
     6da:	3e 81       	ldd	r19, Y+6	; 0x06
     6dc:	26 30       	cpi	r18, 0x06	; 6
     6de:	31 05       	cpc	r19, r1
     6e0:	51 f1       	breq	.+84     	; 0x736 <Dio_vidSetPinDir+0x6a4>
     6e2:	8d 81       	ldd	r24, Y+5	; 0x05
     6e4:	9e 81       	ldd	r25, Y+6	; 0x06
     6e6:	87 30       	cpi	r24, 0x07	; 7
     6e8:	91 05       	cpc	r25, r1
     6ea:	59 f1       	breq	.+86     	; 0x742 <Dio_vidSetPinDir+0x6b0>
     6ec:	2f c0       	rjmp	.+94     	; 0x74c <Dio_vidSetPinDir+0x6ba>
     6ee:	e1 e3       	ldi	r30, 0x31	; 49
     6f0:	f0 e0       	ldi	r31, 0x00	; 0
     6f2:	80 81       	ld	r24, Z
     6f4:	8e 7f       	andi	r24, 0xFE	; 254
     6f6:	80 83       	st	Z, r24
     6f8:	29 c0       	rjmp	.+82     	; 0x74c <Dio_vidSetPinDir+0x6ba>
     6fa:	e1 e3       	ldi	r30, 0x31	; 49
     6fc:	f0 e0       	ldi	r31, 0x00	; 0
     6fe:	80 81       	ld	r24, Z
     700:	8d 7f       	andi	r24, 0xFD	; 253
     702:	80 83       	st	Z, r24
     704:	23 c0       	rjmp	.+70     	; 0x74c <Dio_vidSetPinDir+0x6ba>
     706:	e1 e3       	ldi	r30, 0x31	; 49
     708:	f0 e0       	ldi	r31, 0x00	; 0
     70a:	80 81       	ld	r24, Z
     70c:	8b 7f       	andi	r24, 0xFB	; 251
     70e:	80 83       	st	Z, r24
     710:	1d c0       	rjmp	.+58     	; 0x74c <Dio_vidSetPinDir+0x6ba>
     712:	e1 e3       	ldi	r30, 0x31	; 49
     714:	f0 e0       	ldi	r31, 0x00	; 0
     716:	80 81       	ld	r24, Z
     718:	87 7f       	andi	r24, 0xF7	; 247
     71a:	80 83       	st	Z, r24
     71c:	17 c0       	rjmp	.+46     	; 0x74c <Dio_vidSetPinDir+0x6ba>
     71e:	e1 e3       	ldi	r30, 0x31	; 49
     720:	f0 e0       	ldi	r31, 0x00	; 0
     722:	80 81       	ld	r24, Z
     724:	8f 7e       	andi	r24, 0xEF	; 239
     726:	80 83       	st	Z, r24
     728:	11 c0       	rjmp	.+34     	; 0x74c <Dio_vidSetPinDir+0x6ba>
     72a:	e1 e3       	ldi	r30, 0x31	; 49
     72c:	f0 e0       	ldi	r31, 0x00	; 0
     72e:	80 81       	ld	r24, Z
     730:	8f 7d       	andi	r24, 0xDF	; 223
     732:	80 83       	st	Z, r24
     734:	0b c0       	rjmp	.+22     	; 0x74c <Dio_vidSetPinDir+0x6ba>
     736:	e1 e3       	ldi	r30, 0x31	; 49
     738:	f0 e0       	ldi	r31, 0x00	; 0
     73a:	80 81       	ld	r24, Z
     73c:	8f 7b       	andi	r24, 0xBF	; 191
     73e:	80 83       	st	Z, r24
     740:	05 c0       	rjmp	.+10     	; 0x74c <Dio_vidSetPinDir+0x6ba>
     742:	e1 e3       	ldi	r30, 0x31	; 49
     744:	f0 e0       	ldi	r31, 0x00	; 0
     746:	80 81       	ld	r24, Z
     748:	8f 77       	andi	r24, 0x7F	; 127
     74a:	80 83       	st	Z, r24
     74c:	66 96       	adiw	r28, 0x16	; 22
     74e:	0f b6       	in	r0, 0x3f	; 63
     750:	f8 94       	cli
     752:	de bf       	out	0x3e, r29	; 62
     754:	0f be       	out	0x3f, r0	; 63
     756:	cd bf       	out	0x3d, r28	; 61
     758:	cf 91       	pop	r28
     75a:	df 91       	pop	r29
     75c:	08 95       	ret

0000075e <Dio_vidSetPinVal>:
		break;
	}
}

void Dio_vidSetPinVal(u8 Pin , u8 Val)
{
     75e:	df 93       	push	r29
     760:	cf 93       	push	r28
     762:	cd b7       	in	r28, 0x3d	; 61
     764:	de b7       	in	r29, 0x3e	; 62
     766:	66 97       	sbiw	r28, 0x16	; 22
     768:	0f b6       	in	r0, 0x3f	; 63
     76a:	f8 94       	cli
     76c:	de bf       	out	0x3e, r29	; 62
     76e:	0f be       	out	0x3f, r0	; 63
     770:	cd bf       	out	0x3d, r28	; 61
     772:	8b 83       	std	Y+3, r24	; 0x03
     774:	6c 83       	std	Y+4, r22	; 0x04
	u8 PortId;
	u8 PinLoc;

	PortId = Pin/8;
     776:	8b 81       	ldd	r24, Y+3	; 0x03
     778:	86 95       	lsr	r24
     77a:	86 95       	lsr	r24
     77c:	86 95       	lsr	r24
     77e:	8a 83       	std	Y+2, r24	; 0x02
	PinLoc = Pin%8;
     780:	8b 81       	ldd	r24, Y+3	; 0x03
     782:	87 70       	andi	r24, 0x07	; 7
     784:	89 83       	std	Y+1, r24	; 0x01

	switch(PortId){
     786:	8a 81       	ldd	r24, Y+2	; 0x02
     788:	28 2f       	mov	r18, r24
     78a:	30 e0       	ldi	r19, 0x00	; 0
     78c:	3e 8b       	std	Y+22, r19	; 0x16
     78e:	2d 8b       	std	Y+21, r18	; 0x15
     790:	8d 89       	ldd	r24, Y+21	; 0x15
     792:	9e 89       	ldd	r25, Y+22	; 0x16
     794:	81 30       	cpi	r24, 0x01	; 1
     796:	91 05       	cpc	r25, r1
     798:	09 f4       	brne	.+2      	; 0x79c <Dio_vidSetPinVal+0x3e>
     79a:	e1 c0       	rjmp	.+450    	; 0x95e <__stack+0xff>
     79c:	2d 89       	ldd	r18, Y+21	; 0x15
     79e:	3e 89       	ldd	r19, Y+22	; 0x16
     7a0:	22 30       	cpi	r18, 0x02	; 2
     7a2:	31 05       	cpc	r19, r1
     7a4:	2c f4       	brge	.+10     	; 0x7b0 <Dio_vidSetPinVal+0x52>
     7a6:	8d 89       	ldd	r24, Y+21	; 0x15
     7a8:	9e 89       	ldd	r25, Y+22	; 0x16
     7aa:	00 97       	sbiw	r24, 0x00	; 0
     7ac:	71 f0       	breq	.+28     	; 0x7ca <Dio_vidSetPinVal+0x6c>
     7ae:	34 c3       	rjmp	.+1640   	; 0xe18 <__stack+0x5b9>
     7b0:	2d 89       	ldd	r18, Y+21	; 0x15
     7b2:	3e 89       	ldd	r19, Y+22	; 0x16
     7b4:	22 30       	cpi	r18, 0x02	; 2
     7b6:	31 05       	cpc	r19, r1
     7b8:	09 f4       	brne	.+2      	; 0x7bc <Dio_vidSetPinVal+0x5e>
     7ba:	9b c1       	rjmp	.+822    	; 0xaf2 <__stack+0x293>
     7bc:	8d 89       	ldd	r24, Y+21	; 0x15
     7be:	9e 89       	ldd	r25, Y+22	; 0x16
     7c0:	83 30       	cpi	r24, 0x03	; 3
     7c2:	91 05       	cpc	r25, r1
     7c4:	09 f4       	brne	.+2      	; 0x7c8 <Dio_vidSetPinVal+0x6a>
     7c6:	5f c2       	rjmp	.+1214   	; 0xc86 <__stack+0x427>
     7c8:	27 c3       	rjmp	.+1614   	; 0xe18 <__stack+0x5b9>
		case 0:
			if(Val ==1)
     7ca:	8c 81       	ldd	r24, Y+4	; 0x04
     7cc:	81 30       	cpi	r24, 0x01	; 1
     7ce:	09 f0       	breq	.+2      	; 0x7d2 <Dio_vidSetPinVal+0x74>
     7d0:	63 c0       	rjmp	.+198    	; 0x898 <__stack+0x39>
				{
					switch(PinLoc)
     7d2:	89 81       	ldd	r24, Y+1	; 0x01
     7d4:	28 2f       	mov	r18, r24
     7d6:	30 e0       	ldi	r19, 0x00	; 0
     7d8:	3c 8b       	std	Y+20, r19	; 0x14
     7da:	2b 8b       	std	Y+19, r18	; 0x13
     7dc:	8b 89       	ldd	r24, Y+19	; 0x13
     7de:	9c 89       	ldd	r25, Y+20	; 0x14
     7e0:	83 30       	cpi	r24, 0x03	; 3
     7e2:	91 05       	cpc	r25, r1
     7e4:	d9 f1       	breq	.+118    	; 0x85c <Dio_vidSetPinVal+0xfe>
     7e6:	2b 89       	ldd	r18, Y+19	; 0x13
     7e8:	3c 89       	ldd	r19, Y+20	; 0x14
     7ea:	24 30       	cpi	r18, 0x04	; 4
     7ec:	31 05       	cpc	r19, r1
     7ee:	7c f4       	brge	.+30     	; 0x80e <Dio_vidSetPinVal+0xb0>
     7f0:	8b 89       	ldd	r24, Y+19	; 0x13
     7f2:	9c 89       	ldd	r25, Y+20	; 0x14
     7f4:	81 30       	cpi	r24, 0x01	; 1
     7f6:	91 05       	cpc	r25, r1
     7f8:	29 f1       	breq	.+74     	; 0x844 <Dio_vidSetPinVal+0xe6>
     7fa:	2b 89       	ldd	r18, Y+19	; 0x13
     7fc:	3c 89       	ldd	r19, Y+20	; 0x14
     7fe:	22 30       	cpi	r18, 0x02	; 2
     800:	31 05       	cpc	r19, r1
     802:	34 f5       	brge	.+76     	; 0x850 <Dio_vidSetPinVal+0xf2>
     804:	8b 89       	ldd	r24, Y+19	; 0x13
     806:	9c 89       	ldd	r25, Y+20	; 0x14
     808:	00 97       	sbiw	r24, 0x00	; 0
     80a:	b1 f0       	breq	.+44     	; 0x838 <Dio_vidSetPinVal+0xda>
     80c:	05 c3       	rjmp	.+1546   	; 0xe18 <__stack+0x5b9>
     80e:	2b 89       	ldd	r18, Y+19	; 0x13
     810:	3c 89       	ldd	r19, Y+20	; 0x14
     812:	25 30       	cpi	r18, 0x05	; 5
     814:	31 05       	cpc	r19, r1
     816:	71 f1       	breq	.+92     	; 0x874 <__stack+0x15>
     818:	8b 89       	ldd	r24, Y+19	; 0x13
     81a:	9c 89       	ldd	r25, Y+20	; 0x14
     81c:	85 30       	cpi	r24, 0x05	; 5
     81e:	91 05       	cpc	r25, r1
     820:	1c f1       	brlt	.+70     	; 0x868 <__stack+0x9>
     822:	2b 89       	ldd	r18, Y+19	; 0x13
     824:	3c 89       	ldd	r19, Y+20	; 0x14
     826:	26 30       	cpi	r18, 0x06	; 6
     828:	31 05       	cpc	r19, r1
     82a:	51 f1       	breq	.+84     	; 0x880 <__stack+0x21>
     82c:	8b 89       	ldd	r24, Y+19	; 0x13
     82e:	9c 89       	ldd	r25, Y+20	; 0x14
     830:	87 30       	cpi	r24, 0x07	; 7
     832:	91 05       	cpc	r25, r1
     834:	59 f1       	breq	.+86     	; 0x88c <__stack+0x2d>
     836:	f0 c2       	rjmp	.+1504   	; 0xe18 <__stack+0x5b9>
					{
						case 0:
							PORTA.Bits.Pin0 =1;
     838:	eb e3       	ldi	r30, 0x3B	; 59
     83a:	f0 e0       	ldi	r31, 0x00	; 0
     83c:	80 81       	ld	r24, Z
     83e:	81 60       	ori	r24, 0x01	; 1
     840:	80 83       	st	Z, r24
     842:	ea c2       	rjmp	.+1492   	; 0xe18 <__stack+0x5b9>
						break;

						case 1:
							PORTA.Bits.Pin1 =1;
     844:	eb e3       	ldi	r30, 0x3B	; 59
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	80 81       	ld	r24, Z
     84a:	82 60       	ori	r24, 0x02	; 2
     84c:	80 83       	st	Z, r24
     84e:	e4 c2       	rjmp	.+1480   	; 0xe18 <__stack+0x5b9>
						break;

						case 2:
							PORTA.Bits.Pin2 =1;
     850:	eb e3       	ldi	r30, 0x3B	; 59
     852:	f0 e0       	ldi	r31, 0x00	; 0
     854:	80 81       	ld	r24, Z
     856:	84 60       	ori	r24, 0x04	; 4
     858:	80 83       	st	Z, r24
     85a:	de c2       	rjmp	.+1468   	; 0xe18 <__stack+0x5b9>
						break;

						case 3:
							PORTA.Bits.Pin3 =1;
     85c:	eb e3       	ldi	r30, 0x3B	; 59
     85e:	f0 e0       	ldi	r31, 0x00	; 0
     860:	80 81       	ld	r24, Z
     862:	88 60       	ori	r24, 0x08	; 8
     864:	80 83       	st	Z, r24
     866:	d8 c2       	rjmp	.+1456   	; 0xe18 <__stack+0x5b9>
						break;

						case 4:
							PORTA.Bits.Pin4 =1;
     868:	eb e3       	ldi	r30, 0x3B	; 59
     86a:	f0 e0       	ldi	r31, 0x00	; 0
     86c:	80 81       	ld	r24, Z
     86e:	80 61       	ori	r24, 0x10	; 16
     870:	80 83       	st	Z, r24
     872:	d2 c2       	rjmp	.+1444   	; 0xe18 <__stack+0x5b9>
						break;

						case 5:
							PORTA.Bits.Pin5 =1;
     874:	eb e3       	ldi	r30, 0x3B	; 59
     876:	f0 e0       	ldi	r31, 0x00	; 0
     878:	80 81       	ld	r24, Z
     87a:	80 62       	ori	r24, 0x20	; 32
     87c:	80 83       	st	Z, r24
     87e:	cc c2       	rjmp	.+1432   	; 0xe18 <__stack+0x5b9>
						break;

						case 6:
							PORTA.Bits.Pin6 =1;
     880:	eb e3       	ldi	r30, 0x3B	; 59
     882:	f0 e0       	ldi	r31, 0x00	; 0
     884:	80 81       	ld	r24, Z
     886:	80 64       	ori	r24, 0x40	; 64
     888:	80 83       	st	Z, r24
     88a:	c6 c2       	rjmp	.+1420   	; 0xe18 <__stack+0x5b9>
						break;

						case 7:
							PORTA.Bits.Pin7 =1;
     88c:	eb e3       	ldi	r30, 0x3B	; 59
     88e:	f0 e0       	ldi	r31, 0x00	; 0
     890:	80 81       	ld	r24, Z
     892:	80 68       	ori	r24, 0x80	; 128
     894:	80 83       	st	Z, r24
     896:	c0 c2       	rjmp	.+1408   	; 0xe18 <__stack+0x5b9>
						break;
					}
				}
			else
			{
				switch(PinLoc)
     898:	89 81       	ldd	r24, Y+1	; 0x01
     89a:	28 2f       	mov	r18, r24
     89c:	30 e0       	ldi	r19, 0x00	; 0
     89e:	3a 8b       	std	Y+18, r19	; 0x12
     8a0:	29 8b       	std	Y+17, r18	; 0x11
     8a2:	89 89       	ldd	r24, Y+17	; 0x11
     8a4:	9a 89       	ldd	r25, Y+18	; 0x12
     8a6:	83 30       	cpi	r24, 0x03	; 3
     8a8:	91 05       	cpc	r25, r1
     8aa:	d9 f1       	breq	.+118    	; 0x922 <__stack+0xc3>
     8ac:	29 89       	ldd	r18, Y+17	; 0x11
     8ae:	3a 89       	ldd	r19, Y+18	; 0x12
     8b0:	24 30       	cpi	r18, 0x04	; 4
     8b2:	31 05       	cpc	r19, r1
     8b4:	7c f4       	brge	.+30     	; 0x8d4 <__stack+0x75>
     8b6:	89 89       	ldd	r24, Y+17	; 0x11
     8b8:	9a 89       	ldd	r25, Y+18	; 0x12
     8ba:	81 30       	cpi	r24, 0x01	; 1
     8bc:	91 05       	cpc	r25, r1
     8be:	29 f1       	breq	.+74     	; 0x90a <__stack+0xab>
     8c0:	29 89       	ldd	r18, Y+17	; 0x11
     8c2:	3a 89       	ldd	r19, Y+18	; 0x12
     8c4:	22 30       	cpi	r18, 0x02	; 2
     8c6:	31 05       	cpc	r19, r1
     8c8:	34 f5       	brge	.+76     	; 0x916 <__stack+0xb7>
     8ca:	89 89       	ldd	r24, Y+17	; 0x11
     8cc:	9a 89       	ldd	r25, Y+18	; 0x12
     8ce:	00 97       	sbiw	r24, 0x00	; 0
     8d0:	b1 f0       	breq	.+44     	; 0x8fe <__stack+0x9f>
     8d2:	a2 c2       	rjmp	.+1348   	; 0xe18 <__stack+0x5b9>
     8d4:	29 89       	ldd	r18, Y+17	; 0x11
     8d6:	3a 89       	ldd	r19, Y+18	; 0x12
     8d8:	25 30       	cpi	r18, 0x05	; 5
     8da:	31 05       	cpc	r19, r1
     8dc:	71 f1       	breq	.+92     	; 0x93a <__stack+0xdb>
     8de:	89 89       	ldd	r24, Y+17	; 0x11
     8e0:	9a 89       	ldd	r25, Y+18	; 0x12
     8e2:	85 30       	cpi	r24, 0x05	; 5
     8e4:	91 05       	cpc	r25, r1
     8e6:	1c f1       	brlt	.+70     	; 0x92e <__stack+0xcf>
     8e8:	29 89       	ldd	r18, Y+17	; 0x11
     8ea:	3a 89       	ldd	r19, Y+18	; 0x12
     8ec:	26 30       	cpi	r18, 0x06	; 6
     8ee:	31 05       	cpc	r19, r1
     8f0:	51 f1       	breq	.+84     	; 0x946 <__stack+0xe7>
     8f2:	89 89       	ldd	r24, Y+17	; 0x11
     8f4:	9a 89       	ldd	r25, Y+18	; 0x12
     8f6:	87 30       	cpi	r24, 0x07	; 7
     8f8:	91 05       	cpc	r25, r1
     8fa:	59 f1       	breq	.+86     	; 0x952 <__stack+0xf3>
     8fc:	8d c2       	rjmp	.+1306   	; 0xe18 <__stack+0x5b9>
				{
					case 0:
						PORTA.Bits.Pin0 =0;
     8fe:	eb e3       	ldi	r30, 0x3B	; 59
     900:	f0 e0       	ldi	r31, 0x00	; 0
     902:	80 81       	ld	r24, Z
     904:	8e 7f       	andi	r24, 0xFE	; 254
     906:	80 83       	st	Z, r24
     908:	87 c2       	rjmp	.+1294   	; 0xe18 <__stack+0x5b9>
					break;

					case 1:
						PORTA.Bits.Pin1 =0;
     90a:	eb e3       	ldi	r30, 0x3B	; 59
     90c:	f0 e0       	ldi	r31, 0x00	; 0
     90e:	80 81       	ld	r24, Z
     910:	8d 7f       	andi	r24, 0xFD	; 253
     912:	80 83       	st	Z, r24
     914:	81 c2       	rjmp	.+1282   	; 0xe18 <__stack+0x5b9>
					break;

					case 2:
						PORTA.Bits.Pin2 =0;
     916:	eb e3       	ldi	r30, 0x3B	; 59
     918:	f0 e0       	ldi	r31, 0x00	; 0
     91a:	80 81       	ld	r24, Z
     91c:	8b 7f       	andi	r24, 0xFB	; 251
     91e:	80 83       	st	Z, r24
     920:	7b c2       	rjmp	.+1270   	; 0xe18 <__stack+0x5b9>
					break;

					case 3:
						PORTA.Bits.Pin3 =0;
     922:	eb e3       	ldi	r30, 0x3B	; 59
     924:	f0 e0       	ldi	r31, 0x00	; 0
     926:	80 81       	ld	r24, Z
     928:	87 7f       	andi	r24, 0xF7	; 247
     92a:	80 83       	st	Z, r24
     92c:	75 c2       	rjmp	.+1258   	; 0xe18 <__stack+0x5b9>
					break;

					case 4:
						PORTA.Bits.Pin4 =0;
     92e:	eb e3       	ldi	r30, 0x3B	; 59
     930:	f0 e0       	ldi	r31, 0x00	; 0
     932:	80 81       	ld	r24, Z
     934:	8f 7e       	andi	r24, 0xEF	; 239
     936:	80 83       	st	Z, r24
     938:	6f c2       	rjmp	.+1246   	; 0xe18 <__stack+0x5b9>
					break;

					case 5:
						PORTA.Bits.Pin5 =0;
     93a:	eb e3       	ldi	r30, 0x3B	; 59
     93c:	f0 e0       	ldi	r31, 0x00	; 0
     93e:	80 81       	ld	r24, Z
     940:	8f 7d       	andi	r24, 0xDF	; 223
     942:	80 83       	st	Z, r24
     944:	69 c2       	rjmp	.+1234   	; 0xe18 <__stack+0x5b9>
					break;

					case 6:
						PORTA.Bits.Pin6 =0;
     946:	eb e3       	ldi	r30, 0x3B	; 59
     948:	f0 e0       	ldi	r31, 0x00	; 0
     94a:	80 81       	ld	r24, Z
     94c:	8f 7b       	andi	r24, 0xBF	; 191
     94e:	80 83       	st	Z, r24
     950:	63 c2       	rjmp	.+1222   	; 0xe18 <__stack+0x5b9>
					break;

					case 7:
						PORTA.Bits.Pin7 =0;
     952:	eb e3       	ldi	r30, 0x3B	; 59
     954:	f0 e0       	ldi	r31, 0x00	; 0
     956:	80 81       	ld	r24, Z
     958:	8f 77       	andi	r24, 0x7F	; 127
     95a:	80 83       	st	Z, r24
     95c:	5d c2       	rjmp	.+1210   	; 0xe18 <__stack+0x5b9>
				}
			}
		break;

		case 1:
			if(Val ==1)
     95e:	8c 81       	ldd	r24, Y+4	; 0x04
     960:	81 30       	cpi	r24, 0x01	; 1
     962:	09 f0       	breq	.+2      	; 0x966 <__stack+0x107>
     964:	63 c0       	rjmp	.+198    	; 0xa2c <__stack+0x1cd>
				{
					switch(PinLoc)
     966:	89 81       	ldd	r24, Y+1	; 0x01
     968:	28 2f       	mov	r18, r24
     96a:	30 e0       	ldi	r19, 0x00	; 0
     96c:	38 8b       	std	Y+16, r19	; 0x10
     96e:	2f 87       	std	Y+15, r18	; 0x0f
     970:	8f 85       	ldd	r24, Y+15	; 0x0f
     972:	98 89       	ldd	r25, Y+16	; 0x10
     974:	83 30       	cpi	r24, 0x03	; 3
     976:	91 05       	cpc	r25, r1
     978:	d9 f1       	breq	.+118    	; 0x9f0 <__stack+0x191>
     97a:	2f 85       	ldd	r18, Y+15	; 0x0f
     97c:	38 89       	ldd	r19, Y+16	; 0x10
     97e:	24 30       	cpi	r18, 0x04	; 4
     980:	31 05       	cpc	r19, r1
     982:	7c f4       	brge	.+30     	; 0x9a2 <__stack+0x143>
     984:	8f 85       	ldd	r24, Y+15	; 0x0f
     986:	98 89       	ldd	r25, Y+16	; 0x10
     988:	81 30       	cpi	r24, 0x01	; 1
     98a:	91 05       	cpc	r25, r1
     98c:	29 f1       	breq	.+74     	; 0x9d8 <__stack+0x179>
     98e:	2f 85       	ldd	r18, Y+15	; 0x0f
     990:	38 89       	ldd	r19, Y+16	; 0x10
     992:	22 30       	cpi	r18, 0x02	; 2
     994:	31 05       	cpc	r19, r1
     996:	34 f5       	brge	.+76     	; 0x9e4 <__stack+0x185>
     998:	8f 85       	ldd	r24, Y+15	; 0x0f
     99a:	98 89       	ldd	r25, Y+16	; 0x10
     99c:	00 97       	sbiw	r24, 0x00	; 0
     99e:	b1 f0       	breq	.+44     	; 0x9cc <__stack+0x16d>
     9a0:	3b c2       	rjmp	.+1142   	; 0xe18 <__stack+0x5b9>
     9a2:	2f 85       	ldd	r18, Y+15	; 0x0f
     9a4:	38 89       	ldd	r19, Y+16	; 0x10
     9a6:	25 30       	cpi	r18, 0x05	; 5
     9a8:	31 05       	cpc	r19, r1
     9aa:	71 f1       	breq	.+92     	; 0xa08 <__stack+0x1a9>
     9ac:	8f 85       	ldd	r24, Y+15	; 0x0f
     9ae:	98 89       	ldd	r25, Y+16	; 0x10
     9b0:	85 30       	cpi	r24, 0x05	; 5
     9b2:	91 05       	cpc	r25, r1
     9b4:	1c f1       	brlt	.+70     	; 0x9fc <__stack+0x19d>
     9b6:	2f 85       	ldd	r18, Y+15	; 0x0f
     9b8:	38 89       	ldd	r19, Y+16	; 0x10
     9ba:	26 30       	cpi	r18, 0x06	; 6
     9bc:	31 05       	cpc	r19, r1
     9be:	51 f1       	breq	.+84     	; 0xa14 <__stack+0x1b5>
     9c0:	8f 85       	ldd	r24, Y+15	; 0x0f
     9c2:	98 89       	ldd	r25, Y+16	; 0x10
     9c4:	87 30       	cpi	r24, 0x07	; 7
     9c6:	91 05       	cpc	r25, r1
     9c8:	59 f1       	breq	.+86     	; 0xa20 <__stack+0x1c1>
     9ca:	26 c2       	rjmp	.+1100   	; 0xe18 <__stack+0x5b9>
					{
						case 0:
							PORTB.Bits.Pin0 =1;
     9cc:	e8 e3       	ldi	r30, 0x38	; 56
     9ce:	f0 e0       	ldi	r31, 0x00	; 0
     9d0:	80 81       	ld	r24, Z
     9d2:	81 60       	ori	r24, 0x01	; 1
     9d4:	80 83       	st	Z, r24
     9d6:	20 c2       	rjmp	.+1088   	; 0xe18 <__stack+0x5b9>
						break;

						case 1:
							PORTB.Bits.Pin1 =1;
     9d8:	e8 e3       	ldi	r30, 0x38	; 56
     9da:	f0 e0       	ldi	r31, 0x00	; 0
     9dc:	80 81       	ld	r24, Z
     9de:	82 60       	ori	r24, 0x02	; 2
     9e0:	80 83       	st	Z, r24
     9e2:	1a c2       	rjmp	.+1076   	; 0xe18 <__stack+0x5b9>
						break;

						case 2:
							PORTB.Bits.Pin2 =1;
     9e4:	e8 e3       	ldi	r30, 0x38	; 56
     9e6:	f0 e0       	ldi	r31, 0x00	; 0
     9e8:	80 81       	ld	r24, Z
     9ea:	84 60       	ori	r24, 0x04	; 4
     9ec:	80 83       	st	Z, r24
     9ee:	14 c2       	rjmp	.+1064   	; 0xe18 <__stack+0x5b9>
						break;

						case 3:
							PORTB.Bits.Pin3 =1;
     9f0:	e8 e3       	ldi	r30, 0x38	; 56
     9f2:	f0 e0       	ldi	r31, 0x00	; 0
     9f4:	80 81       	ld	r24, Z
     9f6:	88 60       	ori	r24, 0x08	; 8
     9f8:	80 83       	st	Z, r24
     9fa:	0e c2       	rjmp	.+1052   	; 0xe18 <__stack+0x5b9>
						break;

						case 4:
							PORTB.Bits.Pin4 =1;
     9fc:	e8 e3       	ldi	r30, 0x38	; 56
     9fe:	f0 e0       	ldi	r31, 0x00	; 0
     a00:	80 81       	ld	r24, Z
     a02:	80 61       	ori	r24, 0x10	; 16
     a04:	80 83       	st	Z, r24
     a06:	08 c2       	rjmp	.+1040   	; 0xe18 <__stack+0x5b9>
						break;

						case 5:
							PORTB.Bits.Pin5 =1;
     a08:	e8 e3       	ldi	r30, 0x38	; 56
     a0a:	f0 e0       	ldi	r31, 0x00	; 0
     a0c:	80 81       	ld	r24, Z
     a0e:	80 62       	ori	r24, 0x20	; 32
     a10:	80 83       	st	Z, r24
     a12:	02 c2       	rjmp	.+1028   	; 0xe18 <__stack+0x5b9>
						break;

						case 6:
							PORTB.Bits.Pin6 =1;
     a14:	e8 e3       	ldi	r30, 0x38	; 56
     a16:	f0 e0       	ldi	r31, 0x00	; 0
     a18:	80 81       	ld	r24, Z
     a1a:	80 64       	ori	r24, 0x40	; 64
     a1c:	80 83       	st	Z, r24
     a1e:	fc c1       	rjmp	.+1016   	; 0xe18 <__stack+0x5b9>
						break;

						case 7:
							PORTB.Bits.Pin7 =1;
     a20:	e8 e3       	ldi	r30, 0x38	; 56
     a22:	f0 e0       	ldi	r31, 0x00	; 0
     a24:	80 81       	ld	r24, Z
     a26:	80 68       	ori	r24, 0x80	; 128
     a28:	80 83       	st	Z, r24
     a2a:	f6 c1       	rjmp	.+1004   	; 0xe18 <__stack+0x5b9>
						break;
					}
				}
			else
			{
				switch(PinLoc)
     a2c:	89 81       	ldd	r24, Y+1	; 0x01
     a2e:	28 2f       	mov	r18, r24
     a30:	30 e0       	ldi	r19, 0x00	; 0
     a32:	3e 87       	std	Y+14, r19	; 0x0e
     a34:	2d 87       	std	Y+13, r18	; 0x0d
     a36:	8d 85       	ldd	r24, Y+13	; 0x0d
     a38:	9e 85       	ldd	r25, Y+14	; 0x0e
     a3a:	83 30       	cpi	r24, 0x03	; 3
     a3c:	91 05       	cpc	r25, r1
     a3e:	d9 f1       	breq	.+118    	; 0xab6 <__stack+0x257>
     a40:	2d 85       	ldd	r18, Y+13	; 0x0d
     a42:	3e 85       	ldd	r19, Y+14	; 0x0e
     a44:	24 30       	cpi	r18, 0x04	; 4
     a46:	31 05       	cpc	r19, r1
     a48:	7c f4       	brge	.+30     	; 0xa68 <__stack+0x209>
     a4a:	8d 85       	ldd	r24, Y+13	; 0x0d
     a4c:	9e 85       	ldd	r25, Y+14	; 0x0e
     a4e:	81 30       	cpi	r24, 0x01	; 1
     a50:	91 05       	cpc	r25, r1
     a52:	29 f1       	breq	.+74     	; 0xa9e <__stack+0x23f>
     a54:	2d 85       	ldd	r18, Y+13	; 0x0d
     a56:	3e 85       	ldd	r19, Y+14	; 0x0e
     a58:	22 30       	cpi	r18, 0x02	; 2
     a5a:	31 05       	cpc	r19, r1
     a5c:	34 f5       	brge	.+76     	; 0xaaa <__stack+0x24b>
     a5e:	8d 85       	ldd	r24, Y+13	; 0x0d
     a60:	9e 85       	ldd	r25, Y+14	; 0x0e
     a62:	00 97       	sbiw	r24, 0x00	; 0
     a64:	b1 f0       	breq	.+44     	; 0xa92 <__stack+0x233>
     a66:	d8 c1       	rjmp	.+944    	; 0xe18 <__stack+0x5b9>
     a68:	2d 85       	ldd	r18, Y+13	; 0x0d
     a6a:	3e 85       	ldd	r19, Y+14	; 0x0e
     a6c:	25 30       	cpi	r18, 0x05	; 5
     a6e:	31 05       	cpc	r19, r1
     a70:	71 f1       	breq	.+92     	; 0xace <__stack+0x26f>
     a72:	8d 85       	ldd	r24, Y+13	; 0x0d
     a74:	9e 85       	ldd	r25, Y+14	; 0x0e
     a76:	85 30       	cpi	r24, 0x05	; 5
     a78:	91 05       	cpc	r25, r1
     a7a:	1c f1       	brlt	.+70     	; 0xac2 <__stack+0x263>
     a7c:	2d 85       	ldd	r18, Y+13	; 0x0d
     a7e:	3e 85       	ldd	r19, Y+14	; 0x0e
     a80:	26 30       	cpi	r18, 0x06	; 6
     a82:	31 05       	cpc	r19, r1
     a84:	51 f1       	breq	.+84     	; 0xada <__stack+0x27b>
     a86:	8d 85       	ldd	r24, Y+13	; 0x0d
     a88:	9e 85       	ldd	r25, Y+14	; 0x0e
     a8a:	87 30       	cpi	r24, 0x07	; 7
     a8c:	91 05       	cpc	r25, r1
     a8e:	59 f1       	breq	.+86     	; 0xae6 <__stack+0x287>
     a90:	c3 c1       	rjmp	.+902    	; 0xe18 <__stack+0x5b9>
				{
					case 0:
						PORTB.Bits.Pin0 =0;
     a92:	e8 e3       	ldi	r30, 0x38	; 56
     a94:	f0 e0       	ldi	r31, 0x00	; 0
     a96:	80 81       	ld	r24, Z
     a98:	8e 7f       	andi	r24, 0xFE	; 254
     a9a:	80 83       	st	Z, r24
     a9c:	bd c1       	rjmp	.+890    	; 0xe18 <__stack+0x5b9>
					break;

					case 1:
						PORTB.Bits.Pin1 =0;
     a9e:	e8 e3       	ldi	r30, 0x38	; 56
     aa0:	f0 e0       	ldi	r31, 0x00	; 0
     aa2:	80 81       	ld	r24, Z
     aa4:	8d 7f       	andi	r24, 0xFD	; 253
     aa6:	80 83       	st	Z, r24
     aa8:	b7 c1       	rjmp	.+878    	; 0xe18 <__stack+0x5b9>
					break;

					case 2:
						PORTB.Bits.Pin2 =0;
     aaa:	e8 e3       	ldi	r30, 0x38	; 56
     aac:	f0 e0       	ldi	r31, 0x00	; 0
     aae:	80 81       	ld	r24, Z
     ab0:	8b 7f       	andi	r24, 0xFB	; 251
     ab2:	80 83       	st	Z, r24
     ab4:	b1 c1       	rjmp	.+866    	; 0xe18 <__stack+0x5b9>
					break;

					case 3:
						PORTB.Bits.Pin3 =0;
     ab6:	e8 e3       	ldi	r30, 0x38	; 56
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	80 81       	ld	r24, Z
     abc:	87 7f       	andi	r24, 0xF7	; 247
     abe:	80 83       	st	Z, r24
     ac0:	ab c1       	rjmp	.+854    	; 0xe18 <__stack+0x5b9>
					break;

					case 4:
						PORTB.Bits.Pin4 =0;
     ac2:	e8 e3       	ldi	r30, 0x38	; 56
     ac4:	f0 e0       	ldi	r31, 0x00	; 0
     ac6:	80 81       	ld	r24, Z
     ac8:	8f 7e       	andi	r24, 0xEF	; 239
     aca:	80 83       	st	Z, r24
     acc:	a5 c1       	rjmp	.+842    	; 0xe18 <__stack+0x5b9>
					break;

					case 5:
						PORTB.Bits.Pin5 =0;
     ace:	e8 e3       	ldi	r30, 0x38	; 56
     ad0:	f0 e0       	ldi	r31, 0x00	; 0
     ad2:	80 81       	ld	r24, Z
     ad4:	8f 7d       	andi	r24, 0xDF	; 223
     ad6:	80 83       	st	Z, r24
     ad8:	9f c1       	rjmp	.+830    	; 0xe18 <__stack+0x5b9>
					break;

					case 6:
						PORTB.Bits.Pin6 =0;
     ada:	e8 e3       	ldi	r30, 0x38	; 56
     adc:	f0 e0       	ldi	r31, 0x00	; 0
     ade:	80 81       	ld	r24, Z
     ae0:	8f 7b       	andi	r24, 0xBF	; 191
     ae2:	80 83       	st	Z, r24
     ae4:	99 c1       	rjmp	.+818    	; 0xe18 <__stack+0x5b9>
					break;

					case 7:
						PORTB.Bits.Pin7 =0;
     ae6:	e8 e3       	ldi	r30, 0x38	; 56
     ae8:	f0 e0       	ldi	r31, 0x00	; 0
     aea:	80 81       	ld	r24, Z
     aec:	8f 77       	andi	r24, 0x7F	; 127
     aee:	80 83       	st	Z, r24
     af0:	93 c1       	rjmp	.+806    	; 0xe18 <__stack+0x5b9>
				}
			}
			break;

		case 2:
			if(Val ==1)
     af2:	8c 81       	ldd	r24, Y+4	; 0x04
     af4:	81 30       	cpi	r24, 0x01	; 1
     af6:	09 f0       	breq	.+2      	; 0xafa <__stack+0x29b>
     af8:	63 c0       	rjmp	.+198    	; 0xbc0 <__stack+0x361>
				{
					switch(PinLoc)
     afa:	89 81       	ldd	r24, Y+1	; 0x01
     afc:	28 2f       	mov	r18, r24
     afe:	30 e0       	ldi	r19, 0x00	; 0
     b00:	3c 87       	std	Y+12, r19	; 0x0c
     b02:	2b 87       	std	Y+11, r18	; 0x0b
     b04:	8b 85       	ldd	r24, Y+11	; 0x0b
     b06:	9c 85       	ldd	r25, Y+12	; 0x0c
     b08:	83 30       	cpi	r24, 0x03	; 3
     b0a:	91 05       	cpc	r25, r1
     b0c:	d9 f1       	breq	.+118    	; 0xb84 <__stack+0x325>
     b0e:	2b 85       	ldd	r18, Y+11	; 0x0b
     b10:	3c 85       	ldd	r19, Y+12	; 0x0c
     b12:	24 30       	cpi	r18, 0x04	; 4
     b14:	31 05       	cpc	r19, r1
     b16:	7c f4       	brge	.+30     	; 0xb36 <__stack+0x2d7>
     b18:	8b 85       	ldd	r24, Y+11	; 0x0b
     b1a:	9c 85       	ldd	r25, Y+12	; 0x0c
     b1c:	81 30       	cpi	r24, 0x01	; 1
     b1e:	91 05       	cpc	r25, r1
     b20:	29 f1       	breq	.+74     	; 0xb6c <__stack+0x30d>
     b22:	2b 85       	ldd	r18, Y+11	; 0x0b
     b24:	3c 85       	ldd	r19, Y+12	; 0x0c
     b26:	22 30       	cpi	r18, 0x02	; 2
     b28:	31 05       	cpc	r19, r1
     b2a:	34 f5       	brge	.+76     	; 0xb78 <__stack+0x319>
     b2c:	8b 85       	ldd	r24, Y+11	; 0x0b
     b2e:	9c 85       	ldd	r25, Y+12	; 0x0c
     b30:	00 97       	sbiw	r24, 0x00	; 0
     b32:	b1 f0       	breq	.+44     	; 0xb60 <__stack+0x301>
     b34:	71 c1       	rjmp	.+738    	; 0xe18 <__stack+0x5b9>
     b36:	2b 85       	ldd	r18, Y+11	; 0x0b
     b38:	3c 85       	ldd	r19, Y+12	; 0x0c
     b3a:	25 30       	cpi	r18, 0x05	; 5
     b3c:	31 05       	cpc	r19, r1
     b3e:	71 f1       	breq	.+92     	; 0xb9c <__stack+0x33d>
     b40:	8b 85       	ldd	r24, Y+11	; 0x0b
     b42:	9c 85       	ldd	r25, Y+12	; 0x0c
     b44:	85 30       	cpi	r24, 0x05	; 5
     b46:	91 05       	cpc	r25, r1
     b48:	1c f1       	brlt	.+70     	; 0xb90 <__stack+0x331>
     b4a:	2b 85       	ldd	r18, Y+11	; 0x0b
     b4c:	3c 85       	ldd	r19, Y+12	; 0x0c
     b4e:	26 30       	cpi	r18, 0x06	; 6
     b50:	31 05       	cpc	r19, r1
     b52:	51 f1       	breq	.+84     	; 0xba8 <__stack+0x349>
     b54:	8b 85       	ldd	r24, Y+11	; 0x0b
     b56:	9c 85       	ldd	r25, Y+12	; 0x0c
     b58:	87 30       	cpi	r24, 0x07	; 7
     b5a:	91 05       	cpc	r25, r1
     b5c:	59 f1       	breq	.+86     	; 0xbb4 <__stack+0x355>
     b5e:	5c c1       	rjmp	.+696    	; 0xe18 <__stack+0x5b9>
					{
						case 0:
							PORTC.Bits.Pin0 =1;
     b60:	e5 e3       	ldi	r30, 0x35	; 53
     b62:	f0 e0       	ldi	r31, 0x00	; 0
     b64:	80 81       	ld	r24, Z
     b66:	81 60       	ori	r24, 0x01	; 1
     b68:	80 83       	st	Z, r24
     b6a:	56 c1       	rjmp	.+684    	; 0xe18 <__stack+0x5b9>
						break;

						case 1:
							PORTC.Bits.Pin1 =1;
     b6c:	e5 e3       	ldi	r30, 0x35	; 53
     b6e:	f0 e0       	ldi	r31, 0x00	; 0
     b70:	80 81       	ld	r24, Z
     b72:	82 60       	ori	r24, 0x02	; 2
     b74:	80 83       	st	Z, r24
     b76:	50 c1       	rjmp	.+672    	; 0xe18 <__stack+0x5b9>
						break;

						case 2:
							PORTC.Bits.Pin2 =1;
     b78:	e5 e3       	ldi	r30, 0x35	; 53
     b7a:	f0 e0       	ldi	r31, 0x00	; 0
     b7c:	80 81       	ld	r24, Z
     b7e:	84 60       	ori	r24, 0x04	; 4
     b80:	80 83       	st	Z, r24
     b82:	4a c1       	rjmp	.+660    	; 0xe18 <__stack+0x5b9>
						break;

						case 3:
							PORTC.Bits.Pin3 =1;
     b84:	e5 e3       	ldi	r30, 0x35	; 53
     b86:	f0 e0       	ldi	r31, 0x00	; 0
     b88:	80 81       	ld	r24, Z
     b8a:	88 60       	ori	r24, 0x08	; 8
     b8c:	80 83       	st	Z, r24
     b8e:	44 c1       	rjmp	.+648    	; 0xe18 <__stack+0x5b9>
						break;

						case 4:
							PORTC.Bits.Pin4 =1;
     b90:	e5 e3       	ldi	r30, 0x35	; 53
     b92:	f0 e0       	ldi	r31, 0x00	; 0
     b94:	80 81       	ld	r24, Z
     b96:	80 61       	ori	r24, 0x10	; 16
     b98:	80 83       	st	Z, r24
     b9a:	3e c1       	rjmp	.+636    	; 0xe18 <__stack+0x5b9>
						break;

						case 5:
							PORTC.Bits.Pin5 =1;
     b9c:	e5 e3       	ldi	r30, 0x35	; 53
     b9e:	f0 e0       	ldi	r31, 0x00	; 0
     ba0:	80 81       	ld	r24, Z
     ba2:	80 62       	ori	r24, 0x20	; 32
     ba4:	80 83       	st	Z, r24
     ba6:	38 c1       	rjmp	.+624    	; 0xe18 <__stack+0x5b9>
						break;

						case 6:
							PORTC.Bits.Pin6 =1;
     ba8:	e5 e3       	ldi	r30, 0x35	; 53
     baa:	f0 e0       	ldi	r31, 0x00	; 0
     bac:	80 81       	ld	r24, Z
     bae:	80 64       	ori	r24, 0x40	; 64
     bb0:	80 83       	st	Z, r24
     bb2:	32 c1       	rjmp	.+612    	; 0xe18 <__stack+0x5b9>
						break;

						case 7:
							PORTC.Bits.Pin7 =1;
     bb4:	e5 e3       	ldi	r30, 0x35	; 53
     bb6:	f0 e0       	ldi	r31, 0x00	; 0
     bb8:	80 81       	ld	r24, Z
     bba:	80 68       	ori	r24, 0x80	; 128
     bbc:	80 83       	st	Z, r24
     bbe:	2c c1       	rjmp	.+600    	; 0xe18 <__stack+0x5b9>
						break;
					}
				}
			else
			{
				switch(PinLoc)
     bc0:	89 81       	ldd	r24, Y+1	; 0x01
     bc2:	28 2f       	mov	r18, r24
     bc4:	30 e0       	ldi	r19, 0x00	; 0
     bc6:	3a 87       	std	Y+10, r19	; 0x0a
     bc8:	29 87       	std	Y+9, r18	; 0x09
     bca:	89 85       	ldd	r24, Y+9	; 0x09
     bcc:	9a 85       	ldd	r25, Y+10	; 0x0a
     bce:	83 30       	cpi	r24, 0x03	; 3
     bd0:	91 05       	cpc	r25, r1
     bd2:	d9 f1       	breq	.+118    	; 0xc4a <__stack+0x3eb>
     bd4:	29 85       	ldd	r18, Y+9	; 0x09
     bd6:	3a 85       	ldd	r19, Y+10	; 0x0a
     bd8:	24 30       	cpi	r18, 0x04	; 4
     bda:	31 05       	cpc	r19, r1
     bdc:	7c f4       	brge	.+30     	; 0xbfc <__stack+0x39d>
     bde:	89 85       	ldd	r24, Y+9	; 0x09
     be0:	9a 85       	ldd	r25, Y+10	; 0x0a
     be2:	81 30       	cpi	r24, 0x01	; 1
     be4:	91 05       	cpc	r25, r1
     be6:	29 f1       	breq	.+74     	; 0xc32 <__stack+0x3d3>
     be8:	29 85       	ldd	r18, Y+9	; 0x09
     bea:	3a 85       	ldd	r19, Y+10	; 0x0a
     bec:	22 30       	cpi	r18, 0x02	; 2
     bee:	31 05       	cpc	r19, r1
     bf0:	34 f5       	brge	.+76     	; 0xc3e <__stack+0x3df>
     bf2:	89 85       	ldd	r24, Y+9	; 0x09
     bf4:	9a 85       	ldd	r25, Y+10	; 0x0a
     bf6:	00 97       	sbiw	r24, 0x00	; 0
     bf8:	b1 f0       	breq	.+44     	; 0xc26 <__stack+0x3c7>
     bfa:	0e c1       	rjmp	.+540    	; 0xe18 <__stack+0x5b9>
     bfc:	29 85       	ldd	r18, Y+9	; 0x09
     bfe:	3a 85       	ldd	r19, Y+10	; 0x0a
     c00:	25 30       	cpi	r18, 0x05	; 5
     c02:	31 05       	cpc	r19, r1
     c04:	71 f1       	breq	.+92     	; 0xc62 <__stack+0x403>
     c06:	89 85       	ldd	r24, Y+9	; 0x09
     c08:	9a 85       	ldd	r25, Y+10	; 0x0a
     c0a:	85 30       	cpi	r24, 0x05	; 5
     c0c:	91 05       	cpc	r25, r1
     c0e:	1c f1       	brlt	.+70     	; 0xc56 <__stack+0x3f7>
     c10:	29 85       	ldd	r18, Y+9	; 0x09
     c12:	3a 85       	ldd	r19, Y+10	; 0x0a
     c14:	26 30       	cpi	r18, 0x06	; 6
     c16:	31 05       	cpc	r19, r1
     c18:	51 f1       	breq	.+84     	; 0xc6e <__stack+0x40f>
     c1a:	89 85       	ldd	r24, Y+9	; 0x09
     c1c:	9a 85       	ldd	r25, Y+10	; 0x0a
     c1e:	87 30       	cpi	r24, 0x07	; 7
     c20:	91 05       	cpc	r25, r1
     c22:	59 f1       	breq	.+86     	; 0xc7a <__stack+0x41b>
     c24:	f9 c0       	rjmp	.+498    	; 0xe18 <__stack+0x5b9>
				{
					case 0:
						PORTC.Bits.Pin0 =0;
     c26:	e5 e3       	ldi	r30, 0x35	; 53
     c28:	f0 e0       	ldi	r31, 0x00	; 0
     c2a:	80 81       	ld	r24, Z
     c2c:	8e 7f       	andi	r24, 0xFE	; 254
     c2e:	80 83       	st	Z, r24
     c30:	f3 c0       	rjmp	.+486    	; 0xe18 <__stack+0x5b9>
					break;

					case 1:
						PORTC.Bits.Pin1 =0;
     c32:	e5 e3       	ldi	r30, 0x35	; 53
     c34:	f0 e0       	ldi	r31, 0x00	; 0
     c36:	80 81       	ld	r24, Z
     c38:	8d 7f       	andi	r24, 0xFD	; 253
     c3a:	80 83       	st	Z, r24
     c3c:	ed c0       	rjmp	.+474    	; 0xe18 <__stack+0x5b9>
					break;

					case 2:
						PORTC.Bits.Pin2 =0;
     c3e:	e5 e3       	ldi	r30, 0x35	; 53
     c40:	f0 e0       	ldi	r31, 0x00	; 0
     c42:	80 81       	ld	r24, Z
     c44:	8b 7f       	andi	r24, 0xFB	; 251
     c46:	80 83       	st	Z, r24
     c48:	e7 c0       	rjmp	.+462    	; 0xe18 <__stack+0x5b9>
					break;

					case 3:
						PORTC.Bits.Pin3 =0;
     c4a:	e5 e3       	ldi	r30, 0x35	; 53
     c4c:	f0 e0       	ldi	r31, 0x00	; 0
     c4e:	80 81       	ld	r24, Z
     c50:	87 7f       	andi	r24, 0xF7	; 247
     c52:	80 83       	st	Z, r24
     c54:	e1 c0       	rjmp	.+450    	; 0xe18 <__stack+0x5b9>
					break;

					case 4:
						PORTC.Bits.Pin4 =0;
     c56:	e5 e3       	ldi	r30, 0x35	; 53
     c58:	f0 e0       	ldi	r31, 0x00	; 0
     c5a:	80 81       	ld	r24, Z
     c5c:	8f 7e       	andi	r24, 0xEF	; 239
     c5e:	80 83       	st	Z, r24
     c60:	db c0       	rjmp	.+438    	; 0xe18 <__stack+0x5b9>
					break;

					case 5:
						PORTC.Bits.Pin5 =0;
     c62:	e5 e3       	ldi	r30, 0x35	; 53
     c64:	f0 e0       	ldi	r31, 0x00	; 0
     c66:	80 81       	ld	r24, Z
     c68:	8f 7d       	andi	r24, 0xDF	; 223
     c6a:	80 83       	st	Z, r24
     c6c:	d5 c0       	rjmp	.+426    	; 0xe18 <__stack+0x5b9>
					break;

					case 6:
						PORTC.Bits.Pin6 =0;
     c6e:	e5 e3       	ldi	r30, 0x35	; 53
     c70:	f0 e0       	ldi	r31, 0x00	; 0
     c72:	80 81       	ld	r24, Z
     c74:	8f 7b       	andi	r24, 0xBF	; 191
     c76:	80 83       	st	Z, r24
     c78:	cf c0       	rjmp	.+414    	; 0xe18 <__stack+0x5b9>
					break;

					case 7:
						PORTC.Bits.Pin7 =0;
     c7a:	e5 e3       	ldi	r30, 0x35	; 53
     c7c:	f0 e0       	ldi	r31, 0x00	; 0
     c7e:	80 81       	ld	r24, Z
     c80:	8f 77       	andi	r24, 0x7F	; 127
     c82:	80 83       	st	Z, r24
     c84:	c9 c0       	rjmp	.+402    	; 0xe18 <__stack+0x5b9>
			}
		break;


		case 3:
			if(Val ==1)
     c86:	8c 81       	ldd	r24, Y+4	; 0x04
     c88:	81 30       	cpi	r24, 0x01	; 1
     c8a:	09 f0       	breq	.+2      	; 0xc8e <__stack+0x42f>
     c8c:	63 c0       	rjmp	.+198    	; 0xd54 <__stack+0x4f5>
				{
					switch(PinLoc)
     c8e:	89 81       	ldd	r24, Y+1	; 0x01
     c90:	28 2f       	mov	r18, r24
     c92:	30 e0       	ldi	r19, 0x00	; 0
     c94:	38 87       	std	Y+8, r19	; 0x08
     c96:	2f 83       	std	Y+7, r18	; 0x07
     c98:	8f 81       	ldd	r24, Y+7	; 0x07
     c9a:	98 85       	ldd	r25, Y+8	; 0x08
     c9c:	83 30       	cpi	r24, 0x03	; 3
     c9e:	91 05       	cpc	r25, r1
     ca0:	d9 f1       	breq	.+118    	; 0xd18 <__stack+0x4b9>
     ca2:	2f 81       	ldd	r18, Y+7	; 0x07
     ca4:	38 85       	ldd	r19, Y+8	; 0x08
     ca6:	24 30       	cpi	r18, 0x04	; 4
     ca8:	31 05       	cpc	r19, r1
     caa:	7c f4       	brge	.+30     	; 0xcca <__stack+0x46b>
     cac:	8f 81       	ldd	r24, Y+7	; 0x07
     cae:	98 85       	ldd	r25, Y+8	; 0x08
     cb0:	81 30       	cpi	r24, 0x01	; 1
     cb2:	91 05       	cpc	r25, r1
     cb4:	29 f1       	breq	.+74     	; 0xd00 <__stack+0x4a1>
     cb6:	2f 81       	ldd	r18, Y+7	; 0x07
     cb8:	38 85       	ldd	r19, Y+8	; 0x08
     cba:	22 30       	cpi	r18, 0x02	; 2
     cbc:	31 05       	cpc	r19, r1
     cbe:	34 f5       	brge	.+76     	; 0xd0c <__stack+0x4ad>
     cc0:	8f 81       	ldd	r24, Y+7	; 0x07
     cc2:	98 85       	ldd	r25, Y+8	; 0x08
     cc4:	00 97       	sbiw	r24, 0x00	; 0
     cc6:	b1 f0       	breq	.+44     	; 0xcf4 <__stack+0x495>
     cc8:	a7 c0       	rjmp	.+334    	; 0xe18 <__stack+0x5b9>
     cca:	2f 81       	ldd	r18, Y+7	; 0x07
     ccc:	38 85       	ldd	r19, Y+8	; 0x08
     cce:	25 30       	cpi	r18, 0x05	; 5
     cd0:	31 05       	cpc	r19, r1
     cd2:	71 f1       	breq	.+92     	; 0xd30 <__stack+0x4d1>
     cd4:	8f 81       	ldd	r24, Y+7	; 0x07
     cd6:	98 85       	ldd	r25, Y+8	; 0x08
     cd8:	85 30       	cpi	r24, 0x05	; 5
     cda:	91 05       	cpc	r25, r1
     cdc:	1c f1       	brlt	.+70     	; 0xd24 <__stack+0x4c5>
     cde:	2f 81       	ldd	r18, Y+7	; 0x07
     ce0:	38 85       	ldd	r19, Y+8	; 0x08
     ce2:	26 30       	cpi	r18, 0x06	; 6
     ce4:	31 05       	cpc	r19, r1
     ce6:	51 f1       	breq	.+84     	; 0xd3c <__stack+0x4dd>
     ce8:	8f 81       	ldd	r24, Y+7	; 0x07
     cea:	98 85       	ldd	r25, Y+8	; 0x08
     cec:	87 30       	cpi	r24, 0x07	; 7
     cee:	91 05       	cpc	r25, r1
     cf0:	59 f1       	breq	.+86     	; 0xd48 <__stack+0x4e9>
     cf2:	92 c0       	rjmp	.+292    	; 0xe18 <__stack+0x5b9>
					{
						case 0:
							PORTD.Bits.Pin0 =1;
     cf4:	e2 e3       	ldi	r30, 0x32	; 50
     cf6:	f0 e0       	ldi	r31, 0x00	; 0
     cf8:	80 81       	ld	r24, Z
     cfa:	81 60       	ori	r24, 0x01	; 1
     cfc:	80 83       	st	Z, r24
     cfe:	8c c0       	rjmp	.+280    	; 0xe18 <__stack+0x5b9>
						break;

						case 1:
							PORTD.Bits.Pin1 =1;
     d00:	e2 e3       	ldi	r30, 0x32	; 50
     d02:	f0 e0       	ldi	r31, 0x00	; 0
     d04:	80 81       	ld	r24, Z
     d06:	82 60       	ori	r24, 0x02	; 2
     d08:	80 83       	st	Z, r24
     d0a:	86 c0       	rjmp	.+268    	; 0xe18 <__stack+0x5b9>
						break;

						case 2:
							PORTD.Bits.Pin2 =1;
     d0c:	e2 e3       	ldi	r30, 0x32	; 50
     d0e:	f0 e0       	ldi	r31, 0x00	; 0
     d10:	80 81       	ld	r24, Z
     d12:	84 60       	ori	r24, 0x04	; 4
     d14:	80 83       	st	Z, r24
     d16:	80 c0       	rjmp	.+256    	; 0xe18 <__stack+0x5b9>
						break;

						case 3:
							PORTD.Bits.Pin3 =1;
     d18:	e2 e3       	ldi	r30, 0x32	; 50
     d1a:	f0 e0       	ldi	r31, 0x00	; 0
     d1c:	80 81       	ld	r24, Z
     d1e:	88 60       	ori	r24, 0x08	; 8
     d20:	80 83       	st	Z, r24
     d22:	7a c0       	rjmp	.+244    	; 0xe18 <__stack+0x5b9>
						break;

						case 4:
							PORTD.Bits.Pin4 =1;
     d24:	e2 e3       	ldi	r30, 0x32	; 50
     d26:	f0 e0       	ldi	r31, 0x00	; 0
     d28:	80 81       	ld	r24, Z
     d2a:	80 61       	ori	r24, 0x10	; 16
     d2c:	80 83       	st	Z, r24
     d2e:	74 c0       	rjmp	.+232    	; 0xe18 <__stack+0x5b9>
						break;

						case 5:
							PORTD.Bits.Pin5 =1;
     d30:	e2 e3       	ldi	r30, 0x32	; 50
     d32:	f0 e0       	ldi	r31, 0x00	; 0
     d34:	80 81       	ld	r24, Z
     d36:	80 62       	ori	r24, 0x20	; 32
     d38:	80 83       	st	Z, r24
     d3a:	6e c0       	rjmp	.+220    	; 0xe18 <__stack+0x5b9>
						break;

						case 6:
							PORTD.Bits.Pin6 =1;
     d3c:	e2 e3       	ldi	r30, 0x32	; 50
     d3e:	f0 e0       	ldi	r31, 0x00	; 0
     d40:	80 81       	ld	r24, Z
     d42:	80 64       	ori	r24, 0x40	; 64
     d44:	80 83       	st	Z, r24
     d46:	68 c0       	rjmp	.+208    	; 0xe18 <__stack+0x5b9>
						break;

						case 7:
							PORTD.Bits.Pin7 =1;
     d48:	e2 e3       	ldi	r30, 0x32	; 50
     d4a:	f0 e0       	ldi	r31, 0x00	; 0
     d4c:	80 81       	ld	r24, Z
     d4e:	80 68       	ori	r24, 0x80	; 128
     d50:	80 83       	st	Z, r24
     d52:	62 c0       	rjmp	.+196    	; 0xe18 <__stack+0x5b9>
						break;
					}
				}
			else
			{
				switch(PinLoc)
     d54:	89 81       	ldd	r24, Y+1	; 0x01
     d56:	28 2f       	mov	r18, r24
     d58:	30 e0       	ldi	r19, 0x00	; 0
     d5a:	3e 83       	std	Y+6, r19	; 0x06
     d5c:	2d 83       	std	Y+5, r18	; 0x05
     d5e:	8d 81       	ldd	r24, Y+5	; 0x05
     d60:	9e 81       	ldd	r25, Y+6	; 0x06
     d62:	83 30       	cpi	r24, 0x03	; 3
     d64:	91 05       	cpc	r25, r1
     d66:	d9 f1       	breq	.+118    	; 0xdde <__stack+0x57f>
     d68:	2d 81       	ldd	r18, Y+5	; 0x05
     d6a:	3e 81       	ldd	r19, Y+6	; 0x06
     d6c:	24 30       	cpi	r18, 0x04	; 4
     d6e:	31 05       	cpc	r19, r1
     d70:	7c f4       	brge	.+30     	; 0xd90 <__stack+0x531>
     d72:	8d 81       	ldd	r24, Y+5	; 0x05
     d74:	9e 81       	ldd	r25, Y+6	; 0x06
     d76:	81 30       	cpi	r24, 0x01	; 1
     d78:	91 05       	cpc	r25, r1
     d7a:	29 f1       	breq	.+74     	; 0xdc6 <__stack+0x567>
     d7c:	2d 81       	ldd	r18, Y+5	; 0x05
     d7e:	3e 81       	ldd	r19, Y+6	; 0x06
     d80:	22 30       	cpi	r18, 0x02	; 2
     d82:	31 05       	cpc	r19, r1
     d84:	34 f5       	brge	.+76     	; 0xdd2 <__stack+0x573>
     d86:	8d 81       	ldd	r24, Y+5	; 0x05
     d88:	9e 81       	ldd	r25, Y+6	; 0x06
     d8a:	00 97       	sbiw	r24, 0x00	; 0
     d8c:	b1 f0       	breq	.+44     	; 0xdba <__stack+0x55b>
     d8e:	44 c0       	rjmp	.+136    	; 0xe18 <__stack+0x5b9>
     d90:	2d 81       	ldd	r18, Y+5	; 0x05
     d92:	3e 81       	ldd	r19, Y+6	; 0x06
     d94:	25 30       	cpi	r18, 0x05	; 5
     d96:	31 05       	cpc	r19, r1
     d98:	71 f1       	breq	.+92     	; 0xdf6 <__stack+0x597>
     d9a:	8d 81       	ldd	r24, Y+5	; 0x05
     d9c:	9e 81       	ldd	r25, Y+6	; 0x06
     d9e:	85 30       	cpi	r24, 0x05	; 5
     da0:	91 05       	cpc	r25, r1
     da2:	1c f1       	brlt	.+70     	; 0xdea <__stack+0x58b>
     da4:	2d 81       	ldd	r18, Y+5	; 0x05
     da6:	3e 81       	ldd	r19, Y+6	; 0x06
     da8:	26 30       	cpi	r18, 0x06	; 6
     daa:	31 05       	cpc	r19, r1
     dac:	51 f1       	breq	.+84     	; 0xe02 <__stack+0x5a3>
     dae:	8d 81       	ldd	r24, Y+5	; 0x05
     db0:	9e 81       	ldd	r25, Y+6	; 0x06
     db2:	87 30       	cpi	r24, 0x07	; 7
     db4:	91 05       	cpc	r25, r1
     db6:	59 f1       	breq	.+86     	; 0xe0e <__stack+0x5af>
     db8:	2f c0       	rjmp	.+94     	; 0xe18 <__stack+0x5b9>
				{
					case 0:
						PORTD.Bits.Pin0 =0;
     dba:	e2 e3       	ldi	r30, 0x32	; 50
     dbc:	f0 e0       	ldi	r31, 0x00	; 0
     dbe:	80 81       	ld	r24, Z
     dc0:	8e 7f       	andi	r24, 0xFE	; 254
     dc2:	80 83       	st	Z, r24
     dc4:	29 c0       	rjmp	.+82     	; 0xe18 <__stack+0x5b9>
					break;

					case 1:
						PORTD.Bits.Pin1 =0;
     dc6:	e2 e3       	ldi	r30, 0x32	; 50
     dc8:	f0 e0       	ldi	r31, 0x00	; 0
     dca:	80 81       	ld	r24, Z
     dcc:	8d 7f       	andi	r24, 0xFD	; 253
     dce:	80 83       	st	Z, r24
     dd0:	23 c0       	rjmp	.+70     	; 0xe18 <__stack+0x5b9>
					break;

					case 2:
						PORTD.Bits.Pin2 =0;
     dd2:	e2 e3       	ldi	r30, 0x32	; 50
     dd4:	f0 e0       	ldi	r31, 0x00	; 0
     dd6:	80 81       	ld	r24, Z
     dd8:	8b 7f       	andi	r24, 0xFB	; 251
     dda:	80 83       	st	Z, r24
     ddc:	1d c0       	rjmp	.+58     	; 0xe18 <__stack+0x5b9>
					break;

					case 3:
						PORTD.Bits.Pin3 =0;
     dde:	e2 e3       	ldi	r30, 0x32	; 50
     de0:	f0 e0       	ldi	r31, 0x00	; 0
     de2:	80 81       	ld	r24, Z
     de4:	87 7f       	andi	r24, 0xF7	; 247
     de6:	80 83       	st	Z, r24
     de8:	17 c0       	rjmp	.+46     	; 0xe18 <__stack+0x5b9>
					break;

					case 4:
						PORTD.Bits.Pin4 =0;
     dea:	e2 e3       	ldi	r30, 0x32	; 50
     dec:	f0 e0       	ldi	r31, 0x00	; 0
     dee:	80 81       	ld	r24, Z
     df0:	8f 7e       	andi	r24, 0xEF	; 239
     df2:	80 83       	st	Z, r24
     df4:	11 c0       	rjmp	.+34     	; 0xe18 <__stack+0x5b9>
					break;

					case 5:
						PORTD.Bits.Pin5 =0;
     df6:	e2 e3       	ldi	r30, 0x32	; 50
     df8:	f0 e0       	ldi	r31, 0x00	; 0
     dfa:	80 81       	ld	r24, Z
     dfc:	8f 7d       	andi	r24, 0xDF	; 223
     dfe:	80 83       	st	Z, r24
     e00:	0b c0       	rjmp	.+22     	; 0xe18 <__stack+0x5b9>
					break;

					case 6:
						PORTD.Bits.Pin6 =0;
     e02:	e2 e3       	ldi	r30, 0x32	; 50
     e04:	f0 e0       	ldi	r31, 0x00	; 0
     e06:	80 81       	ld	r24, Z
     e08:	8f 7b       	andi	r24, 0xBF	; 191
     e0a:	80 83       	st	Z, r24
     e0c:	05 c0       	rjmp	.+10     	; 0xe18 <__stack+0x5b9>
					break;

					case 7:
						PORTD.Bits.Pin7 =0;
     e0e:	e2 e3       	ldi	r30, 0x32	; 50
     e10:	f0 e0       	ldi	r31, 0x00	; 0
     e12:	80 81       	ld	r24, Z
     e14:	8f 77       	andi	r24, 0x7F	; 127
     e16:	80 83       	st	Z, r24
					break;
				}
			}
		break;
	}
}
     e18:	66 96       	adiw	r28, 0x16	; 22
     e1a:	0f b6       	in	r0, 0x3f	; 63
     e1c:	f8 94       	cli
     e1e:	de bf       	out	0x3e, r29	; 62
     e20:	0f be       	out	0x3f, r0	; 63
     e22:	cd bf       	out	0x3d, r28	; 61
     e24:	cf 91       	pop	r28
     e26:	df 91       	pop	r29
     e28:	08 95       	ret

00000e2a <Dio_u8GetPinVal>:

u8 Dio_u8GetPinVal(u8 pin)
{
     e2a:	df 93       	push	r29
     e2c:	cf 93       	push	r28
     e2e:	cd b7       	in	r28, 0x3d	; 61
     e30:	de b7       	in	r29, 0x3e	; 62
     e32:	2e 97       	sbiw	r28, 0x0e	; 14
     e34:	0f b6       	in	r0, 0x3f	; 63
     e36:	f8 94       	cli
     e38:	de bf       	out	0x3e, r29	; 62
     e3a:	0f be       	out	0x3f, r0	; 63
     e3c:	cd bf       	out	0x3d, r28	; 61
     e3e:	8c 83       	std	Y+4, r24	; 0x04
	u8 PortId;
	u8 PinLoc;
	u8 PinVal;


	PortId = pin/8;
     e40:	8c 81       	ldd	r24, Y+4	; 0x04
     e42:	86 95       	lsr	r24
     e44:	86 95       	lsr	r24
     e46:	86 95       	lsr	r24
     e48:	8b 83       	std	Y+3, r24	; 0x03
	PinLoc = pin%8;
     e4a:	8c 81       	ldd	r24, Y+4	; 0x04
     e4c:	87 70       	andi	r24, 0x07	; 7
     e4e:	8a 83       	std	Y+2, r24	; 0x02

	switch(PortId)
     e50:	8b 81       	ldd	r24, Y+3	; 0x03
     e52:	28 2f       	mov	r18, r24
     e54:	30 e0       	ldi	r19, 0x00	; 0
     e56:	3e 87       	std	Y+14, r19	; 0x0e
     e58:	2d 87       	std	Y+13, r18	; 0x0d
     e5a:	8d 85       	ldd	r24, Y+13	; 0x0d
     e5c:	9e 85       	ldd	r25, Y+14	; 0x0e
     e5e:	81 30       	cpi	r24, 0x01	; 1
     e60:	91 05       	cpc	r25, r1
     e62:	09 f4       	brne	.+2      	; 0xe66 <Dio_u8GetPinVal+0x3c>
     e64:	8c c0       	rjmp	.+280    	; 0xf7e <Dio_u8GetPinVal+0x154>
     e66:	2d 85       	ldd	r18, Y+13	; 0x0d
     e68:	3e 85       	ldd	r19, Y+14	; 0x0e
     e6a:	22 30       	cpi	r18, 0x02	; 2
     e6c:	31 05       	cpc	r19, r1
     e6e:	2c f4       	brge	.+10     	; 0xe7a <Dio_u8GetPinVal+0x50>
     e70:	8d 85       	ldd	r24, Y+13	; 0x0d
     e72:	9e 85       	ldd	r25, Y+14	; 0x0e
     e74:	00 97       	sbiw	r24, 0x00	; 0
     e76:	71 f0       	breq	.+28     	; 0xe94 <Dio_u8GetPinVal+0x6a>
     e78:	e0 c1       	rjmp	.+960    	; 0x123a <Dio_u8GetPinVal+0x410>
     e7a:	2d 85       	ldd	r18, Y+13	; 0x0d
     e7c:	3e 85       	ldd	r19, Y+14	; 0x0e
     e7e:	22 30       	cpi	r18, 0x02	; 2
     e80:	31 05       	cpc	r19, r1
     e82:	09 f4       	brne	.+2      	; 0xe86 <Dio_u8GetPinVal+0x5c>
     e84:	f1 c0       	rjmp	.+482    	; 0x1068 <Dio_u8GetPinVal+0x23e>
     e86:	8d 85       	ldd	r24, Y+13	; 0x0d
     e88:	9e 85       	ldd	r25, Y+14	; 0x0e
     e8a:	83 30       	cpi	r24, 0x03	; 3
     e8c:	91 05       	cpc	r25, r1
     e8e:	09 f4       	brne	.+2      	; 0xe92 <Dio_u8GetPinVal+0x68>
     e90:	60 c1       	rjmp	.+704    	; 0x1152 <Dio_u8GetPinVal+0x328>
     e92:	d3 c1       	rjmp	.+934    	; 0x123a <Dio_u8GetPinVal+0x410>
	{
		case 0:
			switch(PinLoc)
     e94:	8a 81       	ldd	r24, Y+2	; 0x02
     e96:	28 2f       	mov	r18, r24
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	3c 87       	std	Y+12, r19	; 0x0c
     e9c:	2b 87       	std	Y+11, r18	; 0x0b
     e9e:	8b 85       	ldd	r24, Y+11	; 0x0b
     ea0:	9c 85       	ldd	r25, Y+12	; 0x0c
     ea2:	83 30       	cpi	r24, 0x03	; 3
     ea4:	91 05       	cpc	r25, r1
     ea6:	09 f4       	brne	.+2      	; 0xeaa <Dio_u8GetPinVal+0x80>
     ea8:	3e c0       	rjmp	.+124    	; 0xf26 <Dio_u8GetPinVal+0xfc>
     eaa:	2b 85       	ldd	r18, Y+11	; 0x0b
     eac:	3c 85       	ldd	r19, Y+12	; 0x0c
     eae:	24 30       	cpi	r18, 0x04	; 4
     eb0:	31 05       	cpc	r19, r1
     eb2:	7c f4       	brge	.+30     	; 0xed2 <Dio_u8GetPinVal+0xa8>
     eb4:	8b 85       	ldd	r24, Y+11	; 0x0b
     eb6:	9c 85       	ldd	r25, Y+12	; 0x0c
     eb8:	81 30       	cpi	r24, 0x01	; 1
     eba:	91 05       	cpc	r25, r1
     ebc:	29 f1       	breq	.+74     	; 0xf08 <Dio_u8GetPinVal+0xde>
     ebe:	2b 85       	ldd	r18, Y+11	; 0x0b
     ec0:	3c 85       	ldd	r19, Y+12	; 0x0c
     ec2:	22 30       	cpi	r18, 0x02	; 2
     ec4:	31 05       	cpc	r19, r1
     ec6:	3c f5       	brge	.+78     	; 0xf16 <Dio_u8GetPinVal+0xec>
     ec8:	8b 85       	ldd	r24, Y+11	; 0x0b
     eca:	9c 85       	ldd	r25, Y+12	; 0x0c
     ecc:	00 97       	sbiw	r24, 0x00	; 0
     ece:	b1 f0       	breq	.+44     	; 0xefc <Dio_u8GetPinVal+0xd2>
     ed0:	b4 c1       	rjmp	.+872    	; 0x123a <Dio_u8GetPinVal+0x410>
     ed2:	2b 85       	ldd	r18, Y+11	; 0x0b
     ed4:	3c 85       	ldd	r19, Y+12	; 0x0c
     ed6:	25 30       	cpi	r18, 0x05	; 5
     ed8:	31 05       	cpc	r19, r1
     eda:	b1 f1       	breq	.+108    	; 0xf48 <Dio_u8GetPinVal+0x11e>
     edc:	8b 85       	ldd	r24, Y+11	; 0x0b
     ede:	9c 85       	ldd	r25, Y+12	; 0x0c
     ee0:	85 30       	cpi	r24, 0x05	; 5
     ee2:	91 05       	cpc	r25, r1
     ee4:	4c f1       	brlt	.+82     	; 0xf38 <Dio_u8GetPinVal+0x10e>
     ee6:	2b 85       	ldd	r18, Y+11	; 0x0b
     ee8:	3c 85       	ldd	r19, Y+12	; 0x0c
     eea:	26 30       	cpi	r18, 0x06	; 6
     eec:	31 05       	cpc	r19, r1
     eee:	a9 f1       	breq	.+106    	; 0xf5a <Dio_u8GetPinVal+0x130>
     ef0:	8b 85       	ldd	r24, Y+11	; 0x0b
     ef2:	9c 85       	ldd	r25, Y+12	; 0x0c
     ef4:	87 30       	cpi	r24, 0x07	; 7
     ef6:	91 05       	cpc	r25, r1
     ef8:	d1 f1       	breq	.+116    	; 0xf6e <Dio_u8GetPinVal+0x144>
     efa:	9f c1       	rjmp	.+830    	; 0x123a <Dio_u8GetPinVal+0x410>
			{
				case 0:
					PinVal = PINA.Bits.Pin0;
     efc:	e9 e3       	ldi	r30, 0x39	; 57
     efe:	f0 e0       	ldi	r31, 0x00	; 0
     f00:	80 81       	ld	r24, Z
     f02:	81 70       	andi	r24, 0x01	; 1
     f04:	89 83       	std	Y+1, r24	; 0x01
     f06:	99 c1       	rjmp	.+818    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 1:
					PinVal = PINA.Bits.Pin1;
     f08:	e9 e3       	ldi	r30, 0x39	; 57
     f0a:	f0 e0       	ldi	r31, 0x00	; 0
     f0c:	80 81       	ld	r24, Z
     f0e:	86 95       	lsr	r24
     f10:	81 70       	andi	r24, 0x01	; 1
     f12:	89 83       	std	Y+1, r24	; 0x01
     f14:	92 c1       	rjmp	.+804    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 2:
					PinVal = PINA.Bits.Pin2;
     f16:	e9 e3       	ldi	r30, 0x39	; 57
     f18:	f0 e0       	ldi	r31, 0x00	; 0
     f1a:	80 81       	ld	r24, Z
     f1c:	86 95       	lsr	r24
     f1e:	86 95       	lsr	r24
     f20:	81 70       	andi	r24, 0x01	; 1
     f22:	89 83       	std	Y+1, r24	; 0x01
     f24:	8a c1       	rjmp	.+788    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 3:
					PinVal = PINA.Bits.Pin3 ;
     f26:	e9 e3       	ldi	r30, 0x39	; 57
     f28:	f0 e0       	ldi	r31, 0x00	; 0
     f2a:	80 81       	ld	r24, Z
     f2c:	86 95       	lsr	r24
     f2e:	86 95       	lsr	r24
     f30:	86 95       	lsr	r24
     f32:	81 70       	andi	r24, 0x01	; 1
     f34:	89 83       	std	Y+1, r24	; 0x01
     f36:	81 c1       	rjmp	.+770    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 4:
					PinVal = PINA.Bits.Pin4;
     f38:	e9 e3       	ldi	r30, 0x39	; 57
     f3a:	f0 e0       	ldi	r31, 0x00	; 0
     f3c:	80 81       	ld	r24, Z
     f3e:	82 95       	swap	r24
     f40:	8f 70       	andi	r24, 0x0F	; 15
     f42:	81 70       	andi	r24, 0x01	; 1
     f44:	89 83       	std	Y+1, r24	; 0x01
     f46:	79 c1       	rjmp	.+754    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 5:
					PinVal = PINA.Bits.Pin5;
     f48:	e9 e3       	ldi	r30, 0x39	; 57
     f4a:	f0 e0       	ldi	r31, 0x00	; 0
     f4c:	80 81       	ld	r24, Z
     f4e:	82 95       	swap	r24
     f50:	86 95       	lsr	r24
     f52:	87 70       	andi	r24, 0x07	; 7
     f54:	81 70       	andi	r24, 0x01	; 1
     f56:	89 83       	std	Y+1, r24	; 0x01
     f58:	70 c1       	rjmp	.+736    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 6:
					PinVal = PINA.Bits.Pin6;
     f5a:	e9 e3       	ldi	r30, 0x39	; 57
     f5c:	f0 e0       	ldi	r31, 0x00	; 0
     f5e:	80 81       	ld	r24, Z
     f60:	82 95       	swap	r24
     f62:	86 95       	lsr	r24
     f64:	86 95       	lsr	r24
     f66:	83 70       	andi	r24, 0x03	; 3
     f68:	81 70       	andi	r24, 0x01	; 1
     f6a:	89 83       	std	Y+1, r24	; 0x01
     f6c:	66 c1       	rjmp	.+716    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 7:
					PinVal = PINA.Bits.Pin7;
     f6e:	e9 e3       	ldi	r30, 0x39	; 57
     f70:	f0 e0       	ldi	r31, 0x00	; 0
     f72:	80 81       	ld	r24, Z
     f74:	88 1f       	adc	r24, r24
     f76:	88 27       	eor	r24, r24
     f78:	88 1f       	adc	r24, r24
     f7a:	89 83       	std	Y+1, r24	; 0x01
     f7c:	5e c1       	rjmp	.+700    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;
			}
		break;

		case 1:
			switch(PinLoc)
     f7e:	8a 81       	ldd	r24, Y+2	; 0x02
     f80:	28 2f       	mov	r18, r24
     f82:	30 e0       	ldi	r19, 0x00	; 0
     f84:	3a 87       	std	Y+10, r19	; 0x0a
     f86:	29 87       	std	Y+9, r18	; 0x09
     f88:	89 85       	ldd	r24, Y+9	; 0x09
     f8a:	9a 85       	ldd	r25, Y+10	; 0x0a
     f8c:	83 30       	cpi	r24, 0x03	; 3
     f8e:	91 05       	cpc	r25, r1
     f90:	09 f4       	brne	.+2      	; 0xf94 <Dio_u8GetPinVal+0x16a>
     f92:	3e c0       	rjmp	.+124    	; 0x1010 <Dio_u8GetPinVal+0x1e6>
     f94:	29 85       	ldd	r18, Y+9	; 0x09
     f96:	3a 85       	ldd	r19, Y+10	; 0x0a
     f98:	24 30       	cpi	r18, 0x04	; 4
     f9a:	31 05       	cpc	r19, r1
     f9c:	7c f4       	brge	.+30     	; 0xfbc <Dio_u8GetPinVal+0x192>
     f9e:	89 85       	ldd	r24, Y+9	; 0x09
     fa0:	9a 85       	ldd	r25, Y+10	; 0x0a
     fa2:	81 30       	cpi	r24, 0x01	; 1
     fa4:	91 05       	cpc	r25, r1
     fa6:	29 f1       	breq	.+74     	; 0xff2 <Dio_u8GetPinVal+0x1c8>
     fa8:	29 85       	ldd	r18, Y+9	; 0x09
     faa:	3a 85       	ldd	r19, Y+10	; 0x0a
     fac:	22 30       	cpi	r18, 0x02	; 2
     fae:	31 05       	cpc	r19, r1
     fb0:	3c f5       	brge	.+78     	; 0x1000 <Dio_u8GetPinVal+0x1d6>
     fb2:	89 85       	ldd	r24, Y+9	; 0x09
     fb4:	9a 85       	ldd	r25, Y+10	; 0x0a
     fb6:	00 97       	sbiw	r24, 0x00	; 0
     fb8:	b1 f0       	breq	.+44     	; 0xfe6 <Dio_u8GetPinVal+0x1bc>
     fba:	3f c1       	rjmp	.+638    	; 0x123a <Dio_u8GetPinVal+0x410>
     fbc:	29 85       	ldd	r18, Y+9	; 0x09
     fbe:	3a 85       	ldd	r19, Y+10	; 0x0a
     fc0:	25 30       	cpi	r18, 0x05	; 5
     fc2:	31 05       	cpc	r19, r1
     fc4:	b1 f1       	breq	.+108    	; 0x1032 <Dio_u8GetPinVal+0x208>
     fc6:	89 85       	ldd	r24, Y+9	; 0x09
     fc8:	9a 85       	ldd	r25, Y+10	; 0x0a
     fca:	85 30       	cpi	r24, 0x05	; 5
     fcc:	91 05       	cpc	r25, r1
     fce:	4c f1       	brlt	.+82     	; 0x1022 <Dio_u8GetPinVal+0x1f8>
     fd0:	29 85       	ldd	r18, Y+9	; 0x09
     fd2:	3a 85       	ldd	r19, Y+10	; 0x0a
     fd4:	26 30       	cpi	r18, 0x06	; 6
     fd6:	31 05       	cpc	r19, r1
     fd8:	a9 f1       	breq	.+106    	; 0x1044 <Dio_u8GetPinVal+0x21a>
     fda:	89 85       	ldd	r24, Y+9	; 0x09
     fdc:	9a 85       	ldd	r25, Y+10	; 0x0a
     fde:	87 30       	cpi	r24, 0x07	; 7
     fe0:	91 05       	cpc	r25, r1
     fe2:	d1 f1       	breq	.+116    	; 0x1058 <Dio_u8GetPinVal+0x22e>
     fe4:	2a c1       	rjmp	.+596    	; 0x123a <Dio_u8GetPinVal+0x410>
			{
				case 0:
					PinVal = PINB.Bits.Pin0;
     fe6:	e6 e3       	ldi	r30, 0x36	; 54
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	80 81       	ld	r24, Z
     fec:	81 70       	andi	r24, 0x01	; 1
     fee:	89 83       	std	Y+1, r24	; 0x01
     ff0:	24 c1       	rjmp	.+584    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 1:
					PinVal = PINB.Bits.Pin1;
     ff2:	e6 e3       	ldi	r30, 0x36	; 54
     ff4:	f0 e0       	ldi	r31, 0x00	; 0
     ff6:	80 81       	ld	r24, Z
     ff8:	86 95       	lsr	r24
     ffa:	81 70       	andi	r24, 0x01	; 1
     ffc:	89 83       	std	Y+1, r24	; 0x01
     ffe:	1d c1       	rjmp	.+570    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 2:
					PinVal = PINB.Bits.Pin2;
    1000:	e6 e3       	ldi	r30, 0x36	; 54
    1002:	f0 e0       	ldi	r31, 0x00	; 0
    1004:	80 81       	ld	r24, Z
    1006:	86 95       	lsr	r24
    1008:	86 95       	lsr	r24
    100a:	81 70       	andi	r24, 0x01	; 1
    100c:	89 83       	std	Y+1, r24	; 0x01
    100e:	15 c1       	rjmp	.+554    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 3:
					PinVal = PINB.Bits.Pin3;
    1010:	e6 e3       	ldi	r30, 0x36	; 54
    1012:	f0 e0       	ldi	r31, 0x00	; 0
    1014:	80 81       	ld	r24, Z
    1016:	86 95       	lsr	r24
    1018:	86 95       	lsr	r24
    101a:	86 95       	lsr	r24
    101c:	81 70       	andi	r24, 0x01	; 1
    101e:	89 83       	std	Y+1, r24	; 0x01
    1020:	0c c1       	rjmp	.+536    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 4:
					PinVal = PINB.Bits.Pin4;
    1022:	e6 e3       	ldi	r30, 0x36	; 54
    1024:	f0 e0       	ldi	r31, 0x00	; 0
    1026:	80 81       	ld	r24, Z
    1028:	82 95       	swap	r24
    102a:	8f 70       	andi	r24, 0x0F	; 15
    102c:	81 70       	andi	r24, 0x01	; 1
    102e:	89 83       	std	Y+1, r24	; 0x01
    1030:	04 c1       	rjmp	.+520    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 5:
					PinVal = PINB.Bits.Pin5;
    1032:	e6 e3       	ldi	r30, 0x36	; 54
    1034:	f0 e0       	ldi	r31, 0x00	; 0
    1036:	80 81       	ld	r24, Z
    1038:	82 95       	swap	r24
    103a:	86 95       	lsr	r24
    103c:	87 70       	andi	r24, 0x07	; 7
    103e:	81 70       	andi	r24, 0x01	; 1
    1040:	89 83       	std	Y+1, r24	; 0x01
    1042:	fb c0       	rjmp	.+502    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 6:
					PinVal = PINB.Bits.Pin6;
    1044:	e6 e3       	ldi	r30, 0x36	; 54
    1046:	f0 e0       	ldi	r31, 0x00	; 0
    1048:	80 81       	ld	r24, Z
    104a:	82 95       	swap	r24
    104c:	86 95       	lsr	r24
    104e:	86 95       	lsr	r24
    1050:	83 70       	andi	r24, 0x03	; 3
    1052:	81 70       	andi	r24, 0x01	; 1
    1054:	89 83       	std	Y+1, r24	; 0x01
    1056:	f1 c0       	rjmp	.+482    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 7:
					PinVal = PINB.Bits.Pin7;
    1058:	e6 e3       	ldi	r30, 0x36	; 54
    105a:	f0 e0       	ldi	r31, 0x00	; 0
    105c:	80 81       	ld	r24, Z
    105e:	88 1f       	adc	r24, r24
    1060:	88 27       	eor	r24, r24
    1062:	88 1f       	adc	r24, r24
    1064:	89 83       	std	Y+1, r24	; 0x01
    1066:	e9 c0       	rjmp	.+466    	; 0x123a <Dio_u8GetPinVal+0x410>
			}

		break;

		case 2:
			switch(PinLoc)
    1068:	8a 81       	ldd	r24, Y+2	; 0x02
    106a:	28 2f       	mov	r18, r24
    106c:	30 e0       	ldi	r19, 0x00	; 0
    106e:	38 87       	std	Y+8, r19	; 0x08
    1070:	2f 83       	std	Y+7, r18	; 0x07
    1072:	8f 81       	ldd	r24, Y+7	; 0x07
    1074:	98 85       	ldd	r25, Y+8	; 0x08
    1076:	83 30       	cpi	r24, 0x03	; 3
    1078:	91 05       	cpc	r25, r1
    107a:	09 f4       	brne	.+2      	; 0x107e <Dio_u8GetPinVal+0x254>
    107c:	3e c0       	rjmp	.+124    	; 0x10fa <Dio_u8GetPinVal+0x2d0>
    107e:	2f 81       	ldd	r18, Y+7	; 0x07
    1080:	38 85       	ldd	r19, Y+8	; 0x08
    1082:	24 30       	cpi	r18, 0x04	; 4
    1084:	31 05       	cpc	r19, r1
    1086:	7c f4       	brge	.+30     	; 0x10a6 <Dio_u8GetPinVal+0x27c>
    1088:	8f 81       	ldd	r24, Y+7	; 0x07
    108a:	98 85       	ldd	r25, Y+8	; 0x08
    108c:	81 30       	cpi	r24, 0x01	; 1
    108e:	91 05       	cpc	r25, r1
    1090:	29 f1       	breq	.+74     	; 0x10dc <Dio_u8GetPinVal+0x2b2>
    1092:	2f 81       	ldd	r18, Y+7	; 0x07
    1094:	38 85       	ldd	r19, Y+8	; 0x08
    1096:	22 30       	cpi	r18, 0x02	; 2
    1098:	31 05       	cpc	r19, r1
    109a:	3c f5       	brge	.+78     	; 0x10ea <Dio_u8GetPinVal+0x2c0>
    109c:	8f 81       	ldd	r24, Y+7	; 0x07
    109e:	98 85       	ldd	r25, Y+8	; 0x08
    10a0:	00 97       	sbiw	r24, 0x00	; 0
    10a2:	b1 f0       	breq	.+44     	; 0x10d0 <Dio_u8GetPinVal+0x2a6>
    10a4:	ca c0       	rjmp	.+404    	; 0x123a <Dio_u8GetPinVal+0x410>
    10a6:	2f 81       	ldd	r18, Y+7	; 0x07
    10a8:	38 85       	ldd	r19, Y+8	; 0x08
    10aa:	25 30       	cpi	r18, 0x05	; 5
    10ac:	31 05       	cpc	r19, r1
    10ae:	b1 f1       	breq	.+108    	; 0x111c <Dio_u8GetPinVal+0x2f2>
    10b0:	8f 81       	ldd	r24, Y+7	; 0x07
    10b2:	98 85       	ldd	r25, Y+8	; 0x08
    10b4:	85 30       	cpi	r24, 0x05	; 5
    10b6:	91 05       	cpc	r25, r1
    10b8:	4c f1       	brlt	.+82     	; 0x110c <Dio_u8GetPinVal+0x2e2>
    10ba:	2f 81       	ldd	r18, Y+7	; 0x07
    10bc:	38 85       	ldd	r19, Y+8	; 0x08
    10be:	26 30       	cpi	r18, 0x06	; 6
    10c0:	31 05       	cpc	r19, r1
    10c2:	a9 f1       	breq	.+106    	; 0x112e <Dio_u8GetPinVal+0x304>
    10c4:	8f 81       	ldd	r24, Y+7	; 0x07
    10c6:	98 85       	ldd	r25, Y+8	; 0x08
    10c8:	87 30       	cpi	r24, 0x07	; 7
    10ca:	91 05       	cpc	r25, r1
    10cc:	d1 f1       	breq	.+116    	; 0x1142 <Dio_u8GetPinVal+0x318>
    10ce:	b5 c0       	rjmp	.+362    	; 0x123a <Dio_u8GetPinVal+0x410>
			{
				case 0:
					PinVal = PINC.Bits.Pin0;
    10d0:	e3 e3       	ldi	r30, 0x33	; 51
    10d2:	f0 e0       	ldi	r31, 0x00	; 0
    10d4:	80 81       	ld	r24, Z
    10d6:	81 70       	andi	r24, 0x01	; 1
    10d8:	89 83       	std	Y+1, r24	; 0x01
    10da:	af c0       	rjmp	.+350    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 1:
					PinVal = PINC.Bits.Pin1;
    10dc:	e3 e3       	ldi	r30, 0x33	; 51
    10de:	f0 e0       	ldi	r31, 0x00	; 0
    10e0:	80 81       	ld	r24, Z
    10e2:	86 95       	lsr	r24
    10e4:	81 70       	andi	r24, 0x01	; 1
    10e6:	89 83       	std	Y+1, r24	; 0x01
    10e8:	a8 c0       	rjmp	.+336    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 2:
					PinVal = PINC.Bits.Pin2;
    10ea:	e3 e3       	ldi	r30, 0x33	; 51
    10ec:	f0 e0       	ldi	r31, 0x00	; 0
    10ee:	80 81       	ld	r24, Z
    10f0:	86 95       	lsr	r24
    10f2:	86 95       	lsr	r24
    10f4:	81 70       	andi	r24, 0x01	; 1
    10f6:	89 83       	std	Y+1, r24	; 0x01
    10f8:	a0 c0       	rjmp	.+320    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 3:
					PinVal = PINC.Bits.Pin3;
    10fa:	e3 e3       	ldi	r30, 0x33	; 51
    10fc:	f0 e0       	ldi	r31, 0x00	; 0
    10fe:	80 81       	ld	r24, Z
    1100:	86 95       	lsr	r24
    1102:	86 95       	lsr	r24
    1104:	86 95       	lsr	r24
    1106:	81 70       	andi	r24, 0x01	; 1
    1108:	89 83       	std	Y+1, r24	; 0x01
    110a:	97 c0       	rjmp	.+302    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 4:
					PinVal = PINC.Bits.Pin4;
    110c:	e3 e3       	ldi	r30, 0x33	; 51
    110e:	f0 e0       	ldi	r31, 0x00	; 0
    1110:	80 81       	ld	r24, Z
    1112:	82 95       	swap	r24
    1114:	8f 70       	andi	r24, 0x0F	; 15
    1116:	81 70       	andi	r24, 0x01	; 1
    1118:	89 83       	std	Y+1, r24	; 0x01
    111a:	8f c0       	rjmp	.+286    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 5:
					PinVal = PINC.Bits.Pin5;
    111c:	e3 e3       	ldi	r30, 0x33	; 51
    111e:	f0 e0       	ldi	r31, 0x00	; 0
    1120:	80 81       	ld	r24, Z
    1122:	82 95       	swap	r24
    1124:	86 95       	lsr	r24
    1126:	87 70       	andi	r24, 0x07	; 7
    1128:	81 70       	andi	r24, 0x01	; 1
    112a:	89 83       	std	Y+1, r24	; 0x01
    112c:	86 c0       	rjmp	.+268    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 6:
					PinVal = PINC.Bits.Pin6;
    112e:	e3 e3       	ldi	r30, 0x33	; 51
    1130:	f0 e0       	ldi	r31, 0x00	; 0
    1132:	80 81       	ld	r24, Z
    1134:	82 95       	swap	r24
    1136:	86 95       	lsr	r24
    1138:	86 95       	lsr	r24
    113a:	83 70       	andi	r24, 0x03	; 3
    113c:	81 70       	andi	r24, 0x01	; 1
    113e:	89 83       	std	Y+1, r24	; 0x01
    1140:	7c c0       	rjmp	.+248    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 7:
					PinVal = PINC.Bits.Pin7;
    1142:	e3 e3       	ldi	r30, 0x33	; 51
    1144:	f0 e0       	ldi	r31, 0x00	; 0
    1146:	80 81       	ld	r24, Z
    1148:	88 1f       	adc	r24, r24
    114a:	88 27       	eor	r24, r24
    114c:	88 1f       	adc	r24, r24
    114e:	89 83       	std	Y+1, r24	; 0x01
    1150:	74 c0       	rjmp	.+232    	; 0x123a <Dio_u8GetPinVal+0x410>
			}

		break;

		case 3:
			switch(PinLoc)
    1152:	8a 81       	ldd	r24, Y+2	; 0x02
    1154:	28 2f       	mov	r18, r24
    1156:	30 e0       	ldi	r19, 0x00	; 0
    1158:	3e 83       	std	Y+6, r19	; 0x06
    115a:	2d 83       	std	Y+5, r18	; 0x05
    115c:	8d 81       	ldd	r24, Y+5	; 0x05
    115e:	9e 81       	ldd	r25, Y+6	; 0x06
    1160:	83 30       	cpi	r24, 0x03	; 3
    1162:	91 05       	cpc	r25, r1
    1164:	09 f4       	brne	.+2      	; 0x1168 <Dio_u8GetPinVal+0x33e>
    1166:	3e c0       	rjmp	.+124    	; 0x11e4 <Dio_u8GetPinVal+0x3ba>
    1168:	2d 81       	ldd	r18, Y+5	; 0x05
    116a:	3e 81       	ldd	r19, Y+6	; 0x06
    116c:	24 30       	cpi	r18, 0x04	; 4
    116e:	31 05       	cpc	r19, r1
    1170:	7c f4       	brge	.+30     	; 0x1190 <Dio_u8GetPinVal+0x366>
    1172:	8d 81       	ldd	r24, Y+5	; 0x05
    1174:	9e 81       	ldd	r25, Y+6	; 0x06
    1176:	81 30       	cpi	r24, 0x01	; 1
    1178:	91 05       	cpc	r25, r1
    117a:	29 f1       	breq	.+74     	; 0x11c6 <Dio_u8GetPinVal+0x39c>
    117c:	2d 81       	ldd	r18, Y+5	; 0x05
    117e:	3e 81       	ldd	r19, Y+6	; 0x06
    1180:	22 30       	cpi	r18, 0x02	; 2
    1182:	31 05       	cpc	r19, r1
    1184:	3c f5       	brge	.+78     	; 0x11d4 <Dio_u8GetPinVal+0x3aa>
    1186:	8d 81       	ldd	r24, Y+5	; 0x05
    1188:	9e 81       	ldd	r25, Y+6	; 0x06
    118a:	00 97       	sbiw	r24, 0x00	; 0
    118c:	b1 f0       	breq	.+44     	; 0x11ba <Dio_u8GetPinVal+0x390>
    118e:	55 c0       	rjmp	.+170    	; 0x123a <Dio_u8GetPinVal+0x410>
    1190:	2d 81       	ldd	r18, Y+5	; 0x05
    1192:	3e 81       	ldd	r19, Y+6	; 0x06
    1194:	25 30       	cpi	r18, 0x05	; 5
    1196:	31 05       	cpc	r19, r1
    1198:	b1 f1       	breq	.+108    	; 0x1206 <Dio_u8GetPinVal+0x3dc>
    119a:	8d 81       	ldd	r24, Y+5	; 0x05
    119c:	9e 81       	ldd	r25, Y+6	; 0x06
    119e:	85 30       	cpi	r24, 0x05	; 5
    11a0:	91 05       	cpc	r25, r1
    11a2:	4c f1       	brlt	.+82     	; 0x11f6 <Dio_u8GetPinVal+0x3cc>
    11a4:	2d 81       	ldd	r18, Y+5	; 0x05
    11a6:	3e 81       	ldd	r19, Y+6	; 0x06
    11a8:	26 30       	cpi	r18, 0x06	; 6
    11aa:	31 05       	cpc	r19, r1
    11ac:	a9 f1       	breq	.+106    	; 0x1218 <Dio_u8GetPinVal+0x3ee>
    11ae:	8d 81       	ldd	r24, Y+5	; 0x05
    11b0:	9e 81       	ldd	r25, Y+6	; 0x06
    11b2:	87 30       	cpi	r24, 0x07	; 7
    11b4:	91 05       	cpc	r25, r1
    11b6:	d1 f1       	breq	.+116    	; 0x122c <Dio_u8GetPinVal+0x402>
    11b8:	40 c0       	rjmp	.+128    	; 0x123a <Dio_u8GetPinVal+0x410>
			{
				case 0:
					PinVal = PIND.Bits.Pin0;
    11ba:	e0 e3       	ldi	r30, 0x30	; 48
    11bc:	f0 e0       	ldi	r31, 0x00	; 0
    11be:	80 81       	ld	r24, Z
    11c0:	81 70       	andi	r24, 0x01	; 1
    11c2:	89 83       	std	Y+1, r24	; 0x01
    11c4:	3a c0       	rjmp	.+116    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 1:
					PinVal = PIND.Bits.Pin1;
    11c6:	e0 e3       	ldi	r30, 0x30	; 48
    11c8:	f0 e0       	ldi	r31, 0x00	; 0
    11ca:	80 81       	ld	r24, Z
    11cc:	86 95       	lsr	r24
    11ce:	81 70       	andi	r24, 0x01	; 1
    11d0:	89 83       	std	Y+1, r24	; 0x01
    11d2:	33 c0       	rjmp	.+102    	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 2:
					PinVal = PIND.Bits.Pin2;
    11d4:	e0 e3       	ldi	r30, 0x30	; 48
    11d6:	f0 e0       	ldi	r31, 0x00	; 0
    11d8:	80 81       	ld	r24, Z
    11da:	86 95       	lsr	r24
    11dc:	86 95       	lsr	r24
    11de:	81 70       	andi	r24, 0x01	; 1
    11e0:	89 83       	std	Y+1, r24	; 0x01
    11e2:	2b c0       	rjmp	.+86     	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 3:
					PinVal = PIND.Bits.Pin3;
    11e4:	e0 e3       	ldi	r30, 0x30	; 48
    11e6:	f0 e0       	ldi	r31, 0x00	; 0
    11e8:	80 81       	ld	r24, Z
    11ea:	86 95       	lsr	r24
    11ec:	86 95       	lsr	r24
    11ee:	86 95       	lsr	r24
    11f0:	81 70       	andi	r24, 0x01	; 1
    11f2:	89 83       	std	Y+1, r24	; 0x01
    11f4:	22 c0       	rjmp	.+68     	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 4:
					PinVal = PIND.Bits.Pin4;
    11f6:	e0 e3       	ldi	r30, 0x30	; 48
    11f8:	f0 e0       	ldi	r31, 0x00	; 0
    11fa:	80 81       	ld	r24, Z
    11fc:	82 95       	swap	r24
    11fe:	8f 70       	andi	r24, 0x0F	; 15
    1200:	81 70       	andi	r24, 0x01	; 1
    1202:	89 83       	std	Y+1, r24	; 0x01
    1204:	1a c0       	rjmp	.+52     	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 5:
					PinVal = PIND.Bits.Pin5;
    1206:	e0 e3       	ldi	r30, 0x30	; 48
    1208:	f0 e0       	ldi	r31, 0x00	; 0
    120a:	80 81       	ld	r24, Z
    120c:	82 95       	swap	r24
    120e:	86 95       	lsr	r24
    1210:	87 70       	andi	r24, 0x07	; 7
    1212:	81 70       	andi	r24, 0x01	; 1
    1214:	89 83       	std	Y+1, r24	; 0x01
    1216:	11 c0       	rjmp	.+34     	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 6:
					PinVal = PIND.Bits.Pin6;
    1218:	e0 e3       	ldi	r30, 0x30	; 48
    121a:	f0 e0       	ldi	r31, 0x00	; 0
    121c:	80 81       	ld	r24, Z
    121e:	82 95       	swap	r24
    1220:	86 95       	lsr	r24
    1222:	86 95       	lsr	r24
    1224:	83 70       	andi	r24, 0x03	; 3
    1226:	81 70       	andi	r24, 0x01	; 1
    1228:	89 83       	std	Y+1, r24	; 0x01
    122a:	07 c0       	rjmp	.+14     	; 0x123a <Dio_u8GetPinVal+0x410>
				break;

				case 7:
					PinVal = PIND.Bits.Pin7;
    122c:	e0 e3       	ldi	r30, 0x30	; 48
    122e:	f0 e0       	ldi	r31, 0x00	; 0
    1230:	80 81       	ld	r24, Z
    1232:	88 1f       	adc	r24, r24
    1234:	88 27       	eor	r24, r24
    1236:	88 1f       	adc	r24, r24
    1238:	89 83       	std	Y+1, r24	; 0x01
				break;
			}
		break;
	}
	return PinVal;
    123a:	89 81       	ldd	r24, Y+1	; 0x01
}
    123c:	2e 96       	adiw	r28, 0x0e	; 14
    123e:	0f b6       	in	r0, 0x3f	; 63
    1240:	f8 94       	cli
    1242:	de bf       	out	0x3e, r29	; 62
    1244:	0f be       	out	0x3f, r0	; 63
    1246:	cd bf       	out	0x3d, r28	; 61
    1248:	cf 91       	pop	r28
    124a:	df 91       	pop	r29
    124c:	08 95       	ret

0000124e <Keypad_vidInit>:
#include "Dio_int.h"
#include "Keypad_int.h"


void Keypad_vidInit(void)
{
    124e:	df 93       	push	r29
    1250:	cf 93       	push	r28
    1252:	cd b7       	in	r28, 0x3d	; 61
    1254:	de b7       	in	r29, 0x3e	; 62
	Dio_vidSetPinDir(KEYPAD_u8R1_PIN , DIO_u8OUTPUT);
    1256:	88 e0       	ldi	r24, 0x08	; 8
    1258:	61 e0       	ldi	r22, 0x01	; 1
    125a:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	Dio_vidSetPinDir(KEYPAD_u8R2_PIN , DIO_u8OUTPUT);
    125e:	89 e0       	ldi	r24, 0x09	; 9
    1260:	61 e0       	ldi	r22, 0x01	; 1
    1262:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	Dio_vidSetPinDir(KEYPAD_u8R3_PIN , DIO_u8OUTPUT);
    1266:	8a e0       	ldi	r24, 0x0A	; 10
    1268:	61 e0       	ldi	r22, 0x01	; 1
    126a:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	Dio_vidSetPinDir(KEYPAD_u8R4_PIN , DIO_u8OUTPUT);
    126e:	8b e0       	ldi	r24, 0x0B	; 11
    1270:	61 e0       	ldi	r22, 0x01	; 1
    1272:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	Dio_vidSetPinDir(KEYPAD_u8C1_PIN , DIO_u8INPUT);
    1276:	8c e0       	ldi	r24, 0x0C	; 12
    1278:	60 e0       	ldi	r22, 0x00	; 0
    127a:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	Dio_vidSetPinDir(KEYPAD_u8C2_PIN , DIO_u8INPUT);
    127e:	8d e0       	ldi	r24, 0x0D	; 13
    1280:	60 e0       	ldi	r22, 0x00	; 0
    1282:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	Dio_vidSetPinDir(KEYPAD_u8C3_PIN , DIO_u8INPUT);
    1286:	8e e0       	ldi	r24, 0x0E	; 14
    1288:	60 e0       	ldi	r22, 0x00	; 0
    128a:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	Dio_vidSetPinDir(KEYPAD_u8C4_PIN , DIO_u8INPUT);
    128e:	8f e0       	ldi	r24, 0x0F	; 15
    1290:	60 e0       	ldi	r22, 0x00	; 0
    1292:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>

	Dio_vidSetPinVal(KEYPAD_u8R1_PIN , DIO_u8HIGH);
    1296:	88 e0       	ldi	r24, 0x08	; 8
    1298:	61 e0       	ldi	r22, 0x01	; 1
    129a:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R2_PIN , DIO_u8HIGH);
    129e:	89 e0       	ldi	r24, 0x09	; 9
    12a0:	61 e0       	ldi	r22, 0x01	; 1
    12a2:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R3_PIN , DIO_u8HIGH);
    12a6:	8a e0       	ldi	r24, 0x0A	; 10
    12a8:	61 e0       	ldi	r22, 0x01	; 1
    12aa:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R4_PIN , DIO_u8HIGH);
    12ae:	8b e0       	ldi	r24, 0x0B	; 11
    12b0:	61 e0       	ldi	r22, 0x01	; 1
    12b2:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8C1_PIN , DIO_u8HIGH);
    12b6:	8c e0       	ldi	r24, 0x0C	; 12
    12b8:	61 e0       	ldi	r22, 0x01	; 1
    12ba:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8C2_PIN , DIO_u8HIGH);
    12be:	8d e0       	ldi	r24, 0x0D	; 13
    12c0:	61 e0       	ldi	r22, 0x01	; 1
    12c2:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8C3_PIN , DIO_u8HIGH);
    12c6:	8e e0       	ldi	r24, 0x0E	; 14
    12c8:	61 e0       	ldi	r22, 0x01	; 1
    12ca:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8C4_PIN , DIO_u8HIGH);
    12ce:	8f e0       	ldi	r24, 0x0F	; 15
    12d0:	61 e0       	ldi	r22, 0x01	; 1
    12d2:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>

}
    12d6:	cf 91       	pop	r28
    12d8:	df 91       	pop	r29
    12da:	08 95       	ret

000012dc <Keypad_u8GetKey>:

u8 Keypad_u8GetKey(void)
{
    12dc:	df 93       	push	r29
    12de:	cf 93       	push	r28
    12e0:	cd b7       	in	r28, 0x3d	; 61
    12e2:	de b7       	in	r29, 0x3e	; 62
    12e4:	2e 97       	sbiw	r28, 0x0e	; 14
    12e6:	0f b6       	in	r0, 0x3f	; 63
    12e8:	f8 94       	cli
    12ea:	de bf       	out	0x3e, r29	; 62
    12ec:	0f be       	out	0x3f, r0	; 63
    12ee:	cd bf       	out	0x3d, r28	; 61
	u8 pin_c2;
	u8 pin_c3;
	u8 pin_c4;
	u8 temp;

	Dio_vidSetPinVal(KEYPAD_u8R1_PIN , DIO_u8LOW);
    12f0:	88 e0       	ldi	r24, 0x08	; 8
    12f2:	60 e0       	ldi	r22, 0x00	; 0
    12f4:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R2_PIN , DIO_u8HIGH);
    12f8:	89 e0       	ldi	r24, 0x09	; 9
    12fa:	61 e0       	ldi	r22, 0x01	; 1
    12fc:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R3_PIN , DIO_u8HIGH);
    1300:	8a e0       	ldi	r24, 0x0A	; 10
    1302:	61 e0       	ldi	r22, 0x01	; 1
    1304:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R4_PIN , DIO_u8HIGH);
    1308:	8b e0       	ldi	r24, 0x0B	; 11
    130a:	61 e0       	ldi	r22, 0x01	; 1
    130c:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>

	//create mask to get value of pins
	pin_c1 = Dio_u8GetPinVal(KEYPAD_u8C1_PIN);
    1310:	8c e0       	ldi	r24, 0x0C	; 12
    1312:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    1316:	8d 83       	std	Y+5, r24	; 0x05
	pin_c2 = Dio_u8GetPinVal(KEYPAD_u8C2_PIN);
    1318:	8d e0       	ldi	r24, 0x0D	; 13
    131a:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    131e:	8c 83       	std	Y+4, r24	; 0x04
	pin_c3 = Dio_u8GetPinVal(KEYPAD_u8C3_PIN);
    1320:	8e e0       	ldi	r24, 0x0E	; 14
    1322:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    1326:	8b 83       	std	Y+3, r24	; 0x03
	pin_c4 = Dio_u8GetPinVal(KEYPAD_u8C4_PIN);
    1328:	8f e0       	ldi	r24, 0x0F	; 15
    132a:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    132e:	8a 83       	std	Y+2, r24	; 0x02

	temp = 0;
    1330:	19 82       	std	Y+1, r1	; 0x01
	temp |= (pin_c1 <<4);
    1332:	8d 81       	ldd	r24, Y+5	; 0x05
    1334:	88 2f       	mov	r24, r24
    1336:	90 e0       	ldi	r25, 0x00	; 0
    1338:	82 95       	swap	r24
    133a:	92 95       	swap	r25
    133c:	90 7f       	andi	r25, 0xF0	; 240
    133e:	98 27       	eor	r25, r24
    1340:	80 7f       	andi	r24, 0xF0	; 240
    1342:	98 27       	eor	r25, r24
    1344:	98 2f       	mov	r25, r24
    1346:	89 81       	ldd	r24, Y+1	; 0x01
    1348:	89 2b       	or	r24, r25
    134a:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c2 <<5);
    134c:	8c 81       	ldd	r24, Y+4	; 0x04
    134e:	88 2f       	mov	r24, r24
    1350:	90 e0       	ldi	r25, 0x00	; 0
    1352:	88 0f       	add	r24, r24
    1354:	99 1f       	adc	r25, r25
    1356:	82 95       	swap	r24
    1358:	92 95       	swap	r25
    135a:	90 7f       	andi	r25, 0xF0	; 240
    135c:	98 27       	eor	r25, r24
    135e:	80 7f       	andi	r24, 0xF0	; 240
    1360:	98 27       	eor	r25, r24
    1362:	98 2f       	mov	r25, r24
    1364:	89 81       	ldd	r24, Y+1	; 0x01
    1366:	89 2b       	or	r24, r25
    1368:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c3 <<6);
    136a:	8b 81       	ldd	r24, Y+3	; 0x03
    136c:	88 2f       	mov	r24, r24
    136e:	90 e0       	ldi	r25, 0x00	; 0
    1370:	00 24       	eor	r0, r0
    1372:	96 95       	lsr	r25
    1374:	87 95       	ror	r24
    1376:	07 94       	ror	r0
    1378:	96 95       	lsr	r25
    137a:	87 95       	ror	r24
    137c:	07 94       	ror	r0
    137e:	98 2f       	mov	r25, r24
    1380:	80 2d       	mov	r24, r0
    1382:	98 2f       	mov	r25, r24
    1384:	89 81       	ldd	r24, Y+1	; 0x01
    1386:	89 2b       	or	r24, r25
    1388:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c4 <<7);
    138a:	8a 81       	ldd	r24, Y+2	; 0x02
    138c:	88 2f       	mov	r24, r24
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	96 95       	lsr	r25
    1392:	98 2f       	mov	r25, r24
    1394:	88 27       	eor	r24, r24
    1396:	97 95       	ror	r25
    1398:	87 95       	ror	r24
    139a:	98 2f       	mov	r25, r24
    139c:	89 81       	ldd	r24, Y+1	; 0x01
    139e:	89 2b       	or	r24, r25
    13a0:	89 83       	std	Y+1, r24	; 0x01

	switch(temp)
    13a2:	89 81       	ldd	r24, Y+1	; 0x01
    13a4:	28 2f       	mov	r18, r24
    13a6:	30 e0       	ldi	r19, 0x00	; 0
    13a8:	3e 87       	std	Y+14, r19	; 0x0e
    13aa:	2d 87       	std	Y+13, r18	; 0x0d
    13ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    13ae:	9e 85       	ldd	r25, Y+14	; 0x0e
    13b0:	80 3b       	cpi	r24, 0xB0	; 176
    13b2:	91 05       	cpc	r25, r1
    13b4:	d9 f0       	breq	.+54     	; 0x13ec <Keypad_u8GetKey+0x110>
    13b6:	2d 85       	ldd	r18, Y+13	; 0x0d
    13b8:	3e 85       	ldd	r19, Y+14	; 0x0e
    13ba:	21 3b       	cpi	r18, 0xB1	; 177
    13bc:	31 05       	cpc	r19, r1
    13be:	34 f4       	brge	.+12     	; 0x13cc <Keypad_u8GetKey+0xf0>
    13c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    13c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    13c4:	80 37       	cpi	r24, 0x70	; 112
    13c6:	91 05       	cpc	r25, r1
    13c8:	a1 f0       	breq	.+40     	; 0x13f2 <Keypad_u8GetKey+0x116>
    13ca:	16 c0       	rjmp	.+44     	; 0x13f8 <Keypad_u8GetKey+0x11c>
    13cc:	2d 85       	ldd	r18, Y+13	; 0x0d
    13ce:	3e 85       	ldd	r19, Y+14	; 0x0e
    13d0:	20 3d       	cpi	r18, 0xD0	; 208
    13d2:	31 05       	cpc	r19, r1
    13d4:	41 f0       	breq	.+16     	; 0x13e6 <Keypad_u8GetKey+0x10a>
    13d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    13d8:	9e 85       	ldd	r25, Y+14	; 0x0e
    13da:	80 3e       	cpi	r24, 0xE0	; 224
    13dc:	91 05       	cpc	r25, r1
    13de:	61 f4       	brne	.+24     	; 0x13f8 <Keypad_u8GetKey+0x11c>
	{
		case 0b11100000:
			return KEYPAD_u8R1C1_KEY;
    13e0:	91 e0       	ldi	r25, 0x01	; 1
    13e2:	9c 87       	std	Y+12, r25	; 0x0c
    13e4:	96 c1       	rjmp	.+812    	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b11010000:
			return KEYPAD_u8R1C2_KEY;
    13e6:	22 e0       	ldi	r18, 0x02	; 2
    13e8:	2c 87       	std	Y+12, r18	; 0x0c
    13ea:	93 c1       	rjmp	.+806    	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b10110000:
			return KEYPAD_u8R1C3_KEY;
    13ec:	33 e0       	ldi	r19, 0x03	; 3
    13ee:	3c 87       	std	Y+12, r19	; 0x0c
    13f0:	90 c1       	rjmp	.+800    	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b01110000:
			return KEYPAD_u8R1C4_KEY;
    13f2:	8b e2       	ldi	r24, 0x2B	; 43
    13f4:	8c 87       	std	Y+12, r24	; 0x0c
    13f6:	8d c1       	rjmp	.+794    	; 0x1712 <Keypad_u8GetKey+0x436>
	}


	Dio_vidSetPinVal(KEYPAD_u8R1_PIN , DIO_u8HIGH);
    13f8:	88 e0       	ldi	r24, 0x08	; 8
    13fa:	61 e0       	ldi	r22, 0x01	; 1
    13fc:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R2_PIN , DIO_u8LOW);
    1400:	89 e0       	ldi	r24, 0x09	; 9
    1402:	60 e0       	ldi	r22, 0x00	; 0
    1404:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R3_PIN , DIO_u8HIGH);
    1408:	8a e0       	ldi	r24, 0x0A	; 10
    140a:	61 e0       	ldi	r22, 0x01	; 1
    140c:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R4_PIN , DIO_u8HIGH);
    1410:	8b e0       	ldi	r24, 0x0B	; 11
    1412:	61 e0       	ldi	r22, 0x01	; 1
    1414:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>


	pin_c1 = Dio_u8GetPinVal(KEYPAD_u8C1_PIN);
    1418:	8c e0       	ldi	r24, 0x0C	; 12
    141a:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    141e:	8d 83       	std	Y+5, r24	; 0x05
	pin_c2 = Dio_u8GetPinVal(KEYPAD_u8C2_PIN);
    1420:	8d e0       	ldi	r24, 0x0D	; 13
    1422:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    1426:	8c 83       	std	Y+4, r24	; 0x04
	pin_c3 = Dio_u8GetPinVal(KEYPAD_u8C3_PIN);
    1428:	8e e0       	ldi	r24, 0x0E	; 14
    142a:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    142e:	8b 83       	std	Y+3, r24	; 0x03
	pin_c4 = Dio_u8GetPinVal(KEYPAD_u8C4_PIN);
    1430:	8f e0       	ldi	r24, 0x0F	; 15
    1432:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    1436:	8a 83       	std	Y+2, r24	; 0x02

	temp = 0;
    1438:	19 82       	std	Y+1, r1	; 0x01
	temp |= (pin_c1 <<4);
    143a:	8d 81       	ldd	r24, Y+5	; 0x05
    143c:	88 2f       	mov	r24, r24
    143e:	90 e0       	ldi	r25, 0x00	; 0
    1440:	82 95       	swap	r24
    1442:	92 95       	swap	r25
    1444:	90 7f       	andi	r25, 0xF0	; 240
    1446:	98 27       	eor	r25, r24
    1448:	80 7f       	andi	r24, 0xF0	; 240
    144a:	98 27       	eor	r25, r24
    144c:	98 2f       	mov	r25, r24
    144e:	89 81       	ldd	r24, Y+1	; 0x01
    1450:	89 2b       	or	r24, r25
    1452:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c2 <<5);
    1454:	8c 81       	ldd	r24, Y+4	; 0x04
    1456:	88 2f       	mov	r24, r24
    1458:	90 e0       	ldi	r25, 0x00	; 0
    145a:	88 0f       	add	r24, r24
    145c:	99 1f       	adc	r25, r25
    145e:	82 95       	swap	r24
    1460:	92 95       	swap	r25
    1462:	90 7f       	andi	r25, 0xF0	; 240
    1464:	98 27       	eor	r25, r24
    1466:	80 7f       	andi	r24, 0xF0	; 240
    1468:	98 27       	eor	r25, r24
    146a:	98 2f       	mov	r25, r24
    146c:	89 81       	ldd	r24, Y+1	; 0x01
    146e:	89 2b       	or	r24, r25
    1470:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c3 <<6);
    1472:	8b 81       	ldd	r24, Y+3	; 0x03
    1474:	88 2f       	mov	r24, r24
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	00 24       	eor	r0, r0
    147a:	96 95       	lsr	r25
    147c:	87 95       	ror	r24
    147e:	07 94       	ror	r0
    1480:	96 95       	lsr	r25
    1482:	87 95       	ror	r24
    1484:	07 94       	ror	r0
    1486:	98 2f       	mov	r25, r24
    1488:	80 2d       	mov	r24, r0
    148a:	98 2f       	mov	r25, r24
    148c:	89 81       	ldd	r24, Y+1	; 0x01
    148e:	89 2b       	or	r24, r25
    1490:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c4 <<7);
    1492:	8a 81       	ldd	r24, Y+2	; 0x02
    1494:	88 2f       	mov	r24, r24
    1496:	90 e0       	ldi	r25, 0x00	; 0
    1498:	96 95       	lsr	r25
    149a:	98 2f       	mov	r25, r24
    149c:	88 27       	eor	r24, r24
    149e:	97 95       	ror	r25
    14a0:	87 95       	ror	r24
    14a2:	98 2f       	mov	r25, r24
    14a4:	89 81       	ldd	r24, Y+1	; 0x01
    14a6:	89 2b       	or	r24, r25
    14a8:	89 83       	std	Y+1, r24	; 0x01

	switch(temp)
    14aa:	89 81       	ldd	r24, Y+1	; 0x01
    14ac:	28 2f       	mov	r18, r24
    14ae:	30 e0       	ldi	r19, 0x00	; 0
    14b0:	3b 87       	std	Y+11, r19	; 0x0b
    14b2:	2a 87       	std	Y+10, r18	; 0x0a
    14b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    14b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    14b8:	80 3b       	cpi	r24, 0xB0	; 176
    14ba:	91 05       	cpc	r25, r1
    14bc:	d9 f0       	breq	.+54     	; 0x14f4 <Keypad_u8GetKey+0x218>
    14be:	2a 85       	ldd	r18, Y+10	; 0x0a
    14c0:	3b 85       	ldd	r19, Y+11	; 0x0b
    14c2:	21 3b       	cpi	r18, 0xB1	; 177
    14c4:	31 05       	cpc	r19, r1
    14c6:	34 f4       	brge	.+12     	; 0x14d4 <Keypad_u8GetKey+0x1f8>
    14c8:	8a 85       	ldd	r24, Y+10	; 0x0a
    14ca:	9b 85       	ldd	r25, Y+11	; 0x0b
    14cc:	80 37       	cpi	r24, 0x70	; 112
    14ce:	91 05       	cpc	r25, r1
    14d0:	a1 f0       	breq	.+40     	; 0x14fa <Keypad_u8GetKey+0x21e>
    14d2:	16 c0       	rjmp	.+44     	; 0x1500 <Keypad_u8GetKey+0x224>
    14d4:	2a 85       	ldd	r18, Y+10	; 0x0a
    14d6:	3b 85       	ldd	r19, Y+11	; 0x0b
    14d8:	20 3d       	cpi	r18, 0xD0	; 208
    14da:	31 05       	cpc	r19, r1
    14dc:	41 f0       	breq	.+16     	; 0x14ee <Keypad_u8GetKey+0x212>
    14de:	8a 85       	ldd	r24, Y+10	; 0x0a
    14e0:	9b 85       	ldd	r25, Y+11	; 0x0b
    14e2:	80 3e       	cpi	r24, 0xE0	; 224
    14e4:	91 05       	cpc	r25, r1
    14e6:	61 f4       	brne	.+24     	; 0x1500 <Keypad_u8GetKey+0x224>
	{
		case 0b11100000:
			return KEYPAD_u8R2C1_KEY;
    14e8:	94 e0       	ldi	r25, 0x04	; 4
    14ea:	9c 87       	std	Y+12, r25	; 0x0c
    14ec:	12 c1       	rjmp	.+548    	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b11010000:
			return KEYPAD_u8R2C2_KEY;
    14ee:	25 e0       	ldi	r18, 0x05	; 5
    14f0:	2c 87       	std	Y+12, r18	; 0x0c
    14f2:	0f c1       	rjmp	.+542    	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b10110000:
			return KEYPAD_u8R2C3_KEY;
    14f4:	36 e0       	ldi	r19, 0x06	; 6
    14f6:	3c 87       	std	Y+12, r19	; 0x0c
    14f8:	0c c1       	rjmp	.+536    	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b01110000:
			return KEYPAD_u8R2C4_KEY;
    14fa:	8d e2       	ldi	r24, 0x2D	; 45
    14fc:	8c 87       	std	Y+12, r24	; 0x0c
    14fe:	09 c1       	rjmp	.+530    	; 0x1712 <Keypad_u8GetKey+0x436>
	}


	Dio_vidSetPinVal(KEYPAD_u8R1_PIN , DIO_u8HIGH);
    1500:	88 e0       	ldi	r24, 0x08	; 8
    1502:	61 e0       	ldi	r22, 0x01	; 1
    1504:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R2_PIN , DIO_u8HIGH);
    1508:	89 e0       	ldi	r24, 0x09	; 9
    150a:	61 e0       	ldi	r22, 0x01	; 1
    150c:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R3_PIN , DIO_u8LOW);
    1510:	8a e0       	ldi	r24, 0x0A	; 10
    1512:	60 e0       	ldi	r22, 0x00	; 0
    1514:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R4_PIN , DIO_u8HIGH);
    1518:	8b e0       	ldi	r24, 0x0B	; 11
    151a:	61 e0       	ldi	r22, 0x01	; 1
    151c:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>


	pin_c1 = Dio_u8GetPinVal(KEYPAD_u8C1_PIN);
    1520:	8c e0       	ldi	r24, 0x0C	; 12
    1522:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    1526:	8d 83       	std	Y+5, r24	; 0x05
	pin_c2 = Dio_u8GetPinVal(KEYPAD_u8C2_PIN);
    1528:	8d e0       	ldi	r24, 0x0D	; 13
    152a:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    152e:	8c 83       	std	Y+4, r24	; 0x04
	pin_c3 = Dio_u8GetPinVal(KEYPAD_u8C3_PIN);
    1530:	8e e0       	ldi	r24, 0x0E	; 14
    1532:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    1536:	8b 83       	std	Y+3, r24	; 0x03
	pin_c4 = Dio_u8GetPinVal(KEYPAD_u8C4_PIN);
    1538:	8f e0       	ldi	r24, 0x0F	; 15
    153a:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    153e:	8a 83       	std	Y+2, r24	; 0x02

	temp = 0;
    1540:	19 82       	std	Y+1, r1	; 0x01
	temp |= (pin_c1 <<4);
    1542:	8d 81       	ldd	r24, Y+5	; 0x05
    1544:	88 2f       	mov	r24, r24
    1546:	90 e0       	ldi	r25, 0x00	; 0
    1548:	82 95       	swap	r24
    154a:	92 95       	swap	r25
    154c:	90 7f       	andi	r25, 0xF0	; 240
    154e:	98 27       	eor	r25, r24
    1550:	80 7f       	andi	r24, 0xF0	; 240
    1552:	98 27       	eor	r25, r24
    1554:	98 2f       	mov	r25, r24
    1556:	89 81       	ldd	r24, Y+1	; 0x01
    1558:	89 2b       	or	r24, r25
    155a:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c2 <<5);
    155c:	8c 81       	ldd	r24, Y+4	; 0x04
    155e:	88 2f       	mov	r24, r24
    1560:	90 e0       	ldi	r25, 0x00	; 0
    1562:	88 0f       	add	r24, r24
    1564:	99 1f       	adc	r25, r25
    1566:	82 95       	swap	r24
    1568:	92 95       	swap	r25
    156a:	90 7f       	andi	r25, 0xF0	; 240
    156c:	98 27       	eor	r25, r24
    156e:	80 7f       	andi	r24, 0xF0	; 240
    1570:	98 27       	eor	r25, r24
    1572:	98 2f       	mov	r25, r24
    1574:	89 81       	ldd	r24, Y+1	; 0x01
    1576:	89 2b       	or	r24, r25
    1578:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c3 <<6);
    157a:	8b 81       	ldd	r24, Y+3	; 0x03
    157c:	88 2f       	mov	r24, r24
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	00 24       	eor	r0, r0
    1582:	96 95       	lsr	r25
    1584:	87 95       	ror	r24
    1586:	07 94       	ror	r0
    1588:	96 95       	lsr	r25
    158a:	87 95       	ror	r24
    158c:	07 94       	ror	r0
    158e:	98 2f       	mov	r25, r24
    1590:	80 2d       	mov	r24, r0
    1592:	98 2f       	mov	r25, r24
    1594:	89 81       	ldd	r24, Y+1	; 0x01
    1596:	89 2b       	or	r24, r25
    1598:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c4 <<7);
    159a:	8a 81       	ldd	r24, Y+2	; 0x02
    159c:	88 2f       	mov	r24, r24
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	96 95       	lsr	r25
    15a2:	98 2f       	mov	r25, r24
    15a4:	88 27       	eor	r24, r24
    15a6:	97 95       	ror	r25
    15a8:	87 95       	ror	r24
    15aa:	98 2f       	mov	r25, r24
    15ac:	89 81       	ldd	r24, Y+1	; 0x01
    15ae:	89 2b       	or	r24, r25
    15b0:	89 83       	std	Y+1, r24	; 0x01

	switch(temp)
    15b2:	89 81       	ldd	r24, Y+1	; 0x01
    15b4:	28 2f       	mov	r18, r24
    15b6:	30 e0       	ldi	r19, 0x00	; 0
    15b8:	39 87       	std	Y+9, r19	; 0x09
    15ba:	28 87       	std	Y+8, r18	; 0x08
    15bc:	88 85       	ldd	r24, Y+8	; 0x08
    15be:	99 85       	ldd	r25, Y+9	; 0x09
    15c0:	80 3b       	cpi	r24, 0xB0	; 176
    15c2:	91 05       	cpc	r25, r1
    15c4:	d9 f0       	breq	.+54     	; 0x15fc <Keypad_u8GetKey+0x320>
    15c6:	28 85       	ldd	r18, Y+8	; 0x08
    15c8:	39 85       	ldd	r19, Y+9	; 0x09
    15ca:	21 3b       	cpi	r18, 0xB1	; 177
    15cc:	31 05       	cpc	r19, r1
    15ce:	34 f4       	brge	.+12     	; 0x15dc <Keypad_u8GetKey+0x300>
    15d0:	88 85       	ldd	r24, Y+8	; 0x08
    15d2:	99 85       	ldd	r25, Y+9	; 0x09
    15d4:	80 37       	cpi	r24, 0x70	; 112
    15d6:	91 05       	cpc	r25, r1
    15d8:	a1 f0       	breq	.+40     	; 0x1602 <Keypad_u8GetKey+0x326>
    15da:	16 c0       	rjmp	.+44     	; 0x1608 <Keypad_u8GetKey+0x32c>
    15dc:	28 85       	ldd	r18, Y+8	; 0x08
    15de:	39 85       	ldd	r19, Y+9	; 0x09
    15e0:	20 3d       	cpi	r18, 0xD0	; 208
    15e2:	31 05       	cpc	r19, r1
    15e4:	41 f0       	breq	.+16     	; 0x15f6 <Keypad_u8GetKey+0x31a>
    15e6:	88 85       	ldd	r24, Y+8	; 0x08
    15e8:	99 85       	ldd	r25, Y+9	; 0x09
    15ea:	80 3e       	cpi	r24, 0xE0	; 224
    15ec:	91 05       	cpc	r25, r1
    15ee:	61 f4       	brne	.+24     	; 0x1608 <Keypad_u8GetKey+0x32c>
	{
		case 0b11100000:
			return KEYPAD_u8R3C1_KEY;
    15f0:	97 e0       	ldi	r25, 0x07	; 7
    15f2:	9c 87       	std	Y+12, r25	; 0x0c
    15f4:	8e c0       	rjmp	.+284    	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b11010000:
			return KEYPAD_u8R3C2_KEY;
    15f6:	28 e0       	ldi	r18, 0x08	; 8
    15f8:	2c 87       	std	Y+12, r18	; 0x0c
    15fa:	8b c0       	rjmp	.+278    	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b10110000:
			return KEYPAD_u8R3C3_KEY;
    15fc:	39 e0       	ldi	r19, 0x09	; 9
    15fe:	3c 87       	std	Y+12, r19	; 0x0c
    1600:	88 c0       	rjmp	.+272    	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b01110000:
			return KEYPAD_u8R3C4_KEY;
    1602:	8a e2       	ldi	r24, 0x2A	; 42
    1604:	8c 87       	std	Y+12, r24	; 0x0c
    1606:	85 c0       	rjmp	.+266    	; 0x1712 <Keypad_u8GetKey+0x436>
	}


	Dio_vidSetPinVal(KEYPAD_u8R1_PIN , DIO_u8HIGH);
    1608:	88 e0       	ldi	r24, 0x08	; 8
    160a:	61 e0       	ldi	r22, 0x01	; 1
    160c:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R2_PIN , DIO_u8HIGH);
    1610:	89 e0       	ldi	r24, 0x09	; 9
    1612:	61 e0       	ldi	r22, 0x01	; 1
    1614:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R3_PIN , DIO_u8HIGH);
    1618:	8a e0       	ldi	r24, 0x0A	; 10
    161a:	61 e0       	ldi	r22, 0x01	; 1
    161c:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(KEYPAD_u8R4_PIN , DIO_u8LOW);
    1620:	8b e0       	ldi	r24, 0x0B	; 11
    1622:	60 e0       	ldi	r22, 0x00	; 0
    1624:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>


	pin_c1 = Dio_u8GetPinVal(KEYPAD_u8C1_PIN);
    1628:	8c e0       	ldi	r24, 0x0C	; 12
    162a:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    162e:	8d 83       	std	Y+5, r24	; 0x05
	pin_c2 = Dio_u8GetPinVal(KEYPAD_u8C2_PIN);
    1630:	8d e0       	ldi	r24, 0x0D	; 13
    1632:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    1636:	8c 83       	std	Y+4, r24	; 0x04
	pin_c3 = Dio_u8GetPinVal(KEYPAD_u8C3_PIN);
    1638:	8e e0       	ldi	r24, 0x0E	; 14
    163a:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    163e:	8b 83       	std	Y+3, r24	; 0x03
	pin_c4 = Dio_u8GetPinVal(KEYPAD_u8C4_PIN);
    1640:	8f e0       	ldi	r24, 0x0F	; 15
    1642:	0e 94 15 07 	call	0xe2a	; 0xe2a <Dio_u8GetPinVal>
    1646:	8a 83       	std	Y+2, r24	; 0x02

	temp = 0;
    1648:	19 82       	std	Y+1, r1	; 0x01
	temp |= (pin_c1 <<4);
    164a:	8d 81       	ldd	r24, Y+5	; 0x05
    164c:	88 2f       	mov	r24, r24
    164e:	90 e0       	ldi	r25, 0x00	; 0
    1650:	82 95       	swap	r24
    1652:	92 95       	swap	r25
    1654:	90 7f       	andi	r25, 0xF0	; 240
    1656:	98 27       	eor	r25, r24
    1658:	80 7f       	andi	r24, 0xF0	; 240
    165a:	98 27       	eor	r25, r24
    165c:	98 2f       	mov	r25, r24
    165e:	89 81       	ldd	r24, Y+1	; 0x01
    1660:	89 2b       	or	r24, r25
    1662:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c2 <<5);
    1664:	8c 81       	ldd	r24, Y+4	; 0x04
    1666:	88 2f       	mov	r24, r24
    1668:	90 e0       	ldi	r25, 0x00	; 0
    166a:	88 0f       	add	r24, r24
    166c:	99 1f       	adc	r25, r25
    166e:	82 95       	swap	r24
    1670:	92 95       	swap	r25
    1672:	90 7f       	andi	r25, 0xF0	; 240
    1674:	98 27       	eor	r25, r24
    1676:	80 7f       	andi	r24, 0xF0	; 240
    1678:	98 27       	eor	r25, r24
    167a:	98 2f       	mov	r25, r24
    167c:	89 81       	ldd	r24, Y+1	; 0x01
    167e:	89 2b       	or	r24, r25
    1680:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c3 <<6);
    1682:	8b 81       	ldd	r24, Y+3	; 0x03
    1684:	88 2f       	mov	r24, r24
    1686:	90 e0       	ldi	r25, 0x00	; 0
    1688:	00 24       	eor	r0, r0
    168a:	96 95       	lsr	r25
    168c:	87 95       	ror	r24
    168e:	07 94       	ror	r0
    1690:	96 95       	lsr	r25
    1692:	87 95       	ror	r24
    1694:	07 94       	ror	r0
    1696:	98 2f       	mov	r25, r24
    1698:	80 2d       	mov	r24, r0
    169a:	98 2f       	mov	r25, r24
    169c:	89 81       	ldd	r24, Y+1	; 0x01
    169e:	89 2b       	or	r24, r25
    16a0:	89 83       	std	Y+1, r24	; 0x01
	temp |= (pin_c4 <<7);
    16a2:	8a 81       	ldd	r24, Y+2	; 0x02
    16a4:	88 2f       	mov	r24, r24
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	96 95       	lsr	r25
    16aa:	98 2f       	mov	r25, r24
    16ac:	88 27       	eor	r24, r24
    16ae:	97 95       	ror	r25
    16b0:	87 95       	ror	r24
    16b2:	98 2f       	mov	r25, r24
    16b4:	89 81       	ldd	r24, Y+1	; 0x01
    16b6:	89 2b       	or	r24, r25
    16b8:	89 83       	std	Y+1, r24	; 0x01

	switch(temp)
    16ba:	89 81       	ldd	r24, Y+1	; 0x01
    16bc:	28 2f       	mov	r18, r24
    16be:	30 e0       	ldi	r19, 0x00	; 0
    16c0:	3f 83       	std	Y+7, r19	; 0x07
    16c2:	2e 83       	std	Y+6, r18	; 0x06
    16c4:	8e 81       	ldd	r24, Y+6	; 0x06
    16c6:	9f 81       	ldd	r25, Y+7	; 0x07
    16c8:	80 3b       	cpi	r24, 0xB0	; 176
    16ca:	91 05       	cpc	r25, r1
    16cc:	d1 f0       	breq	.+52     	; 0x1702 <Keypad_u8GetKey+0x426>
    16ce:	2e 81       	ldd	r18, Y+6	; 0x06
    16d0:	3f 81       	ldd	r19, Y+7	; 0x07
    16d2:	21 3b       	cpi	r18, 0xB1	; 177
    16d4:	31 05       	cpc	r19, r1
    16d6:	34 f4       	brge	.+12     	; 0x16e4 <Keypad_u8GetKey+0x408>
    16d8:	8e 81       	ldd	r24, Y+6	; 0x06
    16da:	9f 81       	ldd	r25, Y+7	; 0x07
    16dc:	80 37       	cpi	r24, 0x70	; 112
    16de:	91 05       	cpc	r25, r1
    16e0:	99 f0       	breq	.+38     	; 0x1708 <Keypad_u8GetKey+0x42c>
    16e2:	15 c0       	rjmp	.+42     	; 0x170e <Keypad_u8GetKey+0x432>
    16e4:	2e 81       	ldd	r18, Y+6	; 0x06
    16e6:	3f 81       	ldd	r19, Y+7	; 0x07
    16e8:	20 3d       	cpi	r18, 0xD0	; 208
    16ea:	31 05       	cpc	r19, r1
    16ec:	41 f0       	breq	.+16     	; 0x16fe <Keypad_u8GetKey+0x422>
    16ee:	8e 81       	ldd	r24, Y+6	; 0x06
    16f0:	9f 81       	ldd	r25, Y+7	; 0x07
    16f2:	80 3e       	cpi	r24, 0xE0	; 224
    16f4:	91 05       	cpc	r25, r1
    16f6:	59 f4       	brne	.+22     	; 0x170e <Keypad_u8GetKey+0x432>
	{
		case 0b11100000:
			return KEYPAD_u8R4C1_KEY;
    16f8:	93 e2       	ldi	r25, 0x23	; 35
    16fa:	9c 87       	std	Y+12, r25	; 0x0c
    16fc:	0a c0       	rjmp	.+20     	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b11010000:
			return KEYPAD_u8R4C2_KEY;
    16fe:	1c 86       	std	Y+12, r1	; 0x0c
    1700:	08 c0       	rjmp	.+16     	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b10110000:
			return KEYPAD_u8R4C3_KEY;
    1702:	2d e3       	ldi	r18, 0x3D	; 61
    1704:	2c 87       	std	Y+12, r18	; 0x0c
    1706:	05 c0       	rjmp	.+10     	; 0x1712 <Keypad_u8GetKey+0x436>
		case 0b01110000:
			return KEYPAD_u8R4C4_KEY;
    1708:	3f e2       	ldi	r19, 0x2F	; 47
    170a:	3c 87       	std	Y+12, r19	; 0x0c
    170c:	02 c0       	rjmp	.+4      	; 0x1712 <Keypad_u8GetKey+0x436>
	}


	return KEYPAD_u8NO_KEY;
    170e:	8f ef       	ldi	r24, 0xFF	; 255
    1710:	8c 87       	std	Y+12, r24	; 0x0c
    1712:	8c 85       	ldd	r24, Y+12	; 0x0c
	}
    1714:	2e 96       	adiw	r28, 0x0e	; 14
    1716:	0f b6       	in	r0, 0x3f	; 63
    1718:	f8 94       	cli
    171a:	de bf       	out	0x3e, r29	; 62
    171c:	0f be       	out	0x3f, r0	; 63
    171e:	cd bf       	out	0x3d, r28	; 61
    1720:	cf 91       	pop	r28
    1722:	df 91       	pop	r29
    1724:	08 95       	ret

00001726 <Lcd_vidSendCommand>:
u8  arr_State[MAXIMUM_ELEMENT_IN_QUEUE] ;
u8 Queue_Write_Counter = 0;
u8 Queue_Read_Counter  = 0;

void Lcd_vidSendCommand(u8 Cmd)
{
    1726:	df 93       	push	r29
    1728:	cf 93       	push	r28
    172a:	0f 92       	push	r0
    172c:	cd b7       	in	r28, 0x3d	; 61
    172e:	de b7       	in	r29, 0x3e	; 62
    1730:	89 83       	std	Y+1, r24	; 0x01
	//Start to change in LCD control Reg to indicate it that you will receive command
	Dio_vidSetPinVal(LCD_u8RS_PIN , DIO_u8LOW);  //make RS->0 to indicate LCD "you will receive command not data"
    1732:	80 e0       	ldi	r24, 0x00	; 0
    1734:	60 e0       	ldi	r22, 0x00	; 0
    1736:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8RW_PIN , DIO_u8LOW);  //make RW->0 to indicate LCD "you will write in command Register"
    173a:	81 e0       	ldi	r24, 0x01	; 1
    173c:	60 e0       	ldi	r22, 0x00	; 0
    173e:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8EN_PIN , DIO_u8HIGH); //make EN->1 to indicate LCD "Please LCD don't save any thing in your buffer until be sure all data sent "
    1742:	82 e0       	ldi	r24, 0x02	; 2
    1744:	61 e0       	ldi	r22, 0x01	; 1
    1746:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>

	//Make Data Ready To Sent
	Dio_vidSetPinVal(LCD_u8D0_PIN , GET_BIT(Cmd,0));
    174a:	89 81       	ldd	r24, Y+1	; 0x01
    174c:	98 2f       	mov	r25, r24
    174e:	91 70       	andi	r25, 0x01	; 1
    1750:	88 e1       	ldi	r24, 0x18	; 24
    1752:	69 2f       	mov	r22, r25
    1754:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D1_PIN , GET_BIT(Cmd,1));
    1758:	89 81       	ldd	r24, Y+1	; 0x01
    175a:	86 95       	lsr	r24
    175c:	98 2f       	mov	r25, r24
    175e:	91 70       	andi	r25, 0x01	; 1
    1760:	89 e1       	ldi	r24, 0x19	; 25
    1762:	69 2f       	mov	r22, r25
    1764:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D2_PIN , GET_BIT(Cmd,2));
    1768:	89 81       	ldd	r24, Y+1	; 0x01
    176a:	86 95       	lsr	r24
    176c:	86 95       	lsr	r24
    176e:	98 2f       	mov	r25, r24
    1770:	91 70       	andi	r25, 0x01	; 1
    1772:	8a e1       	ldi	r24, 0x1A	; 26
    1774:	69 2f       	mov	r22, r25
    1776:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D3_PIN , GET_BIT(Cmd,3));
    177a:	89 81       	ldd	r24, Y+1	; 0x01
    177c:	86 95       	lsr	r24
    177e:	86 95       	lsr	r24
    1780:	86 95       	lsr	r24
    1782:	98 2f       	mov	r25, r24
    1784:	91 70       	andi	r25, 0x01	; 1
    1786:	8b e1       	ldi	r24, 0x1B	; 27
    1788:	69 2f       	mov	r22, r25
    178a:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D4_PIN , GET_BIT(Cmd,4));
    178e:	89 81       	ldd	r24, Y+1	; 0x01
    1790:	82 95       	swap	r24
    1792:	8f 70       	andi	r24, 0x0F	; 15
    1794:	98 2f       	mov	r25, r24
    1796:	91 70       	andi	r25, 0x01	; 1
    1798:	8c e1       	ldi	r24, 0x1C	; 28
    179a:	69 2f       	mov	r22, r25
    179c:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D5_PIN , GET_BIT(Cmd,5));
    17a0:	89 81       	ldd	r24, Y+1	; 0x01
    17a2:	82 95       	swap	r24
    17a4:	86 95       	lsr	r24
    17a6:	87 70       	andi	r24, 0x07	; 7
    17a8:	98 2f       	mov	r25, r24
    17aa:	91 70       	andi	r25, 0x01	; 1
    17ac:	8d e1       	ldi	r24, 0x1D	; 29
    17ae:	69 2f       	mov	r22, r25
    17b0:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D6_PIN , GET_BIT(Cmd,6));
    17b4:	89 81       	ldd	r24, Y+1	; 0x01
    17b6:	82 95       	swap	r24
    17b8:	86 95       	lsr	r24
    17ba:	86 95       	lsr	r24
    17bc:	83 70       	andi	r24, 0x03	; 3
    17be:	98 2f       	mov	r25, r24
    17c0:	91 70       	andi	r25, 0x01	; 1
    17c2:	8e e1       	ldi	r24, 0x1E	; 30
    17c4:	69 2f       	mov	r22, r25
    17c6:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D7_PIN , GET_BIT(Cmd,7));
    17ca:	89 81       	ldd	r24, Y+1	; 0x01
    17cc:	98 2f       	mov	r25, r24
    17ce:	99 1f       	adc	r25, r25
    17d0:	99 27       	eor	r25, r25
    17d2:	99 1f       	adc	r25, r25
    17d4:	8f e1       	ldi	r24, 0x1F	; 31
    17d6:	69 2f       	mov	r22, r25
    17d8:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>

}
    17dc:	0f 90       	pop	r0
    17de:	cf 91       	pop	r28
    17e0:	df 91       	pop	r29
    17e2:	08 95       	ret

000017e4 <Lcd_vidInit>:


void Lcd_vidInit(void)
{
    17e4:	df 93       	push	r29
    17e6:	cf 93       	push	r28
    17e8:	0f 92       	push	r0
    17ea:	cd b7       	in	r28, 0x3d	; 61
    17ec:	de b7       	in	r29, 0x3e	; 62
	 Dio_vidSetPinDir(LCD_u8RS_PIN , DIO_u8OUTPUT);
    17ee:	80 e0       	ldi	r24, 0x00	; 0
    17f0:	61 e0       	ldi	r22, 0x01	; 1
    17f2:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8RW_PIN , DIO_u8OUTPUT);
    17f6:	81 e0       	ldi	r24, 0x01	; 1
    17f8:	61 e0       	ldi	r22, 0x01	; 1
    17fa:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8EN_PIN , DIO_u8OUTPUT);
    17fe:	82 e0       	ldi	r24, 0x02	; 2
    1800:	61 e0       	ldi	r22, 0x01	; 1
    1802:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>

	 Dio_vidSetPinDir(LCD_u8D0_PIN , DIO_u8OUTPUT);
    1806:	88 e1       	ldi	r24, 0x18	; 24
    1808:	61 e0       	ldi	r22, 0x01	; 1
    180a:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D1_PIN , DIO_u8OUTPUT);
    180e:	89 e1       	ldi	r24, 0x19	; 25
    1810:	61 e0       	ldi	r22, 0x01	; 1
    1812:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D2_PIN , DIO_u8OUTPUT);
    1816:	8a e1       	ldi	r24, 0x1A	; 26
    1818:	61 e0       	ldi	r22, 0x01	; 1
    181a:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D3_PIN , DIO_u8OUTPUT);
    181e:	8b e1       	ldi	r24, 0x1B	; 27
    1820:	61 e0       	ldi	r22, 0x01	; 1
    1822:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D4_PIN , DIO_u8OUTPUT);
    1826:	8c e1       	ldi	r24, 0x1C	; 28
    1828:	61 e0       	ldi	r22, 0x01	; 1
    182a:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D5_PIN , DIO_u8OUTPUT);
    182e:	8d e1       	ldi	r24, 0x1D	; 29
    1830:	61 e0       	ldi	r22, 0x01	; 1
    1832:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D6_PIN , DIO_u8OUTPUT);
    1836:	8e e1       	ldi	r24, 0x1E	; 30
    1838:	61 e0       	ldi	r22, 0x01	; 1
    183a:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D7_PIN , DIO_u8OUTPUT);
    183e:	8f e1       	ldi	r24, 0x1F	; 31
    1840:	61 e0       	ldi	r22, 0x01	; 1
    1842:	0e 94 49 00 	call	0x92	; 0x92 <Dio_vidSetPinDir>


	 arr_Queue[Queue_Write_Counter]  = LCD_u8CMD_8_BIT_2x16_5x7;
    1846:	80 91 7a 00 	lds	r24, 0x007A
    184a:	88 2f       	mov	r24, r24
    184c:	90 e0       	ldi	r25, 0x00	; 0
    184e:	fc 01       	movw	r30, r24
    1850:	ec 50       	subi	r30, 0x0C	; 12
    1852:	f9 4f       	sbci	r31, 0xF9	; 249
    1854:	88 e3       	ldi	r24, 0x38	; 56
    1856:	80 83       	st	Z, r24
	 arr_State[Queue_Write_Counter]  = COMMAND;
    1858:	80 91 7a 00 	lds	r24, 0x007A
    185c:	88 2f       	mov	r24, r24
    185e:	90 e0       	ldi	r25, 0x00	; 0
    1860:	fc 01       	movw	r30, r24
    1862:	ee 53       	subi	r30, 0x3E	; 62
    1864:	f9 4f       	sbci	r31, 0xF9	; 249
    1866:	81 e0       	ldi	r24, 0x01	; 1
    1868:	80 83       	st	Z, r24
	 Queue_Write_Counter++;
    186a:	80 91 7a 00 	lds	r24, 0x007A
    186e:	8f 5f       	subi	r24, 0xFF	; 255
    1870:	80 93 7a 00 	sts	0x007A, r24

	 arr_Queue[Queue_Write_Counter]  = LCD_u8CMD_DISP_ON_CURS_OFF;
    1874:	80 91 7a 00 	lds	r24, 0x007A
    1878:	88 2f       	mov	r24, r24
    187a:	90 e0       	ldi	r25, 0x00	; 0
    187c:	fc 01       	movw	r30, r24
    187e:	ec 50       	subi	r30, 0x0C	; 12
    1880:	f9 4f       	sbci	r31, 0xF9	; 249
    1882:	8c e0       	ldi	r24, 0x0C	; 12
    1884:	80 83       	st	Z, r24
	 arr_State[Queue_Write_Counter]  = COMMAND;
    1886:	80 91 7a 00 	lds	r24, 0x007A
    188a:	88 2f       	mov	r24, r24
    188c:	90 e0       	ldi	r25, 0x00	; 0
    188e:	fc 01       	movw	r30, r24
    1890:	ee 53       	subi	r30, 0x3E	; 62
    1892:	f9 4f       	sbci	r31, 0xF9	; 249
    1894:	81 e0       	ldi	r24, 0x01	; 1
    1896:	80 83       	st	Z, r24
	 Queue_Write_Counter++;
    1898:	80 91 7a 00 	lds	r24, 0x007A
    189c:	8f 5f       	subi	r24, 0xFF	; 255
    189e:	80 93 7a 00 	sts	0x007A, r24

	 arr_Queue[Queue_Write_Counter]  = LCD_u8CMD_CLR_Display;
    18a2:	80 91 7a 00 	lds	r24, 0x007A
    18a6:	88 2f       	mov	r24, r24
    18a8:	90 e0       	ldi	r25, 0x00	; 0
    18aa:	fc 01       	movw	r30, r24
    18ac:	ec 50       	subi	r30, 0x0C	; 12
    18ae:	f9 4f       	sbci	r31, 0xF9	; 249
    18b0:	81 e0       	ldi	r24, 0x01	; 1
    18b2:	80 83       	st	Z, r24
	 arr_State[Queue_Write_Counter]  = COMMAND;
    18b4:	80 91 7a 00 	lds	r24, 0x007A
    18b8:	88 2f       	mov	r24, r24
    18ba:	90 e0       	ldi	r25, 0x00	; 0
    18bc:	fc 01       	movw	r30, r24
    18be:	ee 53       	subi	r30, 0x3E	; 62
    18c0:	f9 4f       	sbci	r31, 0xF9	; 249
    18c2:	81 e0       	ldi	r24, 0x01	; 1
    18c4:	80 83       	st	Z, r24
	 Queue_Write_Counter++;
    18c6:	80 91 7a 00 	lds	r24, 0x007A
    18ca:	8f 5f       	subi	r24, 0xFF	; 255
    18cc:	80 93 7a 00 	sts	0x007A, r24

	 u8 i;

	 for( i=3; i<MAXIMUM_ELEMENT_IN_QUEUE; i++ )
    18d0:	83 e0       	ldi	r24, 0x03	; 3
    18d2:	89 83       	std	Y+1, r24	; 0x01
    18d4:	13 c0       	rjmp	.+38     	; 0x18fc <Lcd_vidInit+0x118>
	 {
		 arr_Queue[i]  = LCD_QUEUE_NULL;
    18d6:	89 81       	ldd	r24, Y+1	; 0x01
    18d8:	88 2f       	mov	r24, r24
    18da:	90 e0       	ldi	r25, 0x00	; 0
    18dc:	fc 01       	movw	r30, r24
    18de:	ec 50       	subi	r30, 0x0C	; 12
    18e0:	f9 4f       	sbci	r31, 0xF9	; 249
    18e2:	8f ef       	ldi	r24, 0xFF	; 255
    18e4:	80 83       	st	Z, r24
		 arr_State[i]  = LCD_QUEUE_NULL;
    18e6:	89 81       	ldd	r24, Y+1	; 0x01
    18e8:	88 2f       	mov	r24, r24
    18ea:	90 e0       	ldi	r25, 0x00	; 0
    18ec:	fc 01       	movw	r30, r24
    18ee:	ee 53       	subi	r30, 0x3E	; 62
    18f0:	f9 4f       	sbci	r31, 0xF9	; 249
    18f2:	8f ef       	ldi	r24, 0xFF	; 255
    18f4:	80 83       	st	Z, r24
	 arr_State[Queue_Write_Counter]  = COMMAND;
	 Queue_Write_Counter++;

	 u8 i;

	 for( i=3; i<MAXIMUM_ELEMENT_IN_QUEUE; i++ )
    18f6:	89 81       	ldd	r24, Y+1	; 0x01
    18f8:	8f 5f       	subi	r24, 0xFF	; 255
    18fa:	89 83       	std	Y+1, r24	; 0x01
    18fc:	89 81       	ldd	r24, Y+1	; 0x01
    18fe:	82 33       	cpi	r24, 0x32	; 50
    1900:	50 f3       	brcs	.-44     	; 0x18d6 <Lcd_vidInit+0xf2>
	 {
		 arr_Queue[i]  = LCD_QUEUE_NULL;
		 arr_State[i]  = LCD_QUEUE_NULL;
	 }

}
    1902:	0f 90       	pop	r0
    1904:	cf 91       	pop	r28
    1906:	df 91       	pop	r29
    1908:	08 95       	ret

0000190a <Lcd_vidWriteChar>:


void Lcd_vidWriteChar(u8 Char)

{
    190a:	df 93       	push	r29
    190c:	cf 93       	push	r28
    190e:	0f 92       	push	r0
    1910:	cd b7       	in	r28, 0x3d	; 61
    1912:	de b7       	in	r29, 0x3e	; 62
    1914:	89 83       	std	Y+1, r24	; 0x01
	Dio_vidSetPinVal(LCD_u8RS_PIN , DIO_u8HIGH);  //RS
    1916:	80 e0       	ldi	r24, 0x00	; 0
    1918:	61 e0       	ldi	r22, 0x01	; 1
    191a:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8RW_PIN , DIO_u8LOW);   //RW
    191e:	81 e0       	ldi	r24, 0x01	; 1
    1920:	60 e0       	ldi	r22, 0x00	; 0
    1922:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8EN_PIN , DIO_u8HIGH);  //EN
    1926:	82 e0       	ldi	r24, 0x02	; 2
    1928:	61 e0       	ldi	r22, 0x01	; 1
    192a:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>


	//Make Data Ready To Sent
	Dio_vidSetPinVal(LCD_u8D0_PIN , GET_BIT(Char,0));
    192e:	89 81       	ldd	r24, Y+1	; 0x01
    1930:	98 2f       	mov	r25, r24
    1932:	91 70       	andi	r25, 0x01	; 1
    1934:	88 e1       	ldi	r24, 0x18	; 24
    1936:	69 2f       	mov	r22, r25
    1938:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D1_PIN , GET_BIT(Char,1));
    193c:	89 81       	ldd	r24, Y+1	; 0x01
    193e:	86 95       	lsr	r24
    1940:	98 2f       	mov	r25, r24
    1942:	91 70       	andi	r25, 0x01	; 1
    1944:	89 e1       	ldi	r24, 0x19	; 25
    1946:	69 2f       	mov	r22, r25
    1948:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D2_PIN , GET_BIT(Char,2));
    194c:	89 81       	ldd	r24, Y+1	; 0x01
    194e:	86 95       	lsr	r24
    1950:	86 95       	lsr	r24
    1952:	98 2f       	mov	r25, r24
    1954:	91 70       	andi	r25, 0x01	; 1
    1956:	8a e1       	ldi	r24, 0x1A	; 26
    1958:	69 2f       	mov	r22, r25
    195a:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D3_PIN , GET_BIT(Char,3));
    195e:	89 81       	ldd	r24, Y+1	; 0x01
    1960:	86 95       	lsr	r24
    1962:	86 95       	lsr	r24
    1964:	86 95       	lsr	r24
    1966:	98 2f       	mov	r25, r24
    1968:	91 70       	andi	r25, 0x01	; 1
    196a:	8b e1       	ldi	r24, 0x1B	; 27
    196c:	69 2f       	mov	r22, r25
    196e:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D4_PIN , GET_BIT(Char,4));
    1972:	89 81       	ldd	r24, Y+1	; 0x01
    1974:	82 95       	swap	r24
    1976:	8f 70       	andi	r24, 0x0F	; 15
    1978:	98 2f       	mov	r25, r24
    197a:	91 70       	andi	r25, 0x01	; 1
    197c:	8c e1       	ldi	r24, 0x1C	; 28
    197e:	69 2f       	mov	r22, r25
    1980:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D5_PIN , GET_BIT(Char,5));
    1984:	89 81       	ldd	r24, Y+1	; 0x01
    1986:	82 95       	swap	r24
    1988:	86 95       	lsr	r24
    198a:	87 70       	andi	r24, 0x07	; 7
    198c:	98 2f       	mov	r25, r24
    198e:	91 70       	andi	r25, 0x01	; 1
    1990:	8d e1       	ldi	r24, 0x1D	; 29
    1992:	69 2f       	mov	r22, r25
    1994:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D6_PIN , GET_BIT(Char,6));
    1998:	89 81       	ldd	r24, Y+1	; 0x01
    199a:	82 95       	swap	r24
    199c:	86 95       	lsr	r24
    199e:	86 95       	lsr	r24
    19a0:	83 70       	andi	r24, 0x03	; 3
    19a2:	98 2f       	mov	r25, r24
    19a4:	91 70       	andi	r25, 0x01	; 1
    19a6:	8e e1       	ldi	r24, 0x1E	; 30
    19a8:	69 2f       	mov	r22, r25
    19aa:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D7_PIN , GET_BIT(Char,7));
    19ae:	89 81       	ldd	r24, Y+1	; 0x01
    19b0:	98 2f       	mov	r25, r24
    19b2:	99 1f       	adc	r25, r25
    19b4:	99 27       	eor	r25, r25
    19b6:	99 1f       	adc	r25, r25
    19b8:	8f e1       	ldi	r24, 0x1F	; 31
    19ba:	69 2f       	mov	r22, r25
    19bc:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>

}
    19c0:	0f 90       	pop	r0
    19c2:	cf 91       	pop	r28
    19c4:	df 91       	pop	r29
    19c6:	08 95       	ret

000019c8 <Lcd_vidEnableTrigger>:


void Lcd_vidEnableTrigger(void)
{
    19c8:	df 93       	push	r29
    19ca:	cf 93       	push	r28
    19cc:	cd b7       	in	r28, 0x3d	; 61
    19ce:	de b7       	in	r29, 0x3e	; 62

	//make EN->0 to indicate LCD "NOW you can save bits in your buffer all data sent"
	Dio_vidSetPinVal(LCD_u8EN_PIN , DIO_u8LOW);
    19d0:	82 e0       	ldi	r24, 0x02	; 2
    19d2:	60 e0       	ldi	r22, 0x00	; 0
    19d4:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>

}
    19d8:	cf 91       	pop	r28
    19da:	df 91       	pop	r29
    19dc:	08 95       	ret

000019de <Lcd_vidDisableTrigger>:


void Lcd_vidDisableTrigger(void)
{
    19de:	df 93       	push	r29
    19e0:	cf 93       	push	r28
    19e2:	cd b7       	in	r28, 0x3d	; 61
    19e4:	de b7       	in	r29, 0x3e	; 62
	Dio_vidSetPinVal(LCD_u8EN_PIN , DIO_u8HIGH);
    19e6:	82 e0       	ldi	r24, 0x02	; 2
    19e8:	61 e0       	ldi	r22, 0x01	; 1
    19ea:	0e 94 af 03 	call	0x75e	; 0x75e <Dio_vidSetPinVal>
}
    19ee:	cf 91       	pop	r28
    19f0:	df 91       	pop	r29
    19f2:	08 95       	ret

000019f4 <Lcd_vidQueueChar>:


void Lcd_vidQueueChar(u8 Char)
{
    19f4:	df 93       	push	r29
    19f6:	cf 93       	push	r28
    19f8:	0f 92       	push	r0
    19fa:	cd b7       	in	r28, 0x3d	; 61
    19fc:	de b7       	in	r29, 0x3e	; 62
    19fe:	89 83       	std	Y+1, r24	; 0x01
	arr_Queue[Queue_Write_Counter] = Char;
    1a00:	80 91 7a 00 	lds	r24, 0x007A
    1a04:	88 2f       	mov	r24, r24
    1a06:	90 e0       	ldi	r25, 0x00	; 0
    1a08:	fc 01       	movw	r30, r24
    1a0a:	ec 50       	subi	r30, 0x0C	; 12
    1a0c:	f9 4f       	sbci	r31, 0xF9	; 249
    1a0e:	89 81       	ldd	r24, Y+1	; 0x01
    1a10:	80 83       	st	Z, r24
	arr_State[Queue_Write_Counter] = CHAR;
    1a12:	80 91 7a 00 	lds	r24, 0x007A
    1a16:	88 2f       	mov	r24, r24
    1a18:	90 e0       	ldi	r25, 0x00	; 0
    1a1a:	fc 01       	movw	r30, r24
    1a1c:	ee 53       	subi	r30, 0x3E	; 62
    1a1e:	f9 4f       	sbci	r31, 0xF9	; 249
    1a20:	10 82       	st	Z, r1
	Queue_Write_Counter++;
    1a22:	80 91 7a 00 	lds	r24, 0x007A
    1a26:	8f 5f       	subi	r24, 0xFF	; 255
    1a28:	80 93 7a 00 	sts	0x007A, r24
}
    1a2c:	0f 90       	pop	r0
    1a2e:	cf 91       	pop	r28
    1a30:	df 91       	pop	r29
    1a32:	08 95       	ret

00001a34 <Lcd_vidQueueCommand>:


void Lcd_vidQueueCommand(u8 Command)
{
    1a34:	df 93       	push	r29
    1a36:	cf 93       	push	r28
    1a38:	0f 92       	push	r0
    1a3a:	cd b7       	in	r28, 0x3d	; 61
    1a3c:	de b7       	in	r29, 0x3e	; 62
    1a3e:	89 83       	std	Y+1, r24	; 0x01
	arr_Queue[Queue_Write_Counter] = Command;
    1a40:	80 91 7a 00 	lds	r24, 0x007A
    1a44:	88 2f       	mov	r24, r24
    1a46:	90 e0       	ldi	r25, 0x00	; 0
    1a48:	fc 01       	movw	r30, r24
    1a4a:	ec 50       	subi	r30, 0x0C	; 12
    1a4c:	f9 4f       	sbci	r31, 0xF9	; 249
    1a4e:	89 81       	ldd	r24, Y+1	; 0x01
    1a50:	80 83       	st	Z, r24
	arr_State[Queue_Write_Counter] = COMMAND;
    1a52:	80 91 7a 00 	lds	r24, 0x007A
    1a56:	88 2f       	mov	r24, r24
    1a58:	90 e0       	ldi	r25, 0x00	; 0
    1a5a:	fc 01       	movw	r30, r24
    1a5c:	ee 53       	subi	r30, 0x3E	; 62
    1a5e:	f9 4f       	sbci	r31, 0xF9	; 249
    1a60:	81 e0       	ldi	r24, 0x01	; 1
    1a62:	80 83       	st	Z, r24
	Queue_Write_Counter++;
    1a64:	80 91 7a 00 	lds	r24, 0x007A
    1a68:	8f 5f       	subi	r24, 0xFF	; 255
    1a6a:	80 93 7a 00 	sts	0x007A, r24
}
    1a6e:	0f 90       	pop	r0
    1a70:	cf 91       	pop	r28
    1a72:	df 91       	pop	r29
    1a74:	08 95       	ret

00001a76 <Lcd_vidQueueString>:


void Lcd_vidQueueString(u8 *Str)
{
    1a76:	df 93       	push	r29
    1a78:	cf 93       	push	r28
    1a7a:	00 d0       	rcall	.+0      	; 0x1a7c <Lcd_vidQueueString+0x6>
    1a7c:	0f 92       	push	r0
    1a7e:	cd b7       	in	r28, 0x3d	; 61
    1a80:	de b7       	in	r29, 0x3e	; 62
    1a82:	9b 83       	std	Y+3, r25	; 0x03
    1a84:	8a 83       	std	Y+2, r24	; 0x02
	u8 Index = 0 ;
    1a86:	19 82       	std	Y+1, r1	; 0x01
    1a88:	21 c0       	rjmp	.+66     	; 0x1acc <Lcd_vidQueueString+0x56>

	while( Str[Index] != '\0' )
	{
		arr_Queue[Queue_Write_Counter] = Str[Index];
    1a8a:	80 91 7a 00 	lds	r24, 0x007A
    1a8e:	48 2f       	mov	r20, r24
    1a90:	50 e0       	ldi	r21, 0x00	; 0
    1a92:	89 81       	ldd	r24, Y+1	; 0x01
    1a94:	28 2f       	mov	r18, r24
    1a96:	30 e0       	ldi	r19, 0x00	; 0
    1a98:	8a 81       	ldd	r24, Y+2	; 0x02
    1a9a:	9b 81       	ldd	r25, Y+3	; 0x03
    1a9c:	fc 01       	movw	r30, r24
    1a9e:	e2 0f       	add	r30, r18
    1aa0:	f3 1f       	adc	r31, r19
    1aa2:	80 81       	ld	r24, Z
    1aa4:	fa 01       	movw	r30, r20
    1aa6:	ec 50       	subi	r30, 0x0C	; 12
    1aa8:	f9 4f       	sbci	r31, 0xF9	; 249
    1aaa:	80 83       	st	Z, r24
		arr_State[Queue_Write_Counter] = CHAR;
    1aac:	80 91 7a 00 	lds	r24, 0x007A
    1ab0:	88 2f       	mov	r24, r24
    1ab2:	90 e0       	ldi	r25, 0x00	; 0
    1ab4:	fc 01       	movw	r30, r24
    1ab6:	ee 53       	subi	r30, 0x3E	; 62
    1ab8:	f9 4f       	sbci	r31, 0xF9	; 249
    1aba:	10 82       	st	Z, r1
		Index++;
    1abc:	89 81       	ldd	r24, Y+1	; 0x01
    1abe:	8f 5f       	subi	r24, 0xFF	; 255
    1ac0:	89 83       	std	Y+1, r24	; 0x01
		Queue_Write_Counter++;
    1ac2:	80 91 7a 00 	lds	r24, 0x007A
    1ac6:	8f 5f       	subi	r24, 0xFF	; 255
    1ac8:	80 93 7a 00 	sts	0x007A, r24

void Lcd_vidQueueString(u8 *Str)
{
	u8 Index = 0 ;

	while( Str[Index] != '\0' )
    1acc:	89 81       	ldd	r24, Y+1	; 0x01
    1ace:	28 2f       	mov	r18, r24
    1ad0:	30 e0       	ldi	r19, 0x00	; 0
    1ad2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	e2 0f       	add	r30, r18
    1ada:	f3 1f       	adc	r31, r19
    1adc:	80 81       	ld	r24, Z
    1ade:	88 23       	and	r24, r24
    1ae0:	a1 f6       	brne	.-88     	; 0x1a8a <Lcd_vidQueueString+0x14>
		arr_Queue[Queue_Write_Counter] = Str[Index];
		arr_State[Queue_Write_Counter] = CHAR;
		Index++;
		Queue_Write_Counter++;
	}
}
    1ae2:	0f 90       	pop	r0
    1ae4:	0f 90       	pop	r0
    1ae6:	0f 90       	pop	r0
    1ae8:	cf 91       	pop	r28
    1aea:	df 91       	pop	r29
    1aec:	08 95       	ret

00001aee <Lcd_vidClearQueue>:


void Lcd_vidClearQueue(void)
{
    1aee:	df 93       	push	r29
    1af0:	cf 93       	push	r28
    1af2:	0f 92       	push	r0
    1af4:	cd b7       	in	r28, 0x3d	; 61
    1af6:	de b7       	in	r29, 0x3e	; 62
	 u8 i;

	 for( i=0; i<MAXIMUM_ELEMENT_IN_QUEUE; i++ )
    1af8:	19 82       	std	Y+1, r1	; 0x01
    1afa:	13 c0       	rjmp	.+38     	; 0x1b22 <Lcd_vidClearQueue+0x34>
	 {
		 arr_Queue[i]  = LCD_QUEUE_NULL;
    1afc:	89 81       	ldd	r24, Y+1	; 0x01
    1afe:	88 2f       	mov	r24, r24
    1b00:	90 e0       	ldi	r25, 0x00	; 0
    1b02:	fc 01       	movw	r30, r24
    1b04:	ec 50       	subi	r30, 0x0C	; 12
    1b06:	f9 4f       	sbci	r31, 0xF9	; 249
    1b08:	8f ef       	ldi	r24, 0xFF	; 255
    1b0a:	80 83       	st	Z, r24
		 arr_State[i]  = LCD_QUEUE_NULL;
    1b0c:	89 81       	ldd	r24, Y+1	; 0x01
    1b0e:	88 2f       	mov	r24, r24
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	fc 01       	movw	r30, r24
    1b14:	ee 53       	subi	r30, 0x3E	; 62
    1b16:	f9 4f       	sbci	r31, 0xF9	; 249
    1b18:	8f ef       	ldi	r24, 0xFF	; 255
    1b1a:	80 83       	st	Z, r24

void Lcd_vidClearQueue(void)
{
	 u8 i;

	 for( i=0; i<MAXIMUM_ELEMENT_IN_QUEUE; i++ )
    1b1c:	89 81       	ldd	r24, Y+1	; 0x01
    1b1e:	8f 5f       	subi	r24, 0xFF	; 255
    1b20:	89 83       	std	Y+1, r24	; 0x01
    1b22:	89 81       	ldd	r24, Y+1	; 0x01
    1b24:	82 33       	cpi	r24, 0x32	; 50
    1b26:	50 f3       	brcs	.-44     	; 0x1afc <Lcd_vidClearQueue+0xe>
	 {
		 arr_Queue[i]  = LCD_QUEUE_NULL;
		 arr_State[i]  = LCD_QUEUE_NULL;
	 }
	 Queue_Write_Counter = 0;
    1b28:	10 92 7a 00 	sts	0x007A, r1
}
    1b2c:	0f 90       	pop	r0
    1b2e:	cf 91       	pop	r28
    1b30:	df 91       	pop	r29
    1b32:	08 95       	ret

00001b34 <Lcd_u8ReadQueue>:


u8 Lcd_u8ReadQueue(void)
{
    1b34:	df 93       	push	r29
    1b36:	cf 93       	push	r28
    1b38:	00 d0       	rcall	.+0      	; 0x1b3a <Lcd_u8ReadQueue+0x6>
    1b3a:	00 d0       	rcall	.+0      	; 0x1b3c <Lcd_u8ReadQueue+0x8>
    1b3c:	00 d0       	rcall	.+0      	; 0x1b3e <Lcd_u8ReadQueue+0xa>
    1b3e:	cd b7       	in	r28, 0x3d	; 61
    1b40:	de b7       	in	r29, 0x3e	; 62
	u8 State_Value;
	u8 Byte;

	State_Value = arr_State[Queue_Read_Counter];
    1b42:	80 91 7b 00 	lds	r24, 0x007B
    1b46:	88 2f       	mov	r24, r24
    1b48:	90 e0       	ldi	r25, 0x00	; 0
    1b4a:	fc 01       	movw	r30, r24
    1b4c:	ee 53       	subi	r30, 0x3E	; 62
    1b4e:	f9 4f       	sbci	r31, 0xF9	; 249
    1b50:	80 81       	ld	r24, Z
    1b52:	8b 83       	std	Y+3, r24	; 0x03


	if( State_Value != LCD_QUEUE_NULL )
    1b54:	8b 81       	ldd	r24, Y+3	; 0x03
    1b56:	8f 3f       	cpi	r24, 0xFF	; 255
    1b58:	a9 f1       	breq	.+106    	; 0x1bc4 <Lcd_u8ReadQueue+0x90>
	{
		switch(State_Value)
    1b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5c:	28 2f       	mov	r18, r24
    1b5e:	30 e0       	ldi	r19, 0x00	; 0
    1b60:	3e 83       	std	Y+6, r19	; 0x06
    1b62:	2d 83       	std	Y+5, r18	; 0x05
    1b64:	8d 81       	ldd	r24, Y+5	; 0x05
    1b66:	9e 81       	ldd	r25, Y+6	; 0x06
    1b68:	00 97       	sbiw	r24, 0x00	; 0
    1b6a:	31 f0       	breq	.+12     	; 0x1b78 <Lcd_u8ReadQueue+0x44>
    1b6c:	2d 81       	ldd	r18, Y+5	; 0x05
    1b6e:	3e 81       	ldd	r19, Y+6	; 0x06
    1b70:	21 30       	cpi	r18, 0x01	; 1
    1b72:	31 05       	cpc	r19, r1
    1b74:	99 f0       	breq	.+38     	; 0x1b9c <Lcd_u8ReadQueue+0x68>
    1b76:	23 c0       	rjmp	.+70     	; 0x1bbe <Lcd_u8ReadQueue+0x8a>
		{
		case CHAR:
			Byte = arr_Queue[Queue_Read_Counter];
    1b78:	80 91 7b 00 	lds	r24, 0x007B
    1b7c:	88 2f       	mov	r24, r24
    1b7e:	90 e0       	ldi	r25, 0x00	; 0
    1b80:	fc 01       	movw	r30, r24
    1b82:	ec 50       	subi	r30, 0x0C	; 12
    1b84:	f9 4f       	sbci	r31, 0xF9	; 249
    1b86:	80 81       	ld	r24, Z
    1b88:	8a 83       	std	Y+2, r24	; 0x02
			Lcd_vidWriteChar( Byte );
    1b8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b8c:	0e 94 85 0c 	call	0x190a	; 0x190a <Lcd_vidWriteChar>
			Queue_Read_Counter++;
    1b90:	80 91 7b 00 	lds	r24, 0x007B
    1b94:	8f 5f       	subi	r24, 0xFF	; 255
    1b96:	80 93 7b 00 	sts	0x007B, r24
    1b9a:	11 c0       	rjmp	.+34     	; 0x1bbe <Lcd_u8ReadQueue+0x8a>
			break;

		case COMMAND:
			Byte = arr_Queue[Queue_Read_Counter];
    1b9c:	80 91 7b 00 	lds	r24, 0x007B
    1ba0:	88 2f       	mov	r24, r24
    1ba2:	90 e0       	ldi	r25, 0x00	; 0
    1ba4:	fc 01       	movw	r30, r24
    1ba6:	ec 50       	subi	r30, 0x0C	; 12
    1ba8:	f9 4f       	sbci	r31, 0xF9	; 249
    1baa:	80 81       	ld	r24, Z
    1bac:	8a 83       	std	Y+2, r24	; 0x02
			Lcd_vidSendCommand( Byte );
    1bae:	8a 81       	ldd	r24, Y+2	; 0x02
    1bb0:	0e 94 93 0b 	call	0x1726	; 0x1726 <Lcd_vidSendCommand>
			Queue_Read_Counter++;
    1bb4:	80 91 7b 00 	lds	r24, 0x007B
    1bb8:	8f 5f       	subi	r24, 0xFF	; 255
    1bba:	80 93 7b 00 	sts	0x007B, r24
			break;
		}
		return 1;
    1bbe:	31 e0       	ldi	r19, 0x01	; 1
    1bc0:	3c 83       	std	Y+4, r19	; 0x04
    1bc2:	1e c0       	rjmp	.+60     	; 0x1c00 <Lcd_u8ReadQueue+0xcc>
	}
	else
	{
		 u8 i;

		 for( i=0; i<MAXIMUM_ELEMENT_IN_QUEUE; i++ )
    1bc4:	19 82       	std	Y+1, r1	; 0x01
    1bc6:	13 c0       	rjmp	.+38     	; 0x1bee <Lcd_u8ReadQueue+0xba>
		 {
			 arr_Queue[i]  = LCD_QUEUE_NULL;
    1bc8:	89 81       	ldd	r24, Y+1	; 0x01
    1bca:	88 2f       	mov	r24, r24
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
    1bce:	fc 01       	movw	r30, r24
    1bd0:	ec 50       	subi	r30, 0x0C	; 12
    1bd2:	f9 4f       	sbci	r31, 0xF9	; 249
    1bd4:	8f ef       	ldi	r24, 0xFF	; 255
    1bd6:	80 83       	st	Z, r24
			 arr_State[i]  = LCD_QUEUE_NULL;
    1bd8:	89 81       	ldd	r24, Y+1	; 0x01
    1bda:	88 2f       	mov	r24, r24
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	fc 01       	movw	r30, r24
    1be0:	ee 53       	subi	r30, 0x3E	; 62
    1be2:	f9 4f       	sbci	r31, 0xF9	; 249
    1be4:	8f ef       	ldi	r24, 0xFF	; 255
    1be6:	80 83       	st	Z, r24
	}
	else
	{
		 u8 i;

		 for( i=0; i<MAXIMUM_ELEMENT_IN_QUEUE; i++ )
    1be8:	89 81       	ldd	r24, Y+1	; 0x01
    1bea:	8f 5f       	subi	r24, 0xFF	; 255
    1bec:	89 83       	std	Y+1, r24	; 0x01
    1bee:	89 81       	ldd	r24, Y+1	; 0x01
    1bf0:	82 33       	cpi	r24, 0x32	; 50
    1bf2:	50 f3       	brcs	.-44     	; 0x1bc8 <Lcd_u8ReadQueue+0x94>
		 {
			 arr_Queue[i]  = LCD_QUEUE_NULL;
			 arr_State[i]  = LCD_QUEUE_NULL;
		 }
		 Queue_Write_Counter = 0;
    1bf4:	10 92 7a 00 	sts	0x007A, r1
		 Queue_Read_Counter  = 0;
    1bf8:	10 92 7b 00 	sts	0x007B, r1

		 return LCD_QUEUE_NULL;
    1bfc:	8f ef       	ldi	r24, 0xFF	; 255
    1bfe:	8c 83       	std	Y+4, r24	; 0x04
    1c00:	8c 81       	ldd	r24, Y+4	; 0x04
	}

}
    1c02:	26 96       	adiw	r28, 0x06	; 6
    1c04:	0f b6       	in	r0, 0x3f	; 63
    1c06:	f8 94       	cli
    1c08:	de bf       	out	0x3e, r29	; 62
    1c0a:	0f be       	out	0x3f, r0	; 63
    1c0c:	cd bf       	out	0x3d, r28	; 61
    1c0e:	cf 91       	pop	r28
    1c10:	df 91       	pop	r29
    1c12:	08 95       	ret

00001c14 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    1c14:	df 93       	push	r29
    1c16:	cf 93       	push	r28
    1c18:	00 d0       	rcall	.+0      	; 0x1c1a <xEventGroupCreate+0x6>
    1c1a:	cd b7       	in	r28, 0x3d	; 61
    1c1c:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1c1e:	8b e0       	ldi	r24, 0x0B	; 11
    1c20:	90 e0       	ldi	r25, 0x00	; 0
    1c22:	0e 94 4f 11 	call	0x229e	; 0x229e <pvPortMalloc>
    1c26:	9a 83       	std	Y+2, r25	; 0x02
    1c28:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    1c2a:	89 81       	ldd	r24, Y+1	; 0x01
    1c2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c2e:	00 97       	sbiw	r24, 0x00	; 0
    1c30:	49 f0       	breq	.+18     	; 0x1c44 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
    1c32:	e9 81       	ldd	r30, Y+1	; 0x01
    1c34:	fa 81       	ldd	r31, Y+2	; 0x02
    1c36:	11 82       	std	Z+1, r1	; 0x01
    1c38:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1c3a:	89 81       	ldd	r24, Y+1	; 0x01
    1c3c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c3e:	02 96       	adiw	r24, 0x02	; 2
    1c40:	0e 94 cb 11 	call	0x2396	; 0x2396 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
    1c46:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1c48:	0f 90       	pop	r0
    1c4a:	0f 90       	pop	r0
    1c4c:	cf 91       	pop	r28
    1c4e:	df 91       	pop	r29
    1c50:	08 95       	ret

00001c52 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1c52:	df 93       	push	r29
    1c54:	cf 93       	push	r28
    1c56:	cd b7       	in	r28, 0x3d	; 61
    1c58:	de b7       	in	r29, 0x3e	; 62
    1c5a:	60 97       	sbiw	r28, 0x10	; 16
    1c5c:	0f b6       	in	r0, 0x3f	; 63
    1c5e:	f8 94       	cli
    1c60:	de bf       	out	0x3e, r29	; 62
    1c62:	0f be       	out	0x3f, r0	; 63
    1c64:	cd bf       	out	0x3d, r28	; 61
    1c66:	9a 87       	std	Y+10, r25	; 0x0a
    1c68:	89 87       	std	Y+9, r24	; 0x09
    1c6a:	7c 87       	std	Y+12, r23	; 0x0c
    1c6c:	6b 87       	std	Y+11, r22	; 0x0b
    1c6e:	5e 87       	std	Y+14, r21	; 0x0e
    1c70:	4d 87       	std	Y+13, r20	; 0x0d
    1c72:	38 8b       	std	Y+16, r19	; 0x10
    1c74:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    1c76:	89 85       	ldd	r24, Y+9	; 0x09
    1c78:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c7a:	9c 83       	std	Y+4, r25	; 0x04
    1c7c:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1c7e:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1c80:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1c84:	eb 81       	ldd	r30, Y+3	; 0x03
    1c86:	fc 81       	ldd	r31, Y+4	; 0x04
    1c88:	80 81       	ld	r24, Z
    1c8a:	91 81       	ldd	r25, Z+1	; 0x01
    1c8c:	98 87       	std	Y+8, r25	; 0x08
    1c8e:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1c90:	89 85       	ldd	r24, Y+9	; 0x09
    1c92:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c94:	2b 85       	ldd	r18, Y+11	; 0x0b
    1c96:	3c 85       	ldd	r19, Y+12	; 0x0c
    1c98:	b9 01       	movw	r22, r18
    1c9a:	0e 94 00 10 	call	0x2000	; 0x2000 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1c9e:	2f 81       	ldd	r18, Y+7	; 0x07
    1ca0:	38 85       	ldd	r19, Y+8	; 0x08
    1ca2:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ca4:	9c 85       	ldd	r25, Y+12	; 0x0c
    1ca6:	28 2b       	or	r18, r24
    1ca8:	39 2b       	or	r19, r25
    1caa:	8d 85       	ldd	r24, Y+13	; 0x0d
    1cac:	9e 85       	ldd	r25, Y+14	; 0x0e
    1cae:	28 23       	and	r18, r24
    1cb0:	39 23       	and	r19, r25
    1cb2:	8d 85       	ldd	r24, Y+13	; 0x0d
    1cb4:	9e 85       	ldd	r25, Y+14	; 0x0e
    1cb6:	28 17       	cp	r18, r24
    1cb8:	39 07       	cpc	r19, r25
    1cba:	c9 f4       	brne	.+50     	; 0x1cee <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1cbc:	2f 81       	ldd	r18, Y+7	; 0x07
    1cbe:	38 85       	ldd	r19, Y+8	; 0x08
    1cc0:	8b 85       	ldd	r24, Y+11	; 0x0b
    1cc2:	9c 85       	ldd	r25, Y+12	; 0x0c
    1cc4:	82 2b       	or	r24, r18
    1cc6:	93 2b       	or	r25, r19
    1cc8:	9e 83       	std	Y+6, r25	; 0x06
    1cca:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1ccc:	eb 81       	ldd	r30, Y+3	; 0x03
    1cce:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd0:	20 81       	ld	r18, Z
    1cd2:	31 81       	ldd	r19, Z+1	; 0x01
    1cd4:	8d 85       	ldd	r24, Y+13	; 0x0d
    1cd6:	9e 85       	ldd	r25, Y+14	; 0x0e
    1cd8:	80 95       	com	r24
    1cda:	90 95       	com	r25
    1cdc:	82 23       	and	r24, r18
    1cde:	93 23       	and	r25, r19
    1ce0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce4:	91 83       	std	Z+1, r25	; 0x01
    1ce6:	80 83       	st	Z, r24

			xTicksToWait = 0;
    1ce8:	18 8a       	std	Y+16, r1	; 0x10
    1cea:	1f 86       	std	Y+15, r1	; 0x0f
    1cec:	1e c0       	rjmp	.+60     	; 0x1d2a <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    1cee:	8f 85       	ldd	r24, Y+15	; 0x0f
    1cf0:	98 89       	ldd	r25, Y+16	; 0x10
    1cf2:	00 97       	sbiw	r24, 0x00	; 0
    1cf4:	91 f0       	breq	.+36     	; 0x1d1a <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cfa:	bc 01       	movw	r22, r24
    1cfc:	6e 5f       	subi	r22, 0xFE	; 254
    1cfe:	7f 4f       	sbci	r23, 0xFF	; 255
    1d00:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d02:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d04:	9c 01       	movw	r18, r24
    1d06:	35 60       	ori	r19, 0x05	; 5
    1d08:	4f 85       	ldd	r20, Y+15	; 0x0f
    1d0a:	58 89       	ldd	r21, Y+16	; 0x10
    1d0c:	cb 01       	movw	r24, r22
    1d0e:	b9 01       	movw	r22, r18
    1d10:	0e 94 2e 2c 	call	0x585c	; 0x585c <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1d14:	1e 82       	std	Y+6, r1	; 0x06
    1d16:	1d 82       	std	Y+5, r1	; 0x05
    1d18:	08 c0       	rjmp	.+16     	; 0x1d2a <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1d1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d1e:	80 81       	ld	r24, Z
    1d20:	91 81       	ldd	r25, Z+1	; 0x01
    1d22:	9e 83       	std	Y+6, r25	; 0x06
    1d24:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
    1d26:	81 e0       	ldi	r24, 0x01	; 1
    1d28:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1d2a:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    1d2e:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    1d30:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d32:	98 89       	ldd	r25, Y+16	; 0x10
    1d34:	00 97       	sbiw	r24, 0x00	; 0
    1d36:	09 f4       	brne	.+2      	; 0x1d3a <xEventGroupSync+0xe8>
    1d38:	3a c0       	rjmp	.+116    	; 0x1dae <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
    1d3a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d3c:	88 23       	and	r24, r24
    1d3e:	11 f4       	brne	.+4      	; 0x1d44 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
    1d40:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1d44:	0e 94 a1 2e 	call	0x5d42	; 0x5d42 <uxTaskResetEventItemValue>
    1d48:	9e 83       	std	Y+6, r25	; 0x06
    1d4a:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1d4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d4e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d50:	80 70       	andi	r24, 0x00	; 0
    1d52:	92 70       	andi	r25, 0x02	; 2
    1d54:	00 97       	sbiw	r24, 0x00	; 0
    1d56:	31 f5       	brne	.+76     	; 0x1da4 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1d58:	0f b6       	in	r0, 0x3f	; 63
    1d5a:	f8 94       	cli
    1d5c:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1d5e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d60:	fc 81       	ldd	r31, Y+4	; 0x04
    1d62:	80 81       	ld	r24, Z
    1d64:	91 81       	ldd	r25, Z+1	; 0x01
    1d66:	9e 83       	std	Y+6, r25	; 0x06
    1d68:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1d6a:	2d 81       	ldd	r18, Y+5	; 0x05
    1d6c:	3e 81       	ldd	r19, Y+6	; 0x06
    1d6e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d70:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d72:	28 23       	and	r18, r24
    1d74:	39 23       	and	r19, r25
    1d76:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d78:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d7a:	28 17       	cp	r18, r24
    1d7c:	39 07       	cpc	r19, r25
    1d7e:	71 f4       	brne	.+28     	; 0x1d9c <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1d80:	eb 81       	ldd	r30, Y+3	; 0x03
    1d82:	fc 81       	ldd	r31, Y+4	; 0x04
    1d84:	20 81       	ld	r18, Z
    1d86:	31 81       	ldd	r19, Z+1	; 0x01
    1d88:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d8a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d8c:	80 95       	com	r24
    1d8e:	90 95       	com	r25
    1d90:	82 23       	and	r24, r18
    1d92:	93 23       	and	r25, r19
    1d94:	eb 81       	ldd	r30, Y+3	; 0x03
    1d96:	fc 81       	ldd	r31, Y+4	; 0x04
    1d98:	91 83       	std	Z+1, r25	; 0x01
    1d9a:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1d9c:	0f 90       	pop	r0
    1d9e:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1da0:	81 e0       	ldi	r24, 0x01	; 1
    1da2:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1da4:	8d 81       	ldd	r24, Y+5	; 0x05
    1da6:	9e 81       	ldd	r25, Y+6	; 0x06
    1da8:	90 70       	andi	r25, 0x00	; 0
    1daa:	9e 83       	std	Y+6, r25	; 0x06
    1dac:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    1dae:	8d 81       	ldd	r24, Y+5	; 0x05
    1db0:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1db2:	60 96       	adiw	r28, 0x10	; 16
    1db4:	0f b6       	in	r0, 0x3f	; 63
    1db6:	f8 94       	cli
    1db8:	de bf       	out	0x3e, r29	; 62
    1dba:	0f be       	out	0x3f, r0	; 63
    1dbc:	cd bf       	out	0x3d, r28	; 61
    1dbe:	cf 91       	pop	r28
    1dc0:	df 91       	pop	r29
    1dc2:	08 95       	ret

00001dc4 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1dc4:	0f 93       	push	r16
    1dc6:	1f 93       	push	r17
    1dc8:	df 93       	push	r29
    1dca:	cf 93       	push	r28
    1dcc:	cd b7       	in	r28, 0x3d	; 61
    1dce:	de b7       	in	r29, 0x3e	; 62
    1dd0:	63 97       	sbiw	r28, 0x13	; 19
    1dd2:	0f b6       	in	r0, 0x3f	; 63
    1dd4:	f8 94       	cli
    1dd6:	de bf       	out	0x3e, r29	; 62
    1dd8:	0f be       	out	0x3f, r0	; 63
    1dda:	cd bf       	out	0x3d, r28	; 61
    1ddc:	9d 87       	std	Y+13, r25	; 0x0d
    1dde:	8c 87       	std	Y+12, r24	; 0x0c
    1de0:	7f 87       	std	Y+15, r23	; 0x0f
    1de2:	6e 87       	std	Y+14, r22	; 0x0e
    1de4:	48 8b       	std	Y+16, r20	; 0x10
    1de6:	29 8b       	std	Y+17, r18	; 0x11
    1de8:	1b 8b       	std	Y+19, r17	; 0x13
    1dea:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    1dec:	8c 85       	ldd	r24, Y+12	; 0x0c
    1dee:	9d 85       	ldd	r25, Y+13	; 0x0d
    1df0:	9b 87       	std	Y+11, r25	; 0x0b
    1df2:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    1df4:	1f 82       	std	Y+7, r1	; 0x07
    1df6:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1df8:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1dfa:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1dfe:	ea 85       	ldd	r30, Y+10	; 0x0a
    1e00:	fb 85       	ldd	r31, Y+11	; 0x0b
    1e02:	80 81       	ld	r24, Z
    1e04:	91 81       	ldd	r25, Z+1	; 0x01
    1e06:	9a 83       	std	Y+2, r25	; 0x02
    1e08:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1e0a:	89 81       	ldd	r24, Y+1	; 0x01
    1e0c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e0e:	2e 85       	ldd	r18, Y+14	; 0x0e
    1e10:	3f 85       	ldd	r19, Y+15	; 0x0f
    1e12:	b9 01       	movw	r22, r18
    1e14:	49 89       	ldd	r20, Y+17	; 0x11
    1e16:	0e 94 1d 11 	call	0x223a	; 0x223a <prvTestWaitCondition>
    1e1a:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    1e1c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e1e:	88 23       	and	r24, r24
    1e20:	c1 f0       	breq	.+48     	; 0x1e52 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    1e22:	89 81       	ldd	r24, Y+1	; 0x01
    1e24:	9a 81       	ldd	r25, Y+2	; 0x02
    1e26:	99 87       	std	Y+9, r25	; 0x09
    1e28:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    1e2a:	1b 8a       	std	Y+19, r1	; 0x13
    1e2c:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    1e2e:	88 89       	ldd	r24, Y+16	; 0x10
    1e30:	88 23       	and	r24, r24
    1e32:	e9 f1       	breq	.+122    	; 0x1eae <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1e34:	ea 85       	ldd	r30, Y+10	; 0x0a
    1e36:	fb 85       	ldd	r31, Y+11	; 0x0b
    1e38:	20 81       	ld	r18, Z
    1e3a:	31 81       	ldd	r19, Z+1	; 0x01
    1e3c:	8e 85       	ldd	r24, Y+14	; 0x0e
    1e3e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1e40:	80 95       	com	r24
    1e42:	90 95       	com	r25
    1e44:	82 23       	and	r24, r18
    1e46:	93 23       	and	r25, r19
    1e48:	ea 85       	ldd	r30, Y+10	; 0x0a
    1e4a:	fb 85       	ldd	r31, Y+11	; 0x0b
    1e4c:	91 83       	std	Z+1, r25	; 0x01
    1e4e:	80 83       	st	Z, r24
    1e50:	2e c0       	rjmp	.+92     	; 0x1eae <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    1e52:	8a 89       	ldd	r24, Y+18	; 0x12
    1e54:	9b 89       	ldd	r25, Y+19	; 0x13
    1e56:	00 97       	sbiw	r24, 0x00	; 0
    1e58:	39 f4       	brne	.+14     	; 0x1e68 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    1e5a:	89 81       	ldd	r24, Y+1	; 0x01
    1e5c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e5e:	99 87       	std	Y+9, r25	; 0x09
    1e60:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
    1e62:	81 e0       	ldi	r24, 0x01	; 1
    1e64:	8b 83       	std	Y+3, r24	; 0x03
    1e66:	23 c0       	rjmp	.+70     	; 0x1eae <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    1e68:	88 89       	ldd	r24, Y+16	; 0x10
    1e6a:	88 23       	and	r24, r24
    1e6c:	29 f0       	breq	.+10     	; 0x1e78 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1e6e:	8e 81       	ldd	r24, Y+6	; 0x06
    1e70:	9f 81       	ldd	r25, Y+7	; 0x07
    1e72:	91 60       	ori	r25, 0x01	; 1
    1e74:	9f 83       	std	Y+7, r25	; 0x07
    1e76:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    1e78:	89 89       	ldd	r24, Y+17	; 0x11
    1e7a:	88 23       	and	r24, r24
    1e7c:	29 f0       	breq	.+10     	; 0x1e88 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1e7e:	8e 81       	ldd	r24, Y+6	; 0x06
    1e80:	9f 81       	ldd	r25, Y+7	; 0x07
    1e82:	94 60       	ori	r25, 0x04	; 4
    1e84:	9f 83       	std	Y+7, r25	; 0x07
    1e86:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1e88:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e8a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e8c:	bc 01       	movw	r22, r24
    1e8e:	6e 5f       	subi	r22, 0xFE	; 254
    1e90:	7f 4f       	sbci	r23, 0xFF	; 255
    1e92:	2e 85       	ldd	r18, Y+14	; 0x0e
    1e94:	3f 85       	ldd	r19, Y+15	; 0x0f
    1e96:	8e 81       	ldd	r24, Y+6	; 0x06
    1e98:	9f 81       	ldd	r25, Y+7	; 0x07
    1e9a:	28 2b       	or	r18, r24
    1e9c:	39 2b       	or	r19, r25
    1e9e:	4a 89       	ldd	r20, Y+18	; 0x12
    1ea0:	5b 89       	ldd	r21, Y+19	; 0x13
    1ea2:	cb 01       	movw	r24, r22
    1ea4:	b9 01       	movw	r22, r18
    1ea6:	0e 94 2e 2c 	call	0x585c	; 0x585c <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    1eaa:	19 86       	std	Y+9, r1	; 0x09
    1eac:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1eae:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    1eb2:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    1eb4:	8a 89       	ldd	r24, Y+18	; 0x12
    1eb6:	9b 89       	ldd	r25, Y+19	; 0x13
    1eb8:	00 97       	sbiw	r24, 0x00	; 0
    1eba:	09 f4       	brne	.+2      	; 0x1ebe <xEventGroupWaitBits+0xfa>
    1ebc:	3c c0       	rjmp	.+120    	; 0x1f36 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    1ebe:	8c 81       	ldd	r24, Y+4	; 0x04
    1ec0:	88 23       	and	r24, r24
    1ec2:	11 f4       	brne	.+4      	; 0x1ec8 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    1ec4:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1ec8:	0e 94 a1 2e 	call	0x5d42	; 0x5d42 <uxTaskResetEventItemValue>
    1ecc:	99 87       	std	Y+9, r25	; 0x09
    1ece:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1ed0:	88 85       	ldd	r24, Y+8	; 0x08
    1ed2:	99 85       	ldd	r25, Y+9	; 0x09
    1ed4:	80 70       	andi	r24, 0x00	; 0
    1ed6:	92 70       	andi	r25, 0x02	; 2
    1ed8:	00 97       	sbiw	r24, 0x00	; 0
    1eda:	41 f5       	brne	.+80     	; 0x1f2c <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    1edc:	0f b6       	in	r0, 0x3f	; 63
    1ede:	f8 94       	cli
    1ee0:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1ee2:	ea 85       	ldd	r30, Y+10	; 0x0a
    1ee4:	fb 85       	ldd	r31, Y+11	; 0x0b
    1ee6:	80 81       	ld	r24, Z
    1ee8:	91 81       	ldd	r25, Z+1	; 0x01
    1eea:	99 87       	std	Y+9, r25	; 0x09
    1eec:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1eee:	88 85       	ldd	r24, Y+8	; 0x08
    1ef0:	99 85       	ldd	r25, Y+9	; 0x09
    1ef2:	2e 85       	ldd	r18, Y+14	; 0x0e
    1ef4:	3f 85       	ldd	r19, Y+15	; 0x0f
    1ef6:	b9 01       	movw	r22, r18
    1ef8:	49 89       	ldd	r20, Y+17	; 0x11
    1efa:	0e 94 1d 11 	call	0x223a	; 0x223a <prvTestWaitCondition>
    1efe:	88 23       	and	r24, r24
    1f00:	89 f0       	breq	.+34     	; 0x1f24 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    1f02:	88 89       	ldd	r24, Y+16	; 0x10
    1f04:	88 23       	and	r24, r24
    1f06:	71 f0       	breq	.+28     	; 0x1f24 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1f08:	ea 85       	ldd	r30, Y+10	; 0x0a
    1f0a:	fb 85       	ldd	r31, Y+11	; 0x0b
    1f0c:	20 81       	ld	r18, Z
    1f0e:	31 81       	ldd	r19, Z+1	; 0x01
    1f10:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f12:	9f 85       	ldd	r25, Y+15	; 0x0f
    1f14:	80 95       	com	r24
    1f16:	90 95       	com	r25
    1f18:	82 23       	and	r24, r18
    1f1a:	93 23       	and	r25, r19
    1f1c:	ea 85       	ldd	r30, Y+10	; 0x0a
    1f1e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1f20:	91 83       	std	Z+1, r25	; 0x01
    1f22:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    1f24:	81 e0       	ldi	r24, 0x01	; 1
    1f26:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    1f28:	0f 90       	pop	r0
    1f2a:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1f2c:	88 85       	ldd	r24, Y+8	; 0x08
    1f2e:	99 85       	ldd	r25, Y+9	; 0x09
    1f30:	90 70       	andi	r25, 0x00	; 0
    1f32:	99 87       	std	Y+9, r25	; 0x09
    1f34:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    1f36:	88 85       	ldd	r24, Y+8	; 0x08
    1f38:	99 85       	ldd	r25, Y+9	; 0x09
}
    1f3a:	63 96       	adiw	r28, 0x13	; 19
    1f3c:	0f b6       	in	r0, 0x3f	; 63
    1f3e:	f8 94       	cli
    1f40:	de bf       	out	0x3e, r29	; 62
    1f42:	0f be       	out	0x3f, r0	; 63
    1f44:	cd bf       	out	0x3d, r28	; 61
    1f46:	cf 91       	pop	r28
    1f48:	df 91       	pop	r29
    1f4a:	1f 91       	pop	r17
    1f4c:	0f 91       	pop	r16
    1f4e:	08 95       	ret

00001f50 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    1f50:	df 93       	push	r29
    1f52:	cf 93       	push	r28
    1f54:	cd b7       	in	r28, 0x3d	; 61
    1f56:	de b7       	in	r29, 0x3e	; 62
    1f58:	28 97       	sbiw	r28, 0x08	; 8
    1f5a:	0f b6       	in	r0, 0x3f	; 63
    1f5c:	f8 94       	cli
    1f5e:	de bf       	out	0x3e, r29	; 62
    1f60:	0f be       	out	0x3f, r0	; 63
    1f62:	cd bf       	out	0x3d, r28	; 61
    1f64:	9e 83       	std	Y+6, r25	; 0x06
    1f66:	8d 83       	std	Y+5, r24	; 0x05
    1f68:	78 87       	std	Y+8, r23	; 0x08
    1f6a:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    1f6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f6e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f70:	9c 83       	std	Y+4, r25	; 0x04
    1f72:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    1f74:	0f b6       	in	r0, 0x3f	; 63
    1f76:	f8 94       	cli
    1f78:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    1f7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f7e:	80 81       	ld	r24, Z
    1f80:	91 81       	ldd	r25, Z+1	; 0x01
    1f82:	9a 83       	std	Y+2, r25	; 0x02
    1f84:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1f86:	eb 81       	ldd	r30, Y+3	; 0x03
    1f88:	fc 81       	ldd	r31, Y+4	; 0x04
    1f8a:	20 81       	ld	r18, Z
    1f8c:	31 81       	ldd	r19, Z+1	; 0x01
    1f8e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f90:	98 85       	ldd	r25, Y+8	; 0x08
    1f92:	80 95       	com	r24
    1f94:	90 95       	com	r25
    1f96:	82 23       	and	r24, r18
    1f98:	93 23       	and	r25, r19
    1f9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f9e:	91 83       	std	Z+1, r25	; 0x01
    1fa0:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    1fa2:	0f 90       	pop	r0
    1fa4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1fa6:	89 81       	ldd	r24, Y+1	; 0x01
    1fa8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1faa:	28 96       	adiw	r28, 0x08	; 8
    1fac:	0f b6       	in	r0, 0x3f	; 63
    1fae:	f8 94       	cli
    1fb0:	de bf       	out	0x3e, r29	; 62
    1fb2:	0f be       	out	0x3f, r0	; 63
    1fb4:	cd bf       	out	0x3d, r28	; 61
    1fb6:	cf 91       	pop	r28
    1fb8:	df 91       	pop	r29
    1fba:	08 95       	ret

00001fbc <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1fbc:	df 93       	push	r29
    1fbe:	cf 93       	push	r28
    1fc0:	cd b7       	in	r28, 0x3d	; 61
    1fc2:	de b7       	in	r29, 0x3e	; 62
    1fc4:	27 97       	sbiw	r28, 0x07	; 7
    1fc6:	0f b6       	in	r0, 0x3f	; 63
    1fc8:	f8 94       	cli
    1fca:	de bf       	out	0x3e, r29	; 62
    1fcc:	0f be       	out	0x3f, r0	; 63
    1fce:	cd bf       	out	0x3d, r28	; 61
    1fd0:	9f 83       	std	Y+7, r25	; 0x07
    1fd2:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    1fd4:	8e 81       	ldd	r24, Y+6	; 0x06
    1fd6:	9f 81       	ldd	r25, Y+7	; 0x07
    1fd8:	9c 83       	std	Y+4, r25	; 0x04
    1fda:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fdc:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    1fde:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe0:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe2:	80 81       	ld	r24, Z
    1fe4:	91 81       	ldd	r25, Z+1	; 0x01
    1fe6:	9a 83       	std	Y+2, r25	; 0x02
    1fe8:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    1fea:	89 81       	ldd	r24, Y+1	; 0x01
    1fec:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1fee:	27 96       	adiw	r28, 0x07	; 7
    1ff0:	0f b6       	in	r0, 0x3f	; 63
    1ff2:	f8 94       	cli
    1ff4:	de bf       	out	0x3e, r29	; 62
    1ff6:	0f be       	out	0x3f, r0	; 63
    1ff8:	cd bf       	out	0x3d, r28	; 61
    1ffa:	cf 91       	pop	r28
    1ffc:	df 91       	pop	r29
    1ffe:	08 95       	ret

00002000 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2000:	df 93       	push	r29
    2002:	cf 93       	push	r28
    2004:	cd b7       	in	r28, 0x3d	; 61
    2006:	de b7       	in	r29, 0x3e	; 62
    2008:	65 97       	sbiw	r28, 0x15	; 21
    200a:	0f b6       	in	r0, 0x3f	; 63
    200c:	f8 94       	cli
    200e:	de bf       	out	0x3e, r29	; 62
    2010:	0f be       	out	0x3f, r0	; 63
    2012:	cd bf       	out	0x3d, r28	; 61
    2014:	9b 8b       	std	Y+19, r25	; 0x13
    2016:	8a 8b       	std	Y+18, r24	; 0x12
    2018:	7d 8b       	std	Y+21, r23	; 0x15
    201a:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    201c:	19 86       	std	Y+9, r1	; 0x09
    201e:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    2020:	8a 89       	ldd	r24, Y+18	; 0x12
    2022:	9b 89       	ldd	r25, Y+19	; 0x13
    2024:	9b 83       	std	Y+3, r25	; 0x03
    2026:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    2028:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    202a:	8a 81       	ldd	r24, Y+2	; 0x02
    202c:	9b 81       	ldd	r25, Y+3	; 0x03
    202e:	02 96       	adiw	r24, 0x02	; 2
    2030:	9b 87       	std	Y+11, r25	; 0x0b
    2032:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2034:	8a 85       	ldd	r24, Y+10	; 0x0a
    2036:	9b 85       	ldd	r25, Y+11	; 0x0b
    2038:	03 96       	adiw	r24, 0x03	; 3
    203a:	9d 87       	std	Y+13, r25	; 0x0d
    203c:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    203e:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2042:	ea 85       	ldd	r30, Y+10	; 0x0a
    2044:	fb 85       	ldd	r31, Y+11	; 0x0b
    2046:	85 81       	ldd	r24, Z+5	; 0x05
    2048:	96 81       	ldd	r25, Z+6	; 0x06
    204a:	99 8b       	std	Y+17, r25	; 0x11
    204c:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    204e:	ea 81       	ldd	r30, Y+2	; 0x02
    2050:	fb 81       	ldd	r31, Y+3	; 0x03
    2052:	20 81       	ld	r18, Z
    2054:	31 81       	ldd	r19, Z+1	; 0x01
    2056:	8c 89       	ldd	r24, Y+20	; 0x14
    2058:	9d 89       	ldd	r25, Y+21	; 0x15
    205a:	82 2b       	or	r24, r18
    205c:	93 2b       	or	r25, r19
    205e:	ea 81       	ldd	r30, Y+2	; 0x02
    2060:	fb 81       	ldd	r31, Y+3	; 0x03
    2062:	91 83       	std	Z+1, r25	; 0x01
    2064:	80 83       	st	Z, r24
    2066:	59 c0       	rjmp	.+178    	; 0x211a <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    2068:	e8 89       	ldd	r30, Y+16	; 0x10
    206a:	f9 89       	ldd	r31, Y+17	; 0x11
    206c:	82 81       	ldd	r24, Z+2	; 0x02
    206e:	93 81       	ldd	r25, Z+3	; 0x03
    2070:	9f 87       	std	Y+15, r25	; 0x0f
    2072:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2074:	e8 89       	ldd	r30, Y+16	; 0x10
    2076:	f9 89       	ldd	r31, Y+17	; 0x11
    2078:	80 81       	ld	r24, Z
    207a:	91 81       	ldd	r25, Z+1	; 0x01
    207c:	9f 83       	std	Y+7, r25	; 0x07
    207e:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    2080:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2082:	8e 81       	ldd	r24, Y+6	; 0x06
    2084:	9f 81       	ldd	r25, Y+7	; 0x07
    2086:	80 70       	andi	r24, 0x00	; 0
    2088:	9d 83       	std	Y+5, r25	; 0x05
    208a:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    208c:	8e 81       	ldd	r24, Y+6	; 0x06
    208e:	9f 81       	ldd	r25, Y+7	; 0x07
    2090:	90 70       	andi	r25, 0x00	; 0
    2092:	9f 83       	std	Y+7, r25	; 0x07
    2094:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2096:	8c 81       	ldd	r24, Y+4	; 0x04
    2098:	9d 81       	ldd	r25, Y+5	; 0x05
    209a:	80 70       	andi	r24, 0x00	; 0
    209c:	94 70       	andi	r25, 0x04	; 4
    209e:	00 97       	sbiw	r24, 0x00	; 0
    20a0:	69 f4       	brne	.+26     	; 0x20bc <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    20a2:	ea 81       	ldd	r30, Y+2	; 0x02
    20a4:	fb 81       	ldd	r31, Y+3	; 0x03
    20a6:	20 81       	ld	r18, Z
    20a8:	31 81       	ldd	r19, Z+1	; 0x01
    20aa:	8e 81       	ldd	r24, Y+6	; 0x06
    20ac:	9f 81       	ldd	r25, Y+7	; 0x07
    20ae:	82 23       	and	r24, r18
    20b0:	93 23       	and	r25, r19
    20b2:	00 97       	sbiw	r24, 0x00	; 0
    20b4:	91 f0       	breq	.+36     	; 0x20da <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    20b6:	81 e0       	ldi	r24, 0x01	; 1
    20b8:	89 83       	std	Y+1, r24	; 0x01
    20ba:	0f c0       	rjmp	.+30     	; 0x20da <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    20bc:	ea 81       	ldd	r30, Y+2	; 0x02
    20be:	fb 81       	ldd	r31, Y+3	; 0x03
    20c0:	20 81       	ld	r18, Z
    20c2:	31 81       	ldd	r19, Z+1	; 0x01
    20c4:	8e 81       	ldd	r24, Y+6	; 0x06
    20c6:	9f 81       	ldd	r25, Y+7	; 0x07
    20c8:	28 23       	and	r18, r24
    20ca:	39 23       	and	r19, r25
    20cc:	8e 81       	ldd	r24, Y+6	; 0x06
    20ce:	9f 81       	ldd	r25, Y+7	; 0x07
    20d0:	28 17       	cp	r18, r24
    20d2:	39 07       	cpc	r19, r25
    20d4:	11 f4       	brne	.+4      	; 0x20da <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    20d6:	81 e0       	ldi	r24, 0x01	; 1
    20d8:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    20da:	89 81       	ldd	r24, Y+1	; 0x01
    20dc:	88 23       	and	r24, r24
    20de:	c9 f0       	breq	.+50     	; 0x2112 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    20e0:	8c 81       	ldd	r24, Y+4	; 0x04
    20e2:	9d 81       	ldd	r25, Y+5	; 0x05
    20e4:	80 70       	andi	r24, 0x00	; 0
    20e6:	91 70       	andi	r25, 0x01	; 1
    20e8:	00 97       	sbiw	r24, 0x00	; 0
    20ea:	41 f0       	breq	.+16     	; 0x20fc <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    20ec:	88 85       	ldd	r24, Y+8	; 0x08
    20ee:	99 85       	ldd	r25, Y+9	; 0x09
    20f0:	2e 81       	ldd	r18, Y+6	; 0x06
    20f2:	3f 81       	ldd	r19, Y+7	; 0x07
    20f4:	82 2b       	or	r24, r18
    20f6:	93 2b       	or	r25, r19
    20f8:	99 87       	std	Y+9, r25	; 0x09
    20fa:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    20fc:	ea 81       	ldd	r30, Y+2	; 0x02
    20fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2100:	80 81       	ld	r24, Z
    2102:	91 81       	ldd	r25, Z+1	; 0x01
    2104:	9c 01       	movw	r18, r24
    2106:	32 60       	ori	r19, 0x02	; 2
    2108:	88 89       	ldd	r24, Y+16	; 0x10
    210a:	99 89       	ldd	r25, Y+17	; 0x11
    210c:	b9 01       	movw	r22, r18
    210e:	0e 94 c9 2c 	call	0x5992	; 0x5992 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    2112:	8e 85       	ldd	r24, Y+14	; 0x0e
    2114:	9f 85       	ldd	r25, Y+15	; 0x0f
    2116:	99 8b       	std	Y+17, r25	; 0x11
    2118:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    211a:	28 89       	ldd	r18, Y+16	; 0x10
    211c:	39 89       	ldd	r19, Y+17	; 0x11
    211e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2120:	9d 85       	ldd	r25, Y+13	; 0x0d
    2122:	28 17       	cp	r18, r24
    2124:	39 07       	cpc	r19, r25
    2126:	09 f0       	breq	.+2      	; 0x212a <xEventGroupSetBits+0x12a>
    2128:	9f cf       	rjmp	.-194    	; 0x2068 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    212a:	ea 81       	ldd	r30, Y+2	; 0x02
    212c:	fb 81       	ldd	r31, Y+3	; 0x03
    212e:	20 81       	ld	r18, Z
    2130:	31 81       	ldd	r19, Z+1	; 0x01
    2132:	88 85       	ldd	r24, Y+8	; 0x08
    2134:	99 85       	ldd	r25, Y+9	; 0x09
    2136:	80 95       	com	r24
    2138:	90 95       	com	r25
    213a:	82 23       	and	r24, r18
    213c:	93 23       	and	r25, r19
    213e:	ea 81       	ldd	r30, Y+2	; 0x02
    2140:	fb 81       	ldd	r31, Y+3	; 0x03
    2142:	91 83       	std	Z+1, r25	; 0x01
    2144:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    2146:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    214a:	ea 81       	ldd	r30, Y+2	; 0x02
    214c:	fb 81       	ldd	r31, Y+3	; 0x03
    214e:	80 81       	ld	r24, Z
    2150:	91 81       	ldd	r25, Z+1	; 0x01
}
    2152:	65 96       	adiw	r28, 0x15	; 21
    2154:	0f b6       	in	r0, 0x3f	; 63
    2156:	f8 94       	cli
    2158:	de bf       	out	0x3e, r29	; 62
    215a:	0f be       	out	0x3f, r0	; 63
    215c:	cd bf       	out	0x3d, r28	; 61
    215e:	cf 91       	pop	r28
    2160:	df 91       	pop	r29
    2162:	08 95       	ret

00002164 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2164:	df 93       	push	r29
    2166:	cf 93       	push	r28
    2168:	00 d0       	rcall	.+0      	; 0x216a <vEventGroupDelete+0x6>
    216a:	00 d0       	rcall	.+0      	; 0x216c <vEventGroupDelete+0x8>
    216c:	00 d0       	rcall	.+0      	; 0x216e <vEventGroupDelete+0xa>
    216e:	cd b7       	in	r28, 0x3d	; 61
    2170:	de b7       	in	r29, 0x3e	; 62
    2172:	9e 83       	std	Y+6, r25	; 0x06
    2174:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    2176:	8d 81       	ldd	r24, Y+5	; 0x05
    2178:	9e 81       	ldd	r25, Y+6	; 0x06
    217a:	9c 83       	std	Y+4, r25	; 0x04
    217c:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    217e:	8b 81       	ldd	r24, Y+3	; 0x03
    2180:	9c 81       	ldd	r25, Y+4	; 0x04
    2182:	02 96       	adiw	r24, 0x02	; 2
    2184:	9a 83       	std	Y+2, r25	; 0x02
    2186:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    2188:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
    218c:	08 c0       	rjmp	.+16     	; 0x219e <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    218e:	e9 81       	ldd	r30, Y+1	; 0x01
    2190:	fa 81       	ldd	r31, Y+2	; 0x02
    2192:	85 81       	ldd	r24, Z+5	; 0x05
    2194:	96 81       	ldd	r25, Z+6	; 0x06
    2196:	60 e0       	ldi	r22, 0x00	; 0
    2198:	72 e0       	ldi	r23, 0x02	; 2
    219a:	0e 94 c9 2c 	call	0x5992	; 0x5992 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    219e:	e9 81       	ldd	r30, Y+1	; 0x01
    21a0:	fa 81       	ldd	r31, Y+2	; 0x02
    21a2:	80 81       	ld	r24, Z
    21a4:	88 23       	and	r24, r24
    21a6:	99 f7       	brne	.-26     	; 0x218e <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    21a8:	8b 81       	ldd	r24, Y+3	; 0x03
    21aa:	9c 81       	ldd	r25, Y+4	; 0x04
    21ac:	0e 94 a5 11 	call	0x234a	; 0x234a <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    21b0:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
}
    21b4:	26 96       	adiw	r28, 0x06	; 6
    21b6:	0f b6       	in	r0, 0x3f	; 63
    21b8:	f8 94       	cli
    21ba:	de bf       	out	0x3e, r29	; 62
    21bc:	0f be       	out	0x3f, r0	; 63
    21be:	cd bf       	out	0x3d, r28	; 61
    21c0:	cf 91       	pop	r28
    21c2:	df 91       	pop	r29
    21c4:	08 95       	ret

000021c6 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    21c6:	df 93       	push	r29
    21c8:	cf 93       	push	r28
    21ca:	00 d0       	rcall	.+0      	; 0x21cc <vEventGroupSetBitsCallback+0x6>
    21cc:	00 d0       	rcall	.+0      	; 0x21ce <vEventGroupSetBitsCallback+0x8>
    21ce:	00 d0       	rcall	.+0      	; 0x21d0 <vEventGroupSetBitsCallback+0xa>
    21d0:	cd b7       	in	r28, 0x3d	; 61
    21d2:	de b7       	in	r29, 0x3e	; 62
    21d4:	9a 83       	std	Y+2, r25	; 0x02
    21d6:	89 83       	std	Y+1, r24	; 0x01
    21d8:	4b 83       	std	Y+3, r20	; 0x03
    21da:	5c 83       	std	Y+4, r21	; 0x04
    21dc:	6d 83       	std	Y+5, r22	; 0x05
    21de:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    21e0:	89 81       	ldd	r24, Y+1	; 0x01
    21e2:	9a 81       	ldd	r25, Y+2	; 0x02
    21e4:	2b 81       	ldd	r18, Y+3	; 0x03
    21e6:	3c 81       	ldd	r19, Y+4	; 0x04
    21e8:	b9 01       	movw	r22, r18
    21ea:	0e 94 00 10 	call	0x2000	; 0x2000 <xEventGroupSetBits>
}
    21ee:	26 96       	adiw	r28, 0x06	; 6
    21f0:	0f b6       	in	r0, 0x3f	; 63
    21f2:	f8 94       	cli
    21f4:	de bf       	out	0x3e, r29	; 62
    21f6:	0f be       	out	0x3f, r0	; 63
    21f8:	cd bf       	out	0x3d, r28	; 61
    21fa:	cf 91       	pop	r28
    21fc:	df 91       	pop	r29
    21fe:	08 95       	ret

00002200 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    2200:	df 93       	push	r29
    2202:	cf 93       	push	r28
    2204:	00 d0       	rcall	.+0      	; 0x2206 <vEventGroupClearBitsCallback+0x6>
    2206:	00 d0       	rcall	.+0      	; 0x2208 <vEventGroupClearBitsCallback+0x8>
    2208:	00 d0       	rcall	.+0      	; 0x220a <vEventGroupClearBitsCallback+0xa>
    220a:	cd b7       	in	r28, 0x3d	; 61
    220c:	de b7       	in	r29, 0x3e	; 62
    220e:	9a 83       	std	Y+2, r25	; 0x02
    2210:	89 83       	std	Y+1, r24	; 0x01
    2212:	4b 83       	std	Y+3, r20	; 0x03
    2214:	5c 83       	std	Y+4, r21	; 0x04
    2216:	6d 83       	std	Y+5, r22	; 0x05
    2218:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    221a:	89 81       	ldd	r24, Y+1	; 0x01
    221c:	9a 81       	ldd	r25, Y+2	; 0x02
    221e:	2b 81       	ldd	r18, Y+3	; 0x03
    2220:	3c 81       	ldd	r19, Y+4	; 0x04
    2222:	b9 01       	movw	r22, r18
    2224:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <xEventGroupClearBits>
}
    2228:	26 96       	adiw	r28, 0x06	; 6
    222a:	0f b6       	in	r0, 0x3f	; 63
    222c:	f8 94       	cli
    222e:	de bf       	out	0x3e, r29	; 62
    2230:	0f be       	out	0x3f, r0	; 63
    2232:	cd bf       	out	0x3d, r28	; 61
    2234:	cf 91       	pop	r28
    2236:	df 91       	pop	r29
    2238:	08 95       	ret

0000223a <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    223a:	df 93       	push	r29
    223c:	cf 93       	push	r28
    223e:	00 d0       	rcall	.+0      	; 0x2240 <prvTestWaitCondition+0x6>
    2240:	00 d0       	rcall	.+0      	; 0x2242 <prvTestWaitCondition+0x8>
    2242:	00 d0       	rcall	.+0      	; 0x2244 <prvTestWaitCondition+0xa>
    2244:	cd b7       	in	r28, 0x3d	; 61
    2246:	de b7       	in	r29, 0x3e	; 62
    2248:	9b 83       	std	Y+3, r25	; 0x03
    224a:	8a 83       	std	Y+2, r24	; 0x02
    224c:	7d 83       	std	Y+5, r23	; 0x05
    224e:	6c 83       	std	Y+4, r22	; 0x04
    2250:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    2252:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    2254:	8e 81       	ldd	r24, Y+6	; 0x06
    2256:	88 23       	and	r24, r24
    2258:	59 f4       	brne	.+22     	; 0x2270 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    225a:	8a 81       	ldd	r24, Y+2	; 0x02
    225c:	9b 81       	ldd	r25, Y+3	; 0x03
    225e:	2c 81       	ldd	r18, Y+4	; 0x04
    2260:	3d 81       	ldd	r19, Y+5	; 0x05
    2262:	82 23       	and	r24, r18
    2264:	93 23       	and	r25, r19
    2266:	00 97       	sbiw	r24, 0x00	; 0
    2268:	81 f0       	breq	.+32     	; 0x228a <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    226a:	81 e0       	ldi	r24, 0x01	; 1
    226c:	89 83       	std	Y+1, r24	; 0x01
    226e:	0d c0       	rjmp	.+26     	; 0x228a <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2270:	2a 81       	ldd	r18, Y+2	; 0x02
    2272:	3b 81       	ldd	r19, Y+3	; 0x03
    2274:	8c 81       	ldd	r24, Y+4	; 0x04
    2276:	9d 81       	ldd	r25, Y+5	; 0x05
    2278:	28 23       	and	r18, r24
    227a:	39 23       	and	r19, r25
    227c:	8c 81       	ldd	r24, Y+4	; 0x04
    227e:	9d 81       	ldd	r25, Y+5	; 0x05
    2280:	28 17       	cp	r18, r24
    2282:	39 07       	cpc	r19, r25
    2284:	11 f4       	brne	.+4      	; 0x228a <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    2286:	81 e0       	ldi	r24, 0x01	; 1
    2288:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    228a:	89 81       	ldd	r24, Y+1	; 0x01
}
    228c:	26 96       	adiw	r28, 0x06	; 6
    228e:	0f b6       	in	r0, 0x3f	; 63
    2290:	f8 94       	cli
    2292:	de bf       	out	0x3e, r29	; 62
    2294:	0f be       	out	0x3f, r0	; 63
    2296:	cd bf       	out	0x3d, r28	; 61
    2298:	cf 91       	pop	r28
    229a:	df 91       	pop	r29
    229c:	08 95       	ret

0000229e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    229e:	df 93       	push	r29
    22a0:	cf 93       	push	r28
    22a2:	00 d0       	rcall	.+0      	; 0x22a4 <pvPortMalloc+0x6>
    22a4:	00 d0       	rcall	.+0      	; 0x22a6 <pvPortMalloc+0x8>
    22a6:	cd b7       	in	r28, 0x3d	; 61
    22a8:	de b7       	in	r29, 0x3e	; 62
    22aa:	9c 83       	std	Y+4, r25	; 0x04
    22ac:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    22ae:	1a 82       	std	Y+2, r1	; 0x02
    22b0:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    22b2:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    22b6:	80 91 7e 00 	lds	r24, 0x007E
    22ba:	90 91 7f 00 	lds	r25, 0x007F
    22be:	00 97       	sbiw	r24, 0x00	; 0
    22c0:	31 f4       	brne	.+12     	; 0x22ce <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    22c2:	81 e8       	ldi	r24, 0x81	; 129
    22c4:	90 e0       	ldi	r25, 0x00	; 0
    22c6:	90 93 7f 00 	sts	0x007F, r25
    22ca:	80 93 7e 00 	sts	0x007E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    22ce:	80 91 7c 00 	lds	r24, 0x007C
    22d2:	90 91 7d 00 	lds	r25, 0x007D
    22d6:	2b 81       	ldd	r18, Y+3	; 0x03
    22d8:	3c 81       	ldd	r19, Y+4	; 0x04
    22da:	82 0f       	add	r24, r18
    22dc:	93 1f       	adc	r25, r19
    22de:	25 e0       	ldi	r18, 0x05	; 5
    22e0:	8b 3d       	cpi	r24, 0xDB	; 219
    22e2:	92 07       	cpc	r25, r18
    22e4:	38 f5       	brcc	.+78     	; 0x2334 <pvPortMalloc+0x96>
    22e6:	20 91 7c 00 	lds	r18, 0x007C
    22ea:	30 91 7d 00 	lds	r19, 0x007D
    22ee:	8b 81       	ldd	r24, Y+3	; 0x03
    22f0:	9c 81       	ldd	r25, Y+4	; 0x04
    22f2:	28 0f       	add	r18, r24
    22f4:	39 1f       	adc	r19, r25
    22f6:	80 91 7c 00 	lds	r24, 0x007C
    22fa:	90 91 7d 00 	lds	r25, 0x007D
    22fe:	82 17       	cp	r24, r18
    2300:	93 07       	cpc	r25, r19
    2302:	c0 f4       	brcc	.+48     	; 0x2334 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2304:	20 91 7e 00 	lds	r18, 0x007E
    2308:	30 91 7f 00 	lds	r19, 0x007F
    230c:	80 91 7c 00 	lds	r24, 0x007C
    2310:	90 91 7d 00 	lds	r25, 0x007D
    2314:	82 0f       	add	r24, r18
    2316:	93 1f       	adc	r25, r19
    2318:	9a 83       	std	Y+2, r25	; 0x02
    231a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    231c:	20 91 7c 00 	lds	r18, 0x007C
    2320:	30 91 7d 00 	lds	r19, 0x007D
    2324:	8b 81       	ldd	r24, Y+3	; 0x03
    2326:	9c 81       	ldd	r25, Y+4	; 0x04
    2328:	82 0f       	add	r24, r18
    232a:	93 1f       	adc	r25, r19
    232c:	90 93 7d 00 	sts	0x007D, r25
    2330:	80 93 7c 00 	sts	0x007C, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2334:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2338:	89 81       	ldd	r24, Y+1	; 0x01
    233a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    233c:	0f 90       	pop	r0
    233e:	0f 90       	pop	r0
    2340:	0f 90       	pop	r0
    2342:	0f 90       	pop	r0
    2344:	cf 91       	pop	r28
    2346:	df 91       	pop	r29
    2348:	08 95       	ret

0000234a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    234a:	df 93       	push	r29
    234c:	cf 93       	push	r28
    234e:	00 d0       	rcall	.+0      	; 0x2350 <vPortFree+0x6>
    2350:	cd b7       	in	r28, 0x3d	; 61
    2352:	de b7       	in	r29, 0x3e	; 62
    2354:	9a 83       	std	Y+2, r25	; 0x02
    2356:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2358:	0f 90       	pop	r0
    235a:	0f 90       	pop	r0
    235c:	cf 91       	pop	r28
    235e:	df 91       	pop	r29
    2360:	08 95       	ret

00002362 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2362:	df 93       	push	r29
    2364:	cf 93       	push	r28
    2366:	cd b7       	in	r28, 0x3d	; 61
    2368:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    236a:	10 92 7d 00 	sts	0x007D, r1
    236e:	10 92 7c 00 	sts	0x007C, r1
}
    2372:	cf 91       	pop	r28
    2374:	df 91       	pop	r29
    2376:	08 95       	ret

00002378 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2378:	df 93       	push	r29
    237a:	cf 93       	push	r28
    237c:	cd b7       	in	r28, 0x3d	; 61
    237e:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2380:	20 91 7c 00 	lds	r18, 0x007C
    2384:	30 91 7d 00 	lds	r19, 0x007D
    2388:	8b ed       	ldi	r24, 0xDB	; 219
    238a:	95 e0       	ldi	r25, 0x05	; 5
    238c:	82 1b       	sub	r24, r18
    238e:	93 0b       	sbc	r25, r19
}
    2390:	cf 91       	pop	r28
    2392:	df 91       	pop	r29
    2394:	08 95       	ret

00002396 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2396:	df 93       	push	r29
    2398:	cf 93       	push	r28
    239a:	00 d0       	rcall	.+0      	; 0x239c <vListInitialise+0x6>
    239c:	cd b7       	in	r28, 0x3d	; 61
    239e:	de b7       	in	r29, 0x3e	; 62
    23a0:	9a 83       	std	Y+2, r25	; 0x02
    23a2:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    23a4:	89 81       	ldd	r24, Y+1	; 0x01
    23a6:	9a 81       	ldd	r25, Y+2	; 0x02
    23a8:	03 96       	adiw	r24, 0x03	; 3
    23aa:	e9 81       	ldd	r30, Y+1	; 0x01
    23ac:	fa 81       	ldd	r31, Y+2	; 0x02
    23ae:	92 83       	std	Z+2, r25	; 0x02
    23b0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    23b2:	e9 81       	ldd	r30, Y+1	; 0x01
    23b4:	fa 81       	ldd	r31, Y+2	; 0x02
    23b6:	8f ef       	ldi	r24, 0xFF	; 255
    23b8:	9f ef       	ldi	r25, 0xFF	; 255
    23ba:	94 83       	std	Z+4, r25	; 0x04
    23bc:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    23be:	89 81       	ldd	r24, Y+1	; 0x01
    23c0:	9a 81       	ldd	r25, Y+2	; 0x02
    23c2:	03 96       	adiw	r24, 0x03	; 3
    23c4:	e9 81       	ldd	r30, Y+1	; 0x01
    23c6:	fa 81       	ldd	r31, Y+2	; 0x02
    23c8:	96 83       	std	Z+6, r25	; 0x06
    23ca:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    23cc:	89 81       	ldd	r24, Y+1	; 0x01
    23ce:	9a 81       	ldd	r25, Y+2	; 0x02
    23d0:	03 96       	adiw	r24, 0x03	; 3
    23d2:	e9 81       	ldd	r30, Y+1	; 0x01
    23d4:	fa 81       	ldd	r31, Y+2	; 0x02
    23d6:	90 87       	std	Z+8, r25	; 0x08
    23d8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    23da:	e9 81       	ldd	r30, Y+1	; 0x01
    23dc:	fa 81       	ldd	r31, Y+2	; 0x02
    23de:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    23e0:	0f 90       	pop	r0
    23e2:	0f 90       	pop	r0
    23e4:	cf 91       	pop	r28
    23e6:	df 91       	pop	r29
    23e8:	08 95       	ret

000023ea <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    23ea:	df 93       	push	r29
    23ec:	cf 93       	push	r28
    23ee:	00 d0       	rcall	.+0      	; 0x23f0 <vListInitialiseItem+0x6>
    23f0:	cd b7       	in	r28, 0x3d	; 61
    23f2:	de b7       	in	r29, 0x3e	; 62
    23f4:	9a 83       	std	Y+2, r25	; 0x02
    23f6:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    23f8:	e9 81       	ldd	r30, Y+1	; 0x01
    23fa:	fa 81       	ldd	r31, Y+2	; 0x02
    23fc:	11 86       	std	Z+9, r1	; 0x09
    23fe:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2400:	0f 90       	pop	r0
    2402:	0f 90       	pop	r0
    2404:	cf 91       	pop	r28
    2406:	df 91       	pop	r29
    2408:	08 95       	ret

0000240a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    240a:	df 93       	push	r29
    240c:	cf 93       	push	r28
    240e:	00 d0       	rcall	.+0      	; 0x2410 <vListInsertEnd+0x6>
    2410:	00 d0       	rcall	.+0      	; 0x2412 <vListInsertEnd+0x8>
    2412:	00 d0       	rcall	.+0      	; 0x2414 <vListInsertEnd+0xa>
    2414:	cd b7       	in	r28, 0x3d	; 61
    2416:	de b7       	in	r29, 0x3e	; 62
    2418:	9c 83       	std	Y+4, r25	; 0x04
    241a:	8b 83       	std	Y+3, r24	; 0x03
    241c:	7e 83       	std	Y+6, r23	; 0x06
    241e:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    2420:	eb 81       	ldd	r30, Y+3	; 0x03
    2422:	fc 81       	ldd	r31, Y+4	; 0x04
    2424:	81 81       	ldd	r24, Z+1	; 0x01
    2426:	92 81       	ldd	r25, Z+2	; 0x02
    2428:	9a 83       	std	Y+2, r25	; 0x02
    242a:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    242c:	ed 81       	ldd	r30, Y+5	; 0x05
    242e:	fe 81       	ldd	r31, Y+6	; 0x06
    2430:	89 81       	ldd	r24, Y+1	; 0x01
    2432:	9a 81       	ldd	r25, Y+2	; 0x02
    2434:	93 83       	std	Z+3, r25	; 0x03
    2436:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2438:	e9 81       	ldd	r30, Y+1	; 0x01
    243a:	fa 81       	ldd	r31, Y+2	; 0x02
    243c:	84 81       	ldd	r24, Z+4	; 0x04
    243e:	95 81       	ldd	r25, Z+5	; 0x05
    2440:	ed 81       	ldd	r30, Y+5	; 0x05
    2442:	fe 81       	ldd	r31, Y+6	; 0x06
    2444:	95 83       	std	Z+5, r25	; 0x05
    2446:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2448:	e9 81       	ldd	r30, Y+1	; 0x01
    244a:	fa 81       	ldd	r31, Y+2	; 0x02
    244c:	04 80       	ldd	r0, Z+4	; 0x04
    244e:	f5 81       	ldd	r31, Z+5	; 0x05
    2450:	e0 2d       	mov	r30, r0
    2452:	8d 81       	ldd	r24, Y+5	; 0x05
    2454:	9e 81       	ldd	r25, Y+6	; 0x06
    2456:	93 83       	std	Z+3, r25	; 0x03
    2458:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    245a:	e9 81       	ldd	r30, Y+1	; 0x01
    245c:	fa 81       	ldd	r31, Y+2	; 0x02
    245e:	8d 81       	ldd	r24, Y+5	; 0x05
    2460:	9e 81       	ldd	r25, Y+6	; 0x06
    2462:	95 83       	std	Z+5, r25	; 0x05
    2464:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2466:	ed 81       	ldd	r30, Y+5	; 0x05
    2468:	fe 81       	ldd	r31, Y+6	; 0x06
    246a:	8b 81       	ldd	r24, Y+3	; 0x03
    246c:	9c 81       	ldd	r25, Y+4	; 0x04
    246e:	91 87       	std	Z+9, r25	; 0x09
    2470:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2472:	eb 81       	ldd	r30, Y+3	; 0x03
    2474:	fc 81       	ldd	r31, Y+4	; 0x04
    2476:	80 81       	ld	r24, Z
    2478:	8f 5f       	subi	r24, 0xFF	; 255
    247a:	eb 81       	ldd	r30, Y+3	; 0x03
    247c:	fc 81       	ldd	r31, Y+4	; 0x04
    247e:	80 83       	st	Z, r24
}
    2480:	26 96       	adiw	r28, 0x06	; 6
    2482:	0f b6       	in	r0, 0x3f	; 63
    2484:	f8 94       	cli
    2486:	de bf       	out	0x3e, r29	; 62
    2488:	0f be       	out	0x3f, r0	; 63
    248a:	cd bf       	out	0x3d, r28	; 61
    248c:	cf 91       	pop	r28
    248e:	df 91       	pop	r29
    2490:	08 95       	ret

00002492 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2492:	df 93       	push	r29
    2494:	cf 93       	push	r28
    2496:	cd b7       	in	r28, 0x3d	; 61
    2498:	de b7       	in	r29, 0x3e	; 62
    249a:	28 97       	sbiw	r28, 0x08	; 8
    249c:	0f b6       	in	r0, 0x3f	; 63
    249e:	f8 94       	cli
    24a0:	de bf       	out	0x3e, r29	; 62
    24a2:	0f be       	out	0x3f, r0	; 63
    24a4:	cd bf       	out	0x3d, r28	; 61
    24a6:	9e 83       	std	Y+6, r25	; 0x06
    24a8:	8d 83       	std	Y+5, r24	; 0x05
    24aa:	78 87       	std	Y+8, r23	; 0x08
    24ac:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    24ae:	ef 81       	ldd	r30, Y+7	; 0x07
    24b0:	f8 85       	ldd	r31, Y+8	; 0x08
    24b2:	80 81       	ld	r24, Z
    24b4:	91 81       	ldd	r25, Z+1	; 0x01
    24b6:	9a 83       	std	Y+2, r25	; 0x02
    24b8:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    24ba:	89 81       	ldd	r24, Y+1	; 0x01
    24bc:	9a 81       	ldd	r25, Y+2	; 0x02
    24be:	2f ef       	ldi	r18, 0xFF	; 255
    24c0:	8f 3f       	cpi	r24, 0xFF	; 255
    24c2:	92 07       	cpc	r25, r18
    24c4:	39 f4       	brne	.+14     	; 0x24d4 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    24c6:	ed 81       	ldd	r30, Y+5	; 0x05
    24c8:	fe 81       	ldd	r31, Y+6	; 0x06
    24ca:	87 81       	ldd	r24, Z+7	; 0x07
    24cc:	90 85       	ldd	r25, Z+8	; 0x08
    24ce:	9c 83       	std	Y+4, r25	; 0x04
    24d0:	8b 83       	std	Y+3, r24	; 0x03
    24d2:	18 c0       	rjmp	.+48     	; 0x2504 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    24d4:	8d 81       	ldd	r24, Y+5	; 0x05
    24d6:	9e 81       	ldd	r25, Y+6	; 0x06
    24d8:	03 96       	adiw	r24, 0x03	; 3
    24da:	9c 83       	std	Y+4, r25	; 0x04
    24dc:	8b 83       	std	Y+3, r24	; 0x03
    24de:	06 c0       	rjmp	.+12     	; 0x24ec <vListInsert+0x5a>
    24e0:	eb 81       	ldd	r30, Y+3	; 0x03
    24e2:	fc 81       	ldd	r31, Y+4	; 0x04
    24e4:	82 81       	ldd	r24, Z+2	; 0x02
    24e6:	93 81       	ldd	r25, Z+3	; 0x03
    24e8:	9c 83       	std	Y+4, r25	; 0x04
    24ea:	8b 83       	std	Y+3, r24	; 0x03
    24ec:	eb 81       	ldd	r30, Y+3	; 0x03
    24ee:	fc 81       	ldd	r31, Y+4	; 0x04
    24f0:	02 80       	ldd	r0, Z+2	; 0x02
    24f2:	f3 81       	ldd	r31, Z+3	; 0x03
    24f4:	e0 2d       	mov	r30, r0
    24f6:	20 81       	ld	r18, Z
    24f8:	31 81       	ldd	r19, Z+1	; 0x01
    24fa:	89 81       	ldd	r24, Y+1	; 0x01
    24fc:	9a 81       	ldd	r25, Y+2	; 0x02
    24fe:	82 17       	cp	r24, r18
    2500:	93 07       	cpc	r25, r19
    2502:	70 f7       	brcc	.-36     	; 0x24e0 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2504:	eb 81       	ldd	r30, Y+3	; 0x03
    2506:	fc 81       	ldd	r31, Y+4	; 0x04
    2508:	82 81       	ldd	r24, Z+2	; 0x02
    250a:	93 81       	ldd	r25, Z+3	; 0x03
    250c:	ef 81       	ldd	r30, Y+7	; 0x07
    250e:	f8 85       	ldd	r31, Y+8	; 0x08
    2510:	93 83       	std	Z+3, r25	; 0x03
    2512:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2514:	ef 81       	ldd	r30, Y+7	; 0x07
    2516:	f8 85       	ldd	r31, Y+8	; 0x08
    2518:	02 80       	ldd	r0, Z+2	; 0x02
    251a:	f3 81       	ldd	r31, Z+3	; 0x03
    251c:	e0 2d       	mov	r30, r0
    251e:	8f 81       	ldd	r24, Y+7	; 0x07
    2520:	98 85       	ldd	r25, Y+8	; 0x08
    2522:	95 83       	std	Z+5, r25	; 0x05
    2524:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2526:	ef 81       	ldd	r30, Y+7	; 0x07
    2528:	f8 85       	ldd	r31, Y+8	; 0x08
    252a:	8b 81       	ldd	r24, Y+3	; 0x03
    252c:	9c 81       	ldd	r25, Y+4	; 0x04
    252e:	95 83       	std	Z+5, r25	; 0x05
    2530:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2532:	eb 81       	ldd	r30, Y+3	; 0x03
    2534:	fc 81       	ldd	r31, Y+4	; 0x04
    2536:	8f 81       	ldd	r24, Y+7	; 0x07
    2538:	98 85       	ldd	r25, Y+8	; 0x08
    253a:	93 83       	std	Z+3, r25	; 0x03
    253c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    253e:	ef 81       	ldd	r30, Y+7	; 0x07
    2540:	f8 85       	ldd	r31, Y+8	; 0x08
    2542:	8d 81       	ldd	r24, Y+5	; 0x05
    2544:	9e 81       	ldd	r25, Y+6	; 0x06
    2546:	91 87       	std	Z+9, r25	; 0x09
    2548:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    254a:	ed 81       	ldd	r30, Y+5	; 0x05
    254c:	fe 81       	ldd	r31, Y+6	; 0x06
    254e:	80 81       	ld	r24, Z
    2550:	8f 5f       	subi	r24, 0xFF	; 255
    2552:	ed 81       	ldd	r30, Y+5	; 0x05
    2554:	fe 81       	ldd	r31, Y+6	; 0x06
    2556:	80 83       	st	Z, r24
}
    2558:	28 96       	adiw	r28, 0x08	; 8
    255a:	0f b6       	in	r0, 0x3f	; 63
    255c:	f8 94       	cli
    255e:	de bf       	out	0x3e, r29	; 62
    2560:	0f be       	out	0x3f, r0	; 63
    2562:	cd bf       	out	0x3d, r28	; 61
    2564:	cf 91       	pop	r28
    2566:	df 91       	pop	r29
    2568:	08 95       	ret

0000256a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    256a:	df 93       	push	r29
    256c:	cf 93       	push	r28
    256e:	00 d0       	rcall	.+0      	; 0x2570 <uxListRemove+0x6>
    2570:	00 d0       	rcall	.+0      	; 0x2572 <uxListRemove+0x8>
    2572:	cd b7       	in	r28, 0x3d	; 61
    2574:	de b7       	in	r29, 0x3e	; 62
    2576:	9c 83       	std	Y+4, r25	; 0x04
    2578:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    257a:	eb 81       	ldd	r30, Y+3	; 0x03
    257c:	fc 81       	ldd	r31, Y+4	; 0x04
    257e:	80 85       	ldd	r24, Z+8	; 0x08
    2580:	91 85       	ldd	r25, Z+9	; 0x09
    2582:	9a 83       	std	Y+2, r25	; 0x02
    2584:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2586:	eb 81       	ldd	r30, Y+3	; 0x03
    2588:	fc 81       	ldd	r31, Y+4	; 0x04
    258a:	a2 81       	ldd	r26, Z+2	; 0x02
    258c:	b3 81       	ldd	r27, Z+3	; 0x03
    258e:	eb 81       	ldd	r30, Y+3	; 0x03
    2590:	fc 81       	ldd	r31, Y+4	; 0x04
    2592:	84 81       	ldd	r24, Z+4	; 0x04
    2594:	95 81       	ldd	r25, Z+5	; 0x05
    2596:	15 96       	adiw	r26, 0x05	; 5
    2598:	9c 93       	st	X, r25
    259a:	8e 93       	st	-X, r24
    259c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    259e:	eb 81       	ldd	r30, Y+3	; 0x03
    25a0:	fc 81       	ldd	r31, Y+4	; 0x04
    25a2:	a4 81       	ldd	r26, Z+4	; 0x04
    25a4:	b5 81       	ldd	r27, Z+5	; 0x05
    25a6:	eb 81       	ldd	r30, Y+3	; 0x03
    25a8:	fc 81       	ldd	r31, Y+4	; 0x04
    25aa:	82 81       	ldd	r24, Z+2	; 0x02
    25ac:	93 81       	ldd	r25, Z+3	; 0x03
    25ae:	13 96       	adiw	r26, 0x03	; 3
    25b0:	9c 93       	st	X, r25
    25b2:	8e 93       	st	-X, r24
    25b4:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    25b6:	e9 81       	ldd	r30, Y+1	; 0x01
    25b8:	fa 81       	ldd	r31, Y+2	; 0x02
    25ba:	21 81       	ldd	r18, Z+1	; 0x01
    25bc:	32 81       	ldd	r19, Z+2	; 0x02
    25be:	8b 81       	ldd	r24, Y+3	; 0x03
    25c0:	9c 81       	ldd	r25, Y+4	; 0x04
    25c2:	28 17       	cp	r18, r24
    25c4:	39 07       	cpc	r19, r25
    25c6:	41 f4       	brne	.+16     	; 0x25d8 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    25c8:	eb 81       	ldd	r30, Y+3	; 0x03
    25ca:	fc 81       	ldd	r31, Y+4	; 0x04
    25cc:	84 81       	ldd	r24, Z+4	; 0x04
    25ce:	95 81       	ldd	r25, Z+5	; 0x05
    25d0:	e9 81       	ldd	r30, Y+1	; 0x01
    25d2:	fa 81       	ldd	r31, Y+2	; 0x02
    25d4:	92 83       	std	Z+2, r25	; 0x02
    25d6:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    25d8:	eb 81       	ldd	r30, Y+3	; 0x03
    25da:	fc 81       	ldd	r31, Y+4	; 0x04
    25dc:	11 86       	std	Z+9, r1	; 0x09
    25de:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    25e0:	e9 81       	ldd	r30, Y+1	; 0x01
    25e2:	fa 81       	ldd	r31, Y+2	; 0x02
    25e4:	80 81       	ld	r24, Z
    25e6:	81 50       	subi	r24, 0x01	; 1
    25e8:	e9 81       	ldd	r30, Y+1	; 0x01
    25ea:	fa 81       	ldd	r31, Y+2	; 0x02
    25ec:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    25ee:	e9 81       	ldd	r30, Y+1	; 0x01
    25f0:	fa 81       	ldd	r31, Y+2	; 0x02
    25f2:	80 81       	ld	r24, Z
}
    25f4:	0f 90       	pop	r0
    25f6:	0f 90       	pop	r0
    25f8:	0f 90       	pop	r0
    25fa:	0f 90       	pop	r0
    25fc:	cf 91       	pop	r28
    25fe:	df 91       	pop	r29
    2600:	08 95       	ret

00002602 <main>:

/* Create Message Queue Handle */
xQueueHandle Buffer;

int main(void)
{
    2602:	ef 92       	push	r14
    2604:	ff 92       	push	r15
    2606:	0f 93       	push	r16
    2608:	df 93       	push	r29
    260a:	cf 93       	push	r28
    260c:	cd b7       	in	r28, 0x3d	; 61
    260e:	de b7       	in	r29, 0x3e	; 62
	/* Initialize LCD */
	Lcd_vidInit();
    2610:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <Lcd_vidInit>

	/* Initialize LCD */
	Keypad_vidInit();
    2614:	0e 94 27 09 	call	0x124e	; 0x124e <Keypad_vidInit>

	/* Create Message Queue  */
	Buffer = xQueueCreate( 6 , sizeof(u8) );
    2618:	86 e0       	ldi	r24, 0x06	; 6
    261a:	61 e0       	ldi	r22, 0x01	; 1
    261c:	40 e0       	ldi	r20, 0x00	; 0
    261e:	0e 94 11 17 	call	0x2e22	; 0x2e22 <xQueueGenericCreate>
    2622:	90 93 27 07 	sts	0x0727, r25
    2626:	80 93 26 07 	sts	0x0726, r24

	/* Create KeyPad Task */
	xTaskCreate( KeyPad_Task_Func , "TASK_1" , 200 , NULL , 3 , NULL);
    262a:	89 e4       	ldi	r24, 0x49	; 73
    262c:	93 e1       	ldi	r25, 0x13	; 19
    262e:	20 e6       	ldi	r18, 0x60	; 96
    2630:	30 e0       	ldi	r19, 0x00	; 0
    2632:	b9 01       	movw	r22, r18
    2634:	48 ec       	ldi	r20, 0xC8	; 200
    2636:	50 e0       	ldi	r21, 0x00	; 0
    2638:	20 e0       	ldi	r18, 0x00	; 0
    263a:	30 e0       	ldi	r19, 0x00	; 0
    263c:	03 e0       	ldi	r16, 0x03	; 3
    263e:	ee 24       	eor	r14, r14
    2640:	ff 24       	eor	r15, r15
    2642:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <xTaskCreate>

	/* Create LCD Task */
	xTaskCreate( LCD_Task_Func    , "TASK_2" , 200 , NULL , 2 , NULL);
    2646:	8d e7       	ldi	r24, 0x7D	; 125
    2648:	93 e1       	ldi	r25, 0x13	; 19
    264a:	27 e6       	ldi	r18, 0x67	; 103
    264c:	30 e0       	ldi	r19, 0x00	; 0
    264e:	b9 01       	movw	r22, r18
    2650:	48 ec       	ldi	r20, 0xC8	; 200
    2652:	50 e0       	ldi	r21, 0x00	; 0
    2654:	20 e0       	ldi	r18, 0x00	; 0
    2656:	30 e0       	ldi	r19, 0x00	; 0
    2658:	02 e0       	ldi	r16, 0x02	; 2
    265a:	ee 24       	eor	r14, r14
    265c:	ff 24       	eor	r15, r15
    265e:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <xTaskCreate>

	/* Create Read LCD Queue Task */
	xTaskCreate( LCD_QUEU_Func    , "TASK_3" , 200 , NULL , 1 , NULL);
    2662:	8d e9       	ldi	r24, 0x9D	; 157
    2664:	93 e1       	ldi	r25, 0x13	; 19
    2666:	2e e6       	ldi	r18, 0x6E	; 110
    2668:	30 e0       	ldi	r19, 0x00	; 0
    266a:	b9 01       	movw	r22, r18
    266c:	48 ec       	ldi	r20, 0xC8	; 200
    266e:	50 e0       	ldi	r21, 0x00	; 0
    2670:	20 e0       	ldi	r18, 0x00	; 0
    2672:	30 e0       	ldi	r19, 0x00	; 0
    2674:	01 e0       	ldi	r16, 0x01	; 1
    2676:	ee 24       	eor	r14, r14
    2678:	ff 24       	eor	r15, r15
    267a:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <xTaskCreate>


	/*  Start Scheduler */
	vTaskStartScheduler();
    267e:	0e 94 80 29 	call	0x5300	; 0x5300 <vTaskStartScheduler>

	return 0;
    2682:	80 e0       	ldi	r24, 0x00	; 0
    2684:	90 e0       	ldi	r25, 0x00	; 0
}
    2686:	cf 91       	pop	r28
    2688:	df 91       	pop	r29
    268a:	0f 91       	pop	r16
    268c:	ff 90       	pop	r15
    268e:	ef 90       	pop	r14
    2690:	08 95       	ret

00002692 <KeyPad_Task_Func>:



void KeyPad_Task_Func( void * pvParamter )
{
    2692:	df 93       	push	r29
    2694:	cf 93       	push	r28
    2696:	00 d0       	rcall	.+0      	; 0x2698 <KeyPad_Task_Func+0x6>
    2698:	0f 92       	push	r0
    269a:	cd b7       	in	r28, 0x3d	; 61
    269c:	de b7       	in	r29, 0x3e	; 62
    269e:	9b 83       	std	Y+3, r25	; 0x03
    26a0:	8a 83       	std	Y+2, r24	; 0x02
	u8 Key;

	while(1)
	{
		Key = Keypad_u8GetKey();
    26a2:	0e 94 6e 09 	call	0x12dc	; 0x12dc <Keypad_u8GetKey>
    26a6:	89 83       	std	Y+1, r24	; 0x01

		if( Key != KEYPAD_u8NO_KEY )
    26a8:	89 81       	ldd	r24, Y+1	; 0x01
    26aa:	8f 3f       	cpi	r24, 0xFF	; 255
    26ac:	09 f1       	breq	.+66     	; 0x26f0 <KeyPad_Task_Func+0x5e>
		{
			if( (Key >= 0) && (Key <= 9) )
    26ae:	89 81       	ldd	r24, Y+1	; 0x01
    26b0:	8a 30       	cpi	r24, 0x0A	; 10
    26b2:	88 f4       	brcc	.+34     	; 0x26d6 <KeyPad_Task_Func+0x44>
			{
				Key = Key + '0';
    26b4:	89 81       	ldd	r24, Y+1	; 0x01
    26b6:	80 5d       	subi	r24, 0xD0	; 208
    26b8:	89 83       	std	Y+1, r24	; 0x01
				/* Send Key To RTOS Queue */
				xQueueSend( Buffer , &Key , portMAX_DELAY );
    26ba:	80 91 26 07 	lds	r24, 0x0726
    26be:	90 91 27 07 	lds	r25, 0x0727
    26c2:	9e 01       	movw	r18, r28
    26c4:	2f 5f       	subi	r18, 0xFF	; 255
    26c6:	3f 4f       	sbci	r19, 0xFF	; 255
    26c8:	b9 01       	movw	r22, r18
    26ca:	4f ef       	ldi	r20, 0xFF	; 255
    26cc:	5f ef       	ldi	r21, 0xFF	; 255
    26ce:	20 e0       	ldi	r18, 0x00	; 0
    26d0:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <xQueueGenericSend>
    26d4:	0d c0       	rjmp	.+26     	; 0x26f0 <KeyPad_Task_Func+0x5e>
			}
			else
			{
				/* Send Key To RTOS Queue */
				xQueueSend( Buffer , &Key , portMAX_DELAY );
    26d6:	80 91 26 07 	lds	r24, 0x0726
    26da:	90 91 27 07 	lds	r25, 0x0727
    26de:	9e 01       	movw	r18, r28
    26e0:	2f 5f       	subi	r18, 0xFF	; 255
    26e2:	3f 4f       	sbci	r19, 0xFF	; 255
    26e4:	b9 01       	movw	r22, r18
    26e6:	4f ef       	ldi	r20, 0xFF	; 255
    26e8:	5f ef       	ldi	r21, 0xFF	; 255
    26ea:	20 e0       	ldi	r18, 0x00	; 0
    26ec:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <xQueueGenericSend>
			}

		}

		/* Delay to make Task Periodic Every 150msec */
		vTaskDelay(150);
    26f0:	86 e9       	ldi	r24, 0x96	; 150
    26f2:	90 e0       	ldi	r25, 0x00	; 0
    26f4:	0e 94 f1 27 	call	0x4fe2	; 0x4fe2 <vTaskDelay>
    26f8:	d4 cf       	rjmp	.-88     	; 0x26a2 <KeyPad_Task_Func+0x10>

000026fa <LCD_Task_Func>:

}


void LCD_Task_Func( void * pvParamter )
{
    26fa:	df 93       	push	r29
    26fc:	cf 93       	push	r28
    26fe:	00 d0       	rcall	.+0      	; 0x2700 <LCD_Task_Func+0x6>
    2700:	00 d0       	rcall	.+0      	; 0x2702 <LCD_Task_Func+0x8>
    2702:	cd b7       	in	r28, 0x3d	; 61
    2704:	de b7       	in	r29, 0x3e	; 62
    2706:	9c 83       	std	Y+4, r25	; 0x04
    2708:	8b 83       	std	Y+3, r24	; 0x03
	u8 Key;

	while(1)
	{
		/* Receive data From RTOS Queue and save it in Key Variable */
		Ret = xQueueReceive( Buffer , &Key , portMAX_DELAY );
    270a:	80 91 26 07 	lds	r24, 0x0726
    270e:	90 91 27 07 	lds	r25, 0x0727
    2712:	9e 01       	movw	r18, r28
    2714:	2e 5f       	subi	r18, 0xFE	; 254
    2716:	3f 4f       	sbci	r19, 0xFF	; 255
    2718:	b9 01       	movw	r22, r18
    271a:	4f ef       	ldi	r20, 0xFF	; 255
    271c:	5f ef       	ldi	r21, 0xFF	; 255
    271e:	0e 94 12 19 	call	0x3224	; 0x3224 <xQueueReceive>
    2722:	89 83       	std	Y+1, r24	; 0x01

		if( Ret == pdTRUE)
    2724:	89 81       	ldd	r24, Y+1	; 0x01
    2726:	81 30       	cpi	r24, 0x01	; 1
    2728:	19 f4       	brne	.+6      	; 0x2730 <LCD_Task_Func+0x36>
		{
			Lcd_vidQueueChar( Key );
    272a:	8a 81       	ldd	r24, Y+2	; 0x02
    272c:	0e 94 fa 0c 	call	0x19f4	; 0x19f4 <Lcd_vidQueueChar>
		}

		/* Delay to make Task Periodic Every 50msec */
		vTaskDelay(50);
    2730:	82 e3       	ldi	r24, 0x32	; 50
    2732:	90 e0       	ldi	r25, 0x00	; 0
    2734:	0e 94 f1 27 	call	0x4fe2	; 0x4fe2 <vTaskDelay>
    2738:	e8 cf       	rjmp	.-48     	; 0x270a <LCD_Task_Func+0x10>

0000273a <LCD_QUEU_Func>:
	}

}

void LCD_QUEU_Func( void * pvParamter )
{
    273a:	df 93       	push	r29
    273c:	cf 93       	push	r28
    273e:	00 d0       	rcall	.+0      	; 0x2740 <LCD_QUEU_Func+0x6>
    2740:	0f 92       	push	r0
    2742:	cd b7       	in	r28, 0x3d	; 61
    2744:	de b7       	in	r29, 0x3e	; 62
    2746:	9b 83       	std	Y+3, r25	; 0x03
    2748:	8a 83       	std	Y+2, r24	; 0x02
	u8 RetVar;

	while(1)
	{
		Lcd_vidDisableTrigger();
    274a:	0e 94 ef 0c 	call	0x19de	; 0x19de <Lcd_vidDisableTrigger>

		/* Read LCD Queue */
		RetVar = Lcd_u8ReadQueue();
    274e:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <Lcd_u8ReadQueue>
    2752:	89 83       	std	Y+1, r24	; 0x01

		/* Check LCD Queue To Read All Element In Queue */
		if(RetVar != LCD_QUEUE_NULL)
    2754:	89 81       	ldd	r24, Y+1	; 0x01
    2756:	8f 3f       	cpi	r24, 0xFF	; 255
    2758:	39 f0       	breq	.+14     	; 0x2768 <LCD_QUEU_Func+0x2e>
		{
			/* Wait 2msec To Trigger*/
			vTaskDelay(2);
    275a:	82 e0       	ldi	r24, 0x02	; 2
    275c:	90 e0       	ldi	r25, 0x00	; 0
    275e:	0e 94 f1 27 	call	0x4fe2	; 0x4fe2 <vTaskDelay>

			/* Enable Trigger */
			Lcd_vidEnableTrigger();
    2762:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <Lcd_vidEnableTrigger>
    2766:	f1 cf       	rjmp	.-30     	; 0x274a <LCD_QUEU_Func+0x10>
		}
		else
		{
			Lcd_vidDisableTrigger();
    2768:	0e 94 ef 0c 	call	0x19de	; 0x19de <Lcd_vidDisableTrigger>
    276c:	ee cf       	rjmp	.-36     	; 0x274a <LCD_QUEU_Func+0x10>

0000276e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    276e:	df 93       	push	r29
    2770:	cf 93       	push	r28
    2772:	cd b7       	in	r28, 0x3d	; 61
    2774:	de b7       	in	r29, 0x3e	; 62
    2776:	28 97       	sbiw	r28, 0x08	; 8
    2778:	0f b6       	in	r0, 0x3f	; 63
    277a:	f8 94       	cli
    277c:	de bf       	out	0x3e, r29	; 62
    277e:	0f be       	out	0x3f, r0	; 63
    2780:	cd bf       	out	0x3d, r28	; 61
    2782:	9c 83       	std	Y+4, r25	; 0x04
    2784:	8b 83       	std	Y+3, r24	; 0x03
    2786:	7e 83       	std	Y+6, r23	; 0x06
    2788:	6d 83       	std	Y+5, r22	; 0x05
    278a:	58 87       	std	Y+8, r21	; 0x08
    278c:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    278e:	eb 81       	ldd	r30, Y+3	; 0x03
    2790:	fc 81       	ldd	r31, Y+4	; 0x04
    2792:	81 e1       	ldi	r24, 0x11	; 17
    2794:	80 83       	st	Z, r24
	pxTopOfStack--;
    2796:	8b 81       	ldd	r24, Y+3	; 0x03
    2798:	9c 81       	ldd	r25, Y+4	; 0x04
    279a:	01 97       	sbiw	r24, 0x01	; 1
    279c:	9c 83       	std	Y+4, r25	; 0x04
    279e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    27a0:	eb 81       	ldd	r30, Y+3	; 0x03
    27a2:	fc 81       	ldd	r31, Y+4	; 0x04
    27a4:	82 e2       	ldi	r24, 0x22	; 34
    27a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    27a8:	8b 81       	ldd	r24, Y+3	; 0x03
    27aa:	9c 81       	ldd	r25, Y+4	; 0x04
    27ac:	01 97       	sbiw	r24, 0x01	; 1
    27ae:	9c 83       	std	Y+4, r25	; 0x04
    27b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    27b2:	eb 81       	ldd	r30, Y+3	; 0x03
    27b4:	fc 81       	ldd	r31, Y+4	; 0x04
    27b6:	83 e3       	ldi	r24, 0x33	; 51
    27b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    27ba:	8b 81       	ldd	r24, Y+3	; 0x03
    27bc:	9c 81       	ldd	r25, Y+4	; 0x04
    27be:	01 97       	sbiw	r24, 0x01	; 1
    27c0:	9c 83       	std	Y+4, r25	; 0x04
    27c2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    27c4:	8d 81       	ldd	r24, Y+5	; 0x05
    27c6:	9e 81       	ldd	r25, Y+6	; 0x06
    27c8:	9a 83       	std	Y+2, r25	; 0x02
    27ca:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    27cc:	89 81       	ldd	r24, Y+1	; 0x01
    27ce:	eb 81       	ldd	r30, Y+3	; 0x03
    27d0:	fc 81       	ldd	r31, Y+4	; 0x04
    27d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    27d4:	8b 81       	ldd	r24, Y+3	; 0x03
    27d6:	9c 81       	ldd	r25, Y+4	; 0x04
    27d8:	01 97       	sbiw	r24, 0x01	; 1
    27da:	9c 83       	std	Y+4, r25	; 0x04
    27dc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    27de:	89 81       	ldd	r24, Y+1	; 0x01
    27e0:	9a 81       	ldd	r25, Y+2	; 0x02
    27e2:	89 2f       	mov	r24, r25
    27e4:	99 27       	eor	r25, r25
    27e6:	9a 83       	std	Y+2, r25	; 0x02
    27e8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    27ea:	89 81       	ldd	r24, Y+1	; 0x01
    27ec:	eb 81       	ldd	r30, Y+3	; 0x03
    27ee:	fc 81       	ldd	r31, Y+4	; 0x04
    27f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    27f2:	8b 81       	ldd	r24, Y+3	; 0x03
    27f4:	9c 81       	ldd	r25, Y+4	; 0x04
    27f6:	01 97       	sbiw	r24, 0x01	; 1
    27f8:	9c 83       	std	Y+4, r25	; 0x04
    27fa:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    27fc:	eb 81       	ldd	r30, Y+3	; 0x03
    27fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2800:	10 82       	st	Z, r1
	pxTopOfStack--;
    2802:	8b 81       	ldd	r24, Y+3	; 0x03
    2804:	9c 81       	ldd	r25, Y+4	; 0x04
    2806:	01 97       	sbiw	r24, 0x01	; 1
    2808:	9c 83       	std	Y+4, r25	; 0x04
    280a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    280c:	eb 81       	ldd	r30, Y+3	; 0x03
    280e:	fc 81       	ldd	r31, Y+4	; 0x04
    2810:	80 e8       	ldi	r24, 0x80	; 128
    2812:	80 83       	st	Z, r24
	pxTopOfStack--;
    2814:	8b 81       	ldd	r24, Y+3	; 0x03
    2816:	9c 81       	ldd	r25, Y+4	; 0x04
    2818:	01 97       	sbiw	r24, 0x01	; 1
    281a:	9c 83       	std	Y+4, r25	; 0x04
    281c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    281e:	eb 81       	ldd	r30, Y+3	; 0x03
    2820:	fc 81       	ldd	r31, Y+4	; 0x04
    2822:	10 82       	st	Z, r1
	pxTopOfStack--;
    2824:	8b 81       	ldd	r24, Y+3	; 0x03
    2826:	9c 81       	ldd	r25, Y+4	; 0x04
    2828:	01 97       	sbiw	r24, 0x01	; 1
    282a:	9c 83       	std	Y+4, r25	; 0x04
    282c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    282e:	eb 81       	ldd	r30, Y+3	; 0x03
    2830:	fc 81       	ldd	r31, Y+4	; 0x04
    2832:	82 e0       	ldi	r24, 0x02	; 2
    2834:	80 83       	st	Z, r24
	pxTopOfStack--;
    2836:	8b 81       	ldd	r24, Y+3	; 0x03
    2838:	9c 81       	ldd	r25, Y+4	; 0x04
    283a:	01 97       	sbiw	r24, 0x01	; 1
    283c:	9c 83       	std	Y+4, r25	; 0x04
    283e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2840:	eb 81       	ldd	r30, Y+3	; 0x03
    2842:	fc 81       	ldd	r31, Y+4	; 0x04
    2844:	83 e0       	ldi	r24, 0x03	; 3
    2846:	80 83       	st	Z, r24
	pxTopOfStack--;
    2848:	8b 81       	ldd	r24, Y+3	; 0x03
    284a:	9c 81       	ldd	r25, Y+4	; 0x04
    284c:	01 97       	sbiw	r24, 0x01	; 1
    284e:	9c 83       	std	Y+4, r25	; 0x04
    2850:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2852:	eb 81       	ldd	r30, Y+3	; 0x03
    2854:	fc 81       	ldd	r31, Y+4	; 0x04
    2856:	84 e0       	ldi	r24, 0x04	; 4
    2858:	80 83       	st	Z, r24
	pxTopOfStack--;
    285a:	8b 81       	ldd	r24, Y+3	; 0x03
    285c:	9c 81       	ldd	r25, Y+4	; 0x04
    285e:	01 97       	sbiw	r24, 0x01	; 1
    2860:	9c 83       	std	Y+4, r25	; 0x04
    2862:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2864:	eb 81       	ldd	r30, Y+3	; 0x03
    2866:	fc 81       	ldd	r31, Y+4	; 0x04
    2868:	85 e0       	ldi	r24, 0x05	; 5
    286a:	80 83       	st	Z, r24
	pxTopOfStack--;
    286c:	8b 81       	ldd	r24, Y+3	; 0x03
    286e:	9c 81       	ldd	r25, Y+4	; 0x04
    2870:	01 97       	sbiw	r24, 0x01	; 1
    2872:	9c 83       	std	Y+4, r25	; 0x04
    2874:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2876:	eb 81       	ldd	r30, Y+3	; 0x03
    2878:	fc 81       	ldd	r31, Y+4	; 0x04
    287a:	86 e0       	ldi	r24, 0x06	; 6
    287c:	80 83       	st	Z, r24
	pxTopOfStack--;
    287e:	8b 81       	ldd	r24, Y+3	; 0x03
    2880:	9c 81       	ldd	r25, Y+4	; 0x04
    2882:	01 97       	sbiw	r24, 0x01	; 1
    2884:	9c 83       	std	Y+4, r25	; 0x04
    2886:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2888:	eb 81       	ldd	r30, Y+3	; 0x03
    288a:	fc 81       	ldd	r31, Y+4	; 0x04
    288c:	87 e0       	ldi	r24, 0x07	; 7
    288e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2890:	8b 81       	ldd	r24, Y+3	; 0x03
    2892:	9c 81       	ldd	r25, Y+4	; 0x04
    2894:	01 97       	sbiw	r24, 0x01	; 1
    2896:	9c 83       	std	Y+4, r25	; 0x04
    2898:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    289a:	eb 81       	ldd	r30, Y+3	; 0x03
    289c:	fc 81       	ldd	r31, Y+4	; 0x04
    289e:	88 e0       	ldi	r24, 0x08	; 8
    28a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    28a2:	8b 81       	ldd	r24, Y+3	; 0x03
    28a4:	9c 81       	ldd	r25, Y+4	; 0x04
    28a6:	01 97       	sbiw	r24, 0x01	; 1
    28a8:	9c 83       	std	Y+4, r25	; 0x04
    28aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    28ac:	eb 81       	ldd	r30, Y+3	; 0x03
    28ae:	fc 81       	ldd	r31, Y+4	; 0x04
    28b0:	89 e0       	ldi	r24, 0x09	; 9
    28b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    28b4:	8b 81       	ldd	r24, Y+3	; 0x03
    28b6:	9c 81       	ldd	r25, Y+4	; 0x04
    28b8:	01 97       	sbiw	r24, 0x01	; 1
    28ba:	9c 83       	std	Y+4, r25	; 0x04
    28bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    28be:	eb 81       	ldd	r30, Y+3	; 0x03
    28c0:	fc 81       	ldd	r31, Y+4	; 0x04
    28c2:	80 e1       	ldi	r24, 0x10	; 16
    28c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    28c6:	8b 81       	ldd	r24, Y+3	; 0x03
    28c8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ca:	01 97       	sbiw	r24, 0x01	; 1
    28cc:	9c 83       	std	Y+4, r25	; 0x04
    28ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    28d0:	eb 81       	ldd	r30, Y+3	; 0x03
    28d2:	fc 81       	ldd	r31, Y+4	; 0x04
    28d4:	81 e1       	ldi	r24, 0x11	; 17
    28d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    28d8:	8b 81       	ldd	r24, Y+3	; 0x03
    28da:	9c 81       	ldd	r25, Y+4	; 0x04
    28dc:	01 97       	sbiw	r24, 0x01	; 1
    28de:	9c 83       	std	Y+4, r25	; 0x04
    28e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    28e2:	eb 81       	ldd	r30, Y+3	; 0x03
    28e4:	fc 81       	ldd	r31, Y+4	; 0x04
    28e6:	82 e1       	ldi	r24, 0x12	; 18
    28e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    28ea:	8b 81       	ldd	r24, Y+3	; 0x03
    28ec:	9c 81       	ldd	r25, Y+4	; 0x04
    28ee:	01 97       	sbiw	r24, 0x01	; 1
    28f0:	9c 83       	std	Y+4, r25	; 0x04
    28f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    28f4:	eb 81       	ldd	r30, Y+3	; 0x03
    28f6:	fc 81       	ldd	r31, Y+4	; 0x04
    28f8:	83 e1       	ldi	r24, 0x13	; 19
    28fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    28fc:	8b 81       	ldd	r24, Y+3	; 0x03
    28fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2900:	01 97       	sbiw	r24, 0x01	; 1
    2902:	9c 83       	std	Y+4, r25	; 0x04
    2904:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2906:	eb 81       	ldd	r30, Y+3	; 0x03
    2908:	fc 81       	ldd	r31, Y+4	; 0x04
    290a:	84 e1       	ldi	r24, 0x14	; 20
    290c:	80 83       	st	Z, r24
	pxTopOfStack--;
    290e:	8b 81       	ldd	r24, Y+3	; 0x03
    2910:	9c 81       	ldd	r25, Y+4	; 0x04
    2912:	01 97       	sbiw	r24, 0x01	; 1
    2914:	9c 83       	std	Y+4, r25	; 0x04
    2916:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2918:	eb 81       	ldd	r30, Y+3	; 0x03
    291a:	fc 81       	ldd	r31, Y+4	; 0x04
    291c:	85 e1       	ldi	r24, 0x15	; 21
    291e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2920:	8b 81       	ldd	r24, Y+3	; 0x03
    2922:	9c 81       	ldd	r25, Y+4	; 0x04
    2924:	01 97       	sbiw	r24, 0x01	; 1
    2926:	9c 83       	std	Y+4, r25	; 0x04
    2928:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    292a:	eb 81       	ldd	r30, Y+3	; 0x03
    292c:	fc 81       	ldd	r31, Y+4	; 0x04
    292e:	86 e1       	ldi	r24, 0x16	; 22
    2930:	80 83       	st	Z, r24
	pxTopOfStack--;
    2932:	8b 81       	ldd	r24, Y+3	; 0x03
    2934:	9c 81       	ldd	r25, Y+4	; 0x04
    2936:	01 97       	sbiw	r24, 0x01	; 1
    2938:	9c 83       	std	Y+4, r25	; 0x04
    293a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    293c:	eb 81       	ldd	r30, Y+3	; 0x03
    293e:	fc 81       	ldd	r31, Y+4	; 0x04
    2940:	87 e1       	ldi	r24, 0x17	; 23
    2942:	80 83       	st	Z, r24
	pxTopOfStack--;
    2944:	8b 81       	ldd	r24, Y+3	; 0x03
    2946:	9c 81       	ldd	r25, Y+4	; 0x04
    2948:	01 97       	sbiw	r24, 0x01	; 1
    294a:	9c 83       	std	Y+4, r25	; 0x04
    294c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    294e:	eb 81       	ldd	r30, Y+3	; 0x03
    2950:	fc 81       	ldd	r31, Y+4	; 0x04
    2952:	88 e1       	ldi	r24, 0x18	; 24
    2954:	80 83       	st	Z, r24
	pxTopOfStack--;
    2956:	8b 81       	ldd	r24, Y+3	; 0x03
    2958:	9c 81       	ldd	r25, Y+4	; 0x04
    295a:	01 97       	sbiw	r24, 0x01	; 1
    295c:	9c 83       	std	Y+4, r25	; 0x04
    295e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2960:	eb 81       	ldd	r30, Y+3	; 0x03
    2962:	fc 81       	ldd	r31, Y+4	; 0x04
    2964:	89 e1       	ldi	r24, 0x19	; 25
    2966:	80 83       	st	Z, r24
	pxTopOfStack--;
    2968:	8b 81       	ldd	r24, Y+3	; 0x03
    296a:	9c 81       	ldd	r25, Y+4	; 0x04
    296c:	01 97       	sbiw	r24, 0x01	; 1
    296e:	9c 83       	std	Y+4, r25	; 0x04
    2970:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2972:	eb 81       	ldd	r30, Y+3	; 0x03
    2974:	fc 81       	ldd	r31, Y+4	; 0x04
    2976:	80 e2       	ldi	r24, 0x20	; 32
    2978:	80 83       	st	Z, r24
	pxTopOfStack--;
    297a:	8b 81       	ldd	r24, Y+3	; 0x03
    297c:	9c 81       	ldd	r25, Y+4	; 0x04
    297e:	01 97       	sbiw	r24, 0x01	; 1
    2980:	9c 83       	std	Y+4, r25	; 0x04
    2982:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2984:	eb 81       	ldd	r30, Y+3	; 0x03
    2986:	fc 81       	ldd	r31, Y+4	; 0x04
    2988:	81 e2       	ldi	r24, 0x21	; 33
    298a:	80 83       	st	Z, r24
	pxTopOfStack--;
    298c:	8b 81       	ldd	r24, Y+3	; 0x03
    298e:	9c 81       	ldd	r25, Y+4	; 0x04
    2990:	01 97       	sbiw	r24, 0x01	; 1
    2992:	9c 83       	std	Y+4, r25	; 0x04
    2994:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2996:	eb 81       	ldd	r30, Y+3	; 0x03
    2998:	fc 81       	ldd	r31, Y+4	; 0x04
    299a:	82 e2       	ldi	r24, 0x22	; 34
    299c:	80 83       	st	Z, r24
	pxTopOfStack--;
    299e:	8b 81       	ldd	r24, Y+3	; 0x03
    29a0:	9c 81       	ldd	r25, Y+4	; 0x04
    29a2:	01 97       	sbiw	r24, 0x01	; 1
    29a4:	9c 83       	std	Y+4, r25	; 0x04
    29a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    29a8:	eb 81       	ldd	r30, Y+3	; 0x03
    29aa:	fc 81       	ldd	r31, Y+4	; 0x04
    29ac:	83 e2       	ldi	r24, 0x23	; 35
    29ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    29b0:	8b 81       	ldd	r24, Y+3	; 0x03
    29b2:	9c 81       	ldd	r25, Y+4	; 0x04
    29b4:	01 97       	sbiw	r24, 0x01	; 1
    29b6:	9c 83       	std	Y+4, r25	; 0x04
    29b8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    29ba:	8f 81       	ldd	r24, Y+7	; 0x07
    29bc:	98 85       	ldd	r25, Y+8	; 0x08
    29be:	9a 83       	std	Y+2, r25	; 0x02
    29c0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    29c2:	89 81       	ldd	r24, Y+1	; 0x01
    29c4:	eb 81       	ldd	r30, Y+3	; 0x03
    29c6:	fc 81       	ldd	r31, Y+4	; 0x04
    29c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    29ca:	8b 81       	ldd	r24, Y+3	; 0x03
    29cc:	9c 81       	ldd	r25, Y+4	; 0x04
    29ce:	01 97       	sbiw	r24, 0x01	; 1
    29d0:	9c 83       	std	Y+4, r25	; 0x04
    29d2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    29d4:	89 81       	ldd	r24, Y+1	; 0x01
    29d6:	9a 81       	ldd	r25, Y+2	; 0x02
    29d8:	89 2f       	mov	r24, r25
    29da:	99 27       	eor	r25, r25
    29dc:	9a 83       	std	Y+2, r25	; 0x02
    29de:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    29e0:	89 81       	ldd	r24, Y+1	; 0x01
    29e2:	eb 81       	ldd	r30, Y+3	; 0x03
    29e4:	fc 81       	ldd	r31, Y+4	; 0x04
    29e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    29e8:	8b 81       	ldd	r24, Y+3	; 0x03
    29ea:	9c 81       	ldd	r25, Y+4	; 0x04
    29ec:	01 97       	sbiw	r24, 0x01	; 1
    29ee:	9c 83       	std	Y+4, r25	; 0x04
    29f0:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    29f2:	eb 81       	ldd	r30, Y+3	; 0x03
    29f4:	fc 81       	ldd	r31, Y+4	; 0x04
    29f6:	86 e2       	ldi	r24, 0x26	; 38
    29f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    29fa:	8b 81       	ldd	r24, Y+3	; 0x03
    29fc:	9c 81       	ldd	r25, Y+4	; 0x04
    29fe:	01 97       	sbiw	r24, 0x01	; 1
    2a00:	9c 83       	std	Y+4, r25	; 0x04
    2a02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2a04:	eb 81       	ldd	r30, Y+3	; 0x03
    2a06:	fc 81       	ldd	r31, Y+4	; 0x04
    2a08:	87 e2       	ldi	r24, 0x27	; 39
    2a0a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a10:	01 97       	sbiw	r24, 0x01	; 1
    2a12:	9c 83       	std	Y+4, r25	; 0x04
    2a14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2a16:	eb 81       	ldd	r30, Y+3	; 0x03
    2a18:	fc 81       	ldd	r31, Y+4	; 0x04
    2a1a:	88 e2       	ldi	r24, 0x28	; 40
    2a1c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a20:	9c 81       	ldd	r25, Y+4	; 0x04
    2a22:	01 97       	sbiw	r24, 0x01	; 1
    2a24:	9c 83       	std	Y+4, r25	; 0x04
    2a26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2a28:	eb 81       	ldd	r30, Y+3	; 0x03
    2a2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a2c:	89 e2       	ldi	r24, 0x29	; 41
    2a2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a30:	8b 81       	ldd	r24, Y+3	; 0x03
    2a32:	9c 81       	ldd	r25, Y+4	; 0x04
    2a34:	01 97       	sbiw	r24, 0x01	; 1
    2a36:	9c 83       	std	Y+4, r25	; 0x04
    2a38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2a3a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a3c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a3e:	80 e3       	ldi	r24, 0x30	; 48
    2a40:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a42:	8b 81       	ldd	r24, Y+3	; 0x03
    2a44:	9c 81       	ldd	r25, Y+4	; 0x04
    2a46:	01 97       	sbiw	r24, 0x01	; 1
    2a48:	9c 83       	std	Y+4, r25	; 0x04
    2a4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2a4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a50:	81 e3       	ldi	r24, 0x31	; 49
    2a52:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a54:	8b 81       	ldd	r24, Y+3	; 0x03
    2a56:	9c 81       	ldd	r25, Y+4	; 0x04
    2a58:	01 97       	sbiw	r24, 0x01	; 1
    2a5a:	9c 83       	std	Y+4, r25	; 0x04
    2a5c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a60:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2a62:	28 96       	adiw	r28, 0x08	; 8
    2a64:	0f b6       	in	r0, 0x3f	; 63
    2a66:	f8 94       	cli
    2a68:	de bf       	out	0x3e, r29	; 62
    2a6a:	0f be       	out	0x3f, r0	; 63
    2a6c:	cd bf       	out	0x3d, r28	; 61
    2a6e:	cf 91       	pop	r28
    2a70:	df 91       	pop	r29
    2a72:	08 95       	ret

00002a74 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2a74:	df 93       	push	r29
    2a76:	cf 93       	push	r28
    2a78:	cd b7       	in	r28, 0x3d	; 61
    2a7a:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2a7c:	0e 94 2c 16 	call	0x2c58	; 0x2c58 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2a80:	a0 91 5c 06 	lds	r26, 0x065C
    2a84:	b0 91 5d 06 	lds	r27, 0x065D
    2a88:	cd 91       	ld	r28, X+
    2a8a:	cd bf       	out	0x3d, r28	; 61
    2a8c:	dd 91       	ld	r29, X+
    2a8e:	de bf       	out	0x3e, r29	; 62
    2a90:	ff 91       	pop	r31
    2a92:	ef 91       	pop	r30
    2a94:	df 91       	pop	r29
    2a96:	cf 91       	pop	r28
    2a98:	bf 91       	pop	r27
    2a9a:	af 91       	pop	r26
    2a9c:	9f 91       	pop	r25
    2a9e:	8f 91       	pop	r24
    2aa0:	7f 91       	pop	r23
    2aa2:	6f 91       	pop	r22
    2aa4:	5f 91       	pop	r21
    2aa6:	4f 91       	pop	r20
    2aa8:	3f 91       	pop	r19
    2aaa:	2f 91       	pop	r18
    2aac:	1f 91       	pop	r17
    2aae:	0f 91       	pop	r16
    2ab0:	ff 90       	pop	r15
    2ab2:	ef 90       	pop	r14
    2ab4:	df 90       	pop	r13
    2ab6:	cf 90       	pop	r12
    2ab8:	bf 90       	pop	r11
    2aba:	af 90       	pop	r10
    2abc:	9f 90       	pop	r9
    2abe:	8f 90       	pop	r8
    2ac0:	7f 90       	pop	r7
    2ac2:	6f 90       	pop	r6
    2ac4:	5f 90       	pop	r5
    2ac6:	4f 90       	pop	r4
    2ac8:	3f 90       	pop	r3
    2aca:	2f 90       	pop	r2
    2acc:	1f 90       	pop	r1
    2ace:	0f 90       	pop	r0
    2ad0:	0f be       	out	0x3f, r0	; 63
    2ad2:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2ad4:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2ad6:	81 e0       	ldi	r24, 0x01	; 1
}
    2ad8:	cf 91       	pop	r28
    2ada:	df 91       	pop	r29
    2adc:	08 95       	ret

00002ade <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2ade:	df 93       	push	r29
    2ae0:	cf 93       	push	r28
    2ae2:	cd b7       	in	r28, 0x3d	; 61
    2ae4:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2ae6:	cf 91       	pop	r28
    2ae8:	df 91       	pop	r29
    2aea:	08 95       	ret

00002aec <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2aec:	0f 92       	push	r0
    2aee:	0f b6       	in	r0, 0x3f	; 63
    2af0:	f8 94       	cli
    2af2:	0f 92       	push	r0
    2af4:	1f 92       	push	r1
    2af6:	11 24       	eor	r1, r1
    2af8:	2f 92       	push	r2
    2afa:	3f 92       	push	r3
    2afc:	4f 92       	push	r4
    2afe:	5f 92       	push	r5
    2b00:	6f 92       	push	r6
    2b02:	7f 92       	push	r7
    2b04:	8f 92       	push	r8
    2b06:	9f 92       	push	r9
    2b08:	af 92       	push	r10
    2b0a:	bf 92       	push	r11
    2b0c:	cf 92       	push	r12
    2b0e:	df 92       	push	r13
    2b10:	ef 92       	push	r14
    2b12:	ff 92       	push	r15
    2b14:	0f 93       	push	r16
    2b16:	1f 93       	push	r17
    2b18:	2f 93       	push	r18
    2b1a:	3f 93       	push	r19
    2b1c:	4f 93       	push	r20
    2b1e:	5f 93       	push	r21
    2b20:	6f 93       	push	r22
    2b22:	7f 93       	push	r23
    2b24:	8f 93       	push	r24
    2b26:	9f 93       	push	r25
    2b28:	af 93       	push	r26
    2b2a:	bf 93       	push	r27
    2b2c:	cf 93       	push	r28
    2b2e:	df 93       	push	r29
    2b30:	ef 93       	push	r30
    2b32:	ff 93       	push	r31
    2b34:	a0 91 5c 06 	lds	r26, 0x065C
    2b38:	b0 91 5d 06 	lds	r27, 0x065D
    2b3c:	0d b6       	in	r0, 0x3d	; 61
    2b3e:	0d 92       	st	X+, r0
    2b40:	0e b6       	in	r0, 0x3e	; 62
    2b42:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2b44:	0e 94 9f 2b 	call	0x573e	; 0x573e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2b48:	a0 91 5c 06 	lds	r26, 0x065C
    2b4c:	b0 91 5d 06 	lds	r27, 0x065D
    2b50:	cd 91       	ld	r28, X+
    2b52:	cd bf       	out	0x3d, r28	; 61
    2b54:	dd 91       	ld	r29, X+
    2b56:	de bf       	out	0x3e, r29	; 62
    2b58:	ff 91       	pop	r31
    2b5a:	ef 91       	pop	r30
    2b5c:	df 91       	pop	r29
    2b5e:	cf 91       	pop	r28
    2b60:	bf 91       	pop	r27
    2b62:	af 91       	pop	r26
    2b64:	9f 91       	pop	r25
    2b66:	8f 91       	pop	r24
    2b68:	7f 91       	pop	r23
    2b6a:	6f 91       	pop	r22
    2b6c:	5f 91       	pop	r21
    2b6e:	4f 91       	pop	r20
    2b70:	3f 91       	pop	r19
    2b72:	2f 91       	pop	r18
    2b74:	1f 91       	pop	r17
    2b76:	0f 91       	pop	r16
    2b78:	ff 90       	pop	r15
    2b7a:	ef 90       	pop	r14
    2b7c:	df 90       	pop	r13
    2b7e:	cf 90       	pop	r12
    2b80:	bf 90       	pop	r11
    2b82:	af 90       	pop	r10
    2b84:	9f 90       	pop	r9
    2b86:	8f 90       	pop	r8
    2b88:	7f 90       	pop	r7
    2b8a:	6f 90       	pop	r6
    2b8c:	5f 90       	pop	r5
    2b8e:	4f 90       	pop	r4
    2b90:	3f 90       	pop	r3
    2b92:	2f 90       	pop	r2
    2b94:	1f 90       	pop	r1
    2b96:	0f 90       	pop	r0
    2b98:	0f be       	out	0x3f, r0	; 63
    2b9a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2b9c:	08 95       	ret

00002b9e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2b9e:	0f 92       	push	r0
    2ba0:	0f b6       	in	r0, 0x3f	; 63
    2ba2:	f8 94       	cli
    2ba4:	0f 92       	push	r0
    2ba6:	1f 92       	push	r1
    2ba8:	11 24       	eor	r1, r1
    2baa:	2f 92       	push	r2
    2bac:	3f 92       	push	r3
    2bae:	4f 92       	push	r4
    2bb0:	5f 92       	push	r5
    2bb2:	6f 92       	push	r6
    2bb4:	7f 92       	push	r7
    2bb6:	8f 92       	push	r8
    2bb8:	9f 92       	push	r9
    2bba:	af 92       	push	r10
    2bbc:	bf 92       	push	r11
    2bbe:	cf 92       	push	r12
    2bc0:	df 92       	push	r13
    2bc2:	ef 92       	push	r14
    2bc4:	ff 92       	push	r15
    2bc6:	0f 93       	push	r16
    2bc8:	1f 93       	push	r17
    2bca:	2f 93       	push	r18
    2bcc:	3f 93       	push	r19
    2bce:	4f 93       	push	r20
    2bd0:	5f 93       	push	r21
    2bd2:	6f 93       	push	r22
    2bd4:	7f 93       	push	r23
    2bd6:	8f 93       	push	r24
    2bd8:	9f 93       	push	r25
    2bda:	af 93       	push	r26
    2bdc:	bf 93       	push	r27
    2bde:	cf 93       	push	r28
    2be0:	df 93       	push	r29
    2be2:	ef 93       	push	r30
    2be4:	ff 93       	push	r31
    2be6:	a0 91 5c 06 	lds	r26, 0x065C
    2bea:	b0 91 5d 06 	lds	r27, 0x065D
    2bee:	0d b6       	in	r0, 0x3d	; 61
    2bf0:	0d 92       	st	X+, r0
    2bf2:	0e b6       	in	r0, 0x3e	; 62
    2bf4:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2bf6:	0e 94 ba 2a 	call	0x5574	; 0x5574 <xTaskIncrementTick>
    2bfa:	88 23       	and	r24, r24
    2bfc:	11 f0       	breq	.+4      	; 0x2c02 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2bfe:	0e 94 9f 2b 	call	0x573e	; 0x573e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2c02:	a0 91 5c 06 	lds	r26, 0x065C
    2c06:	b0 91 5d 06 	lds	r27, 0x065D
    2c0a:	cd 91       	ld	r28, X+
    2c0c:	cd bf       	out	0x3d, r28	; 61
    2c0e:	dd 91       	ld	r29, X+
    2c10:	de bf       	out	0x3e, r29	; 62
    2c12:	ff 91       	pop	r31
    2c14:	ef 91       	pop	r30
    2c16:	df 91       	pop	r29
    2c18:	cf 91       	pop	r28
    2c1a:	bf 91       	pop	r27
    2c1c:	af 91       	pop	r26
    2c1e:	9f 91       	pop	r25
    2c20:	8f 91       	pop	r24
    2c22:	7f 91       	pop	r23
    2c24:	6f 91       	pop	r22
    2c26:	5f 91       	pop	r21
    2c28:	4f 91       	pop	r20
    2c2a:	3f 91       	pop	r19
    2c2c:	2f 91       	pop	r18
    2c2e:	1f 91       	pop	r17
    2c30:	0f 91       	pop	r16
    2c32:	ff 90       	pop	r15
    2c34:	ef 90       	pop	r14
    2c36:	df 90       	pop	r13
    2c38:	cf 90       	pop	r12
    2c3a:	bf 90       	pop	r11
    2c3c:	af 90       	pop	r10
    2c3e:	9f 90       	pop	r9
    2c40:	8f 90       	pop	r8
    2c42:	7f 90       	pop	r7
    2c44:	6f 90       	pop	r6
    2c46:	5f 90       	pop	r5
    2c48:	4f 90       	pop	r4
    2c4a:	3f 90       	pop	r3
    2c4c:	2f 90       	pop	r2
    2c4e:	1f 90       	pop	r1
    2c50:	0f 90       	pop	r0
    2c52:	0f be       	out	0x3f, r0	; 63
    2c54:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2c56:	08 95       	ret

00002c58 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2c58:	df 93       	push	r29
    2c5a:	cf 93       	push	r28
    2c5c:	00 d0       	rcall	.+0      	; 0x2c5e <prvSetupTimerInterrupt+0x6>
    2c5e:	00 d0       	rcall	.+0      	; 0x2c60 <prvSetupTimerInterrupt+0x8>
    2c60:	00 d0       	rcall	.+0      	; 0x2c62 <prvSetupTimerInterrupt+0xa>
    2c62:	cd b7       	in	r28, 0x3d	; 61
    2c64:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2c66:	80 e4       	ldi	r24, 0x40	; 64
    2c68:	9f e1       	ldi	r25, 0x1F	; 31
    2c6a:	a0 e0       	ldi	r26, 0x00	; 0
    2c6c:	b0 e0       	ldi	r27, 0x00	; 0
    2c6e:	8b 83       	std	Y+3, r24	; 0x03
    2c70:	9c 83       	std	Y+4, r25	; 0x04
    2c72:	ad 83       	std	Y+5, r26	; 0x05
    2c74:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2c76:	8b 81       	ldd	r24, Y+3	; 0x03
    2c78:	9c 81       	ldd	r25, Y+4	; 0x04
    2c7a:	ad 81       	ldd	r26, Y+5	; 0x05
    2c7c:	be 81       	ldd	r27, Y+6	; 0x06
    2c7e:	68 94       	set
    2c80:	15 f8       	bld	r1, 5
    2c82:	b6 95       	lsr	r27
    2c84:	a7 95       	ror	r26
    2c86:	97 95       	ror	r25
    2c88:	87 95       	ror	r24
    2c8a:	16 94       	lsr	r1
    2c8c:	d1 f7       	brne	.-12     	; 0x2c82 <prvSetupTimerInterrupt+0x2a>
    2c8e:	8b 83       	std	Y+3, r24	; 0x03
    2c90:	9c 83       	std	Y+4, r25	; 0x04
    2c92:	ad 83       	std	Y+5, r26	; 0x05
    2c94:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2c96:	8b 81       	ldd	r24, Y+3	; 0x03
    2c98:	9c 81       	ldd	r25, Y+4	; 0x04
    2c9a:	ad 81       	ldd	r26, Y+5	; 0x05
    2c9c:	be 81       	ldd	r27, Y+6	; 0x06
    2c9e:	01 97       	sbiw	r24, 0x01	; 1
    2ca0:	a1 09       	sbc	r26, r1
    2ca2:	b1 09       	sbc	r27, r1
    2ca4:	8b 83       	std	Y+3, r24	; 0x03
    2ca6:	9c 83       	std	Y+4, r25	; 0x04
    2ca8:	ad 83       	std	Y+5, r26	; 0x05
    2caa:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2cac:	8b 81       	ldd	r24, Y+3	; 0x03
    2cae:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2cb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb4:	ad 81       	ldd	r26, Y+5	; 0x05
    2cb6:	be 81       	ldd	r27, Y+6	; 0x06
    2cb8:	89 2f       	mov	r24, r25
    2cba:	9a 2f       	mov	r25, r26
    2cbc:	ab 2f       	mov	r26, r27
    2cbe:	bb 27       	eor	r27, r27
    2cc0:	8b 83       	std	Y+3, r24	; 0x03
    2cc2:	9c 83       	std	Y+4, r25	; 0x04
    2cc4:	ad 83       	std	Y+5, r26	; 0x05
    2cc6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2cc8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cca:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2ccc:	eb e4       	ldi	r30, 0x4B	; 75
    2cce:	f0 e0       	ldi	r31, 0x00	; 0
    2cd0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cd2:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2cd4:	ea e4       	ldi	r30, 0x4A	; 74
    2cd6:	f0 e0       	ldi	r31, 0x00	; 0
    2cd8:	89 81       	ldd	r24, Y+1	; 0x01
    2cda:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2cdc:	8b e0       	ldi	r24, 0x0B	; 11
    2cde:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2ce0:	ee e4       	ldi	r30, 0x4E	; 78
    2ce2:	f0 e0       	ldi	r31, 0x00	; 0
    2ce4:	89 81       	ldd	r24, Y+1	; 0x01
    2ce6:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2ce8:	e9 e5       	ldi	r30, 0x59	; 89
    2cea:	f0 e0       	ldi	r31, 0x00	; 0
    2cec:	80 81       	ld	r24, Z
    2cee:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2cf0:	89 81       	ldd	r24, Y+1	; 0x01
    2cf2:	80 61       	ori	r24, 0x10	; 16
    2cf4:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2cf6:	e9 e5       	ldi	r30, 0x59	; 89
    2cf8:	f0 e0       	ldi	r31, 0x00	; 0
    2cfa:	89 81       	ldd	r24, Y+1	; 0x01
    2cfc:	80 83       	st	Z, r24
}
    2cfe:	26 96       	adiw	r28, 0x06	; 6
    2d00:	0f b6       	in	r0, 0x3f	; 63
    2d02:	f8 94       	cli
    2d04:	de bf       	out	0x3e, r29	; 62
    2d06:	0f be       	out	0x3f, r0	; 63
    2d08:	cd bf       	out	0x3d, r28	; 61
    2d0a:	cf 91       	pop	r28
    2d0c:	df 91       	pop	r29
    2d0e:	08 95       	ret

00002d10 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2d10:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vPortYieldFromTick>
		asm volatile ( "reti" );
    2d14:	18 95       	reti

00002d16 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2d16:	df 93       	push	r29
    2d18:	cf 93       	push	r28
    2d1a:	00 d0       	rcall	.+0      	; 0x2d1c <xQueueGenericReset+0x6>
    2d1c:	00 d0       	rcall	.+0      	; 0x2d1e <xQueueGenericReset+0x8>
    2d1e:	0f 92       	push	r0
    2d20:	cd b7       	in	r28, 0x3d	; 61
    2d22:	de b7       	in	r29, 0x3e	; 62
    2d24:	9c 83       	std	Y+4, r25	; 0x04
    2d26:	8b 83       	std	Y+3, r24	; 0x03
    2d28:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    2d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d2e:	9a 83       	std	Y+2, r25	; 0x02
    2d30:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2d32:	0f b6       	in	r0, 0x3f	; 63
    2d34:	f8 94       	cli
    2d36:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2d38:	e9 81       	ldd	r30, Y+1	; 0x01
    2d3a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d3c:	40 81       	ld	r20, Z
    2d3e:	51 81       	ldd	r21, Z+1	; 0x01
    2d40:	e9 81       	ldd	r30, Y+1	; 0x01
    2d42:	fa 81       	ldd	r31, Y+2	; 0x02
    2d44:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d46:	28 2f       	mov	r18, r24
    2d48:	30 e0       	ldi	r19, 0x00	; 0
    2d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d4e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d50:	88 2f       	mov	r24, r24
    2d52:	90 e0       	ldi	r25, 0x00	; 0
    2d54:	bc 01       	movw	r22, r24
    2d56:	26 9f       	mul	r18, r22
    2d58:	c0 01       	movw	r24, r0
    2d5a:	27 9f       	mul	r18, r23
    2d5c:	90 0d       	add	r25, r0
    2d5e:	36 9f       	mul	r19, r22
    2d60:	90 0d       	add	r25, r0
    2d62:	11 24       	eor	r1, r1
    2d64:	84 0f       	add	r24, r20
    2d66:	95 1f       	adc	r25, r21
    2d68:	e9 81       	ldd	r30, Y+1	; 0x01
    2d6a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d6c:	95 83       	std	Z+5, r25	; 0x05
    2d6e:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2d70:	e9 81       	ldd	r30, Y+1	; 0x01
    2d72:	fa 81       	ldd	r31, Y+2	; 0x02
    2d74:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2d76:	e9 81       	ldd	r30, Y+1	; 0x01
    2d78:	fa 81       	ldd	r31, Y+2	; 0x02
    2d7a:	80 81       	ld	r24, Z
    2d7c:	91 81       	ldd	r25, Z+1	; 0x01
    2d7e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d80:	fa 81       	ldd	r31, Y+2	; 0x02
    2d82:	93 83       	std	Z+3, r25	; 0x03
    2d84:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2d86:	e9 81       	ldd	r30, Y+1	; 0x01
    2d88:	fa 81       	ldd	r31, Y+2	; 0x02
    2d8a:	40 81       	ld	r20, Z
    2d8c:	51 81       	ldd	r21, Z+1	; 0x01
    2d8e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d90:	fa 81       	ldd	r31, Y+2	; 0x02
    2d92:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d94:	88 2f       	mov	r24, r24
    2d96:	90 e0       	ldi	r25, 0x00	; 0
    2d98:	9c 01       	movw	r18, r24
    2d9a:	21 50       	subi	r18, 0x01	; 1
    2d9c:	30 40       	sbci	r19, 0x00	; 0
    2d9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2da0:	fa 81       	ldd	r31, Y+2	; 0x02
    2da2:	84 8d       	ldd	r24, Z+28	; 0x1c
    2da4:	88 2f       	mov	r24, r24
    2da6:	90 e0       	ldi	r25, 0x00	; 0
    2da8:	bc 01       	movw	r22, r24
    2daa:	26 9f       	mul	r18, r22
    2dac:	c0 01       	movw	r24, r0
    2dae:	27 9f       	mul	r18, r23
    2db0:	90 0d       	add	r25, r0
    2db2:	36 9f       	mul	r19, r22
    2db4:	90 0d       	add	r25, r0
    2db6:	11 24       	eor	r1, r1
    2db8:	84 0f       	add	r24, r20
    2dba:	95 1f       	adc	r25, r21
    2dbc:	e9 81       	ldd	r30, Y+1	; 0x01
    2dbe:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc0:	97 83       	std	Z+7, r25	; 0x07
    2dc2:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    2dc4:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc6:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc8:	8f ef       	ldi	r24, 0xFF	; 255
    2dca:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    2dcc:	e9 81       	ldd	r30, Y+1	; 0x01
    2dce:	fa 81       	ldd	r31, Y+2	; 0x02
    2dd0:	8f ef       	ldi	r24, 0xFF	; 255
    2dd2:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    2dd4:	8d 81       	ldd	r24, Y+5	; 0x05
    2dd6:	88 23       	and	r24, r24
    2dd8:	79 f4       	brne	.+30     	; 0x2df8 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2dda:	e9 81       	ldd	r30, Y+1	; 0x01
    2ddc:	fa 81       	ldd	r31, Y+2	; 0x02
    2dde:	80 85       	ldd	r24, Z+8	; 0x08
    2de0:	88 23       	and	r24, r24
    2de2:	a1 f0       	breq	.+40     	; 0x2e0c <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2de4:	89 81       	ldd	r24, Y+1	; 0x01
    2de6:	9a 81       	ldd	r25, Y+2	; 0x02
    2de8:	08 96       	adiw	r24, 0x08	; 8
    2dea:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <xTaskRemoveFromEventList>
    2dee:	88 23       	and	r24, r24
    2df0:	69 f0       	breq	.+26     	; 0x2e0c <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2df2:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    2df6:	0a c0       	rjmp	.+20     	; 0x2e0c <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2df8:	89 81       	ldd	r24, Y+1	; 0x01
    2dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    2dfc:	08 96       	adiw	r24, 0x08	; 8
    2dfe:	0e 94 cb 11 	call	0x2396	; 0x2396 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2e02:	89 81       	ldd	r24, Y+1	; 0x01
    2e04:	9a 81       	ldd	r25, Y+2	; 0x02
    2e06:	41 96       	adiw	r24, 0x11	; 17
    2e08:	0e 94 cb 11 	call	0x2396	; 0x2396 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2e0c:	0f 90       	pop	r0
    2e0e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2e10:	81 e0       	ldi	r24, 0x01	; 1
}
    2e12:	0f 90       	pop	r0
    2e14:	0f 90       	pop	r0
    2e16:	0f 90       	pop	r0
    2e18:	0f 90       	pop	r0
    2e1a:	0f 90       	pop	r0
    2e1c:	cf 91       	pop	r28
    2e1e:	df 91       	pop	r29
    2e20:	08 95       	ret

00002e22 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    2e22:	0f 93       	push	r16
    2e24:	1f 93       	push	r17
    2e26:	df 93       	push	r29
    2e28:	cf 93       	push	r28
    2e2a:	cd b7       	in	r28, 0x3d	; 61
    2e2c:	de b7       	in	r29, 0x3e	; 62
    2e2e:	29 97       	sbiw	r28, 0x09	; 9
    2e30:	0f b6       	in	r0, 0x3f	; 63
    2e32:	f8 94       	cli
    2e34:	de bf       	out	0x3e, r29	; 62
    2e36:	0f be       	out	0x3f, r0	; 63
    2e38:	cd bf       	out	0x3d, r28	; 61
    2e3a:	8f 83       	std	Y+7, r24	; 0x07
    2e3c:	68 87       	std	Y+8, r22	; 0x08
    2e3e:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    2e40:	88 85       	ldd	r24, Y+8	; 0x08
    2e42:	88 23       	and	r24, r24
    2e44:	19 f4       	brne	.+6      	; 0x2e4c <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    2e46:	1c 82       	std	Y+4, r1	; 0x04
    2e48:	1b 82       	std	Y+3, r1	; 0x03
    2e4a:	10 c0       	rjmp	.+32     	; 0x2e6c <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2e4c:	8f 81       	ldd	r24, Y+7	; 0x07
    2e4e:	28 2f       	mov	r18, r24
    2e50:	30 e0       	ldi	r19, 0x00	; 0
    2e52:	88 85       	ldd	r24, Y+8	; 0x08
    2e54:	88 2f       	mov	r24, r24
    2e56:	90 e0       	ldi	r25, 0x00	; 0
    2e58:	ac 01       	movw	r20, r24
    2e5a:	24 9f       	mul	r18, r20
    2e5c:	c0 01       	movw	r24, r0
    2e5e:	25 9f       	mul	r18, r21
    2e60:	90 0d       	add	r25, r0
    2e62:	34 9f       	mul	r19, r20
    2e64:	90 0d       	add	r25, r0
    2e66:	11 24       	eor	r1, r1
    2e68:	9c 83       	std	Y+4, r25	; 0x04
    2e6a:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e70:	4f 96       	adiw	r24, 0x1f	; 31
    2e72:	0e 94 4f 11 	call	0x229e	; 0x229e <pvPortMalloc>
    2e76:	9e 83       	std	Y+6, r25	; 0x06
    2e78:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    2e7a:	8d 81       	ldd	r24, Y+5	; 0x05
    2e7c:	9e 81       	ldd	r25, Y+6	; 0x06
    2e7e:	00 97       	sbiw	r24, 0x00	; 0
    2e80:	a1 f0       	breq	.+40     	; 0x2eaa <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    2e82:	8d 81       	ldd	r24, Y+5	; 0x05
    2e84:	9e 81       	ldd	r25, Y+6	; 0x06
    2e86:	9a 83       	std	Y+2, r25	; 0x02
    2e88:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2e8a:	89 81       	ldd	r24, Y+1	; 0x01
    2e8c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e8e:	4f 96       	adiw	r24, 0x1f	; 31
    2e90:	9a 83       	std	Y+2, r25	; 0x02
    2e92:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2e94:	29 81       	ldd	r18, Y+1	; 0x01
    2e96:	3a 81       	ldd	r19, Y+2	; 0x02
    2e98:	ed 81       	ldd	r30, Y+5	; 0x05
    2e9a:	fe 81       	ldd	r31, Y+6	; 0x06
    2e9c:	8f 81       	ldd	r24, Y+7	; 0x07
    2e9e:	68 85       	ldd	r22, Y+8	; 0x08
    2ea0:	a9 01       	movw	r20, r18
    2ea2:	29 85       	ldd	r18, Y+9	; 0x09
    2ea4:	8f 01       	movw	r16, r30
    2ea6:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    2eaa:	8d 81       	ldd	r24, Y+5	; 0x05
    2eac:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    2eae:	29 96       	adiw	r28, 0x09	; 9
    2eb0:	0f b6       	in	r0, 0x3f	; 63
    2eb2:	f8 94       	cli
    2eb4:	de bf       	out	0x3e, r29	; 62
    2eb6:	0f be       	out	0x3f, r0	; 63
    2eb8:	cd bf       	out	0x3d, r28	; 61
    2eba:	cf 91       	pop	r28
    2ebc:	df 91       	pop	r29
    2ebe:	1f 91       	pop	r17
    2ec0:	0f 91       	pop	r16
    2ec2:	08 95       	ret

00002ec4 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    2ec4:	0f 93       	push	r16
    2ec6:	1f 93       	push	r17
    2ec8:	df 93       	push	r29
    2eca:	cf 93       	push	r28
    2ecc:	cd b7       	in	r28, 0x3d	; 61
    2ece:	de b7       	in	r29, 0x3e	; 62
    2ed0:	27 97       	sbiw	r28, 0x07	; 7
    2ed2:	0f b6       	in	r0, 0x3f	; 63
    2ed4:	f8 94       	cli
    2ed6:	de bf       	out	0x3e, r29	; 62
    2ed8:	0f be       	out	0x3f, r0	; 63
    2eda:	cd bf       	out	0x3d, r28	; 61
    2edc:	89 83       	std	Y+1, r24	; 0x01
    2ede:	6a 83       	std	Y+2, r22	; 0x02
    2ee0:	5c 83       	std	Y+4, r21	; 0x04
    2ee2:	4b 83       	std	Y+3, r20	; 0x03
    2ee4:	2d 83       	std	Y+5, r18	; 0x05
    2ee6:	1f 83       	std	Y+7, r17	; 0x07
    2ee8:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    2eea:	8a 81       	ldd	r24, Y+2	; 0x02
    2eec:	88 23       	and	r24, r24
    2eee:	39 f4       	brne	.+14     	; 0x2efe <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2ef0:	8e 81       	ldd	r24, Y+6	; 0x06
    2ef2:	9f 81       	ldd	r25, Y+7	; 0x07
    2ef4:	ee 81       	ldd	r30, Y+6	; 0x06
    2ef6:	ff 81       	ldd	r31, Y+7	; 0x07
    2ef8:	91 83       	std	Z+1, r25	; 0x01
    2efa:	80 83       	st	Z, r24
    2efc:	06 c0       	rjmp	.+12     	; 0x2f0a <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2efe:	8b 81       	ldd	r24, Y+3	; 0x03
    2f00:	9c 81       	ldd	r25, Y+4	; 0x04
    2f02:	ee 81       	ldd	r30, Y+6	; 0x06
    2f04:	ff 81       	ldd	r31, Y+7	; 0x07
    2f06:	91 83       	std	Z+1, r25	; 0x01
    2f08:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    2f0a:	ee 81       	ldd	r30, Y+6	; 0x06
    2f0c:	ff 81       	ldd	r31, Y+7	; 0x07
    2f0e:	89 81       	ldd	r24, Y+1	; 0x01
    2f10:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    2f12:	ee 81       	ldd	r30, Y+6	; 0x06
    2f14:	ff 81       	ldd	r31, Y+7	; 0x07
    2f16:	8a 81       	ldd	r24, Y+2	; 0x02
    2f18:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2f1a:	8e 81       	ldd	r24, Y+6	; 0x06
    2f1c:	9f 81       	ldd	r25, Y+7	; 0x07
    2f1e:	61 e0       	ldi	r22, 0x01	; 1
    2f20:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    2f24:	27 96       	adiw	r28, 0x07	; 7
    2f26:	0f b6       	in	r0, 0x3f	; 63
    2f28:	f8 94       	cli
    2f2a:	de bf       	out	0x3e, r29	; 62
    2f2c:	0f be       	out	0x3f, r0	; 63
    2f2e:	cd bf       	out	0x3d, r28	; 61
    2f30:	cf 91       	pop	r28
    2f32:	df 91       	pop	r29
    2f34:	1f 91       	pop	r17
    2f36:	0f 91       	pop	r16
    2f38:	08 95       	ret

00002f3a <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    2f3a:	df 93       	push	r29
    2f3c:	cf 93       	push	r28
    2f3e:	00 d0       	rcall	.+0      	; 0x2f40 <xQueueCreateCountingSemaphore+0x6>
    2f40:	00 d0       	rcall	.+0      	; 0x2f42 <xQueueCreateCountingSemaphore+0x8>
    2f42:	cd b7       	in	r28, 0x3d	; 61
    2f44:	de b7       	in	r29, 0x3e	; 62
    2f46:	8b 83       	std	Y+3, r24	; 0x03
    2f48:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    2f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f4c:	60 e0       	ldi	r22, 0x00	; 0
    2f4e:	42 e0       	ldi	r20, 0x02	; 2
    2f50:	0e 94 11 17 	call	0x2e22	; 0x2e22 <xQueueGenericCreate>
    2f54:	9a 83       	std	Y+2, r25	; 0x02
    2f56:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    2f58:	89 81       	ldd	r24, Y+1	; 0x01
    2f5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f5c:	00 97       	sbiw	r24, 0x00	; 0
    2f5e:	21 f0       	breq	.+8      	; 0x2f68 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    2f60:	e9 81       	ldd	r30, Y+1	; 0x01
    2f62:	fa 81       	ldd	r31, Y+2	; 0x02
    2f64:	8c 81       	ldd	r24, Y+4	; 0x04
    2f66:	82 8f       	std	Z+26, r24	; 0x1a
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
    2f68:	89 81       	ldd	r24, Y+1	; 0x01
    2f6a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    2f6c:	0f 90       	pop	r0
    2f6e:	0f 90       	pop	r0
    2f70:	0f 90       	pop	r0
    2f72:	0f 90       	pop	r0
    2f74:	cf 91       	pop	r28
    2f76:	df 91       	pop	r29
    2f78:	08 95       	ret

00002f7a <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2f7a:	df 93       	push	r29
    2f7c:	cf 93       	push	r28
    2f7e:	cd b7       	in	r28, 0x3d	; 61
    2f80:	de b7       	in	r29, 0x3e	; 62
    2f82:	2f 97       	sbiw	r28, 0x0f	; 15
    2f84:	0f b6       	in	r0, 0x3f	; 63
    2f86:	f8 94       	cli
    2f88:	de bf       	out	0x3e, r29	; 62
    2f8a:	0f be       	out	0x3f, r0	; 63
    2f8c:	cd bf       	out	0x3d, r28	; 61
    2f8e:	99 87       	std	Y+9, r25	; 0x09
    2f90:	88 87       	std	Y+8, r24	; 0x08
    2f92:	7b 87       	std	Y+11, r23	; 0x0b
    2f94:	6a 87       	std	Y+10, r22	; 0x0a
    2f96:	5d 87       	std	Y+13, r21	; 0x0d
    2f98:	4c 87       	std	Y+12, r20	; 0x0c
    2f9a:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2f9c:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2f9e:	88 85       	ldd	r24, Y+8	; 0x08
    2fa0:	99 85       	ldd	r25, Y+9	; 0x09
    2fa2:	9a 83       	std	Y+2, r25	; 0x02
    2fa4:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2fa6:	0f b6       	in	r0, 0x3f	; 63
    2fa8:	f8 94       	cli
    2faa:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2fac:	e9 81       	ldd	r30, Y+1	; 0x01
    2fae:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb0:	92 8d       	ldd	r25, Z+26	; 0x1a
    2fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb6:	83 8d       	ldd	r24, Z+27	; 0x1b
    2fb8:	98 17       	cp	r25, r24
    2fba:	18 f0       	brcs	.+6      	; 0x2fc2 <xQueueGenericSend+0x48>
    2fbc:	8e 85       	ldd	r24, Y+14	; 0x0e
    2fbe:	82 30       	cpi	r24, 0x02	; 2
    2fc0:	11 f5       	brne	.+68     	; 0x3006 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2fc2:	89 81       	ldd	r24, Y+1	; 0x01
    2fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc6:	2a 85       	ldd	r18, Y+10	; 0x0a
    2fc8:	3b 85       	ldd	r19, Y+11	; 0x0b
    2fca:	b9 01       	movw	r22, r18
    2fcc:	4e 85       	ldd	r20, Y+14	; 0x0e
    2fce:	0e 94 0f 1c 	call	0x381e	; 0x381e <prvCopyDataToQueue>
    2fd2:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2fd4:	e9 81       	ldd	r30, Y+1	; 0x01
    2fd6:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd8:	81 89       	ldd	r24, Z+17	; 0x11
    2fda:	88 23       	and	r24, r24
    2fdc:	51 f0       	breq	.+20     	; 0x2ff2 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2fde:	89 81       	ldd	r24, Y+1	; 0x01
    2fe0:	9a 81       	ldd	r25, Y+2	; 0x02
    2fe2:	41 96       	adiw	r24, 0x11	; 17
    2fe4:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <xTaskRemoveFromEventList>
    2fe8:	88 23       	and	r24, r24
    2fea:	41 f0       	breq	.+16     	; 0x2ffc <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2fec:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    2ff0:	05 c0       	rjmp	.+10     	; 0x2ffc <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff4:	88 23       	and	r24, r24
    2ff6:	11 f0       	breq	.+4      	; 0x2ffc <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2ff8:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2ffc:	0f 90       	pop	r0
    2ffe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3000:	81 e0       	ldi	r24, 0x01	; 1
    3002:	8f 87       	std	Y+15, r24	; 0x0f
    3004:	5c c0       	rjmp	.+184    	; 0x30be <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3006:	8c 85       	ldd	r24, Y+12	; 0x0c
    3008:	9d 85       	ldd	r25, Y+13	; 0x0d
    300a:	00 97       	sbiw	r24, 0x00	; 0
    300c:	21 f4       	brne	.+8      	; 0x3016 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    300e:	0f 90       	pop	r0
    3010:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3012:	1f 86       	std	Y+15, r1	; 0x0f
    3014:	54 c0       	rjmp	.+168    	; 0x30be <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    3016:	8c 81       	ldd	r24, Y+4	; 0x04
    3018:	88 23       	and	r24, r24
    301a:	31 f4       	brne	.+12     	; 0x3028 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    301c:	ce 01       	movw	r24, r28
    301e:	05 96       	adiw	r24, 0x05	; 5
    3020:	0e 94 44 2d 	call	0x5a88	; 0x5a88 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3024:	81 e0       	ldi	r24, 0x01	; 1
    3026:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3028:	0f 90       	pop	r0
    302a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    302c:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3030:	0f b6       	in	r0, 0x3f	; 63
    3032:	f8 94       	cli
    3034:	0f 92       	push	r0
    3036:	e9 81       	ldd	r30, Y+1	; 0x01
    3038:	fa 81       	ldd	r31, Y+2	; 0x02
    303a:	85 8d       	ldd	r24, Z+29	; 0x1d
    303c:	8f 3f       	cpi	r24, 0xFF	; 255
    303e:	19 f4       	brne	.+6      	; 0x3046 <xQueueGenericSend+0xcc>
    3040:	e9 81       	ldd	r30, Y+1	; 0x01
    3042:	fa 81       	ldd	r31, Y+2	; 0x02
    3044:	15 8e       	std	Z+29, r1	; 0x1d
    3046:	e9 81       	ldd	r30, Y+1	; 0x01
    3048:	fa 81       	ldd	r31, Y+2	; 0x02
    304a:	86 8d       	ldd	r24, Z+30	; 0x1e
    304c:	8f 3f       	cpi	r24, 0xFF	; 255
    304e:	19 f4       	brne	.+6      	; 0x3056 <xQueueGenericSend+0xdc>
    3050:	e9 81       	ldd	r30, Y+1	; 0x01
    3052:	fa 81       	ldd	r31, Y+2	; 0x02
    3054:	16 8e       	std	Z+30, r1	; 0x1e
    3056:	0f 90       	pop	r0
    3058:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    305a:	ce 01       	movw	r24, r28
    305c:	05 96       	adiw	r24, 0x05	; 5
    305e:	9e 01       	movw	r18, r28
    3060:	24 5f       	subi	r18, 0xF4	; 244
    3062:	3f 4f       	sbci	r19, 0xFF	; 255
    3064:	b9 01       	movw	r22, r18
    3066:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <xTaskCheckForTimeOut>
    306a:	88 23       	and	r24, r24
    306c:	09 f5       	brne	.+66     	; 0x30b0 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    306e:	89 81       	ldd	r24, Y+1	; 0x01
    3070:	9a 81       	ldd	r25, Y+2	; 0x02
    3072:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <prvIsQueueFull>
    3076:	88 23       	and	r24, r24
    3078:	a1 f0       	breq	.+40     	; 0x30a2 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    307a:	89 81       	ldd	r24, Y+1	; 0x01
    307c:	9a 81       	ldd	r25, Y+2	; 0x02
    307e:	08 96       	adiw	r24, 0x08	; 8
    3080:	2c 85       	ldd	r18, Y+12	; 0x0c
    3082:	3d 85       	ldd	r19, Y+13	; 0x0d
    3084:	b9 01       	movw	r22, r18
    3086:	0e 94 0c 2c 	call	0x5818	; 0x5818 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    308a:	89 81       	ldd	r24, Y+1	; 0x01
    308c:	9a 81       	ldd	r25, Y+2	; 0x02
    308e:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3092:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    3096:	88 23       	and	r24, r24
    3098:	09 f0       	breq	.+2      	; 0x309c <xQueueGenericSend+0x122>
    309a:	85 cf       	rjmp	.-246    	; 0x2fa6 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    309c:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    30a0:	82 cf       	rjmp	.-252    	; 0x2fa6 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    30a2:	89 81       	ldd	r24, Y+1	; 0x01
    30a4:	9a 81       	ldd	r25, Y+2	; 0x02
    30a6:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    30aa:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    30ae:	7b cf       	rjmp	.-266    	; 0x2fa6 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    30b0:	89 81       	ldd	r24, Y+1	; 0x01
    30b2:	9a 81       	ldd	r25, Y+2	; 0x02
    30b4:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    30b8:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    30bc:	1f 86       	std	Y+15, r1	; 0x0f
    30be:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    30c0:	2f 96       	adiw	r28, 0x0f	; 15
    30c2:	0f b6       	in	r0, 0x3f	; 63
    30c4:	f8 94       	cli
    30c6:	de bf       	out	0x3e, r29	; 62
    30c8:	0f be       	out	0x3f, r0	; 63
    30ca:	cd bf       	out	0x3d, r28	; 61
    30cc:	cf 91       	pop	r28
    30ce:	df 91       	pop	r29
    30d0:	08 95       	ret

000030d2 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    30d2:	df 93       	push	r29
    30d4:	cf 93       	push	r28
    30d6:	cd b7       	in	r28, 0x3d	; 61
    30d8:	de b7       	in	r29, 0x3e	; 62
    30da:	2c 97       	sbiw	r28, 0x0c	; 12
    30dc:	0f b6       	in	r0, 0x3f	; 63
    30de:	f8 94       	cli
    30e0:	de bf       	out	0x3e, r29	; 62
    30e2:	0f be       	out	0x3f, r0	; 63
    30e4:	cd bf       	out	0x3d, r28	; 61
    30e6:	9f 83       	std	Y+7, r25	; 0x07
    30e8:	8e 83       	std	Y+6, r24	; 0x06
    30ea:	79 87       	std	Y+9, r23	; 0x09
    30ec:	68 87       	std	Y+8, r22	; 0x08
    30ee:	5b 87       	std	Y+11, r21	; 0x0b
    30f0:	4a 87       	std	Y+10, r20	; 0x0a
    30f2:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    30f4:	8e 81       	ldd	r24, Y+6	; 0x06
    30f6:	9f 81       	ldd	r25, Y+7	; 0x07
    30f8:	9b 83       	std	Y+3, r25	; 0x03
    30fa:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    30fc:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    30fe:	ea 81       	ldd	r30, Y+2	; 0x02
    3100:	fb 81       	ldd	r31, Y+3	; 0x03
    3102:	92 8d       	ldd	r25, Z+26	; 0x1a
    3104:	ea 81       	ldd	r30, Y+2	; 0x02
    3106:	fb 81       	ldd	r31, Y+3	; 0x03
    3108:	83 8d       	ldd	r24, Z+27	; 0x1b
    310a:	98 17       	cp	r25, r24
    310c:	18 f0       	brcs	.+6      	; 0x3114 <xQueueGenericSendFromISR+0x42>
    310e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3110:	82 30       	cpi	r24, 0x02	; 2
    3112:	61 f5       	brne	.+88     	; 0x316c <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    3114:	ea 81       	ldd	r30, Y+2	; 0x02
    3116:	fb 81       	ldd	r31, Y+3	; 0x03
    3118:	86 8d       	ldd	r24, Z+30	; 0x1e
    311a:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    311c:	8a 81       	ldd	r24, Y+2	; 0x02
    311e:	9b 81       	ldd	r25, Y+3	; 0x03
    3120:	28 85       	ldd	r18, Y+8	; 0x08
    3122:	39 85       	ldd	r19, Y+9	; 0x09
    3124:	b9 01       	movw	r22, r18
    3126:	4c 85       	ldd	r20, Y+12	; 0x0c
    3128:	0e 94 0f 1c 	call	0x381e	; 0x381e <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    312c:	89 81       	ldd	r24, Y+1	; 0x01
    312e:	8f 3f       	cpi	r24, 0xFF	; 255
    3130:	a9 f4       	brne	.+42     	; 0x315c <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3132:	ea 81       	ldd	r30, Y+2	; 0x02
    3134:	fb 81       	ldd	r31, Y+3	; 0x03
    3136:	81 89       	ldd	r24, Z+17	; 0x11
    3138:	88 23       	and	r24, r24
    313a:	a9 f0       	breq	.+42     	; 0x3166 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    313c:	8a 81       	ldd	r24, Y+2	; 0x02
    313e:	9b 81       	ldd	r25, Y+3	; 0x03
    3140:	41 96       	adiw	r24, 0x11	; 17
    3142:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <xTaskRemoveFromEventList>
    3146:	88 23       	and	r24, r24
    3148:	71 f0       	breq	.+28     	; 0x3166 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    314a:	8a 85       	ldd	r24, Y+10	; 0x0a
    314c:	9b 85       	ldd	r25, Y+11	; 0x0b
    314e:	00 97       	sbiw	r24, 0x00	; 0
    3150:	51 f0       	breq	.+20     	; 0x3166 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3152:	ea 85       	ldd	r30, Y+10	; 0x0a
    3154:	fb 85       	ldd	r31, Y+11	; 0x0b
    3156:	81 e0       	ldi	r24, 0x01	; 1
    3158:	80 83       	st	Z, r24
    315a:	05 c0       	rjmp	.+10     	; 0x3166 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    315c:	89 81       	ldd	r24, Y+1	; 0x01
    315e:	8f 5f       	subi	r24, 0xFF	; 255
    3160:	ea 81       	ldd	r30, Y+2	; 0x02
    3162:	fb 81       	ldd	r31, Y+3	; 0x03
    3164:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3166:	81 e0       	ldi	r24, 0x01	; 1
    3168:	8d 83       	std	Y+5, r24	; 0x05
    316a:	01 c0       	rjmp	.+2      	; 0x316e <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    316c:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    316e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3170:	2c 96       	adiw	r28, 0x0c	; 12
    3172:	0f b6       	in	r0, 0x3f	; 63
    3174:	f8 94       	cli
    3176:	de bf       	out	0x3e, r29	; 62
    3178:	0f be       	out	0x3f, r0	; 63
    317a:	cd bf       	out	0x3d, r28	; 61
    317c:	cf 91       	pop	r28
    317e:	df 91       	pop	r29
    3180:	08 95       	ret

00003182 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3182:	df 93       	push	r29
    3184:	cf 93       	push	r28
    3186:	cd b7       	in	r28, 0x3d	; 61
    3188:	de b7       	in	r29, 0x3e	; 62
    318a:	2a 97       	sbiw	r28, 0x0a	; 10
    318c:	0f b6       	in	r0, 0x3f	; 63
    318e:	f8 94       	cli
    3190:	de bf       	out	0x3e, r29	; 62
    3192:	0f be       	out	0x3f, r0	; 63
    3194:	cd bf       	out	0x3d, r28	; 61
    3196:	98 87       	std	Y+8, r25	; 0x08
    3198:	8f 83       	std	Y+7, r24	; 0x07
    319a:	7a 87       	std	Y+10, r23	; 0x0a
    319c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    319e:	8f 81       	ldd	r24, Y+7	; 0x07
    31a0:	98 85       	ldd	r25, Y+8	; 0x08
    31a2:	9c 83       	std	Y+4, r25	; 0x04
    31a4:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    31a6:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    31a8:	eb 81       	ldd	r30, Y+3	; 0x03
    31aa:	fc 81       	ldd	r31, Y+4	; 0x04
    31ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    31ae:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    31b0:	eb 81       	ldd	r30, Y+3	; 0x03
    31b2:	fc 81       	ldd	r31, Y+4	; 0x04
    31b4:	93 8d       	ldd	r25, Z+27	; 0x1b
    31b6:	8a 81       	ldd	r24, Y+2	; 0x02
    31b8:	89 17       	cp	r24, r25
    31ba:	48 f5       	brcc	.+82     	; 0x320e <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    31bc:	eb 81       	ldd	r30, Y+3	; 0x03
    31be:	fc 81       	ldd	r31, Y+4	; 0x04
    31c0:	86 8d       	ldd	r24, Z+30	; 0x1e
    31c2:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    31c4:	8a 81       	ldd	r24, Y+2	; 0x02
    31c6:	8f 5f       	subi	r24, 0xFF	; 255
    31c8:	eb 81       	ldd	r30, Y+3	; 0x03
    31ca:	fc 81       	ldd	r31, Y+4	; 0x04
    31cc:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    31ce:	89 81       	ldd	r24, Y+1	; 0x01
    31d0:	8f 3f       	cpi	r24, 0xFF	; 255
    31d2:	a9 f4       	brne	.+42     	; 0x31fe <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    31d4:	eb 81       	ldd	r30, Y+3	; 0x03
    31d6:	fc 81       	ldd	r31, Y+4	; 0x04
    31d8:	81 89       	ldd	r24, Z+17	; 0x11
    31da:	88 23       	and	r24, r24
    31dc:	a9 f0       	breq	.+42     	; 0x3208 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    31de:	8b 81       	ldd	r24, Y+3	; 0x03
    31e0:	9c 81       	ldd	r25, Y+4	; 0x04
    31e2:	41 96       	adiw	r24, 0x11	; 17
    31e4:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <xTaskRemoveFromEventList>
    31e8:	88 23       	and	r24, r24
    31ea:	71 f0       	breq	.+28     	; 0x3208 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    31ec:	89 85       	ldd	r24, Y+9	; 0x09
    31ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    31f0:	00 97       	sbiw	r24, 0x00	; 0
    31f2:	51 f0       	breq	.+20     	; 0x3208 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    31f4:	e9 85       	ldd	r30, Y+9	; 0x09
    31f6:	fa 85       	ldd	r31, Y+10	; 0x0a
    31f8:	81 e0       	ldi	r24, 0x01	; 1
    31fa:	80 83       	st	Z, r24
    31fc:	05 c0       	rjmp	.+10     	; 0x3208 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    31fe:	89 81       	ldd	r24, Y+1	; 0x01
    3200:	8f 5f       	subi	r24, 0xFF	; 255
    3202:	eb 81       	ldd	r30, Y+3	; 0x03
    3204:	fc 81       	ldd	r31, Y+4	; 0x04
    3206:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3208:	81 e0       	ldi	r24, 0x01	; 1
    320a:	8e 83       	std	Y+6, r24	; 0x06
    320c:	01 c0       	rjmp	.+2      	; 0x3210 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    320e:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3210:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3212:	2a 96       	adiw	r28, 0x0a	; 10
    3214:	0f b6       	in	r0, 0x3f	; 63
    3216:	f8 94       	cli
    3218:	de bf       	out	0x3e, r29	; 62
    321a:	0f be       	out	0x3f, r0	; 63
    321c:	cd bf       	out	0x3d, r28	; 61
    321e:	cf 91       	pop	r28
    3220:	df 91       	pop	r29
    3222:	08 95       	ret

00003224 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    3224:	df 93       	push	r29
    3226:	cf 93       	push	r28
    3228:	cd b7       	in	r28, 0x3d	; 61
    322a:	de b7       	in	r29, 0x3e	; 62
    322c:	2e 97       	sbiw	r28, 0x0e	; 14
    322e:	0f b6       	in	r0, 0x3f	; 63
    3230:	f8 94       	cli
    3232:	de bf       	out	0x3e, r29	; 62
    3234:	0f be       	out	0x3f, r0	; 63
    3236:	cd bf       	out	0x3d, r28	; 61
    3238:	99 87       	std	Y+9, r25	; 0x09
    323a:	88 87       	std	Y+8, r24	; 0x08
    323c:	7b 87       	std	Y+11, r23	; 0x0b
    323e:	6a 87       	std	Y+10, r22	; 0x0a
    3240:	5d 87       	std	Y+13, r21	; 0x0d
    3242:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    3244:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3246:	88 85       	ldd	r24, Y+8	; 0x08
    3248:	99 85       	ldd	r25, Y+9	; 0x09
    324a:	9b 83       	std	Y+3, r25	; 0x03
    324c:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    324e:	0f b6       	in	r0, 0x3f	; 63
    3250:	f8 94       	cli
    3252:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3254:	ea 81       	ldd	r30, Y+2	; 0x02
    3256:	fb 81       	ldd	r31, Y+3	; 0x03
    3258:	82 8d       	ldd	r24, Z+26	; 0x1a
    325a:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    325c:	89 81       	ldd	r24, Y+1	; 0x01
    325e:	88 23       	and	r24, r24
    3260:	f9 f0       	breq	.+62     	; 0x32a0 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3262:	8a 81       	ldd	r24, Y+2	; 0x02
    3264:	9b 81       	ldd	r25, Y+3	; 0x03
    3266:	2a 85       	ldd	r18, Y+10	; 0x0a
    3268:	3b 85       	ldd	r19, Y+11	; 0x0b
    326a:	b9 01       	movw	r22, r18
    326c:	0e 94 b5 1c 	call	0x396a	; 0x396a <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3270:	89 81       	ldd	r24, Y+1	; 0x01
    3272:	81 50       	subi	r24, 0x01	; 1
    3274:	ea 81       	ldd	r30, Y+2	; 0x02
    3276:	fb 81       	ldd	r31, Y+3	; 0x03
    3278:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    327a:	ea 81       	ldd	r30, Y+2	; 0x02
    327c:	fb 81       	ldd	r31, Y+3	; 0x03
    327e:	80 85       	ldd	r24, Z+8	; 0x08
    3280:	88 23       	and	r24, r24
    3282:	49 f0       	breq	.+18     	; 0x3296 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3284:	8a 81       	ldd	r24, Y+2	; 0x02
    3286:	9b 81       	ldd	r25, Y+3	; 0x03
    3288:	08 96       	adiw	r24, 0x08	; 8
    328a:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <xTaskRemoveFromEventList>
    328e:	88 23       	and	r24, r24
    3290:	11 f0       	breq	.+4      	; 0x3296 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    3292:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3296:	0f 90       	pop	r0
    3298:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    329a:	81 e0       	ldi	r24, 0x01	; 1
    329c:	8e 87       	std	Y+14, r24	; 0x0e
    329e:	63 c0       	rjmp	.+198    	; 0x3366 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    32a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    32a2:	9d 85       	ldd	r25, Y+13	; 0x0d
    32a4:	00 97       	sbiw	r24, 0x00	; 0
    32a6:	21 f4       	brne	.+8      	; 0x32b0 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    32a8:	0f 90       	pop	r0
    32aa:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    32ac:	1e 86       	std	Y+14, r1	; 0x0e
    32ae:	5b c0       	rjmp	.+182    	; 0x3366 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    32b0:	8c 81       	ldd	r24, Y+4	; 0x04
    32b2:	88 23       	and	r24, r24
    32b4:	31 f4       	brne	.+12     	; 0x32c2 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    32b6:	ce 01       	movw	r24, r28
    32b8:	05 96       	adiw	r24, 0x05	; 5
    32ba:	0e 94 44 2d 	call	0x5a88	; 0x5a88 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    32be:	81 e0       	ldi	r24, 0x01	; 1
    32c0:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    32c2:	0f 90       	pop	r0
    32c4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    32c6:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    32ca:	0f b6       	in	r0, 0x3f	; 63
    32cc:	f8 94       	cli
    32ce:	0f 92       	push	r0
    32d0:	ea 81       	ldd	r30, Y+2	; 0x02
    32d2:	fb 81       	ldd	r31, Y+3	; 0x03
    32d4:	85 8d       	ldd	r24, Z+29	; 0x1d
    32d6:	8f 3f       	cpi	r24, 0xFF	; 255
    32d8:	19 f4       	brne	.+6      	; 0x32e0 <xQueueReceive+0xbc>
    32da:	ea 81       	ldd	r30, Y+2	; 0x02
    32dc:	fb 81       	ldd	r31, Y+3	; 0x03
    32de:	15 8e       	std	Z+29, r1	; 0x1d
    32e0:	ea 81       	ldd	r30, Y+2	; 0x02
    32e2:	fb 81       	ldd	r31, Y+3	; 0x03
    32e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    32e6:	8f 3f       	cpi	r24, 0xFF	; 255
    32e8:	19 f4       	brne	.+6      	; 0x32f0 <xQueueReceive+0xcc>
    32ea:	ea 81       	ldd	r30, Y+2	; 0x02
    32ec:	fb 81       	ldd	r31, Y+3	; 0x03
    32ee:	16 8e       	std	Z+30, r1	; 0x1e
    32f0:	0f 90       	pop	r0
    32f2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    32f4:	ce 01       	movw	r24, r28
    32f6:	05 96       	adiw	r24, 0x05	; 5
    32f8:	9e 01       	movw	r18, r28
    32fa:	24 5f       	subi	r18, 0xF4	; 244
    32fc:	3f 4f       	sbci	r19, 0xFF	; 255
    32fe:	b9 01       	movw	r22, r18
    3300:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <xTaskCheckForTimeOut>
    3304:	88 23       	and	r24, r24
    3306:	09 f5       	brne	.+66     	; 0x334a <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3308:	8a 81       	ldd	r24, Y+2	; 0x02
    330a:	9b 81       	ldd	r25, Y+3	; 0x03
    330c:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <prvIsQueueEmpty>
    3310:	88 23       	and	r24, r24
    3312:	a1 f0       	breq	.+40     	; 0x333c <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3314:	8a 81       	ldd	r24, Y+2	; 0x02
    3316:	9b 81       	ldd	r25, Y+3	; 0x03
    3318:	41 96       	adiw	r24, 0x11	; 17
    331a:	2c 85       	ldd	r18, Y+12	; 0x0c
    331c:	3d 85       	ldd	r19, Y+13	; 0x0d
    331e:	b9 01       	movw	r22, r18
    3320:	0e 94 0c 2c 	call	0x5818	; 0x5818 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3324:	8a 81       	ldd	r24, Y+2	; 0x02
    3326:	9b 81       	ldd	r25, Y+3	; 0x03
    3328:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    332c:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    3330:	88 23       	and	r24, r24
    3332:	09 f0       	breq	.+2      	; 0x3336 <xQueueReceive+0x112>
    3334:	8c cf       	rjmp	.-232    	; 0x324e <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    3336:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    333a:	89 cf       	rjmp	.-238    	; 0x324e <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    333c:	8a 81       	ldd	r24, Y+2	; 0x02
    333e:	9b 81       	ldd	r25, Y+3	; 0x03
    3340:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3344:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    3348:	82 cf       	rjmp	.-252    	; 0x324e <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    334a:	8a 81       	ldd	r24, Y+2	; 0x02
    334c:	9b 81       	ldd	r25, Y+3	; 0x03
    334e:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3352:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3356:	8a 81       	ldd	r24, Y+2	; 0x02
    3358:	9b 81       	ldd	r25, Y+3	; 0x03
    335a:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <prvIsQueueEmpty>
    335e:	88 23       	and	r24, r24
    3360:	09 f4       	brne	.+2      	; 0x3364 <xQueueReceive+0x140>
    3362:	75 cf       	rjmp	.-278    	; 0x324e <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3364:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    3366:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    3368:	2e 96       	adiw	r28, 0x0e	; 14
    336a:	0f b6       	in	r0, 0x3f	; 63
    336c:	f8 94       	cli
    336e:	de bf       	out	0x3e, r29	; 62
    3370:	0f be       	out	0x3f, r0	; 63
    3372:	cd bf       	out	0x3d, r28	; 61
    3374:	cf 91       	pop	r28
    3376:	df 91       	pop	r29
    3378:	08 95       	ret

0000337a <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    337a:	df 93       	push	r29
    337c:	cf 93       	push	r28
    337e:	cd b7       	in	r28, 0x3d	; 61
    3380:	de b7       	in	r29, 0x3e	; 62
    3382:	2c 97       	sbiw	r28, 0x0c	; 12
    3384:	0f b6       	in	r0, 0x3f	; 63
    3386:	f8 94       	cli
    3388:	de bf       	out	0x3e, r29	; 62
    338a:	0f be       	out	0x3f, r0	; 63
    338c:	cd bf       	out	0x3d, r28	; 61
    338e:	99 87       	std	Y+9, r25	; 0x09
    3390:	88 87       	std	Y+8, r24	; 0x08
    3392:	7b 87       	std	Y+11, r23	; 0x0b
    3394:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    3396:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3398:	88 85       	ldd	r24, Y+8	; 0x08
    339a:	99 85       	ldd	r25, Y+9	; 0x09
    339c:	9b 83       	std	Y+3, r25	; 0x03
    339e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    33a0:	0f b6       	in	r0, 0x3f	; 63
    33a2:	f8 94       	cli
    33a4:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    33a6:	ea 81       	ldd	r30, Y+2	; 0x02
    33a8:	fb 81       	ldd	r31, Y+3	; 0x03
    33aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    33ac:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    33ae:	89 81       	ldd	r24, Y+1	; 0x01
    33b0:	88 23       	and	r24, r24
    33b2:	c1 f0       	breq	.+48     	; 0x33e4 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    33b4:	89 81       	ldd	r24, Y+1	; 0x01
    33b6:	81 50       	subi	r24, 0x01	; 1
    33b8:	ea 81       	ldd	r30, Y+2	; 0x02
    33ba:	fb 81       	ldd	r31, Y+3	; 0x03
    33bc:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    33be:	ea 81       	ldd	r30, Y+2	; 0x02
    33c0:	fb 81       	ldd	r31, Y+3	; 0x03
    33c2:	80 85       	ldd	r24, Z+8	; 0x08
    33c4:	88 23       	and	r24, r24
    33c6:	49 f0       	breq	.+18     	; 0x33da <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    33c8:	8a 81       	ldd	r24, Y+2	; 0x02
    33ca:	9b 81       	ldd	r25, Y+3	; 0x03
    33cc:	08 96       	adiw	r24, 0x08	; 8
    33ce:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <xTaskRemoveFromEventList>
    33d2:	88 23       	and	r24, r24
    33d4:	11 f0       	breq	.+4      	; 0x33da <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    33d6:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    33da:	0f 90       	pop	r0
    33dc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    33de:	81 e0       	ldi	r24, 0x01	; 1
    33e0:	8c 87       	std	Y+12, r24	; 0x0c
    33e2:	63 c0       	rjmp	.+198    	; 0x34aa <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    33e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    33e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    33e8:	00 97       	sbiw	r24, 0x00	; 0
    33ea:	21 f4       	brne	.+8      	; 0x33f4 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    33ec:	0f 90       	pop	r0
    33ee:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    33f0:	1c 86       	std	Y+12, r1	; 0x0c
    33f2:	5b c0       	rjmp	.+182    	; 0x34aa <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    33f4:	8c 81       	ldd	r24, Y+4	; 0x04
    33f6:	88 23       	and	r24, r24
    33f8:	31 f4       	brne	.+12     	; 0x3406 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    33fa:	ce 01       	movw	r24, r28
    33fc:	05 96       	adiw	r24, 0x05	; 5
    33fe:	0e 94 44 2d 	call	0x5a88	; 0x5a88 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3402:	81 e0       	ldi	r24, 0x01	; 1
    3404:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3406:	0f 90       	pop	r0
    3408:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    340a:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    340e:	0f b6       	in	r0, 0x3f	; 63
    3410:	f8 94       	cli
    3412:	0f 92       	push	r0
    3414:	ea 81       	ldd	r30, Y+2	; 0x02
    3416:	fb 81       	ldd	r31, Y+3	; 0x03
    3418:	85 8d       	ldd	r24, Z+29	; 0x1d
    341a:	8f 3f       	cpi	r24, 0xFF	; 255
    341c:	19 f4       	brne	.+6      	; 0x3424 <xQueueSemaphoreTake+0xaa>
    341e:	ea 81       	ldd	r30, Y+2	; 0x02
    3420:	fb 81       	ldd	r31, Y+3	; 0x03
    3422:	15 8e       	std	Z+29, r1	; 0x1d
    3424:	ea 81       	ldd	r30, Y+2	; 0x02
    3426:	fb 81       	ldd	r31, Y+3	; 0x03
    3428:	86 8d       	ldd	r24, Z+30	; 0x1e
    342a:	8f 3f       	cpi	r24, 0xFF	; 255
    342c:	19 f4       	brne	.+6      	; 0x3434 <xQueueSemaphoreTake+0xba>
    342e:	ea 81       	ldd	r30, Y+2	; 0x02
    3430:	fb 81       	ldd	r31, Y+3	; 0x03
    3432:	16 8e       	std	Z+30, r1	; 0x1e
    3434:	0f 90       	pop	r0
    3436:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3438:	ce 01       	movw	r24, r28
    343a:	05 96       	adiw	r24, 0x05	; 5
    343c:	9e 01       	movw	r18, r28
    343e:	26 5f       	subi	r18, 0xF6	; 246
    3440:	3f 4f       	sbci	r19, 0xFF	; 255
    3442:	b9 01       	movw	r22, r18
    3444:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <xTaskCheckForTimeOut>
    3448:	88 23       	and	r24, r24
    344a:	09 f5       	brne	.+66     	; 0x348e <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    344c:	8a 81       	ldd	r24, Y+2	; 0x02
    344e:	9b 81       	ldd	r25, Y+3	; 0x03
    3450:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <prvIsQueueEmpty>
    3454:	88 23       	and	r24, r24
    3456:	a1 f0       	breq	.+40     	; 0x3480 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3458:	8a 81       	ldd	r24, Y+2	; 0x02
    345a:	9b 81       	ldd	r25, Y+3	; 0x03
    345c:	41 96       	adiw	r24, 0x11	; 17
    345e:	2a 85       	ldd	r18, Y+10	; 0x0a
    3460:	3b 85       	ldd	r19, Y+11	; 0x0b
    3462:	b9 01       	movw	r22, r18
    3464:	0e 94 0c 2c 	call	0x5818	; 0x5818 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3468:	8a 81       	ldd	r24, Y+2	; 0x02
    346a:	9b 81       	ldd	r25, Y+3	; 0x03
    346c:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3470:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    3474:	88 23       	and	r24, r24
    3476:	09 f0       	breq	.+2      	; 0x347a <xQueueSemaphoreTake+0x100>
    3478:	93 cf       	rjmp	.-218    	; 0x33a0 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    347a:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    347e:	90 cf       	rjmp	.-224    	; 0x33a0 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    3480:	8a 81       	ldd	r24, Y+2	; 0x02
    3482:	9b 81       	ldd	r25, Y+3	; 0x03
    3484:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3488:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    348c:	89 cf       	rjmp	.-238    	; 0x33a0 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    348e:	8a 81       	ldd	r24, Y+2	; 0x02
    3490:	9b 81       	ldd	r25, Y+3	; 0x03
    3492:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3496:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    349a:	8a 81       	ldd	r24, Y+2	; 0x02
    349c:	9b 81       	ldd	r25, Y+3	; 0x03
    349e:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <prvIsQueueEmpty>
    34a2:	88 23       	and	r24, r24
    34a4:	09 f4       	brne	.+2      	; 0x34a8 <xQueueSemaphoreTake+0x12e>
    34a6:	7c cf       	rjmp	.-264    	; 0x33a0 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    34a8:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    34aa:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    34ac:	2c 96       	adiw	r28, 0x0c	; 12
    34ae:	0f b6       	in	r0, 0x3f	; 63
    34b0:	f8 94       	cli
    34b2:	de bf       	out	0x3e, r29	; 62
    34b4:	0f be       	out	0x3f, r0	; 63
    34b6:	cd bf       	out	0x3d, r28	; 61
    34b8:	cf 91       	pop	r28
    34ba:	df 91       	pop	r29
    34bc:	08 95       	ret

000034be <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    34be:	df 93       	push	r29
    34c0:	cf 93       	push	r28
    34c2:	cd b7       	in	r28, 0x3d	; 61
    34c4:	de b7       	in	r29, 0x3e	; 62
    34c6:	60 97       	sbiw	r28, 0x10	; 16
    34c8:	0f b6       	in	r0, 0x3f	; 63
    34ca:	f8 94       	cli
    34cc:	de bf       	out	0x3e, r29	; 62
    34ce:	0f be       	out	0x3f, r0	; 63
    34d0:	cd bf       	out	0x3d, r28	; 61
    34d2:	9b 87       	std	Y+11, r25	; 0x0b
    34d4:	8a 87       	std	Y+10, r24	; 0x0a
    34d6:	7d 87       	std	Y+13, r23	; 0x0d
    34d8:	6c 87       	std	Y+12, r22	; 0x0c
    34da:	5f 87       	std	Y+15, r21	; 0x0f
    34dc:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    34de:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    34e0:	8a 85       	ldd	r24, Y+10	; 0x0a
    34e2:	9b 85       	ldd	r25, Y+11	; 0x0b
    34e4:	9b 83       	std	Y+3, r25	; 0x03
    34e6:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    34e8:	0f b6       	in	r0, 0x3f	; 63
    34ea:	f8 94       	cli
    34ec:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    34ee:	ea 81       	ldd	r30, Y+2	; 0x02
    34f0:	fb 81       	ldd	r31, Y+3	; 0x03
    34f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    34f4:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    34f6:	89 81       	ldd	r24, Y+1	; 0x01
    34f8:	88 23       	and	r24, r24
    34fa:	31 f1       	breq	.+76     	; 0x3548 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    34fc:	ea 81       	ldd	r30, Y+2	; 0x02
    34fe:	fb 81       	ldd	r31, Y+3	; 0x03
    3500:	86 81       	ldd	r24, Z+6	; 0x06
    3502:	97 81       	ldd	r25, Z+7	; 0x07
    3504:	9d 83       	std	Y+5, r25	; 0x05
    3506:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3508:	8a 81       	ldd	r24, Y+2	; 0x02
    350a:	9b 81       	ldd	r25, Y+3	; 0x03
    350c:	2c 85       	ldd	r18, Y+12	; 0x0c
    350e:	3d 85       	ldd	r19, Y+13	; 0x0d
    3510:	b9 01       	movw	r22, r18
    3512:	0e 94 b5 1c 	call	0x396a	; 0x396a <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3516:	ea 81       	ldd	r30, Y+2	; 0x02
    3518:	fb 81       	ldd	r31, Y+3	; 0x03
    351a:	8c 81       	ldd	r24, Y+4	; 0x04
    351c:	9d 81       	ldd	r25, Y+5	; 0x05
    351e:	97 83       	std	Z+7, r25	; 0x07
    3520:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3522:	ea 81       	ldd	r30, Y+2	; 0x02
    3524:	fb 81       	ldd	r31, Y+3	; 0x03
    3526:	81 89       	ldd	r24, Z+17	; 0x11
    3528:	88 23       	and	r24, r24
    352a:	49 f0       	breq	.+18     	; 0x353e <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    352c:	8a 81       	ldd	r24, Y+2	; 0x02
    352e:	9b 81       	ldd	r25, Y+3	; 0x03
    3530:	41 96       	adiw	r24, 0x11	; 17
    3532:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <xTaskRemoveFromEventList>
    3536:	88 23       	and	r24, r24
    3538:	11 f0       	breq	.+4      	; 0x353e <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    353a:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    353e:	0f 90       	pop	r0
    3540:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	88 8b       	std	Y+16, r24	; 0x10
    3546:	63 c0       	rjmp	.+198    	; 0x360e <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3548:	8e 85       	ldd	r24, Y+14	; 0x0e
    354a:	9f 85       	ldd	r25, Y+15	; 0x0f
    354c:	00 97       	sbiw	r24, 0x00	; 0
    354e:	21 f4       	brne	.+8      	; 0x3558 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3550:	0f 90       	pop	r0
    3552:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3554:	18 8a       	std	Y+16, r1	; 0x10
    3556:	5b c0       	rjmp	.+182    	; 0x360e <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    3558:	8e 81       	ldd	r24, Y+6	; 0x06
    355a:	88 23       	and	r24, r24
    355c:	31 f4       	brne	.+12     	; 0x356a <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    355e:	ce 01       	movw	r24, r28
    3560:	07 96       	adiw	r24, 0x07	; 7
    3562:	0e 94 44 2d 	call	0x5a88	; 0x5a88 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3566:	81 e0       	ldi	r24, 0x01	; 1
    3568:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    356a:	0f 90       	pop	r0
    356c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    356e:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3572:	0f b6       	in	r0, 0x3f	; 63
    3574:	f8 94       	cli
    3576:	0f 92       	push	r0
    3578:	ea 81       	ldd	r30, Y+2	; 0x02
    357a:	fb 81       	ldd	r31, Y+3	; 0x03
    357c:	85 8d       	ldd	r24, Z+29	; 0x1d
    357e:	8f 3f       	cpi	r24, 0xFF	; 255
    3580:	19 f4       	brne	.+6      	; 0x3588 <xQueuePeek+0xca>
    3582:	ea 81       	ldd	r30, Y+2	; 0x02
    3584:	fb 81       	ldd	r31, Y+3	; 0x03
    3586:	15 8e       	std	Z+29, r1	; 0x1d
    3588:	ea 81       	ldd	r30, Y+2	; 0x02
    358a:	fb 81       	ldd	r31, Y+3	; 0x03
    358c:	86 8d       	ldd	r24, Z+30	; 0x1e
    358e:	8f 3f       	cpi	r24, 0xFF	; 255
    3590:	19 f4       	brne	.+6      	; 0x3598 <xQueuePeek+0xda>
    3592:	ea 81       	ldd	r30, Y+2	; 0x02
    3594:	fb 81       	ldd	r31, Y+3	; 0x03
    3596:	16 8e       	std	Z+30, r1	; 0x1e
    3598:	0f 90       	pop	r0
    359a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    359c:	ce 01       	movw	r24, r28
    359e:	07 96       	adiw	r24, 0x07	; 7
    35a0:	9e 01       	movw	r18, r28
    35a2:	22 5f       	subi	r18, 0xF2	; 242
    35a4:	3f 4f       	sbci	r19, 0xFF	; 255
    35a6:	b9 01       	movw	r22, r18
    35a8:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <xTaskCheckForTimeOut>
    35ac:	88 23       	and	r24, r24
    35ae:	09 f5       	brne	.+66     	; 0x35f2 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    35b0:	8a 81       	ldd	r24, Y+2	; 0x02
    35b2:	9b 81       	ldd	r25, Y+3	; 0x03
    35b4:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <prvIsQueueEmpty>
    35b8:	88 23       	and	r24, r24
    35ba:	a1 f0       	breq	.+40     	; 0x35e4 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    35bc:	8a 81       	ldd	r24, Y+2	; 0x02
    35be:	9b 81       	ldd	r25, Y+3	; 0x03
    35c0:	41 96       	adiw	r24, 0x11	; 17
    35c2:	2e 85       	ldd	r18, Y+14	; 0x0e
    35c4:	3f 85       	ldd	r19, Y+15	; 0x0f
    35c6:	b9 01       	movw	r22, r18
    35c8:	0e 94 0c 2c 	call	0x5818	; 0x5818 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    35cc:	8a 81       	ldd	r24, Y+2	; 0x02
    35ce:	9b 81       	ldd	r25, Y+3	; 0x03
    35d0:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    35d4:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    35d8:	88 23       	and	r24, r24
    35da:	09 f0       	breq	.+2      	; 0x35de <xQueuePeek+0x120>
    35dc:	85 cf       	rjmp	.-246    	; 0x34e8 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    35de:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    35e2:	82 cf       	rjmp	.-252    	; 0x34e8 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    35e4:	8a 81       	ldd	r24, Y+2	; 0x02
    35e6:	9b 81       	ldd	r25, Y+3	; 0x03
    35e8:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    35ec:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    35f0:	7b cf       	rjmp	.-266    	; 0x34e8 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    35f2:	8a 81       	ldd	r24, Y+2	; 0x02
    35f4:	9b 81       	ldd	r25, Y+3	; 0x03
    35f6:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    35fa:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    35fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3600:	9b 81       	ldd	r25, Y+3	; 0x03
    3602:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <prvIsQueueEmpty>
    3606:	88 23       	and	r24, r24
    3608:	09 f4       	brne	.+2      	; 0x360c <xQueuePeek+0x14e>
    360a:	6e cf       	rjmp	.-292    	; 0x34e8 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    360c:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    360e:	88 89       	ldd	r24, Y+16	; 0x10
}
    3610:	60 96       	adiw	r28, 0x10	; 16
    3612:	0f b6       	in	r0, 0x3f	; 63
    3614:	f8 94       	cli
    3616:	de bf       	out	0x3e, r29	; 62
    3618:	0f be       	out	0x3f, r0	; 63
    361a:	cd bf       	out	0x3d, r28	; 61
    361c:	cf 91       	pop	r28
    361e:	df 91       	pop	r29
    3620:	08 95       	ret

00003622 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3622:	df 93       	push	r29
    3624:	cf 93       	push	r28
    3626:	cd b7       	in	r28, 0x3d	; 61
    3628:	de b7       	in	r29, 0x3e	; 62
    362a:	2c 97       	sbiw	r28, 0x0c	; 12
    362c:	0f b6       	in	r0, 0x3f	; 63
    362e:	f8 94       	cli
    3630:	de bf       	out	0x3e, r29	; 62
    3632:	0f be       	out	0x3f, r0	; 63
    3634:	cd bf       	out	0x3d, r28	; 61
    3636:	98 87       	std	Y+8, r25	; 0x08
    3638:	8f 83       	std	Y+7, r24	; 0x07
    363a:	7a 87       	std	Y+10, r23	; 0x0a
    363c:	69 87       	std	Y+9, r22	; 0x09
    363e:	5c 87       	std	Y+12, r21	; 0x0c
    3640:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3642:	8f 81       	ldd	r24, Y+7	; 0x07
    3644:	98 85       	ldd	r25, Y+8	; 0x08
    3646:	9c 83       	std	Y+4, r25	; 0x04
    3648:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    364a:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    364c:	eb 81       	ldd	r30, Y+3	; 0x03
    364e:	fc 81       	ldd	r31, Y+4	; 0x04
    3650:	82 8d       	ldd	r24, Z+26	; 0x1a
    3652:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3654:	8a 81       	ldd	r24, Y+2	; 0x02
    3656:	88 23       	and	r24, r24
    3658:	81 f1       	breq	.+96     	; 0x36ba <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    365a:	eb 81       	ldd	r30, Y+3	; 0x03
    365c:	fc 81       	ldd	r31, Y+4	; 0x04
    365e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3660:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3662:	8b 81       	ldd	r24, Y+3	; 0x03
    3664:	9c 81       	ldd	r25, Y+4	; 0x04
    3666:	29 85       	ldd	r18, Y+9	; 0x09
    3668:	3a 85       	ldd	r19, Y+10	; 0x0a
    366a:	b9 01       	movw	r22, r18
    366c:	0e 94 b5 1c 	call	0x396a	; 0x396a <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3670:	8a 81       	ldd	r24, Y+2	; 0x02
    3672:	81 50       	subi	r24, 0x01	; 1
    3674:	eb 81       	ldd	r30, Y+3	; 0x03
    3676:	fc 81       	ldd	r31, Y+4	; 0x04
    3678:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    367a:	89 81       	ldd	r24, Y+1	; 0x01
    367c:	8f 3f       	cpi	r24, 0xFF	; 255
    367e:	a9 f4       	brne	.+42     	; 0x36aa <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3680:	eb 81       	ldd	r30, Y+3	; 0x03
    3682:	fc 81       	ldd	r31, Y+4	; 0x04
    3684:	80 85       	ldd	r24, Z+8	; 0x08
    3686:	88 23       	and	r24, r24
    3688:	a9 f0       	breq	.+42     	; 0x36b4 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    368a:	8b 81       	ldd	r24, Y+3	; 0x03
    368c:	9c 81       	ldd	r25, Y+4	; 0x04
    368e:	08 96       	adiw	r24, 0x08	; 8
    3690:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <xTaskRemoveFromEventList>
    3694:	88 23       	and	r24, r24
    3696:	71 f0       	breq	.+28     	; 0x36b4 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3698:	8b 85       	ldd	r24, Y+11	; 0x0b
    369a:	9c 85       	ldd	r25, Y+12	; 0x0c
    369c:	00 97       	sbiw	r24, 0x00	; 0
    369e:	51 f0       	breq	.+20     	; 0x36b4 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    36a0:	eb 85       	ldd	r30, Y+11	; 0x0b
    36a2:	fc 85       	ldd	r31, Y+12	; 0x0c
    36a4:	81 e0       	ldi	r24, 0x01	; 1
    36a6:	80 83       	st	Z, r24
    36a8:	05 c0       	rjmp	.+10     	; 0x36b4 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    36aa:	89 81       	ldd	r24, Y+1	; 0x01
    36ac:	8f 5f       	subi	r24, 0xFF	; 255
    36ae:	eb 81       	ldd	r30, Y+3	; 0x03
    36b0:	fc 81       	ldd	r31, Y+4	; 0x04
    36b2:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    36b4:	81 e0       	ldi	r24, 0x01	; 1
    36b6:	8e 83       	std	Y+6, r24	; 0x06
    36b8:	01 c0       	rjmp	.+2      	; 0x36bc <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    36ba:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    36bc:	8e 81       	ldd	r24, Y+6	; 0x06
}
    36be:	2c 96       	adiw	r28, 0x0c	; 12
    36c0:	0f b6       	in	r0, 0x3f	; 63
    36c2:	f8 94       	cli
    36c4:	de bf       	out	0x3e, r29	; 62
    36c6:	0f be       	out	0x3f, r0	; 63
    36c8:	cd bf       	out	0x3d, r28	; 61
    36ca:	cf 91       	pop	r28
    36cc:	df 91       	pop	r29
    36ce:	08 95       	ret

000036d0 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    36d0:	df 93       	push	r29
    36d2:	cf 93       	push	r28
    36d4:	cd b7       	in	r28, 0x3d	; 61
    36d6:	de b7       	in	r29, 0x3e	; 62
    36d8:	2a 97       	sbiw	r28, 0x0a	; 10
    36da:	0f b6       	in	r0, 0x3f	; 63
    36dc:	f8 94       	cli
    36de:	de bf       	out	0x3e, r29	; 62
    36e0:	0f be       	out	0x3f, r0	; 63
    36e2:	cd bf       	out	0x3d, r28	; 61
    36e4:	98 87       	std	Y+8, r25	; 0x08
    36e6:	8f 83       	std	Y+7, r24	; 0x07
    36e8:	7a 87       	std	Y+10, r23	; 0x0a
    36ea:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    36ec:	8f 81       	ldd	r24, Y+7	; 0x07
    36ee:	98 85       	ldd	r25, Y+8	; 0x08
    36f0:	9a 83       	std	Y+2, r25	; 0x02
    36f2:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    36f4:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    36f6:	e9 81       	ldd	r30, Y+1	; 0x01
    36f8:	fa 81       	ldd	r31, Y+2	; 0x02
    36fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    36fc:	88 23       	and	r24, r24
    36fe:	b1 f0       	breq	.+44     	; 0x372c <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3700:	e9 81       	ldd	r30, Y+1	; 0x01
    3702:	fa 81       	ldd	r31, Y+2	; 0x02
    3704:	86 81       	ldd	r24, Z+6	; 0x06
    3706:	97 81       	ldd	r25, Z+7	; 0x07
    3708:	9c 83       	std	Y+4, r25	; 0x04
    370a:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    370c:	89 81       	ldd	r24, Y+1	; 0x01
    370e:	9a 81       	ldd	r25, Y+2	; 0x02
    3710:	29 85       	ldd	r18, Y+9	; 0x09
    3712:	3a 85       	ldd	r19, Y+10	; 0x0a
    3714:	b9 01       	movw	r22, r18
    3716:	0e 94 b5 1c 	call	0x396a	; 0x396a <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    371a:	e9 81       	ldd	r30, Y+1	; 0x01
    371c:	fa 81       	ldd	r31, Y+2	; 0x02
    371e:	8b 81       	ldd	r24, Y+3	; 0x03
    3720:	9c 81       	ldd	r25, Y+4	; 0x04
    3722:	97 83       	std	Z+7, r25	; 0x07
    3724:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    3726:	81 e0       	ldi	r24, 0x01	; 1
    3728:	8e 83       	std	Y+6, r24	; 0x06
    372a:	01 c0       	rjmp	.+2      	; 0x372e <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    372c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    372e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3730:	2a 96       	adiw	r28, 0x0a	; 10
    3732:	0f b6       	in	r0, 0x3f	; 63
    3734:	f8 94       	cli
    3736:	de bf       	out	0x3e, r29	; 62
    3738:	0f be       	out	0x3f, r0	; 63
    373a:	cd bf       	out	0x3d, r28	; 61
    373c:	cf 91       	pop	r28
    373e:	df 91       	pop	r29
    3740:	08 95       	ret

00003742 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3742:	df 93       	push	r29
    3744:	cf 93       	push	r28
    3746:	00 d0       	rcall	.+0      	; 0x3748 <uxQueueMessagesWaiting+0x6>
    3748:	0f 92       	push	r0
    374a:	cd b7       	in	r28, 0x3d	; 61
    374c:	de b7       	in	r29, 0x3e	; 62
    374e:	9b 83       	std	Y+3, r25	; 0x03
    3750:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3752:	0f b6       	in	r0, 0x3f	; 63
    3754:	f8 94       	cli
    3756:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3758:	ea 81       	ldd	r30, Y+2	; 0x02
    375a:	fb 81       	ldd	r31, Y+3	; 0x03
    375c:	82 8d       	ldd	r24, Z+26	; 0x1a
    375e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3760:	0f 90       	pop	r0
    3762:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3764:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3766:	0f 90       	pop	r0
    3768:	0f 90       	pop	r0
    376a:	0f 90       	pop	r0
    376c:	cf 91       	pop	r28
    376e:	df 91       	pop	r29
    3770:	08 95       	ret

00003772 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3772:	df 93       	push	r29
    3774:	cf 93       	push	r28
    3776:	00 d0       	rcall	.+0      	; 0x3778 <uxQueueSpacesAvailable+0x6>
    3778:	00 d0       	rcall	.+0      	; 0x377a <uxQueueSpacesAvailable+0x8>
    377a:	0f 92       	push	r0
    377c:	cd b7       	in	r28, 0x3d	; 61
    377e:	de b7       	in	r29, 0x3e	; 62
    3780:	9d 83       	std	Y+5, r25	; 0x05
    3782:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3784:	8c 81       	ldd	r24, Y+4	; 0x04
    3786:	9d 81       	ldd	r25, Y+5	; 0x05
    3788:	9a 83       	std	Y+2, r25	; 0x02
    378a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    378c:	0f b6       	in	r0, 0x3f	; 63
    378e:	f8 94       	cli
    3790:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3792:	e9 81       	ldd	r30, Y+1	; 0x01
    3794:	fa 81       	ldd	r31, Y+2	; 0x02
    3796:	93 8d       	ldd	r25, Z+27	; 0x1b
    3798:	e9 81       	ldd	r30, Y+1	; 0x01
    379a:	fa 81       	ldd	r31, Y+2	; 0x02
    379c:	82 8d       	ldd	r24, Z+26	; 0x1a
    379e:	29 2f       	mov	r18, r25
    37a0:	28 1b       	sub	r18, r24
    37a2:	82 2f       	mov	r24, r18
    37a4:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    37a6:	0f 90       	pop	r0
    37a8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    37aa:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    37ac:	0f 90       	pop	r0
    37ae:	0f 90       	pop	r0
    37b0:	0f 90       	pop	r0
    37b2:	0f 90       	pop	r0
    37b4:	0f 90       	pop	r0
    37b6:	cf 91       	pop	r28
    37b8:	df 91       	pop	r29
    37ba:	08 95       	ret

000037bc <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    37bc:	df 93       	push	r29
    37be:	cf 93       	push	r28
    37c0:	00 d0       	rcall	.+0      	; 0x37c2 <uxQueueMessagesWaitingFromISR+0x6>
    37c2:	00 d0       	rcall	.+0      	; 0x37c4 <uxQueueMessagesWaitingFromISR+0x8>
    37c4:	0f 92       	push	r0
    37c6:	cd b7       	in	r28, 0x3d	; 61
    37c8:	de b7       	in	r29, 0x3e	; 62
    37ca:	9d 83       	std	Y+5, r25	; 0x05
    37cc:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    37ce:	8c 81       	ldd	r24, Y+4	; 0x04
    37d0:	9d 81       	ldd	r25, Y+5	; 0x05
    37d2:	9a 83       	std	Y+2, r25	; 0x02
    37d4:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    37d6:	e9 81       	ldd	r30, Y+1	; 0x01
    37d8:	fa 81       	ldd	r31, Y+2	; 0x02
    37da:	82 8d       	ldd	r24, Z+26	; 0x1a
    37dc:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    37de:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    37e0:	0f 90       	pop	r0
    37e2:	0f 90       	pop	r0
    37e4:	0f 90       	pop	r0
    37e6:	0f 90       	pop	r0
    37e8:	0f 90       	pop	r0
    37ea:	cf 91       	pop	r28
    37ec:	df 91       	pop	r29
    37ee:	08 95       	ret

000037f0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    37f0:	df 93       	push	r29
    37f2:	cf 93       	push	r28
    37f4:	00 d0       	rcall	.+0      	; 0x37f6 <vQueueDelete+0x6>
    37f6:	00 d0       	rcall	.+0      	; 0x37f8 <vQueueDelete+0x8>
    37f8:	cd b7       	in	r28, 0x3d	; 61
    37fa:	de b7       	in	r29, 0x3e	; 62
    37fc:	9c 83       	std	Y+4, r25	; 0x04
    37fe:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    3800:	8b 81       	ldd	r24, Y+3	; 0x03
    3802:	9c 81       	ldd	r25, Y+4	; 0x04
    3804:	9a 83       	std	Y+2, r25	; 0x02
    3806:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    3808:	89 81       	ldd	r24, Y+1	; 0x01
    380a:	9a 81       	ldd	r25, Y+2	; 0x02
    380c:	0e 94 a5 11 	call	0x234a	; 0x234a <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3810:	0f 90       	pop	r0
    3812:	0f 90       	pop	r0
    3814:	0f 90       	pop	r0
    3816:	0f 90       	pop	r0
    3818:	cf 91       	pop	r28
    381a:	df 91       	pop	r29
    381c:	08 95       	ret

0000381e <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    381e:	df 93       	push	r29
    3820:	cf 93       	push	r28
    3822:	cd b7       	in	r28, 0x3d	; 61
    3824:	de b7       	in	r29, 0x3e	; 62
    3826:	27 97       	sbiw	r28, 0x07	; 7
    3828:	0f b6       	in	r0, 0x3f	; 63
    382a:	f8 94       	cli
    382c:	de bf       	out	0x3e, r29	; 62
    382e:	0f be       	out	0x3f, r0	; 63
    3830:	cd bf       	out	0x3d, r28	; 61
    3832:	9c 83       	std	Y+4, r25	; 0x04
    3834:	8b 83       	std	Y+3, r24	; 0x03
    3836:	7e 83       	std	Y+6, r23	; 0x06
    3838:	6d 83       	std	Y+5, r22	; 0x05
    383a:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    383c:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    383e:	eb 81       	ldd	r30, Y+3	; 0x03
    3840:	fc 81       	ldd	r31, Y+4	; 0x04
    3842:	82 8d       	ldd	r24, Z+26	; 0x1a
    3844:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3846:	eb 81       	ldd	r30, Y+3	; 0x03
    3848:	fc 81       	ldd	r31, Y+4	; 0x04
    384a:	84 8d       	ldd	r24, Z+28	; 0x1c
    384c:	88 23       	and	r24, r24
    384e:	09 f4       	brne	.+2      	; 0x3852 <prvCopyDataToQueue+0x34>
    3850:	7d c0       	rjmp	.+250    	; 0x394c <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3852:	8f 81       	ldd	r24, Y+7	; 0x07
    3854:	88 23       	and	r24, r24
    3856:	99 f5       	brne	.+102    	; 0x38be <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3858:	eb 81       	ldd	r30, Y+3	; 0x03
    385a:	fc 81       	ldd	r31, Y+4	; 0x04
    385c:	62 81       	ldd	r22, Z+2	; 0x02
    385e:	73 81       	ldd	r23, Z+3	; 0x03
    3860:	eb 81       	ldd	r30, Y+3	; 0x03
    3862:	fc 81       	ldd	r31, Y+4	; 0x04
    3864:	84 8d       	ldd	r24, Z+28	; 0x1c
    3866:	48 2f       	mov	r20, r24
    3868:	50 e0       	ldi	r21, 0x00	; 0
    386a:	2d 81       	ldd	r18, Y+5	; 0x05
    386c:	3e 81       	ldd	r19, Y+6	; 0x06
    386e:	cb 01       	movw	r24, r22
    3870:	b9 01       	movw	r22, r18
    3872:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3876:	eb 81       	ldd	r30, Y+3	; 0x03
    3878:	fc 81       	ldd	r31, Y+4	; 0x04
    387a:	22 81       	ldd	r18, Z+2	; 0x02
    387c:	33 81       	ldd	r19, Z+3	; 0x03
    387e:	eb 81       	ldd	r30, Y+3	; 0x03
    3880:	fc 81       	ldd	r31, Y+4	; 0x04
    3882:	84 8d       	ldd	r24, Z+28	; 0x1c
    3884:	88 2f       	mov	r24, r24
    3886:	90 e0       	ldi	r25, 0x00	; 0
    3888:	82 0f       	add	r24, r18
    388a:	93 1f       	adc	r25, r19
    388c:	eb 81       	ldd	r30, Y+3	; 0x03
    388e:	fc 81       	ldd	r31, Y+4	; 0x04
    3890:	93 83       	std	Z+3, r25	; 0x03
    3892:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3894:	eb 81       	ldd	r30, Y+3	; 0x03
    3896:	fc 81       	ldd	r31, Y+4	; 0x04
    3898:	22 81       	ldd	r18, Z+2	; 0x02
    389a:	33 81       	ldd	r19, Z+3	; 0x03
    389c:	eb 81       	ldd	r30, Y+3	; 0x03
    389e:	fc 81       	ldd	r31, Y+4	; 0x04
    38a0:	84 81       	ldd	r24, Z+4	; 0x04
    38a2:	95 81       	ldd	r25, Z+5	; 0x05
    38a4:	28 17       	cp	r18, r24
    38a6:	39 07       	cpc	r19, r25
    38a8:	08 f4       	brcc	.+2      	; 0x38ac <prvCopyDataToQueue+0x8e>
    38aa:	50 c0       	rjmp	.+160    	; 0x394c <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    38ac:	eb 81       	ldd	r30, Y+3	; 0x03
    38ae:	fc 81       	ldd	r31, Y+4	; 0x04
    38b0:	80 81       	ld	r24, Z
    38b2:	91 81       	ldd	r25, Z+1	; 0x01
    38b4:	eb 81       	ldd	r30, Y+3	; 0x03
    38b6:	fc 81       	ldd	r31, Y+4	; 0x04
    38b8:	93 83       	std	Z+3, r25	; 0x03
    38ba:	82 83       	std	Z+2, r24	; 0x02
    38bc:	47 c0       	rjmp	.+142    	; 0x394c <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    38be:	eb 81       	ldd	r30, Y+3	; 0x03
    38c0:	fc 81       	ldd	r31, Y+4	; 0x04
    38c2:	66 81       	ldd	r22, Z+6	; 0x06
    38c4:	77 81       	ldd	r23, Z+7	; 0x07
    38c6:	eb 81       	ldd	r30, Y+3	; 0x03
    38c8:	fc 81       	ldd	r31, Y+4	; 0x04
    38ca:	84 8d       	ldd	r24, Z+28	; 0x1c
    38cc:	48 2f       	mov	r20, r24
    38ce:	50 e0       	ldi	r21, 0x00	; 0
    38d0:	2d 81       	ldd	r18, Y+5	; 0x05
    38d2:	3e 81       	ldd	r19, Y+6	; 0x06
    38d4:	cb 01       	movw	r24, r22
    38d6:	b9 01       	movw	r22, r18
    38d8:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    38dc:	eb 81       	ldd	r30, Y+3	; 0x03
    38de:	fc 81       	ldd	r31, Y+4	; 0x04
    38e0:	26 81       	ldd	r18, Z+6	; 0x06
    38e2:	37 81       	ldd	r19, Z+7	; 0x07
    38e4:	eb 81       	ldd	r30, Y+3	; 0x03
    38e6:	fc 81       	ldd	r31, Y+4	; 0x04
    38e8:	84 8d       	ldd	r24, Z+28	; 0x1c
    38ea:	88 2f       	mov	r24, r24
    38ec:	90 e0       	ldi	r25, 0x00	; 0
    38ee:	90 95       	com	r25
    38f0:	81 95       	neg	r24
    38f2:	9f 4f       	sbci	r25, 0xFF	; 255
    38f4:	82 0f       	add	r24, r18
    38f6:	93 1f       	adc	r25, r19
    38f8:	eb 81       	ldd	r30, Y+3	; 0x03
    38fa:	fc 81       	ldd	r31, Y+4	; 0x04
    38fc:	97 83       	std	Z+7, r25	; 0x07
    38fe:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3900:	eb 81       	ldd	r30, Y+3	; 0x03
    3902:	fc 81       	ldd	r31, Y+4	; 0x04
    3904:	26 81       	ldd	r18, Z+6	; 0x06
    3906:	37 81       	ldd	r19, Z+7	; 0x07
    3908:	eb 81       	ldd	r30, Y+3	; 0x03
    390a:	fc 81       	ldd	r31, Y+4	; 0x04
    390c:	80 81       	ld	r24, Z
    390e:	91 81       	ldd	r25, Z+1	; 0x01
    3910:	28 17       	cp	r18, r24
    3912:	39 07       	cpc	r19, r25
    3914:	90 f4       	brcc	.+36     	; 0x393a <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3916:	eb 81       	ldd	r30, Y+3	; 0x03
    3918:	fc 81       	ldd	r31, Y+4	; 0x04
    391a:	24 81       	ldd	r18, Z+4	; 0x04
    391c:	35 81       	ldd	r19, Z+5	; 0x05
    391e:	eb 81       	ldd	r30, Y+3	; 0x03
    3920:	fc 81       	ldd	r31, Y+4	; 0x04
    3922:	84 8d       	ldd	r24, Z+28	; 0x1c
    3924:	88 2f       	mov	r24, r24
    3926:	90 e0       	ldi	r25, 0x00	; 0
    3928:	90 95       	com	r25
    392a:	81 95       	neg	r24
    392c:	9f 4f       	sbci	r25, 0xFF	; 255
    392e:	82 0f       	add	r24, r18
    3930:	93 1f       	adc	r25, r19
    3932:	eb 81       	ldd	r30, Y+3	; 0x03
    3934:	fc 81       	ldd	r31, Y+4	; 0x04
    3936:	97 83       	std	Z+7, r25	; 0x07
    3938:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    393a:	8f 81       	ldd	r24, Y+7	; 0x07
    393c:	82 30       	cpi	r24, 0x02	; 2
    393e:	31 f4       	brne	.+12     	; 0x394c <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3940:	89 81       	ldd	r24, Y+1	; 0x01
    3942:	88 23       	and	r24, r24
    3944:	19 f0       	breq	.+6      	; 0x394c <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3946:	89 81       	ldd	r24, Y+1	; 0x01
    3948:	81 50       	subi	r24, 0x01	; 1
    394a:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    394c:	89 81       	ldd	r24, Y+1	; 0x01
    394e:	8f 5f       	subi	r24, 0xFF	; 255
    3950:	eb 81       	ldd	r30, Y+3	; 0x03
    3952:	fc 81       	ldd	r31, Y+4	; 0x04
    3954:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    3956:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3958:	27 96       	adiw	r28, 0x07	; 7
    395a:	0f b6       	in	r0, 0x3f	; 63
    395c:	f8 94       	cli
    395e:	de bf       	out	0x3e, r29	; 62
    3960:	0f be       	out	0x3f, r0	; 63
    3962:	cd bf       	out	0x3d, r28	; 61
    3964:	cf 91       	pop	r28
    3966:	df 91       	pop	r29
    3968:	08 95       	ret

0000396a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    396a:	df 93       	push	r29
    396c:	cf 93       	push	r28
    396e:	00 d0       	rcall	.+0      	; 0x3970 <prvCopyDataFromQueue+0x6>
    3970:	00 d0       	rcall	.+0      	; 0x3972 <prvCopyDataFromQueue+0x8>
    3972:	cd b7       	in	r28, 0x3d	; 61
    3974:	de b7       	in	r29, 0x3e	; 62
    3976:	9a 83       	std	Y+2, r25	; 0x02
    3978:	89 83       	std	Y+1, r24	; 0x01
    397a:	7c 83       	std	Y+4, r23	; 0x04
    397c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    397e:	e9 81       	ldd	r30, Y+1	; 0x01
    3980:	fa 81       	ldd	r31, Y+2	; 0x02
    3982:	84 8d       	ldd	r24, Z+28	; 0x1c
    3984:	88 23       	and	r24, r24
    3986:	89 f1       	breq	.+98     	; 0x39ea <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3988:	e9 81       	ldd	r30, Y+1	; 0x01
    398a:	fa 81       	ldd	r31, Y+2	; 0x02
    398c:	26 81       	ldd	r18, Z+6	; 0x06
    398e:	37 81       	ldd	r19, Z+7	; 0x07
    3990:	e9 81       	ldd	r30, Y+1	; 0x01
    3992:	fa 81       	ldd	r31, Y+2	; 0x02
    3994:	84 8d       	ldd	r24, Z+28	; 0x1c
    3996:	88 2f       	mov	r24, r24
    3998:	90 e0       	ldi	r25, 0x00	; 0
    399a:	82 0f       	add	r24, r18
    399c:	93 1f       	adc	r25, r19
    399e:	e9 81       	ldd	r30, Y+1	; 0x01
    39a0:	fa 81       	ldd	r31, Y+2	; 0x02
    39a2:	97 83       	std	Z+7, r25	; 0x07
    39a4:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    39a6:	e9 81       	ldd	r30, Y+1	; 0x01
    39a8:	fa 81       	ldd	r31, Y+2	; 0x02
    39aa:	26 81       	ldd	r18, Z+6	; 0x06
    39ac:	37 81       	ldd	r19, Z+7	; 0x07
    39ae:	e9 81       	ldd	r30, Y+1	; 0x01
    39b0:	fa 81       	ldd	r31, Y+2	; 0x02
    39b2:	84 81       	ldd	r24, Z+4	; 0x04
    39b4:	95 81       	ldd	r25, Z+5	; 0x05
    39b6:	28 17       	cp	r18, r24
    39b8:	39 07       	cpc	r19, r25
    39ba:	40 f0       	brcs	.+16     	; 0x39cc <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    39bc:	e9 81       	ldd	r30, Y+1	; 0x01
    39be:	fa 81       	ldd	r31, Y+2	; 0x02
    39c0:	80 81       	ld	r24, Z
    39c2:	91 81       	ldd	r25, Z+1	; 0x01
    39c4:	e9 81       	ldd	r30, Y+1	; 0x01
    39c6:	fa 81       	ldd	r31, Y+2	; 0x02
    39c8:	97 83       	std	Z+7, r25	; 0x07
    39ca:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    39cc:	e9 81       	ldd	r30, Y+1	; 0x01
    39ce:	fa 81       	ldd	r31, Y+2	; 0x02
    39d0:	46 81       	ldd	r20, Z+6	; 0x06
    39d2:	57 81       	ldd	r21, Z+7	; 0x07
    39d4:	e9 81       	ldd	r30, Y+1	; 0x01
    39d6:	fa 81       	ldd	r31, Y+2	; 0x02
    39d8:	84 8d       	ldd	r24, Z+28	; 0x1c
    39da:	28 2f       	mov	r18, r24
    39dc:	30 e0       	ldi	r19, 0x00	; 0
    39de:	8b 81       	ldd	r24, Y+3	; 0x03
    39e0:	9c 81       	ldd	r25, Y+4	; 0x04
    39e2:	ba 01       	movw	r22, r20
    39e4:	a9 01       	movw	r20, r18
    39e6:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <memcpy>
	}
}
    39ea:	0f 90       	pop	r0
    39ec:	0f 90       	pop	r0
    39ee:	0f 90       	pop	r0
    39f0:	0f 90       	pop	r0
    39f2:	cf 91       	pop	r28
    39f4:	df 91       	pop	r29
    39f6:	08 95       	ret

000039f8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    39f8:	df 93       	push	r29
    39fa:	cf 93       	push	r28
    39fc:	00 d0       	rcall	.+0      	; 0x39fe <prvUnlockQueue+0x6>
    39fe:	00 d0       	rcall	.+0      	; 0x3a00 <prvUnlockQueue+0x8>
    3a00:	cd b7       	in	r28, 0x3d	; 61
    3a02:	de b7       	in	r29, 0x3e	; 62
    3a04:	9c 83       	std	Y+4, r25	; 0x04
    3a06:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3a08:	0f b6       	in	r0, 0x3f	; 63
    3a0a:	f8 94       	cli
    3a0c:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3a0e:	eb 81       	ldd	r30, Y+3	; 0x03
    3a10:	fc 81       	ldd	r31, Y+4	; 0x04
    3a12:	86 8d       	ldd	r24, Z+30	; 0x1e
    3a14:	8a 83       	std	Y+2, r24	; 0x02
    3a16:	11 c0       	rjmp	.+34     	; 0x3a3a <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3a18:	eb 81       	ldd	r30, Y+3	; 0x03
    3a1a:	fc 81       	ldd	r31, Y+4	; 0x04
    3a1c:	81 89       	ldd	r24, Z+17	; 0x11
    3a1e:	88 23       	and	r24, r24
    3a20:	79 f0       	breq	.+30     	; 0x3a40 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3a22:	8b 81       	ldd	r24, Y+3	; 0x03
    3a24:	9c 81       	ldd	r25, Y+4	; 0x04
    3a26:	41 96       	adiw	r24, 0x11	; 17
    3a28:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <xTaskRemoveFromEventList>
    3a2c:	88 23       	and	r24, r24
    3a2e:	11 f0       	breq	.+4      	; 0x3a34 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    3a30:	0e 94 ca 2d 	call	0x5b94	; 0x5b94 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3a34:	8a 81       	ldd	r24, Y+2	; 0x02
    3a36:	81 50       	subi	r24, 0x01	; 1
    3a38:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3a3a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a3c:	18 16       	cp	r1, r24
    3a3e:	64 f3       	brlt	.-40     	; 0x3a18 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3a40:	eb 81       	ldd	r30, Y+3	; 0x03
    3a42:	fc 81       	ldd	r31, Y+4	; 0x04
    3a44:	8f ef       	ldi	r24, 0xFF	; 255
    3a46:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3a48:	0f 90       	pop	r0
    3a4a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3a4c:	0f b6       	in	r0, 0x3f	; 63
    3a4e:	f8 94       	cli
    3a50:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3a52:	eb 81       	ldd	r30, Y+3	; 0x03
    3a54:	fc 81       	ldd	r31, Y+4	; 0x04
    3a56:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a58:	89 83       	std	Y+1, r24	; 0x01
    3a5a:	11 c0       	rjmp	.+34     	; 0x3a7e <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3a5c:	eb 81       	ldd	r30, Y+3	; 0x03
    3a5e:	fc 81       	ldd	r31, Y+4	; 0x04
    3a60:	80 85       	ldd	r24, Z+8	; 0x08
    3a62:	88 23       	and	r24, r24
    3a64:	79 f0       	breq	.+30     	; 0x3a84 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3a66:	8b 81       	ldd	r24, Y+3	; 0x03
    3a68:	9c 81       	ldd	r25, Y+4	; 0x04
    3a6a:	08 96       	adiw	r24, 0x08	; 8
    3a6c:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <xTaskRemoveFromEventList>
    3a70:	88 23       	and	r24, r24
    3a72:	11 f0       	breq	.+4      	; 0x3a78 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    3a74:	0e 94 ca 2d 	call	0x5b94	; 0x5b94 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3a78:	89 81       	ldd	r24, Y+1	; 0x01
    3a7a:	81 50       	subi	r24, 0x01	; 1
    3a7c:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3a7e:	89 81       	ldd	r24, Y+1	; 0x01
    3a80:	18 16       	cp	r1, r24
    3a82:	64 f3       	brlt	.-40     	; 0x3a5c <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3a84:	eb 81       	ldd	r30, Y+3	; 0x03
    3a86:	fc 81       	ldd	r31, Y+4	; 0x04
    3a88:	8f ef       	ldi	r24, 0xFF	; 255
    3a8a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3a8c:	0f 90       	pop	r0
    3a8e:	0f be       	out	0x3f, r0	; 63
}
    3a90:	0f 90       	pop	r0
    3a92:	0f 90       	pop	r0
    3a94:	0f 90       	pop	r0
    3a96:	0f 90       	pop	r0
    3a98:	cf 91       	pop	r28
    3a9a:	df 91       	pop	r29
    3a9c:	08 95       	ret

00003a9e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3a9e:	df 93       	push	r29
    3aa0:	cf 93       	push	r28
    3aa2:	00 d0       	rcall	.+0      	; 0x3aa4 <prvIsQueueEmpty+0x6>
    3aa4:	0f 92       	push	r0
    3aa6:	cd b7       	in	r28, 0x3d	; 61
    3aa8:	de b7       	in	r29, 0x3e	; 62
    3aaa:	9b 83       	std	Y+3, r25	; 0x03
    3aac:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3aae:	0f b6       	in	r0, 0x3f	; 63
    3ab0:	f8 94       	cli
    3ab2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3ab4:	ea 81       	ldd	r30, Y+2	; 0x02
    3ab6:	fb 81       	ldd	r31, Y+3	; 0x03
    3ab8:	82 8d       	ldd	r24, Z+26	; 0x1a
    3aba:	88 23       	and	r24, r24
    3abc:	19 f4       	brne	.+6      	; 0x3ac4 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    3abe:	81 e0       	ldi	r24, 0x01	; 1
    3ac0:	89 83       	std	Y+1, r24	; 0x01
    3ac2:	01 c0       	rjmp	.+2      	; 0x3ac6 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    3ac4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3ac6:	0f 90       	pop	r0
    3ac8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3aca:	89 81       	ldd	r24, Y+1	; 0x01
}
    3acc:	0f 90       	pop	r0
    3ace:	0f 90       	pop	r0
    3ad0:	0f 90       	pop	r0
    3ad2:	cf 91       	pop	r28
    3ad4:	df 91       	pop	r29
    3ad6:	08 95       	ret

00003ad8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3ad8:	df 93       	push	r29
    3ada:	cf 93       	push	r28
    3adc:	00 d0       	rcall	.+0      	; 0x3ade <xQueueIsQueueEmptyFromISR+0x6>
    3ade:	00 d0       	rcall	.+0      	; 0x3ae0 <xQueueIsQueueEmptyFromISR+0x8>
    3ae0:	0f 92       	push	r0
    3ae2:	cd b7       	in	r28, 0x3d	; 61
    3ae4:	de b7       	in	r29, 0x3e	; 62
    3ae6:	9d 83       	std	Y+5, r25	; 0x05
    3ae8:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3aea:	8c 81       	ldd	r24, Y+4	; 0x04
    3aec:	9d 81       	ldd	r25, Y+5	; 0x05
    3aee:	9a 83       	std	Y+2, r25	; 0x02
    3af0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3af2:	e9 81       	ldd	r30, Y+1	; 0x01
    3af4:	fa 81       	ldd	r31, Y+2	; 0x02
    3af6:	82 8d       	ldd	r24, Z+26	; 0x1a
    3af8:	88 23       	and	r24, r24
    3afa:	19 f4       	brne	.+6      	; 0x3b02 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    3afc:	81 e0       	ldi	r24, 0x01	; 1
    3afe:	8b 83       	std	Y+3, r24	; 0x03
    3b00:	01 c0       	rjmp	.+2      	; 0x3b04 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    3b02:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3b04:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3b06:	0f 90       	pop	r0
    3b08:	0f 90       	pop	r0
    3b0a:	0f 90       	pop	r0
    3b0c:	0f 90       	pop	r0
    3b0e:	0f 90       	pop	r0
    3b10:	cf 91       	pop	r28
    3b12:	df 91       	pop	r29
    3b14:	08 95       	ret

00003b16 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3b16:	df 93       	push	r29
    3b18:	cf 93       	push	r28
    3b1a:	00 d0       	rcall	.+0      	; 0x3b1c <prvIsQueueFull+0x6>
    3b1c:	0f 92       	push	r0
    3b1e:	cd b7       	in	r28, 0x3d	; 61
    3b20:	de b7       	in	r29, 0x3e	; 62
    3b22:	9b 83       	std	Y+3, r25	; 0x03
    3b24:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3b26:	0f b6       	in	r0, 0x3f	; 63
    3b28:	f8 94       	cli
    3b2a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3b2c:	ea 81       	ldd	r30, Y+2	; 0x02
    3b2e:	fb 81       	ldd	r31, Y+3	; 0x03
    3b30:	92 8d       	ldd	r25, Z+26	; 0x1a
    3b32:	ea 81       	ldd	r30, Y+2	; 0x02
    3b34:	fb 81       	ldd	r31, Y+3	; 0x03
    3b36:	83 8d       	ldd	r24, Z+27	; 0x1b
    3b38:	98 17       	cp	r25, r24
    3b3a:	19 f4       	brne	.+6      	; 0x3b42 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    3b3c:	81 e0       	ldi	r24, 0x01	; 1
    3b3e:	89 83       	std	Y+1, r24	; 0x01
    3b40:	01 c0       	rjmp	.+2      	; 0x3b44 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    3b42:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3b44:	0f 90       	pop	r0
    3b46:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3b48:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b4a:	0f 90       	pop	r0
    3b4c:	0f 90       	pop	r0
    3b4e:	0f 90       	pop	r0
    3b50:	cf 91       	pop	r28
    3b52:	df 91       	pop	r29
    3b54:	08 95       	ret

00003b56 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3b56:	df 93       	push	r29
    3b58:	cf 93       	push	r28
    3b5a:	00 d0       	rcall	.+0      	; 0x3b5c <xQueueIsQueueFullFromISR+0x6>
    3b5c:	00 d0       	rcall	.+0      	; 0x3b5e <xQueueIsQueueFullFromISR+0x8>
    3b5e:	0f 92       	push	r0
    3b60:	cd b7       	in	r28, 0x3d	; 61
    3b62:	de b7       	in	r29, 0x3e	; 62
    3b64:	9d 83       	std	Y+5, r25	; 0x05
    3b66:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3b68:	8c 81       	ldd	r24, Y+4	; 0x04
    3b6a:	9d 81       	ldd	r25, Y+5	; 0x05
    3b6c:	9a 83       	std	Y+2, r25	; 0x02
    3b6e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3b70:	e9 81       	ldd	r30, Y+1	; 0x01
    3b72:	fa 81       	ldd	r31, Y+2	; 0x02
    3b74:	92 8d       	ldd	r25, Z+26	; 0x1a
    3b76:	e9 81       	ldd	r30, Y+1	; 0x01
    3b78:	fa 81       	ldd	r31, Y+2	; 0x02
    3b7a:	83 8d       	ldd	r24, Z+27	; 0x1b
    3b7c:	98 17       	cp	r25, r24
    3b7e:	19 f4       	brne	.+6      	; 0x3b86 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    3b80:	81 e0       	ldi	r24, 0x01	; 1
    3b82:	8b 83       	std	Y+3, r24	; 0x03
    3b84:	01 c0       	rjmp	.+2      	; 0x3b88 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    3b86:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3b88:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3b8a:	0f 90       	pop	r0
    3b8c:	0f 90       	pop	r0
    3b8e:	0f 90       	pop	r0
    3b90:	0f 90       	pop	r0
    3b92:	0f 90       	pop	r0
    3b94:	cf 91       	pop	r28
    3b96:	df 91       	pop	r29
    3b98:	08 95       	ret

00003b9a <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    3b9a:	0f 93       	push	r16
    3b9c:	df 93       	push	r29
    3b9e:	cf 93       	push	r28
    3ba0:	cd b7       	in	r28, 0x3d	; 61
    3ba2:	de b7       	in	r29, 0x3e	; 62
    3ba4:	28 97       	sbiw	r28, 0x08	; 8
    3ba6:	0f b6       	in	r0, 0x3f	; 63
    3ba8:	f8 94       	cli
    3baa:	de bf       	out	0x3e, r29	; 62
    3bac:	0f be       	out	0x3f, r0	; 63
    3bae:	cd bf       	out	0x3d, r28	; 61
    3bb0:	9d 83       	std	Y+5, r25	; 0x05
    3bb2:	8c 83       	std	Y+4, r24	; 0x04
    3bb4:	7f 83       	std	Y+7, r23	; 0x07
    3bb6:	6e 83       	std	Y+6, r22	; 0x06
    3bb8:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    3bba:	88 85       	ldd	r24, Y+8	; 0x08
    3bbc:	81 30       	cpi	r24, 0x01	; 1
    3bbe:	19 f4       	brne	.+6      	; 0x3bc6 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    3bc0:	81 e0       	ldi	r24, 0x01	; 1
    3bc2:	89 83       	std	Y+1, r24	; 0x01
    3bc4:	01 c0       	rjmp	.+2      	; 0x3bc8 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    3bc6:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    3bc8:	8e 81       	ldd	r24, Y+6	; 0x06
    3bca:	9f 81       	ldd	r25, Y+7	; 0x07
    3bcc:	00 97       	sbiw	r24, 0x00	; 0
    3bce:	21 f4       	brne	.+8      	; 0x3bd8 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    3bd0:	81 e0       	ldi	r24, 0x01	; 1
    3bd2:	90 e0       	ldi	r25, 0x00	; 0
    3bd4:	9f 83       	std	Y+7, r25	; 0x07
    3bd6:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    3bd8:	8c 81       	ldd	r24, Y+4	; 0x04
    3bda:	9d 81       	ldd	r25, Y+5	; 0x05
    3bdc:	01 96       	adiw	r24, 0x01	; 1
    3bde:	9d 83       	std	Y+5, r25	; 0x05
    3be0:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    3be2:	8c 81       	ldd	r24, Y+4	; 0x04
    3be4:	9d 81       	ldd	r25, Y+5	; 0x05
    3be6:	0f 96       	adiw	r24, 0x0f	; 15
    3be8:	0e 94 4f 11 	call	0x229e	; 0x229e <pvPortMalloc>
    3bec:	9b 83       	std	Y+3, r25	; 0x03
    3bee:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    3bf0:	8a 81       	ldd	r24, Y+2	; 0x02
    3bf2:	9b 81       	ldd	r25, Y+3	; 0x03
    3bf4:	00 97       	sbiw	r24, 0x00	; 0
    3bf6:	89 f0       	breq	.+34     	; 0x3c1a <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    3bf8:	6a 81       	ldd	r22, Y+2	; 0x02
    3bfa:	7b 81       	ldd	r23, Y+3	; 0x03
    3bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    3bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    3c00:	9c 01       	movw	r18, r24
    3c02:	21 5f       	subi	r18, 0xF1	; 241
    3c04:	3f 4f       	sbci	r19, 0xFF	; 255
    3c06:	4c 81       	ldd	r20, Y+4	; 0x04
    3c08:	5d 81       	ldd	r21, Y+5	; 0x05
    3c0a:	ee 81       	ldd	r30, Y+6	; 0x06
    3c0c:	ff 81       	ldd	r31, Y+7	; 0x07
    3c0e:	cb 01       	movw	r24, r22
    3c10:	b9 01       	movw	r22, r18
    3c12:	9f 01       	movw	r18, r30
    3c14:	09 81       	ldd	r16, Y+1	; 0x01
    3c16:	0e 94 25 25 	call	0x4a4a	; 0x4a4a <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    3c1a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c1c:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    3c1e:	28 96       	adiw	r28, 0x08	; 8
    3c20:	0f b6       	in	r0, 0x3f	; 63
    3c22:	f8 94       	cli
    3c24:	de bf       	out	0x3e, r29	; 62
    3c26:	0f be       	out	0x3f, r0	; 63
    3c28:	cd bf       	out	0x3d, r28	; 61
    3c2a:	cf 91       	pop	r28
    3c2c:	df 91       	pop	r29
    3c2e:	0f 91       	pop	r16
    3c30:	08 95       	ret

00003c32 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    3c32:	df 93       	push	r29
    3c34:	cf 93       	push	r28
    3c36:	00 d0       	rcall	.+0      	; 0x3c38 <vStreamBufferDelete+0x6>
    3c38:	00 d0       	rcall	.+0      	; 0x3c3a <vStreamBufferDelete+0x8>
    3c3a:	cd b7       	in	r28, 0x3d	; 61
    3c3c:	de b7       	in	r29, 0x3e	; 62
    3c3e:	9c 83       	std	Y+4, r25	; 0x04
    3c40:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    3c42:	8b 81       	ldd	r24, Y+3	; 0x03
    3c44:	9c 81       	ldd	r25, Y+4	; 0x04
    3c46:	9a 83       	std	Y+2, r25	; 0x02
    3c48:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    3c4a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c4c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c4e:	86 85       	ldd	r24, Z+14	; 0x0e
    3c50:	88 2f       	mov	r24, r24
    3c52:	90 e0       	ldi	r25, 0x00	; 0
    3c54:	82 70       	andi	r24, 0x02	; 2
    3c56:	90 70       	andi	r25, 0x00	; 0
    3c58:	00 97       	sbiw	r24, 0x00	; 0
    3c5a:	29 f4       	brne	.+10     	; 0x3c66 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    3c5c:	89 81       	ldd	r24, Y+1	; 0x01
    3c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c60:	0e 94 a5 11 	call	0x234a	; 0x234a <vPortFree>
    3c64:	08 c0       	rjmp	.+16     	; 0x3c76 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    3c66:	89 81       	ldd	r24, Y+1	; 0x01
    3c68:	9a 81       	ldd	r25, Y+2	; 0x02
    3c6a:	60 e0       	ldi	r22, 0x00	; 0
    3c6c:	70 e0       	ldi	r23, 0x00	; 0
    3c6e:	4f e0       	ldi	r20, 0x0F	; 15
    3c70:	50 e0       	ldi	r21, 0x00	; 0
    3c72:	0e 94 f5 32 	call	0x65ea	; 0x65ea <memset>
	}
}
    3c76:	0f 90       	pop	r0
    3c78:	0f 90       	pop	r0
    3c7a:	0f 90       	pop	r0
    3c7c:	0f 90       	pop	r0
    3c7e:	cf 91       	pop	r28
    3c80:	df 91       	pop	r29
    3c82:	08 95       	ret

00003c84 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    3c84:	0f 93       	push	r16
    3c86:	df 93       	push	r29
    3c88:	cf 93       	push	r28
    3c8a:	00 d0       	rcall	.+0      	; 0x3c8c <xStreamBufferReset+0x8>
    3c8c:	00 d0       	rcall	.+0      	; 0x3c8e <xStreamBufferReset+0xa>
    3c8e:	0f 92       	push	r0
    3c90:	cd b7       	in	r28, 0x3d	; 61
    3c92:	de b7       	in	r29, 0x3e	; 62
    3c94:	9d 83       	std	Y+5, r25	; 0x05
    3c96:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3c98:	8c 81       	ldd	r24, Y+4	; 0x04
    3c9a:	9d 81       	ldd	r25, Y+5	; 0x05
    3c9c:	9b 83       	std	Y+3, r25	; 0x03
    3c9e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    3ca0:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    3ca2:	0f b6       	in	r0, 0x3f	; 63
    3ca4:	f8 94       	cli
    3ca6:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    3ca8:	ea 81       	ldd	r30, Y+2	; 0x02
    3caa:	fb 81       	ldd	r31, Y+3	; 0x03
    3cac:	80 85       	ldd	r24, Z+8	; 0x08
    3cae:	91 85       	ldd	r25, Z+9	; 0x09
    3cb0:	00 97       	sbiw	r24, 0x00	; 0
    3cb2:	f1 f4       	brne	.+60     	; 0x3cf0 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    3cb4:	ea 81       	ldd	r30, Y+2	; 0x02
    3cb6:	fb 81       	ldd	r31, Y+3	; 0x03
    3cb8:	82 85       	ldd	r24, Z+10	; 0x0a
    3cba:	93 85       	ldd	r25, Z+11	; 0x0b
    3cbc:	00 97       	sbiw	r24, 0x00	; 0
    3cbe:	c1 f4       	brne	.+48     	; 0x3cf0 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    3cc0:	ea 81       	ldd	r30, Y+2	; 0x02
    3cc2:	fb 81       	ldd	r31, Y+3	; 0x03
    3cc4:	24 85       	ldd	r18, Z+12	; 0x0c
    3cc6:	35 85       	ldd	r19, Z+13	; 0x0d
    3cc8:	ea 81       	ldd	r30, Y+2	; 0x02
    3cca:	fb 81       	ldd	r31, Y+3	; 0x03
    3ccc:	44 81       	ldd	r20, Z+4	; 0x04
    3cce:	55 81       	ldd	r21, Z+5	; 0x05
    3cd0:	ea 81       	ldd	r30, Y+2	; 0x02
    3cd2:	fb 81       	ldd	r31, Y+3	; 0x03
    3cd4:	a6 81       	ldd	r26, Z+6	; 0x06
    3cd6:	b7 81       	ldd	r27, Z+7	; 0x07
    3cd8:	ea 81       	ldd	r30, Y+2	; 0x02
    3cda:	fb 81       	ldd	r31, Y+3	; 0x03
    3cdc:	e6 85       	ldd	r30, Z+14	; 0x0e
    3cde:	8a 81       	ldd	r24, Y+2	; 0x02
    3ce0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ce2:	b9 01       	movw	r22, r18
    3ce4:	9d 01       	movw	r18, r26
    3ce6:	0e 2f       	mov	r16, r30
    3ce8:	0e 94 25 25 	call	0x4a4a	; 0x4a4a <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    3cec:	81 e0       	ldi	r24, 0x01	; 1
    3cee:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    3cf0:	0f 90       	pop	r0
    3cf2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3cf4:	89 81       	ldd	r24, Y+1	; 0x01
}
    3cf6:	0f 90       	pop	r0
    3cf8:	0f 90       	pop	r0
    3cfa:	0f 90       	pop	r0
    3cfc:	0f 90       	pop	r0
    3cfe:	0f 90       	pop	r0
    3d00:	cf 91       	pop	r28
    3d02:	df 91       	pop	r29
    3d04:	0f 91       	pop	r16
    3d06:	08 95       	ret

00003d08 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    3d08:	df 93       	push	r29
    3d0a:	cf 93       	push	r28
    3d0c:	cd b7       	in	r28, 0x3d	; 61
    3d0e:	de b7       	in	r29, 0x3e	; 62
    3d10:	27 97       	sbiw	r28, 0x07	; 7
    3d12:	0f b6       	in	r0, 0x3f	; 63
    3d14:	f8 94       	cli
    3d16:	de bf       	out	0x3e, r29	; 62
    3d18:	0f be       	out	0x3f, r0	; 63
    3d1a:	cd bf       	out	0x3d, r28	; 61
    3d1c:	9d 83       	std	Y+5, r25	; 0x05
    3d1e:	8c 83       	std	Y+4, r24	; 0x04
    3d20:	7f 83       	std	Y+7, r23	; 0x07
    3d22:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3d24:	8c 81       	ldd	r24, Y+4	; 0x04
    3d26:	9d 81       	ldd	r25, Y+5	; 0x05
    3d28:	9b 83       	std	Y+3, r25	; 0x03
    3d2a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    3d2c:	8e 81       	ldd	r24, Y+6	; 0x06
    3d2e:	9f 81       	ldd	r25, Y+7	; 0x07
    3d30:	00 97       	sbiw	r24, 0x00	; 0
    3d32:	21 f4       	brne	.+8      	; 0x3d3c <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    3d34:	81 e0       	ldi	r24, 0x01	; 1
    3d36:	90 e0       	ldi	r25, 0x00	; 0
    3d38:	9f 83       	std	Y+7, r25	; 0x07
    3d3a:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    3d3c:	ea 81       	ldd	r30, Y+2	; 0x02
    3d3e:	fb 81       	ldd	r31, Y+3	; 0x03
    3d40:	24 81       	ldd	r18, Z+4	; 0x04
    3d42:	35 81       	ldd	r19, Z+5	; 0x05
    3d44:	8e 81       	ldd	r24, Y+6	; 0x06
    3d46:	9f 81       	ldd	r25, Y+7	; 0x07
    3d48:	28 17       	cp	r18, r24
    3d4a:	39 07       	cpc	r19, r25
    3d4c:	48 f0       	brcs	.+18     	; 0x3d60 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    3d4e:	ea 81       	ldd	r30, Y+2	; 0x02
    3d50:	fb 81       	ldd	r31, Y+3	; 0x03
    3d52:	8e 81       	ldd	r24, Y+6	; 0x06
    3d54:	9f 81       	ldd	r25, Y+7	; 0x07
    3d56:	97 83       	std	Z+7, r25	; 0x07
    3d58:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    3d5a:	81 e0       	ldi	r24, 0x01	; 1
    3d5c:	89 83       	std	Y+1, r24	; 0x01
    3d5e:	01 c0       	rjmp	.+2      	; 0x3d62 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    3d60:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3d62:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d64:	27 96       	adiw	r28, 0x07	; 7
    3d66:	0f b6       	in	r0, 0x3f	; 63
    3d68:	f8 94       	cli
    3d6a:	de bf       	out	0x3e, r29	; 62
    3d6c:	0f be       	out	0x3f, r0	; 63
    3d6e:	cd bf       	out	0x3d, r28	; 61
    3d70:	cf 91       	pop	r28
    3d72:	df 91       	pop	r29
    3d74:	08 95       	ret

00003d76 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3d76:	df 93       	push	r29
    3d78:	cf 93       	push	r28
    3d7a:	00 d0       	rcall	.+0      	; 0x3d7c <xStreamBufferSpacesAvailable+0x6>
    3d7c:	00 d0       	rcall	.+0      	; 0x3d7e <xStreamBufferSpacesAvailable+0x8>
    3d7e:	00 d0       	rcall	.+0      	; 0x3d80 <xStreamBufferSpacesAvailable+0xa>
    3d80:	cd b7       	in	r28, 0x3d	; 61
    3d82:	de b7       	in	r29, 0x3e	; 62
    3d84:	9e 83       	std	Y+6, r25	; 0x06
    3d86:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3d88:	8d 81       	ldd	r24, Y+5	; 0x05
    3d8a:	9e 81       	ldd	r25, Y+6	; 0x06
    3d8c:	9c 83       	std	Y+4, r25	; 0x04
    3d8e:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3d90:	eb 81       	ldd	r30, Y+3	; 0x03
    3d92:	fc 81       	ldd	r31, Y+4	; 0x04
    3d94:	24 81       	ldd	r18, Z+4	; 0x04
    3d96:	35 81       	ldd	r19, Z+5	; 0x05
    3d98:	eb 81       	ldd	r30, Y+3	; 0x03
    3d9a:	fc 81       	ldd	r31, Y+4	; 0x04
    3d9c:	80 81       	ld	r24, Z
    3d9e:	91 81       	ldd	r25, Z+1	; 0x01
    3da0:	82 0f       	add	r24, r18
    3da2:	93 1f       	adc	r25, r19
    3da4:	9a 83       	std	Y+2, r25	; 0x02
    3da6:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    3da8:	eb 81       	ldd	r30, Y+3	; 0x03
    3daa:	fc 81       	ldd	r31, Y+4	; 0x04
    3dac:	22 81       	ldd	r18, Z+2	; 0x02
    3dae:	33 81       	ldd	r19, Z+3	; 0x03
    3db0:	89 81       	ldd	r24, Y+1	; 0x01
    3db2:	9a 81       	ldd	r25, Y+2	; 0x02
    3db4:	82 1b       	sub	r24, r18
    3db6:	93 0b       	sbc	r25, r19
    3db8:	9a 83       	std	Y+2, r25	; 0x02
    3dba:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    3dbc:	89 81       	ldd	r24, Y+1	; 0x01
    3dbe:	9a 81       	ldd	r25, Y+2	; 0x02
    3dc0:	01 97       	sbiw	r24, 0x01	; 1
    3dc2:	9a 83       	std	Y+2, r25	; 0x02
    3dc4:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    3dc6:	eb 81       	ldd	r30, Y+3	; 0x03
    3dc8:	fc 81       	ldd	r31, Y+4	; 0x04
    3dca:	24 81       	ldd	r18, Z+4	; 0x04
    3dcc:	35 81       	ldd	r19, Z+5	; 0x05
    3dce:	89 81       	ldd	r24, Y+1	; 0x01
    3dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    3dd2:	82 17       	cp	r24, r18
    3dd4:	93 07       	cpc	r25, r19
    3dd6:	50 f0       	brcs	.+20     	; 0x3dec <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    3dd8:	eb 81       	ldd	r30, Y+3	; 0x03
    3dda:	fc 81       	ldd	r31, Y+4	; 0x04
    3ddc:	24 81       	ldd	r18, Z+4	; 0x04
    3dde:	35 81       	ldd	r19, Z+5	; 0x05
    3de0:	89 81       	ldd	r24, Y+1	; 0x01
    3de2:	9a 81       	ldd	r25, Y+2	; 0x02
    3de4:	82 1b       	sub	r24, r18
    3de6:	93 0b       	sbc	r25, r19
    3de8:	9a 83       	std	Y+2, r25	; 0x02
    3dea:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    3dec:	89 81       	ldd	r24, Y+1	; 0x01
    3dee:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3df0:	26 96       	adiw	r28, 0x06	; 6
    3df2:	0f b6       	in	r0, 0x3f	; 63
    3df4:	f8 94       	cli
    3df6:	de bf       	out	0x3e, r29	; 62
    3df8:	0f be       	out	0x3f, r0	; 63
    3dfa:	cd bf       	out	0x3d, r28	; 61
    3dfc:	cf 91       	pop	r28
    3dfe:	df 91       	pop	r29
    3e00:	08 95       	ret

00003e02 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3e02:	df 93       	push	r29
    3e04:	cf 93       	push	r28
    3e06:	00 d0       	rcall	.+0      	; 0x3e08 <xStreamBufferBytesAvailable+0x6>
    3e08:	00 d0       	rcall	.+0      	; 0x3e0a <xStreamBufferBytesAvailable+0x8>
    3e0a:	00 d0       	rcall	.+0      	; 0x3e0c <xStreamBufferBytesAvailable+0xa>
    3e0c:	cd b7       	in	r28, 0x3d	; 61
    3e0e:	de b7       	in	r29, 0x3e	; 62
    3e10:	9e 83       	std	Y+6, r25	; 0x06
    3e12:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3e14:	8d 81       	ldd	r24, Y+5	; 0x05
    3e16:	9e 81       	ldd	r25, Y+6	; 0x06
    3e18:	9c 83       	std	Y+4, r25	; 0x04
    3e1a:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    3e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    3e1e:	9c 81       	ldd	r25, Y+4	; 0x04
    3e20:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <prvBytesInBuffer>
    3e24:	9a 83       	std	Y+2, r25	; 0x02
    3e26:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    3e28:	89 81       	ldd	r24, Y+1	; 0x01
    3e2a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3e2c:	26 96       	adiw	r28, 0x06	; 6
    3e2e:	0f b6       	in	r0, 0x3f	; 63
    3e30:	f8 94       	cli
    3e32:	de bf       	out	0x3e, r29	; 62
    3e34:	0f be       	out	0x3f, r0	; 63
    3e36:	cd bf       	out	0x3d, r28	; 61
    3e38:	cf 91       	pop	r28
    3e3a:	df 91       	pop	r29
    3e3c:	08 95       	ret

00003e3e <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    3e3e:	ef 92       	push	r14
    3e40:	ff 92       	push	r15
    3e42:	0f 93       	push	r16
    3e44:	1f 93       	push	r17
    3e46:	df 93       	push	r29
    3e48:	cf 93       	push	r28
    3e4a:	cd b7       	in	r28, 0x3d	; 61
    3e4c:	de b7       	in	r29, 0x3e	; 62
    3e4e:	63 97       	sbiw	r28, 0x13	; 19
    3e50:	0f b6       	in	r0, 0x3f	; 63
    3e52:	f8 94       	cli
    3e54:	de bf       	out	0x3e, r29	; 62
    3e56:	0f be       	out	0x3f, r0	; 63
    3e58:	cd bf       	out	0x3d, r28	; 61
    3e5a:	9d 87       	std	Y+13, r25	; 0x0d
    3e5c:	8c 87       	std	Y+12, r24	; 0x0c
    3e5e:	7f 87       	std	Y+15, r23	; 0x0f
    3e60:	6e 87       	std	Y+14, r22	; 0x0e
    3e62:	59 8b       	std	Y+17, r21	; 0x11
    3e64:	48 8b       	std	Y+16, r20	; 0x10
    3e66:	3b 8b       	std	Y+19, r19	; 0x13
    3e68:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3e6a:	8c 85       	ldd	r24, Y+12	; 0x0c
    3e6c:	9d 85       	ldd	r25, Y+13	; 0x0d
    3e6e:	98 87       	std	Y+8, r25	; 0x08
    3e70:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    3e72:	1c 82       	std	Y+4, r1	; 0x04
    3e74:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    3e76:	88 89       	ldd	r24, Y+16	; 0x10
    3e78:	99 89       	ldd	r25, Y+17	; 0x11
    3e7a:	9a 83       	std	Y+2, r25	; 0x02
    3e7c:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3e7e:	ef 81       	ldd	r30, Y+7	; 0x07
    3e80:	f8 85       	ldd	r31, Y+8	; 0x08
    3e82:	86 85       	ldd	r24, Z+14	; 0x0e
    3e84:	88 2f       	mov	r24, r24
    3e86:	90 e0       	ldi	r25, 0x00	; 0
    3e88:	81 70       	andi	r24, 0x01	; 1
    3e8a:	90 70       	andi	r25, 0x00	; 0
    3e8c:	88 23       	and	r24, r24
    3e8e:	29 f0       	breq	.+10     	; 0x3e9a <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3e90:	89 81       	ldd	r24, Y+1	; 0x01
    3e92:	9a 81       	ldd	r25, Y+2	; 0x02
    3e94:	02 96       	adiw	r24, 0x02	; 2
    3e96:	9a 83       	std	Y+2, r25	; 0x02
    3e98:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3e9a:	8a 89       	ldd	r24, Y+18	; 0x12
    3e9c:	9b 89       	ldd	r25, Y+19	; 0x13
    3e9e:	00 97       	sbiw	r24, 0x00	; 0
    3ea0:	09 f4       	brne	.+2      	; 0x3ea4 <xStreamBufferSend+0x66>
    3ea2:	40 c0       	rjmp	.+128    	; 0x3f24 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    3ea4:	ce 01       	movw	r24, r28
    3ea6:	09 96       	adiw	r24, 0x09	; 9
    3ea8:	0e 94 26 2d 	call	0x5a4c	; 0x5a4c <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    3eac:	0f b6       	in	r0, 0x3f	; 63
    3eae:	f8 94       	cli
    3eb0:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3eb2:	8f 81       	ldd	r24, Y+7	; 0x07
    3eb4:	98 85       	ldd	r25, Y+8	; 0x08
    3eb6:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <xStreamBufferSpacesAvailable>
    3eba:	9c 83       	std	Y+4, r25	; 0x04
    3ebc:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    3ebe:	2b 81       	ldd	r18, Y+3	; 0x03
    3ec0:	3c 81       	ldd	r19, Y+4	; 0x04
    3ec2:	89 81       	ldd	r24, Y+1	; 0x01
    3ec4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ec6:	28 17       	cp	r18, r24
    3ec8:	39 07       	cpc	r19, r25
    3eca:	50 f5       	brcc	.+84     	; 0x3f20 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    3ecc:	80 e0       	ldi	r24, 0x00	; 0
    3ece:	90 e0       	ldi	r25, 0x00	; 0
    3ed0:	0e 94 36 32 	call	0x646c	; 0x646c <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    3ed4:	0e 94 8f 2e 	call	0x5d1e	; 0x5d1e <xTaskGetCurrentTaskHandle>
    3ed8:	ef 81       	ldd	r30, Y+7	; 0x07
    3eda:	f8 85       	ldd	r31, Y+8	; 0x08
    3edc:	93 87       	std	Z+11, r25	; 0x0b
    3ede:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    3ee0:	0f 90       	pop	r0
    3ee2:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3ee4:	ea 89       	ldd	r30, Y+18	; 0x12
    3ee6:	fb 89       	ldd	r31, Y+19	; 0x13
    3ee8:	60 e0       	ldi	r22, 0x00	; 0
    3eea:	70 e0       	ldi	r23, 0x00	; 0
    3eec:	80 e0       	ldi	r24, 0x00	; 0
    3eee:	90 e0       	ldi	r25, 0x00	; 0
    3ef0:	20 e0       	ldi	r18, 0x00	; 0
    3ef2:	30 e0       	ldi	r19, 0x00	; 0
    3ef4:	40 e0       	ldi	r20, 0x00	; 0
    3ef6:	50 e0       	ldi	r21, 0x00	; 0
    3ef8:	00 e0       	ldi	r16, 0x00	; 0
    3efa:	10 e0       	ldi	r17, 0x00	; 0
    3efc:	7f 01       	movw	r14, r30
    3efe:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    3f02:	ef 81       	ldd	r30, Y+7	; 0x07
    3f04:	f8 85       	ldd	r31, Y+8	; 0x08
    3f06:	13 86       	std	Z+11, r1	; 0x0b
    3f08:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    3f0a:	ce 01       	movw	r24, r28
    3f0c:	09 96       	adiw	r24, 0x09	; 9
    3f0e:	9e 01       	movw	r18, r28
    3f10:	2e 5e       	subi	r18, 0xEE	; 238
    3f12:	3f 4f       	sbci	r19, 0xFF	; 255
    3f14:	b9 01       	movw	r22, r18
    3f16:	0e 94 5d 2d 	call	0x5aba	; 0x5aba <xTaskCheckForTimeOut>
    3f1a:	88 23       	and	r24, r24
    3f1c:	39 f2       	breq	.-114    	; 0x3eac <xStreamBufferSend+0x6e>
    3f1e:	02 c0       	rjmp	.+4      	; 0x3f24 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    3f20:	0f 90       	pop	r0
    3f22:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    3f24:	8b 81       	ldd	r24, Y+3	; 0x03
    3f26:	9c 81       	ldd	r25, Y+4	; 0x04
    3f28:	00 97       	sbiw	r24, 0x00	; 0
    3f2a:	31 f4       	brne	.+12     	; 0x3f38 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3f2c:	8f 81       	ldd	r24, Y+7	; 0x07
    3f2e:	98 85       	ldd	r25, Y+8	; 0x08
    3f30:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <xStreamBufferSpacesAvailable>
    3f34:	9c 83       	std	Y+4, r25	; 0x04
    3f36:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3f38:	8f 81       	ldd	r24, Y+7	; 0x07
    3f3a:	98 85       	ldd	r25, Y+8	; 0x08
    3f3c:	2e 85       	ldd	r18, Y+14	; 0x0e
    3f3e:	3f 85       	ldd	r19, Y+15	; 0x0f
    3f40:	48 89       	ldd	r20, Y+16	; 0x10
    3f42:	59 89       	ldd	r21, Y+17	; 0x11
    3f44:	eb 81       	ldd	r30, Y+3	; 0x03
    3f46:	fc 81       	ldd	r31, Y+4	; 0x04
    3f48:	a9 81       	ldd	r26, Y+1	; 0x01
    3f4a:	ba 81       	ldd	r27, Y+2	; 0x02
    3f4c:	b9 01       	movw	r22, r18
    3f4e:	9f 01       	movw	r18, r30
    3f50:	8d 01       	movw	r16, r26
    3f52:	0e 94 64 20 	call	0x40c8	; 0x40c8 <prvWriteMessageToBuffer>
    3f56:	9e 83       	std	Y+6, r25	; 0x06
    3f58:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    3f5a:	8d 81       	ldd	r24, Y+5	; 0x05
    3f5c:	9e 81       	ldd	r25, Y+6	; 0x06
    3f5e:	00 97       	sbiw	r24, 0x00	; 0
    3f60:	39 f1       	breq	.+78     	; 0x3fb0 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3f62:	8f 81       	ldd	r24, Y+7	; 0x07
    3f64:	98 85       	ldd	r25, Y+8	; 0x08
    3f66:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <prvBytesInBuffer>
    3f6a:	9c 01       	movw	r18, r24
    3f6c:	ef 81       	ldd	r30, Y+7	; 0x07
    3f6e:	f8 85       	ldd	r31, Y+8	; 0x08
    3f70:	86 81       	ldd	r24, Z+6	; 0x06
    3f72:	97 81       	ldd	r25, Z+7	; 0x07
    3f74:	28 17       	cp	r18, r24
    3f76:	39 07       	cpc	r19, r25
    3f78:	d8 f0       	brcs	.+54     	; 0x3fb0 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    3f7a:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
    3f7e:	ef 81       	ldd	r30, Y+7	; 0x07
    3f80:	f8 85       	ldd	r31, Y+8	; 0x08
    3f82:	80 85       	ldd	r24, Z+8	; 0x08
    3f84:	91 85       	ldd	r25, Z+9	; 0x09
    3f86:	00 97       	sbiw	r24, 0x00	; 0
    3f88:	89 f0       	breq	.+34     	; 0x3fac <xStreamBufferSend+0x16e>
    3f8a:	ef 81       	ldd	r30, Y+7	; 0x07
    3f8c:	f8 85       	ldd	r31, Y+8	; 0x08
    3f8e:	80 85       	ldd	r24, Z+8	; 0x08
    3f90:	91 85       	ldd	r25, Z+9	; 0x09
    3f92:	40 e0       	ldi	r20, 0x00	; 0
    3f94:	50 e0       	ldi	r21, 0x00	; 0
    3f96:	60 e0       	ldi	r22, 0x00	; 0
    3f98:	70 e0       	ldi	r23, 0x00	; 0
    3f9a:	20 e0       	ldi	r18, 0x00	; 0
    3f9c:	00 e0       	ldi	r16, 0x00	; 0
    3f9e:	10 e0       	ldi	r17, 0x00	; 0
    3fa0:	0e 94 db 2f 	call	0x5fb6	; 0x5fb6 <xTaskGenericNotify>
    3fa4:	ef 81       	ldd	r30, Y+7	; 0x07
    3fa6:	f8 85       	ldd	r31, Y+8	; 0x08
    3fa8:	11 86       	std	Z+9, r1	; 0x09
    3faa:	10 86       	std	Z+8, r1	; 0x08
    3fac:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    3fb0:	8d 81       	ldd	r24, Y+5	; 0x05
    3fb2:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3fb4:	63 96       	adiw	r28, 0x13	; 19
    3fb6:	0f b6       	in	r0, 0x3f	; 63
    3fb8:	f8 94       	cli
    3fba:	de bf       	out	0x3e, r29	; 62
    3fbc:	0f be       	out	0x3f, r0	; 63
    3fbe:	cd bf       	out	0x3d, r28	; 61
    3fc0:	cf 91       	pop	r28
    3fc2:	df 91       	pop	r29
    3fc4:	1f 91       	pop	r17
    3fc6:	0f 91       	pop	r16
    3fc8:	ff 90       	pop	r15
    3fca:	ef 90       	pop	r14
    3fcc:	08 95       	ret

00003fce <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3fce:	ef 92       	push	r14
    3fd0:	ff 92       	push	r15
    3fd2:	0f 93       	push	r16
    3fd4:	1f 93       	push	r17
    3fd6:	df 93       	push	r29
    3fd8:	cf 93       	push	r28
    3fda:	cd b7       	in	r28, 0x3d	; 61
    3fdc:	de b7       	in	r29, 0x3e	; 62
    3fde:	61 97       	sbiw	r28, 0x11	; 17
    3fe0:	0f b6       	in	r0, 0x3f	; 63
    3fe2:	f8 94       	cli
    3fe4:	de bf       	out	0x3e, r29	; 62
    3fe6:	0f be       	out	0x3f, r0	; 63
    3fe8:	cd bf       	out	0x3d, r28	; 61
    3fea:	9b 87       	std	Y+11, r25	; 0x0b
    3fec:	8a 87       	std	Y+10, r24	; 0x0a
    3fee:	7d 87       	std	Y+13, r23	; 0x0d
    3ff0:	6c 87       	std	Y+12, r22	; 0x0c
    3ff2:	5f 87       	std	Y+15, r21	; 0x0f
    3ff4:	4e 87       	std	Y+14, r20	; 0x0e
    3ff6:	39 8b       	std	Y+17, r19	; 0x11
    3ff8:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3ffa:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ffc:	9b 85       	ldd	r25, Y+11	; 0x0b
    3ffe:	99 87       	std	Y+9, r25	; 0x09
    4000:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    4002:	8e 85       	ldd	r24, Y+14	; 0x0e
    4004:	9f 85       	ldd	r25, Y+15	; 0x0f
    4006:	9b 83       	std	Y+3, r25	; 0x03
    4008:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    400a:	e8 85       	ldd	r30, Y+8	; 0x08
    400c:	f9 85       	ldd	r31, Y+9	; 0x09
    400e:	86 85       	ldd	r24, Z+14	; 0x0e
    4010:	88 2f       	mov	r24, r24
    4012:	90 e0       	ldi	r25, 0x00	; 0
    4014:	81 70       	andi	r24, 0x01	; 1
    4016:	90 70       	andi	r25, 0x00	; 0
    4018:	88 23       	and	r24, r24
    401a:	29 f0       	breq	.+10     	; 0x4026 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    401c:	8a 81       	ldd	r24, Y+2	; 0x02
    401e:	9b 81       	ldd	r25, Y+3	; 0x03
    4020:	02 96       	adiw	r24, 0x02	; 2
    4022:	9b 83       	std	Y+3, r25	; 0x03
    4024:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    4026:	88 85       	ldd	r24, Y+8	; 0x08
    4028:	99 85       	ldd	r25, Y+9	; 0x09
    402a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <xStreamBufferSpacesAvailable>
    402e:	9d 83       	std	Y+5, r25	; 0x05
    4030:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    4032:	88 85       	ldd	r24, Y+8	; 0x08
    4034:	99 85       	ldd	r25, Y+9	; 0x09
    4036:	2c 85       	ldd	r18, Y+12	; 0x0c
    4038:	3d 85       	ldd	r19, Y+13	; 0x0d
    403a:	4e 85       	ldd	r20, Y+14	; 0x0e
    403c:	5f 85       	ldd	r21, Y+15	; 0x0f
    403e:	ec 81       	ldd	r30, Y+4	; 0x04
    4040:	fd 81       	ldd	r31, Y+5	; 0x05
    4042:	aa 81       	ldd	r26, Y+2	; 0x02
    4044:	bb 81       	ldd	r27, Y+3	; 0x03
    4046:	b9 01       	movw	r22, r18
    4048:	9f 01       	movw	r18, r30
    404a:	8d 01       	movw	r16, r26
    404c:	0e 94 64 20 	call	0x40c8	; 0x40c8 <prvWriteMessageToBuffer>
    4050:	9f 83       	std	Y+7, r25	; 0x07
    4052:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    4054:	8e 81       	ldd	r24, Y+6	; 0x06
    4056:	9f 81       	ldd	r25, Y+7	; 0x07
    4058:	00 97       	sbiw	r24, 0x00	; 0
    405a:	39 f1       	breq	.+78     	; 0x40aa <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    405c:	88 85       	ldd	r24, Y+8	; 0x08
    405e:	99 85       	ldd	r25, Y+9	; 0x09
    4060:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <prvBytesInBuffer>
    4064:	9c 01       	movw	r18, r24
    4066:	e8 85       	ldd	r30, Y+8	; 0x08
    4068:	f9 85       	ldd	r31, Y+9	; 0x09
    406a:	86 81       	ldd	r24, Z+6	; 0x06
    406c:	97 81       	ldd	r25, Z+7	; 0x07
    406e:	28 17       	cp	r18, r24
    4070:	39 07       	cpc	r19, r25
    4072:	d8 f0       	brcs	.+54     	; 0x40aa <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    4074:	19 82       	std	Y+1, r1	; 0x01
    4076:	e8 85       	ldd	r30, Y+8	; 0x08
    4078:	f9 85       	ldd	r31, Y+9	; 0x09
    407a:	80 85       	ldd	r24, Z+8	; 0x08
    407c:	91 85       	ldd	r25, Z+9	; 0x09
    407e:	00 97       	sbiw	r24, 0x00	; 0
    4080:	a1 f0       	breq	.+40     	; 0x40aa <xStreamBufferSendFromISR+0xdc>
    4082:	e8 85       	ldd	r30, Y+8	; 0x08
    4084:	f9 85       	ldd	r31, Y+9	; 0x09
    4086:	80 85       	ldd	r24, Z+8	; 0x08
    4088:	91 85       	ldd	r25, Z+9	; 0x09
    408a:	e8 89       	ldd	r30, Y+16	; 0x10
    408c:	f9 89       	ldd	r31, Y+17	; 0x11
    408e:	40 e0       	ldi	r20, 0x00	; 0
    4090:	50 e0       	ldi	r21, 0x00	; 0
    4092:	60 e0       	ldi	r22, 0x00	; 0
    4094:	70 e0       	ldi	r23, 0x00	; 0
    4096:	20 e0       	ldi	r18, 0x00	; 0
    4098:	00 e0       	ldi	r16, 0x00	; 0
    409a:	10 e0       	ldi	r17, 0x00	; 0
    409c:	7f 01       	movw	r14, r30
    409e:	0e 94 b8 30 	call	0x6170	; 0x6170 <xTaskGenericNotifyFromISR>
    40a2:	e8 85       	ldd	r30, Y+8	; 0x08
    40a4:	f9 85       	ldd	r31, Y+9	; 0x09
    40a6:	11 86       	std	Z+9, r1	; 0x09
    40a8:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    40aa:	8e 81       	ldd	r24, Y+6	; 0x06
    40ac:	9f 81       	ldd	r25, Y+7	; 0x07
}
    40ae:	61 96       	adiw	r28, 0x11	; 17
    40b0:	0f b6       	in	r0, 0x3f	; 63
    40b2:	f8 94       	cli
    40b4:	de bf       	out	0x3e, r29	; 62
    40b6:	0f be       	out	0x3f, r0	; 63
    40b8:	cd bf       	out	0x3d, r28	; 61
    40ba:	cf 91       	pop	r28
    40bc:	df 91       	pop	r29
    40be:	1f 91       	pop	r17
    40c0:	0f 91       	pop	r16
    40c2:	ff 90       	pop	r15
    40c4:	ef 90       	pop	r14
    40c6:	08 95       	ret

000040c8 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    40c8:	0f 93       	push	r16
    40ca:	1f 93       	push	r17
    40cc:	df 93       	push	r29
    40ce:	cf 93       	push	r28
    40d0:	cd b7       	in	r28, 0x3d	; 61
    40d2:	de b7       	in	r29, 0x3e	; 62
    40d4:	61 97       	sbiw	r28, 0x11	; 17
    40d6:	0f b6       	in	r0, 0x3f	; 63
    40d8:	f8 94       	cli
    40da:	de bf       	out	0x3e, r29	; 62
    40dc:	0f be       	out	0x3f, r0	; 63
    40de:	cd bf       	out	0x3d, r28	; 61
    40e0:	9d 83       	std	Y+5, r25	; 0x05
    40e2:	8c 83       	std	Y+4, r24	; 0x04
    40e4:	7f 83       	std	Y+7, r23	; 0x07
    40e6:	6e 83       	std	Y+6, r22	; 0x06
    40e8:	59 87       	std	Y+9, r21	; 0x09
    40ea:	48 87       	std	Y+8, r20	; 0x08
    40ec:	3b 87       	std	Y+11, r19	; 0x0b
    40ee:	2a 87       	std	Y+10, r18	; 0x0a
    40f0:	1d 87       	std	Y+13, r17	; 0x0d
    40f2:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    40f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    40f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    40f8:	00 97       	sbiw	r24, 0x00	; 0
    40fa:	11 f4       	brne	.+4      	; 0x4100 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    40fc:	1b 82       	std	Y+3, r1	; 0x03
    40fe:	38 c0       	rjmp	.+112    	; 0x4170 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    4100:	ec 81       	ldd	r30, Y+4	; 0x04
    4102:	fd 81       	ldd	r31, Y+5	; 0x05
    4104:	86 85       	ldd	r24, Z+14	; 0x0e
    4106:	88 2f       	mov	r24, r24
    4108:	90 e0       	ldi	r25, 0x00	; 0
    410a:	81 70       	andi	r24, 0x01	; 1
    410c:	90 70       	andi	r25, 0x00	; 0
    410e:	00 97       	sbiw	r24, 0x00	; 0
    4110:	d1 f4       	brne	.+52     	; 0x4146 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    4112:	81 e0       	ldi	r24, 0x01	; 1
    4114:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    4116:	28 85       	ldd	r18, Y+8	; 0x08
    4118:	39 85       	ldd	r19, Y+9	; 0x09
    411a:	39 8b       	std	Y+17, r19	; 0x11
    411c:	28 8b       	std	Y+16, r18	; 0x10
    411e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4120:	9b 85       	ldd	r25, Y+11	; 0x0b
    4122:	9f 87       	std	Y+15, r25	; 0x0f
    4124:	8e 87       	std	Y+14, r24	; 0x0e
    4126:	2e 85       	ldd	r18, Y+14	; 0x0e
    4128:	3f 85       	ldd	r19, Y+15	; 0x0f
    412a:	88 89       	ldd	r24, Y+16	; 0x10
    412c:	99 89       	ldd	r25, Y+17	; 0x11
    412e:	82 17       	cp	r24, r18
    4130:	93 07       	cpc	r25, r19
    4132:	20 f4       	brcc	.+8      	; 0x413c <prvWriteMessageToBuffer+0x74>
    4134:	28 89       	ldd	r18, Y+16	; 0x10
    4136:	39 89       	ldd	r19, Y+17	; 0x11
    4138:	3f 87       	std	Y+15, r19	; 0x0f
    413a:	2e 87       	std	Y+14, r18	; 0x0e
    413c:	8e 85       	ldd	r24, Y+14	; 0x0e
    413e:	9f 85       	ldd	r25, Y+15	; 0x0f
    4140:	99 87       	std	Y+9, r25	; 0x09
    4142:	88 87       	std	Y+8, r24	; 0x08
    4144:	15 c0       	rjmp	.+42     	; 0x4170 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    4146:	2a 85       	ldd	r18, Y+10	; 0x0a
    4148:	3b 85       	ldd	r19, Y+11	; 0x0b
    414a:	8c 85       	ldd	r24, Y+12	; 0x0c
    414c:	9d 85       	ldd	r25, Y+13	; 0x0d
    414e:	28 17       	cp	r18, r24
    4150:	39 07       	cpc	r19, r25
    4152:	68 f0       	brcs	.+26     	; 0x416e <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    4154:	81 e0       	ldi	r24, 0x01	; 1
    4156:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    4158:	9e 01       	movw	r18, r28
    415a:	28 5f       	subi	r18, 0xF8	; 248
    415c:	3f 4f       	sbci	r19, 0xFF	; 255
    415e:	8c 81       	ldd	r24, Y+4	; 0x04
    4160:	9d 81       	ldd	r25, Y+5	; 0x05
    4162:	b9 01       	movw	r22, r18
    4164:	42 e0       	ldi	r20, 0x02	; 2
    4166:	50 e0       	ldi	r21, 0x00	; 0
    4168:	0e 94 b1 23 	call	0x4762	; 0x4762 <prvWriteBytesToBuffer>
    416c:	01 c0       	rjmp	.+2      	; 0x4170 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    416e:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    4170:	8b 81       	ldd	r24, Y+3	; 0x03
    4172:	88 23       	and	r24, r24
    4174:	61 f0       	breq	.+24     	; 0x418e <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    4176:	2e 81       	ldd	r18, Y+6	; 0x06
    4178:	3f 81       	ldd	r19, Y+7	; 0x07
    417a:	48 85       	ldd	r20, Y+8	; 0x08
    417c:	59 85       	ldd	r21, Y+9	; 0x09
    417e:	8c 81       	ldd	r24, Y+4	; 0x04
    4180:	9d 81       	ldd	r25, Y+5	; 0x05
    4182:	b9 01       	movw	r22, r18
    4184:	0e 94 b1 23 	call	0x4762	; 0x4762 <prvWriteBytesToBuffer>
    4188:	9a 83       	std	Y+2, r25	; 0x02
    418a:	89 83       	std	Y+1, r24	; 0x01
    418c:	02 c0       	rjmp	.+4      	; 0x4192 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    418e:	1a 82       	std	Y+2, r1	; 0x02
    4190:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4192:	89 81       	ldd	r24, Y+1	; 0x01
    4194:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4196:	61 96       	adiw	r28, 0x11	; 17
    4198:	0f b6       	in	r0, 0x3f	; 63
    419a:	f8 94       	cli
    419c:	de bf       	out	0x3e, r29	; 62
    419e:	0f be       	out	0x3f, r0	; 63
    41a0:	cd bf       	out	0x3d, r28	; 61
    41a2:	cf 91       	pop	r28
    41a4:	df 91       	pop	r29
    41a6:	1f 91       	pop	r17
    41a8:	0f 91       	pop	r16
    41aa:	08 95       	ret

000041ac <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    41ac:	ef 92       	push	r14
    41ae:	ff 92       	push	r15
    41b0:	0f 93       	push	r16
    41b2:	1f 93       	push	r17
    41b4:	df 93       	push	r29
    41b6:	cf 93       	push	r28
    41b8:	cd b7       	in	r28, 0x3d	; 61
    41ba:	de b7       	in	r29, 0x3e	; 62
    41bc:	60 97       	sbiw	r28, 0x10	; 16
    41be:	0f b6       	in	r0, 0x3f	; 63
    41c0:	f8 94       	cli
    41c2:	de bf       	out	0x3e, r29	; 62
    41c4:	0f be       	out	0x3f, r0	; 63
    41c6:	cd bf       	out	0x3d, r28	; 61
    41c8:	9a 87       	std	Y+10, r25	; 0x0a
    41ca:	89 87       	std	Y+9, r24	; 0x09
    41cc:	7c 87       	std	Y+12, r23	; 0x0c
    41ce:	6b 87       	std	Y+11, r22	; 0x0b
    41d0:	5e 87       	std	Y+14, r21	; 0x0e
    41d2:	4d 87       	std	Y+13, r20	; 0x0d
    41d4:	38 8b       	std	Y+16, r19	; 0x10
    41d6:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    41d8:	89 85       	ldd	r24, Y+9	; 0x09
    41da:	9a 85       	ldd	r25, Y+10	; 0x0a
    41dc:	98 87       	std	Y+8, r25	; 0x08
    41de:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    41e0:	1e 82       	std	Y+6, r1	; 0x06
    41e2:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    41e4:	ef 81       	ldd	r30, Y+7	; 0x07
    41e6:	f8 85       	ldd	r31, Y+8	; 0x08
    41e8:	86 85       	ldd	r24, Z+14	; 0x0e
    41ea:	88 2f       	mov	r24, r24
    41ec:	90 e0       	ldi	r25, 0x00	; 0
    41ee:	81 70       	andi	r24, 0x01	; 1
    41f0:	90 70       	andi	r25, 0x00	; 0
    41f2:	88 23       	and	r24, r24
    41f4:	29 f0       	breq	.+10     	; 0x4200 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    41f6:	82 e0       	ldi	r24, 0x02	; 2
    41f8:	90 e0       	ldi	r25, 0x00	; 0
    41fa:	9a 83       	std	Y+2, r25	; 0x02
    41fc:	89 83       	std	Y+1, r24	; 0x01
    41fe:	02 c0       	rjmp	.+4      	; 0x4204 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    4200:	1a 82       	std	Y+2, r1	; 0x02
    4202:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    4204:	8f 85       	ldd	r24, Y+15	; 0x0f
    4206:	98 89       	ldd	r25, Y+16	; 0x10
    4208:	00 97       	sbiw	r24, 0x00	; 0
    420a:	09 f4       	brne	.+2      	; 0x420e <xStreamBufferReceive+0x62>
    420c:	3d c0       	rjmp	.+122    	; 0x4288 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    420e:	0f b6       	in	r0, 0x3f	; 63
    4210:	f8 94       	cli
    4212:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4214:	8f 81       	ldd	r24, Y+7	; 0x07
    4216:	98 85       	ldd	r25, Y+8	; 0x08
    4218:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <prvBytesInBuffer>
    421c:	9c 83       	std	Y+4, r25	; 0x04
    421e:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    4220:	2b 81       	ldd	r18, Y+3	; 0x03
    4222:	3c 81       	ldd	r19, Y+4	; 0x04
    4224:	89 81       	ldd	r24, Y+1	; 0x01
    4226:	9a 81       	ldd	r25, Y+2	; 0x02
    4228:	82 17       	cp	r24, r18
    422a:	93 07       	cpc	r25, r19
    422c:	50 f0       	brcs	.+20     	; 0x4242 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    422e:	80 e0       	ldi	r24, 0x00	; 0
    4230:	90 e0       	ldi	r25, 0x00	; 0
    4232:	0e 94 36 32 	call	0x646c	; 0x646c <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    4236:	0e 94 8f 2e 	call	0x5d1e	; 0x5d1e <xTaskGetCurrentTaskHandle>
    423a:	ef 81       	ldd	r30, Y+7	; 0x07
    423c:	f8 85       	ldd	r31, Y+8	; 0x08
    423e:	91 87       	std	Z+9, r25	; 0x09
    4240:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4242:	0f 90       	pop	r0
    4244:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    4246:	2b 81       	ldd	r18, Y+3	; 0x03
    4248:	3c 81       	ldd	r19, Y+4	; 0x04
    424a:	89 81       	ldd	r24, Y+1	; 0x01
    424c:	9a 81       	ldd	r25, Y+2	; 0x02
    424e:	82 17       	cp	r24, r18
    4250:	93 07       	cpc	r25, r19
    4252:	00 f1       	brcs	.+64     	; 0x4294 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    4254:	ef 85       	ldd	r30, Y+15	; 0x0f
    4256:	f8 89       	ldd	r31, Y+16	; 0x10
    4258:	60 e0       	ldi	r22, 0x00	; 0
    425a:	70 e0       	ldi	r23, 0x00	; 0
    425c:	80 e0       	ldi	r24, 0x00	; 0
    425e:	90 e0       	ldi	r25, 0x00	; 0
    4260:	20 e0       	ldi	r18, 0x00	; 0
    4262:	30 e0       	ldi	r19, 0x00	; 0
    4264:	40 e0       	ldi	r20, 0x00	; 0
    4266:	50 e0       	ldi	r21, 0x00	; 0
    4268:	00 e0       	ldi	r16, 0x00	; 0
    426a:	10 e0       	ldi	r17, 0x00	; 0
    426c:	7f 01       	movw	r14, r30
    426e:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    4272:	ef 81       	ldd	r30, Y+7	; 0x07
    4274:	f8 85       	ldd	r31, Y+8	; 0x08
    4276:	11 86       	std	Z+9, r1	; 0x09
    4278:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    427a:	8f 81       	ldd	r24, Y+7	; 0x07
    427c:	98 85       	ldd	r25, Y+8	; 0x08
    427e:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <prvBytesInBuffer>
    4282:	9c 83       	std	Y+4, r25	; 0x04
    4284:	8b 83       	std	Y+3, r24	; 0x03
    4286:	06 c0       	rjmp	.+12     	; 0x4294 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4288:	8f 81       	ldd	r24, Y+7	; 0x07
    428a:	98 85       	ldd	r25, Y+8	; 0x08
    428c:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <prvBytesInBuffer>
    4290:	9c 83       	std	Y+4, r25	; 0x04
    4292:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    4294:	2b 81       	ldd	r18, Y+3	; 0x03
    4296:	3c 81       	ldd	r19, Y+4	; 0x04
    4298:	89 81       	ldd	r24, Y+1	; 0x01
    429a:	9a 81       	ldd	r25, Y+2	; 0x02
    429c:	82 17       	cp	r24, r18
    429e:	93 07       	cpc	r25, r19
    42a0:	80 f5       	brcc	.+96     	; 0x4302 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    42a2:	8f 81       	ldd	r24, Y+7	; 0x07
    42a4:	98 85       	ldd	r25, Y+8	; 0x08
    42a6:	2b 85       	ldd	r18, Y+11	; 0x0b
    42a8:	3c 85       	ldd	r19, Y+12	; 0x0c
    42aa:	4d 85       	ldd	r20, Y+13	; 0x0d
    42ac:	5e 85       	ldd	r21, Y+14	; 0x0e
    42ae:	eb 81       	ldd	r30, Y+3	; 0x03
    42b0:	fc 81       	ldd	r31, Y+4	; 0x04
    42b2:	a9 81       	ldd	r26, Y+1	; 0x01
    42b4:	ba 81       	ldd	r27, Y+2	; 0x02
    42b6:	b9 01       	movw	r22, r18
    42b8:	9f 01       	movw	r18, r30
    42ba:	8d 01       	movw	r16, r26
    42bc:	0e 94 5a 22 	call	0x44b4	; 0x44b4 <prvReadMessageFromBuffer>
    42c0:	9e 83       	std	Y+6, r25	; 0x06
    42c2:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    42c4:	8d 81       	ldd	r24, Y+5	; 0x05
    42c6:	9e 81       	ldd	r25, Y+6	; 0x06
    42c8:	00 97       	sbiw	r24, 0x00	; 0
    42ca:	d9 f0       	breq	.+54     	; 0x4302 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    42cc:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
    42d0:	ef 81       	ldd	r30, Y+7	; 0x07
    42d2:	f8 85       	ldd	r31, Y+8	; 0x08
    42d4:	82 85       	ldd	r24, Z+10	; 0x0a
    42d6:	93 85       	ldd	r25, Z+11	; 0x0b
    42d8:	00 97       	sbiw	r24, 0x00	; 0
    42da:	89 f0       	breq	.+34     	; 0x42fe <xStreamBufferReceive+0x152>
    42dc:	ef 81       	ldd	r30, Y+7	; 0x07
    42de:	f8 85       	ldd	r31, Y+8	; 0x08
    42e0:	82 85       	ldd	r24, Z+10	; 0x0a
    42e2:	93 85       	ldd	r25, Z+11	; 0x0b
    42e4:	40 e0       	ldi	r20, 0x00	; 0
    42e6:	50 e0       	ldi	r21, 0x00	; 0
    42e8:	60 e0       	ldi	r22, 0x00	; 0
    42ea:	70 e0       	ldi	r23, 0x00	; 0
    42ec:	20 e0       	ldi	r18, 0x00	; 0
    42ee:	00 e0       	ldi	r16, 0x00	; 0
    42f0:	10 e0       	ldi	r17, 0x00	; 0
    42f2:	0e 94 db 2f 	call	0x5fb6	; 0x5fb6 <xTaskGenericNotify>
    42f6:	ef 81       	ldd	r30, Y+7	; 0x07
    42f8:	f8 85       	ldd	r31, Y+8	; 0x08
    42fa:	13 86       	std	Z+11, r1	; 0x0b
    42fc:	12 86       	std	Z+10, r1	; 0x0a
    42fe:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    4302:	8d 81       	ldd	r24, Y+5	; 0x05
    4304:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4306:	60 96       	adiw	r28, 0x10	; 16
    4308:	0f b6       	in	r0, 0x3f	; 63
    430a:	f8 94       	cli
    430c:	de bf       	out	0x3e, r29	; 62
    430e:	0f be       	out	0x3f, r0	; 63
    4310:	cd bf       	out	0x3d, r28	; 61
    4312:	cf 91       	pop	r28
    4314:	df 91       	pop	r29
    4316:	1f 91       	pop	r17
    4318:	0f 91       	pop	r16
    431a:	ff 90       	pop	r15
    431c:	ef 90       	pop	r14
    431e:	08 95       	ret

00004320 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    4320:	df 93       	push	r29
    4322:	cf 93       	push	r28
    4324:	cd b7       	in	r28, 0x3d	; 61
    4326:	de b7       	in	r29, 0x3e	; 62
    4328:	2c 97       	sbiw	r28, 0x0c	; 12
    432a:	0f b6       	in	r0, 0x3f	; 63
    432c:	f8 94       	cli
    432e:	de bf       	out	0x3e, r29	; 62
    4330:	0f be       	out	0x3f, r0	; 63
    4332:	cd bf       	out	0x3d, r28	; 61
    4334:	9c 87       	std	Y+12, r25	; 0x0c
    4336:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4338:	8b 85       	ldd	r24, Y+11	; 0x0b
    433a:	9c 85       	ldd	r25, Y+12	; 0x0c
    433c:	98 87       	std	Y+8, r25	; 0x08
    433e:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4340:	ef 81       	ldd	r30, Y+7	; 0x07
    4342:	f8 85       	ldd	r31, Y+8	; 0x08
    4344:	86 85       	ldd	r24, Z+14	; 0x0e
    4346:	88 2f       	mov	r24, r24
    4348:	90 e0       	ldi	r25, 0x00	; 0
    434a:	81 70       	andi	r24, 0x01	; 1
    434c:	90 70       	andi	r25, 0x00	; 0
    434e:	88 23       	and	r24, r24
    4350:	61 f1       	breq	.+88     	; 0x43aa <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4352:	8f 81       	ldd	r24, Y+7	; 0x07
    4354:	98 85       	ldd	r25, Y+8	; 0x08
    4356:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <prvBytesInBuffer>
    435a:	9c 83       	std	Y+4, r25	; 0x04
    435c:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    435e:	8b 81       	ldd	r24, Y+3	; 0x03
    4360:	9c 81       	ldd	r25, Y+4	; 0x04
    4362:	83 30       	cpi	r24, 0x03	; 3
    4364:	91 05       	cpc	r25, r1
    4366:	f0 f0       	brcs	.+60     	; 0x43a4 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    4368:	ef 81       	ldd	r30, Y+7	; 0x07
    436a:	f8 85       	ldd	r31, Y+8	; 0x08
    436c:	80 81       	ld	r24, Z
    436e:	91 81       	ldd	r25, Z+1	; 0x01
    4370:	9a 83       	std	Y+2, r25	; 0x02
    4372:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    4374:	9e 01       	movw	r18, r28
    4376:	27 5f       	subi	r18, 0xF7	; 247
    4378:	3f 4f       	sbci	r19, 0xFF	; 255
    437a:	8f 81       	ldd	r24, Y+7	; 0x07
    437c:	98 85       	ldd	r25, Y+8	; 0x08
    437e:	eb 81       	ldd	r30, Y+3	; 0x03
    4380:	fc 81       	ldd	r31, Y+4	; 0x04
    4382:	b9 01       	movw	r22, r18
    4384:	42 e0       	ldi	r20, 0x02	; 2
    4386:	50 e0       	ldi	r21, 0x00	; 0
    4388:	9f 01       	movw	r18, r30
    438a:	0e 94 3e 24 	call	0x487c	; 0x487c <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    438e:	89 85       	ldd	r24, Y+9	; 0x09
    4390:	9a 85       	ldd	r25, Y+10	; 0x0a
    4392:	9e 83       	std	Y+6, r25	; 0x06
    4394:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    4396:	ef 81       	ldd	r30, Y+7	; 0x07
    4398:	f8 85       	ldd	r31, Y+8	; 0x08
    439a:	89 81       	ldd	r24, Y+1	; 0x01
    439c:	9a 81       	ldd	r25, Y+2	; 0x02
    439e:	91 83       	std	Z+1, r25	; 0x01
    43a0:	80 83       	st	Z, r24
    43a2:	05 c0       	rjmp	.+10     	; 0x43ae <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    43a4:	1e 82       	std	Y+6, r1	; 0x06
    43a6:	1d 82       	std	Y+5, r1	; 0x05
    43a8:	02 c0       	rjmp	.+4      	; 0x43ae <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    43aa:	1e 82       	std	Y+6, r1	; 0x06
    43ac:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    43ae:	8d 81       	ldd	r24, Y+5	; 0x05
    43b0:	9e 81       	ldd	r25, Y+6	; 0x06
}
    43b2:	2c 96       	adiw	r28, 0x0c	; 12
    43b4:	0f b6       	in	r0, 0x3f	; 63
    43b6:	f8 94       	cli
    43b8:	de bf       	out	0x3e, r29	; 62
    43ba:	0f be       	out	0x3f, r0	; 63
    43bc:	cd bf       	out	0x3d, r28	; 61
    43be:	cf 91       	pop	r28
    43c0:	df 91       	pop	r29
    43c2:	08 95       	ret

000043c4 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    43c4:	ef 92       	push	r14
    43c6:	ff 92       	push	r15
    43c8:	0f 93       	push	r16
    43ca:	1f 93       	push	r17
    43cc:	df 93       	push	r29
    43ce:	cf 93       	push	r28
    43d0:	cd b7       	in	r28, 0x3d	; 61
    43d2:	de b7       	in	r29, 0x3e	; 62
    43d4:	61 97       	sbiw	r28, 0x11	; 17
    43d6:	0f b6       	in	r0, 0x3f	; 63
    43d8:	f8 94       	cli
    43da:	de bf       	out	0x3e, r29	; 62
    43dc:	0f be       	out	0x3f, r0	; 63
    43de:	cd bf       	out	0x3d, r28	; 61
    43e0:	9b 87       	std	Y+11, r25	; 0x0b
    43e2:	8a 87       	std	Y+10, r24	; 0x0a
    43e4:	7d 87       	std	Y+13, r23	; 0x0d
    43e6:	6c 87       	std	Y+12, r22	; 0x0c
    43e8:	5f 87       	std	Y+15, r21	; 0x0f
    43ea:	4e 87       	std	Y+14, r20	; 0x0e
    43ec:	39 8b       	std	Y+17, r19	; 0x11
    43ee:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    43f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    43f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    43f4:	99 87       	std	Y+9, r25	; 0x09
    43f6:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    43f8:	1f 82       	std	Y+7, r1	; 0x07
    43fa:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    43fc:	e8 85       	ldd	r30, Y+8	; 0x08
    43fe:	f9 85       	ldd	r31, Y+9	; 0x09
    4400:	86 85       	ldd	r24, Z+14	; 0x0e
    4402:	88 2f       	mov	r24, r24
    4404:	90 e0       	ldi	r25, 0x00	; 0
    4406:	81 70       	andi	r24, 0x01	; 1
    4408:	90 70       	andi	r25, 0x00	; 0
    440a:	88 23       	and	r24, r24
    440c:	29 f0       	breq	.+10     	; 0x4418 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    440e:	82 e0       	ldi	r24, 0x02	; 2
    4410:	90 e0       	ldi	r25, 0x00	; 0
    4412:	9b 83       	std	Y+3, r25	; 0x03
    4414:	8a 83       	std	Y+2, r24	; 0x02
    4416:	02 c0       	rjmp	.+4      	; 0x441c <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    4418:	1b 82       	std	Y+3, r1	; 0x03
    441a:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    441c:	88 85       	ldd	r24, Y+8	; 0x08
    441e:	99 85       	ldd	r25, Y+9	; 0x09
    4420:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <prvBytesInBuffer>
    4424:	9d 83       	std	Y+5, r25	; 0x05
    4426:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    4428:	2c 81       	ldd	r18, Y+4	; 0x04
    442a:	3d 81       	ldd	r19, Y+5	; 0x05
    442c:	8a 81       	ldd	r24, Y+2	; 0x02
    442e:	9b 81       	ldd	r25, Y+3	; 0x03
    4430:	82 17       	cp	r24, r18
    4432:	93 07       	cpc	r25, r19
    4434:	80 f5       	brcc	.+96     	; 0x4496 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    4436:	88 85       	ldd	r24, Y+8	; 0x08
    4438:	99 85       	ldd	r25, Y+9	; 0x09
    443a:	2c 85       	ldd	r18, Y+12	; 0x0c
    443c:	3d 85       	ldd	r19, Y+13	; 0x0d
    443e:	4e 85       	ldd	r20, Y+14	; 0x0e
    4440:	5f 85       	ldd	r21, Y+15	; 0x0f
    4442:	ec 81       	ldd	r30, Y+4	; 0x04
    4444:	fd 81       	ldd	r31, Y+5	; 0x05
    4446:	aa 81       	ldd	r26, Y+2	; 0x02
    4448:	bb 81       	ldd	r27, Y+3	; 0x03
    444a:	b9 01       	movw	r22, r18
    444c:	9f 01       	movw	r18, r30
    444e:	8d 01       	movw	r16, r26
    4450:	0e 94 5a 22 	call	0x44b4	; 0x44b4 <prvReadMessageFromBuffer>
    4454:	9f 83       	std	Y+7, r25	; 0x07
    4456:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    4458:	8e 81       	ldd	r24, Y+6	; 0x06
    445a:	9f 81       	ldd	r25, Y+7	; 0x07
    445c:	00 97       	sbiw	r24, 0x00	; 0
    445e:	d9 f0       	breq	.+54     	; 0x4496 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    4460:	19 82       	std	Y+1, r1	; 0x01
    4462:	e8 85       	ldd	r30, Y+8	; 0x08
    4464:	f9 85       	ldd	r31, Y+9	; 0x09
    4466:	82 85       	ldd	r24, Z+10	; 0x0a
    4468:	93 85       	ldd	r25, Z+11	; 0x0b
    446a:	00 97       	sbiw	r24, 0x00	; 0
    446c:	a1 f0       	breq	.+40     	; 0x4496 <xStreamBufferReceiveFromISR+0xd2>
    446e:	e8 85       	ldd	r30, Y+8	; 0x08
    4470:	f9 85       	ldd	r31, Y+9	; 0x09
    4472:	82 85       	ldd	r24, Z+10	; 0x0a
    4474:	93 85       	ldd	r25, Z+11	; 0x0b
    4476:	e8 89       	ldd	r30, Y+16	; 0x10
    4478:	f9 89       	ldd	r31, Y+17	; 0x11
    447a:	40 e0       	ldi	r20, 0x00	; 0
    447c:	50 e0       	ldi	r21, 0x00	; 0
    447e:	60 e0       	ldi	r22, 0x00	; 0
    4480:	70 e0       	ldi	r23, 0x00	; 0
    4482:	20 e0       	ldi	r18, 0x00	; 0
    4484:	00 e0       	ldi	r16, 0x00	; 0
    4486:	10 e0       	ldi	r17, 0x00	; 0
    4488:	7f 01       	movw	r14, r30
    448a:	0e 94 b8 30 	call	0x6170	; 0x6170 <xTaskGenericNotifyFromISR>
    448e:	e8 85       	ldd	r30, Y+8	; 0x08
    4490:	f9 85       	ldd	r31, Y+9	; 0x09
    4492:	13 86       	std	Z+11, r1	; 0x0b
    4494:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    4496:	8e 81       	ldd	r24, Y+6	; 0x06
    4498:	9f 81       	ldd	r25, Y+7	; 0x07
}
    449a:	61 96       	adiw	r28, 0x11	; 17
    449c:	0f b6       	in	r0, 0x3f	; 63
    449e:	f8 94       	cli
    44a0:	de bf       	out	0x3e, r29	; 62
    44a2:	0f be       	out	0x3f, r0	; 63
    44a4:	cd bf       	out	0x3d, r28	; 61
    44a6:	cf 91       	pop	r28
    44a8:	df 91       	pop	r29
    44aa:	1f 91       	pop	r17
    44ac:	0f 91       	pop	r16
    44ae:	ff 90       	pop	r15
    44b0:	ef 90       	pop	r14
    44b2:	08 95       	ret

000044b4 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    44b4:	0f 93       	push	r16
    44b6:	1f 93       	push	r17
    44b8:	df 93       	push	r29
    44ba:	cf 93       	push	r28
    44bc:	cd b7       	in	r28, 0x3d	; 61
    44be:	de b7       	in	r29, 0x3e	; 62
    44c0:	62 97       	sbiw	r28, 0x12	; 18
    44c2:	0f b6       	in	r0, 0x3f	; 63
    44c4:	f8 94       	cli
    44c6:	de bf       	out	0x3e, r29	; 62
    44c8:	0f be       	out	0x3f, r0	; 63
    44ca:	cd bf       	out	0x3d, r28	; 61
    44cc:	9a 87       	std	Y+10, r25	; 0x0a
    44ce:	89 87       	std	Y+9, r24	; 0x09
    44d0:	7c 87       	std	Y+12, r23	; 0x0c
    44d2:	6b 87       	std	Y+11, r22	; 0x0b
    44d4:	5e 87       	std	Y+14, r21	; 0x0e
    44d6:	4d 87       	std	Y+13, r20	; 0x0d
    44d8:	38 8b       	std	Y+16, r19	; 0x10
    44da:	2f 87       	std	Y+15, r18	; 0x0f
    44dc:	1a 8b       	std	Y+18, r17	; 0x12
    44de:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    44e0:	89 89       	ldd	r24, Y+17	; 0x11
    44e2:	9a 89       	ldd	r25, Y+18	; 0x12
    44e4:	00 97       	sbiw	r24, 0x00	; 0
    44e6:	91 f1       	breq	.+100    	; 0x454c <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    44e8:	e9 85       	ldd	r30, Y+9	; 0x09
    44ea:	fa 85       	ldd	r31, Y+10	; 0x0a
    44ec:	80 81       	ld	r24, Z
    44ee:	91 81       	ldd	r25, Z+1	; 0x01
    44f0:	9e 83       	std	Y+6, r25	; 0x06
    44f2:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    44f4:	ae 01       	movw	r20, r28
    44f6:	49 5f       	subi	r20, 0xF9	; 249
    44f8:	5f 4f       	sbci	r21, 0xFF	; 255
    44fa:	89 85       	ldd	r24, Y+9	; 0x09
    44fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    44fe:	29 89       	ldd	r18, Y+17	; 0x11
    4500:	3a 89       	ldd	r19, Y+18	; 0x12
    4502:	ef 85       	ldd	r30, Y+15	; 0x0f
    4504:	f8 89       	ldd	r31, Y+16	; 0x10
    4506:	ba 01       	movw	r22, r20
    4508:	a9 01       	movw	r20, r18
    450a:	9f 01       	movw	r18, r30
    450c:	0e 94 3e 24 	call	0x487c	; 0x487c <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    4510:	8f 81       	ldd	r24, Y+7	; 0x07
    4512:	98 85       	ldd	r25, Y+8	; 0x08
    4514:	9a 83       	std	Y+2, r25	; 0x02
    4516:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    4518:	2f 85       	ldd	r18, Y+15	; 0x0f
    451a:	38 89       	ldd	r19, Y+16	; 0x10
    451c:	89 89       	ldd	r24, Y+17	; 0x11
    451e:	9a 89       	ldd	r25, Y+18	; 0x12
    4520:	a9 01       	movw	r20, r18
    4522:	48 1b       	sub	r20, r24
    4524:	59 0b       	sbc	r21, r25
    4526:	ca 01       	movw	r24, r20
    4528:	98 8b       	std	Y+16, r25	; 0x10
    452a:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    452c:	29 81       	ldd	r18, Y+1	; 0x01
    452e:	3a 81       	ldd	r19, Y+2	; 0x02
    4530:	8d 85       	ldd	r24, Y+13	; 0x0d
    4532:	9e 85       	ldd	r25, Y+14	; 0x0e
    4534:	82 17       	cp	r24, r18
    4536:	93 07       	cpc	r25, r19
    4538:	68 f4       	brcc	.+26     	; 0x4554 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    453a:	e9 85       	ldd	r30, Y+9	; 0x09
    453c:	fa 85       	ldd	r31, Y+10	; 0x0a
    453e:	8d 81       	ldd	r24, Y+5	; 0x05
    4540:	9e 81       	ldd	r25, Y+6	; 0x06
    4542:	91 83       	std	Z+1, r25	; 0x01
    4544:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    4546:	1a 82       	std	Y+2, r1	; 0x02
    4548:	19 82       	std	Y+1, r1	; 0x01
    454a:	04 c0       	rjmp	.+8      	; 0x4554 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    454c:	8d 85       	ldd	r24, Y+13	; 0x0d
    454e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4550:	9a 83       	std	Y+2, r25	; 0x02
    4552:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    4554:	4b 85       	ldd	r20, Y+11	; 0x0b
    4556:	5c 85       	ldd	r21, Y+12	; 0x0c
    4558:	89 85       	ldd	r24, Y+9	; 0x09
    455a:	9a 85       	ldd	r25, Y+10	; 0x0a
    455c:	29 81       	ldd	r18, Y+1	; 0x01
    455e:	3a 81       	ldd	r19, Y+2	; 0x02
    4560:	ef 85       	ldd	r30, Y+15	; 0x0f
    4562:	f8 89       	ldd	r31, Y+16	; 0x10
    4564:	ba 01       	movw	r22, r20
    4566:	a9 01       	movw	r20, r18
    4568:	9f 01       	movw	r18, r30
    456a:	0e 94 3e 24 	call	0x487c	; 0x487c <prvReadBytesFromBuffer>
    456e:	9c 83       	std	Y+4, r25	; 0x04
    4570:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    4572:	8b 81       	ldd	r24, Y+3	; 0x03
    4574:	9c 81       	ldd	r25, Y+4	; 0x04
}
    4576:	62 96       	adiw	r28, 0x12	; 18
    4578:	0f b6       	in	r0, 0x3f	; 63
    457a:	f8 94       	cli
    457c:	de bf       	out	0x3e, r29	; 62
    457e:	0f be       	out	0x3f, r0	; 63
    4580:	cd bf       	out	0x3d, r28	; 61
    4582:	cf 91       	pop	r28
    4584:	df 91       	pop	r29
    4586:	1f 91       	pop	r17
    4588:	0f 91       	pop	r16
    458a:	08 95       	ret

0000458c <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    458c:	df 93       	push	r29
    458e:	cf 93       	push	r28
    4590:	cd b7       	in	r28, 0x3d	; 61
    4592:	de b7       	in	r29, 0x3e	; 62
    4594:	27 97       	sbiw	r28, 0x07	; 7
    4596:	0f b6       	in	r0, 0x3f	; 63
    4598:	f8 94       	cli
    459a:	de bf       	out	0x3e, r29	; 62
    459c:	0f be       	out	0x3f, r0	; 63
    459e:	cd bf       	out	0x3d, r28	; 61
    45a0:	9f 83       	std	Y+7, r25	; 0x07
    45a2:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    45a4:	8e 81       	ldd	r24, Y+6	; 0x06
    45a6:	9f 81       	ldd	r25, Y+7	; 0x07
    45a8:	9d 83       	std	Y+5, r25	; 0x05
    45aa:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    45ac:	ec 81       	ldd	r30, Y+4	; 0x04
    45ae:	fd 81       	ldd	r31, Y+5	; 0x05
    45b0:	80 81       	ld	r24, Z
    45b2:	91 81       	ldd	r25, Z+1	; 0x01
    45b4:	9a 83       	std	Y+2, r25	; 0x02
    45b6:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    45b8:	ec 81       	ldd	r30, Y+4	; 0x04
    45ba:	fd 81       	ldd	r31, Y+5	; 0x05
    45bc:	22 81       	ldd	r18, Z+2	; 0x02
    45be:	33 81       	ldd	r19, Z+3	; 0x03
    45c0:	89 81       	ldd	r24, Y+1	; 0x01
    45c2:	9a 81       	ldd	r25, Y+2	; 0x02
    45c4:	28 17       	cp	r18, r24
    45c6:	39 07       	cpc	r19, r25
    45c8:	19 f4       	brne	.+6      	; 0x45d0 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    45ca:	81 e0       	ldi	r24, 0x01	; 1
    45cc:	8b 83       	std	Y+3, r24	; 0x03
    45ce:	01 c0       	rjmp	.+2      	; 0x45d2 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    45d0:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    45d2:	8b 81       	ldd	r24, Y+3	; 0x03
}
    45d4:	27 96       	adiw	r28, 0x07	; 7
    45d6:	0f b6       	in	r0, 0x3f	; 63
    45d8:	f8 94       	cli
    45da:	de bf       	out	0x3e, r29	; 62
    45dc:	0f be       	out	0x3f, r0	; 63
    45de:	cd bf       	out	0x3d, r28	; 61
    45e0:	cf 91       	pop	r28
    45e2:	df 91       	pop	r29
    45e4:	08 95       	ret

000045e6 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    45e6:	df 93       	push	r29
    45e8:	cf 93       	push	r28
    45ea:	cd b7       	in	r28, 0x3d	; 61
    45ec:	de b7       	in	r29, 0x3e	; 62
    45ee:	27 97       	sbiw	r28, 0x07	; 7
    45f0:	0f b6       	in	r0, 0x3f	; 63
    45f2:	f8 94       	cli
    45f4:	de bf       	out	0x3e, r29	; 62
    45f6:	0f be       	out	0x3f, r0	; 63
    45f8:	cd bf       	out	0x3d, r28	; 61
    45fa:	9f 83       	std	Y+7, r25	; 0x07
    45fc:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    45fe:	8e 81       	ldd	r24, Y+6	; 0x06
    4600:	9f 81       	ldd	r25, Y+7	; 0x07
    4602:	9a 83       	std	Y+2, r25	; 0x02
    4604:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4606:	e9 81       	ldd	r30, Y+1	; 0x01
    4608:	fa 81       	ldd	r31, Y+2	; 0x02
    460a:	86 85       	ldd	r24, Z+14	; 0x0e
    460c:	88 2f       	mov	r24, r24
    460e:	90 e0       	ldi	r25, 0x00	; 0
    4610:	81 70       	andi	r24, 0x01	; 1
    4612:	90 70       	andi	r25, 0x00	; 0
    4614:	88 23       	and	r24, r24
    4616:	29 f0       	breq	.+10     	; 0x4622 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4618:	82 e0       	ldi	r24, 0x02	; 2
    461a:	90 e0       	ldi	r25, 0x00	; 0
    461c:	9c 83       	std	Y+4, r25	; 0x04
    461e:	8b 83       	std	Y+3, r24	; 0x03
    4620:	02 c0       	rjmp	.+4      	; 0x4626 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    4622:	1c 82       	std	Y+4, r1	; 0x04
    4624:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    4626:	8e 81       	ldd	r24, Y+6	; 0x06
    4628:	9f 81       	ldd	r25, Y+7	; 0x07
    462a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <xStreamBufferSpacesAvailable>
    462e:	9c 01       	movw	r18, r24
    4630:	8b 81       	ldd	r24, Y+3	; 0x03
    4632:	9c 81       	ldd	r25, Y+4	; 0x04
    4634:	82 17       	cp	r24, r18
    4636:	93 07       	cpc	r25, r19
    4638:	18 f0       	brcs	.+6      	; 0x4640 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    463a:	81 e0       	ldi	r24, 0x01	; 1
    463c:	8d 83       	std	Y+5, r24	; 0x05
    463e:	01 c0       	rjmp	.+2      	; 0x4642 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    4640:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    4642:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4644:	27 96       	adiw	r28, 0x07	; 7
    4646:	0f b6       	in	r0, 0x3f	; 63
    4648:	f8 94       	cli
    464a:	de bf       	out	0x3e, r29	; 62
    464c:	0f be       	out	0x3f, r0	; 63
    464e:	cd bf       	out	0x3d, r28	; 61
    4650:	cf 91       	pop	r28
    4652:	df 91       	pop	r29
    4654:	08 95       	ret

00004656 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    4656:	ef 92       	push	r14
    4658:	ff 92       	push	r15
    465a:	0f 93       	push	r16
    465c:	1f 93       	push	r17
    465e:	df 93       	push	r29
    4660:	cf 93       	push	r28
    4662:	cd b7       	in	r28, 0x3d	; 61
    4664:	de b7       	in	r29, 0x3e	; 62
    4666:	28 97       	sbiw	r28, 0x08	; 8
    4668:	0f b6       	in	r0, 0x3f	; 63
    466a:	f8 94       	cli
    466c:	de bf       	out	0x3e, r29	; 62
    466e:	0f be       	out	0x3f, r0	; 63
    4670:	cd bf       	out	0x3d, r28	; 61
    4672:	9e 83       	std	Y+6, r25	; 0x06
    4674:	8d 83       	std	Y+5, r24	; 0x05
    4676:	78 87       	std	Y+8, r23	; 0x08
    4678:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    467a:	8d 81       	ldd	r24, Y+5	; 0x05
    467c:	9e 81       	ldd	r25, Y+6	; 0x06
    467e:	9c 83       	std	Y+4, r25	; 0x04
    4680:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    4682:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    4684:	eb 81       	ldd	r30, Y+3	; 0x03
    4686:	fc 81       	ldd	r31, Y+4	; 0x04
    4688:	80 85       	ldd	r24, Z+8	; 0x08
    468a:	91 85       	ldd	r25, Z+9	; 0x09
    468c:	00 97       	sbiw	r24, 0x00	; 0
    468e:	b9 f0       	breq	.+46     	; 0x46be <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    4690:	eb 81       	ldd	r30, Y+3	; 0x03
    4692:	fc 81       	ldd	r31, Y+4	; 0x04
    4694:	80 85       	ldd	r24, Z+8	; 0x08
    4696:	91 85       	ldd	r25, Z+9	; 0x09
    4698:	ef 81       	ldd	r30, Y+7	; 0x07
    469a:	f8 85       	ldd	r31, Y+8	; 0x08
    469c:	40 e0       	ldi	r20, 0x00	; 0
    469e:	50 e0       	ldi	r21, 0x00	; 0
    46a0:	60 e0       	ldi	r22, 0x00	; 0
    46a2:	70 e0       	ldi	r23, 0x00	; 0
    46a4:	20 e0       	ldi	r18, 0x00	; 0
    46a6:	00 e0       	ldi	r16, 0x00	; 0
    46a8:	10 e0       	ldi	r17, 0x00	; 0
    46aa:	7f 01       	movw	r14, r30
    46ac:	0e 94 b8 30 	call	0x6170	; 0x6170 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    46b0:	eb 81       	ldd	r30, Y+3	; 0x03
    46b2:	fc 81       	ldd	r31, Y+4	; 0x04
    46b4:	11 86       	std	Z+9, r1	; 0x09
    46b6:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    46b8:	81 e0       	ldi	r24, 0x01	; 1
    46ba:	8a 83       	std	Y+2, r24	; 0x02
    46bc:	01 c0       	rjmp	.+2      	; 0x46c0 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    46be:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    46c0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    46c2:	28 96       	adiw	r28, 0x08	; 8
    46c4:	0f b6       	in	r0, 0x3f	; 63
    46c6:	f8 94       	cli
    46c8:	de bf       	out	0x3e, r29	; 62
    46ca:	0f be       	out	0x3f, r0	; 63
    46cc:	cd bf       	out	0x3d, r28	; 61
    46ce:	cf 91       	pop	r28
    46d0:	df 91       	pop	r29
    46d2:	1f 91       	pop	r17
    46d4:	0f 91       	pop	r16
    46d6:	ff 90       	pop	r15
    46d8:	ef 90       	pop	r14
    46da:	08 95       	ret

000046dc <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    46dc:	ef 92       	push	r14
    46de:	ff 92       	push	r15
    46e0:	0f 93       	push	r16
    46e2:	1f 93       	push	r17
    46e4:	df 93       	push	r29
    46e6:	cf 93       	push	r28
    46e8:	cd b7       	in	r28, 0x3d	; 61
    46ea:	de b7       	in	r29, 0x3e	; 62
    46ec:	28 97       	sbiw	r28, 0x08	; 8
    46ee:	0f b6       	in	r0, 0x3f	; 63
    46f0:	f8 94       	cli
    46f2:	de bf       	out	0x3e, r29	; 62
    46f4:	0f be       	out	0x3f, r0	; 63
    46f6:	cd bf       	out	0x3d, r28	; 61
    46f8:	9e 83       	std	Y+6, r25	; 0x06
    46fa:	8d 83       	std	Y+5, r24	; 0x05
    46fc:	78 87       	std	Y+8, r23	; 0x08
    46fe:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4700:	8d 81       	ldd	r24, Y+5	; 0x05
    4702:	9e 81       	ldd	r25, Y+6	; 0x06
    4704:	9c 83       	std	Y+4, r25	; 0x04
    4706:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    4708:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    470a:	eb 81       	ldd	r30, Y+3	; 0x03
    470c:	fc 81       	ldd	r31, Y+4	; 0x04
    470e:	82 85       	ldd	r24, Z+10	; 0x0a
    4710:	93 85       	ldd	r25, Z+11	; 0x0b
    4712:	00 97       	sbiw	r24, 0x00	; 0
    4714:	b9 f0       	breq	.+46     	; 0x4744 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    4716:	eb 81       	ldd	r30, Y+3	; 0x03
    4718:	fc 81       	ldd	r31, Y+4	; 0x04
    471a:	82 85       	ldd	r24, Z+10	; 0x0a
    471c:	93 85       	ldd	r25, Z+11	; 0x0b
    471e:	ef 81       	ldd	r30, Y+7	; 0x07
    4720:	f8 85       	ldd	r31, Y+8	; 0x08
    4722:	40 e0       	ldi	r20, 0x00	; 0
    4724:	50 e0       	ldi	r21, 0x00	; 0
    4726:	60 e0       	ldi	r22, 0x00	; 0
    4728:	70 e0       	ldi	r23, 0x00	; 0
    472a:	20 e0       	ldi	r18, 0x00	; 0
    472c:	00 e0       	ldi	r16, 0x00	; 0
    472e:	10 e0       	ldi	r17, 0x00	; 0
    4730:	7f 01       	movw	r14, r30
    4732:	0e 94 b8 30 	call	0x6170	; 0x6170 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    4736:	eb 81       	ldd	r30, Y+3	; 0x03
    4738:	fc 81       	ldd	r31, Y+4	; 0x04
    473a:	13 86       	std	Z+11, r1	; 0x0b
    473c:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    473e:	81 e0       	ldi	r24, 0x01	; 1
    4740:	8a 83       	std	Y+2, r24	; 0x02
    4742:	01 c0       	rjmp	.+2      	; 0x4746 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    4744:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4746:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4748:	28 96       	adiw	r28, 0x08	; 8
    474a:	0f b6       	in	r0, 0x3f	; 63
    474c:	f8 94       	cli
    474e:	de bf       	out	0x3e, r29	; 62
    4750:	0f be       	out	0x3f, r0	; 63
    4752:	cd bf       	out	0x3d, r28	; 61
    4754:	cf 91       	pop	r28
    4756:	df 91       	pop	r29
    4758:	1f 91       	pop	r17
    475a:	0f 91       	pop	r16
    475c:	ff 90       	pop	r15
    475e:	ef 90       	pop	r14
    4760:	08 95       	ret

00004762 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    4762:	df 93       	push	r29
    4764:	cf 93       	push	r28
    4766:	cd b7       	in	r28, 0x3d	; 61
    4768:	de b7       	in	r29, 0x3e	; 62
    476a:	2e 97       	sbiw	r28, 0x0e	; 14
    476c:	0f b6       	in	r0, 0x3f	; 63
    476e:	f8 94       	cli
    4770:	de bf       	out	0x3e, r29	; 62
    4772:	0f be       	out	0x3f, r0	; 63
    4774:	cd bf       	out	0x3d, r28	; 61
    4776:	9e 83       	std	Y+6, r25	; 0x06
    4778:	8d 83       	std	Y+5, r24	; 0x05
    477a:	78 87       	std	Y+8, r23	; 0x08
    477c:	6f 83       	std	Y+7, r22	; 0x07
    477e:	5a 87       	std	Y+10, r21	; 0x0a
    4780:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    4782:	ed 81       	ldd	r30, Y+5	; 0x05
    4784:	fe 81       	ldd	r31, Y+6	; 0x06
    4786:	82 81       	ldd	r24, Z+2	; 0x02
    4788:	93 81       	ldd	r25, Z+3	; 0x03
    478a:	9c 83       	std	Y+4, r25	; 0x04
    478c:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    478e:	ed 81       	ldd	r30, Y+5	; 0x05
    4790:	fe 81       	ldd	r31, Y+6	; 0x06
    4792:	24 81       	ldd	r18, Z+4	; 0x04
    4794:	35 81       	ldd	r19, Z+5	; 0x05
    4796:	8b 81       	ldd	r24, Y+3	; 0x03
    4798:	9c 81       	ldd	r25, Y+4	; 0x04
    479a:	a9 01       	movw	r20, r18
    479c:	48 1b       	sub	r20, r24
    479e:	59 0b       	sbc	r21, r25
    47a0:	ca 01       	movw	r24, r20
    47a2:	29 85       	ldd	r18, Y+9	; 0x09
    47a4:	3a 85       	ldd	r19, Y+10	; 0x0a
    47a6:	3e 87       	std	Y+14, r19	; 0x0e
    47a8:	2d 87       	std	Y+13, r18	; 0x0d
    47aa:	9c 87       	std	Y+12, r25	; 0x0c
    47ac:	8b 87       	std	Y+11, r24	; 0x0b
    47ae:	4b 85       	ldd	r20, Y+11	; 0x0b
    47b0:	5c 85       	ldd	r21, Y+12	; 0x0c
    47b2:	8d 85       	ldd	r24, Y+13	; 0x0d
    47b4:	9e 85       	ldd	r25, Y+14	; 0x0e
    47b6:	84 17       	cp	r24, r20
    47b8:	95 07       	cpc	r25, r21
    47ba:	20 f4       	brcc	.+8      	; 0x47c4 <prvWriteBytesToBuffer+0x62>
    47bc:	2d 85       	ldd	r18, Y+13	; 0x0d
    47be:	3e 85       	ldd	r19, Y+14	; 0x0e
    47c0:	3c 87       	std	Y+12, r19	; 0x0c
    47c2:	2b 87       	std	Y+11, r18	; 0x0b
    47c4:	4b 85       	ldd	r20, Y+11	; 0x0b
    47c6:	5c 85       	ldd	r21, Y+12	; 0x0c
    47c8:	5a 83       	std	Y+2, r21	; 0x02
    47ca:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    47cc:	ed 81       	ldd	r30, Y+5	; 0x05
    47ce:	fe 81       	ldd	r31, Y+6	; 0x06
    47d0:	24 85       	ldd	r18, Z+12	; 0x0c
    47d2:	35 85       	ldd	r19, Z+13	; 0x0d
    47d4:	8b 81       	ldd	r24, Y+3	; 0x03
    47d6:	9c 81       	ldd	r25, Y+4	; 0x04
    47d8:	82 0f       	add	r24, r18
    47da:	93 1f       	adc	r25, r19
    47dc:	2f 81       	ldd	r18, Y+7	; 0x07
    47de:	38 85       	ldd	r19, Y+8	; 0x08
    47e0:	49 81       	ldd	r20, Y+1	; 0x01
    47e2:	5a 81       	ldd	r21, Y+2	; 0x02
    47e4:	b9 01       	movw	r22, r18
    47e6:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    47ea:	29 85       	ldd	r18, Y+9	; 0x09
    47ec:	3a 85       	ldd	r19, Y+10	; 0x0a
    47ee:	89 81       	ldd	r24, Y+1	; 0x01
    47f0:	9a 81       	ldd	r25, Y+2	; 0x02
    47f2:	82 17       	cp	r24, r18
    47f4:	93 07       	cpc	r25, r19
    47f6:	b0 f4       	brcc	.+44     	; 0x4824 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    47f8:	ed 81       	ldd	r30, Y+5	; 0x05
    47fa:	fe 81       	ldd	r31, Y+6	; 0x06
    47fc:	64 85       	ldd	r22, Z+12	; 0x0c
    47fe:	75 85       	ldd	r23, Z+13	; 0x0d
    4800:	2f 81       	ldd	r18, Y+7	; 0x07
    4802:	38 85       	ldd	r19, Y+8	; 0x08
    4804:	89 81       	ldd	r24, Y+1	; 0x01
    4806:	9a 81       	ldd	r25, Y+2	; 0x02
    4808:	a9 01       	movw	r20, r18
    480a:	48 0f       	add	r20, r24
    480c:	59 1f       	adc	r21, r25
    480e:	29 85       	ldd	r18, Y+9	; 0x09
    4810:	3a 85       	ldd	r19, Y+10	; 0x0a
    4812:	89 81       	ldd	r24, Y+1	; 0x01
    4814:	9a 81       	ldd	r25, Y+2	; 0x02
    4816:	28 1b       	sub	r18, r24
    4818:	39 0b       	sbc	r19, r25
    481a:	cb 01       	movw	r24, r22
    481c:	ba 01       	movw	r22, r20
    481e:	a9 01       	movw	r20, r18
    4820:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    4824:	2b 81       	ldd	r18, Y+3	; 0x03
    4826:	3c 81       	ldd	r19, Y+4	; 0x04
    4828:	89 85       	ldd	r24, Y+9	; 0x09
    482a:	9a 85       	ldd	r25, Y+10	; 0x0a
    482c:	82 0f       	add	r24, r18
    482e:	93 1f       	adc	r25, r19
    4830:	9c 83       	std	Y+4, r25	; 0x04
    4832:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    4834:	ed 81       	ldd	r30, Y+5	; 0x05
    4836:	fe 81       	ldd	r31, Y+6	; 0x06
    4838:	24 81       	ldd	r18, Z+4	; 0x04
    483a:	35 81       	ldd	r19, Z+5	; 0x05
    483c:	8b 81       	ldd	r24, Y+3	; 0x03
    483e:	9c 81       	ldd	r25, Y+4	; 0x04
    4840:	82 17       	cp	r24, r18
    4842:	93 07       	cpc	r25, r19
    4844:	50 f0       	brcs	.+20     	; 0x485a <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    4846:	ed 81       	ldd	r30, Y+5	; 0x05
    4848:	fe 81       	ldd	r31, Y+6	; 0x06
    484a:	24 81       	ldd	r18, Z+4	; 0x04
    484c:	35 81       	ldd	r19, Z+5	; 0x05
    484e:	8b 81       	ldd	r24, Y+3	; 0x03
    4850:	9c 81       	ldd	r25, Y+4	; 0x04
    4852:	82 1b       	sub	r24, r18
    4854:	93 0b       	sbc	r25, r19
    4856:	9c 83       	std	Y+4, r25	; 0x04
    4858:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    485a:	ed 81       	ldd	r30, Y+5	; 0x05
    485c:	fe 81       	ldd	r31, Y+6	; 0x06
    485e:	8b 81       	ldd	r24, Y+3	; 0x03
    4860:	9c 81       	ldd	r25, Y+4	; 0x04
    4862:	93 83       	std	Z+3, r25	; 0x03
    4864:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    4866:	89 85       	ldd	r24, Y+9	; 0x09
    4868:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    486a:	2e 96       	adiw	r28, 0x0e	; 14
    486c:	0f b6       	in	r0, 0x3f	; 63
    486e:	f8 94       	cli
    4870:	de bf       	out	0x3e, r29	; 62
    4872:	0f be       	out	0x3f, r0	; 63
    4874:	cd bf       	out	0x3d, r28	; 61
    4876:	cf 91       	pop	r28
    4878:	df 91       	pop	r29
    487a:	08 95       	ret

0000487c <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    487c:	df 93       	push	r29
    487e:	cf 93       	push	r28
    4880:	cd b7       	in	r28, 0x3d	; 61
    4882:	de b7       	in	r29, 0x3e	; 62
    4884:	66 97       	sbiw	r28, 0x16	; 22
    4886:	0f b6       	in	r0, 0x3f	; 63
    4888:	f8 94       	cli
    488a:	de bf       	out	0x3e, r29	; 62
    488c:	0f be       	out	0x3f, r0	; 63
    488e:	cd bf       	out	0x3d, r28	; 61
    4890:	98 87       	std	Y+8, r25	; 0x08
    4892:	8f 83       	std	Y+7, r24	; 0x07
    4894:	7a 87       	std	Y+10, r23	; 0x0a
    4896:	69 87       	std	Y+9, r22	; 0x09
    4898:	5c 87       	std	Y+12, r21	; 0x0c
    489a:	4b 87       	std	Y+11, r20	; 0x0b
    489c:	3e 87       	std	Y+14, r19	; 0x0e
    489e:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    48a0:	2d 85       	ldd	r18, Y+13	; 0x0d
    48a2:	3e 85       	ldd	r19, Y+14	; 0x0e
    48a4:	3a 8b       	std	Y+18, r19	; 0x12
    48a6:	29 8b       	std	Y+17, r18	; 0x11
    48a8:	4b 85       	ldd	r20, Y+11	; 0x0b
    48aa:	5c 85       	ldd	r21, Y+12	; 0x0c
    48ac:	58 8b       	std	Y+16, r21	; 0x10
    48ae:	4f 87       	std	Y+15, r20	; 0x0f
    48b0:	8f 85       	ldd	r24, Y+15	; 0x0f
    48b2:	98 89       	ldd	r25, Y+16	; 0x10
    48b4:	29 89       	ldd	r18, Y+17	; 0x11
    48b6:	3a 89       	ldd	r19, Y+18	; 0x12
    48b8:	28 17       	cp	r18, r24
    48ba:	39 07       	cpc	r19, r25
    48bc:	20 f4       	brcc	.+8      	; 0x48c6 <prvReadBytesFromBuffer+0x4a>
    48be:	49 89       	ldd	r20, Y+17	; 0x11
    48c0:	5a 89       	ldd	r21, Y+18	; 0x12
    48c2:	58 8b       	std	Y+16, r21	; 0x10
    48c4:	4f 87       	std	Y+15, r20	; 0x0f
    48c6:	8f 85       	ldd	r24, Y+15	; 0x0f
    48c8:	98 89       	ldd	r25, Y+16	; 0x10
    48ca:	9e 83       	std	Y+6, r25	; 0x06
    48cc:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    48ce:	8d 81       	ldd	r24, Y+5	; 0x05
    48d0:	9e 81       	ldd	r25, Y+6	; 0x06
    48d2:	00 97       	sbiw	r24, 0x00	; 0
    48d4:	09 f4       	brne	.+2      	; 0x48d8 <prvReadBytesFromBuffer+0x5c>
    48d6:	74 c0       	rjmp	.+232    	; 0x49c0 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    48d8:	ef 81       	ldd	r30, Y+7	; 0x07
    48da:	f8 85       	ldd	r31, Y+8	; 0x08
    48dc:	80 81       	ld	r24, Z
    48de:	91 81       	ldd	r25, Z+1	; 0x01
    48e0:	9a 83       	std	Y+2, r25	; 0x02
    48e2:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    48e4:	ef 81       	ldd	r30, Y+7	; 0x07
    48e6:	f8 85       	ldd	r31, Y+8	; 0x08
    48e8:	24 81       	ldd	r18, Z+4	; 0x04
    48ea:	35 81       	ldd	r19, Z+5	; 0x05
    48ec:	89 81       	ldd	r24, Y+1	; 0x01
    48ee:	9a 81       	ldd	r25, Y+2	; 0x02
    48f0:	a9 01       	movw	r20, r18
    48f2:	48 1b       	sub	r20, r24
    48f4:	59 0b       	sbc	r21, r25
    48f6:	ca 01       	movw	r24, r20
    48f8:	2d 81       	ldd	r18, Y+5	; 0x05
    48fa:	3e 81       	ldd	r19, Y+6	; 0x06
    48fc:	3e 8b       	std	Y+22, r19	; 0x16
    48fe:	2d 8b       	std	Y+21, r18	; 0x15
    4900:	9c 8b       	std	Y+20, r25	; 0x14
    4902:	8b 8b       	std	Y+19, r24	; 0x13
    4904:	4b 89       	ldd	r20, Y+19	; 0x13
    4906:	5c 89       	ldd	r21, Y+20	; 0x14
    4908:	8d 89       	ldd	r24, Y+21	; 0x15
    490a:	9e 89       	ldd	r25, Y+22	; 0x16
    490c:	84 17       	cp	r24, r20
    490e:	95 07       	cpc	r25, r21
    4910:	20 f4       	brcc	.+8      	; 0x491a <prvReadBytesFromBuffer+0x9e>
    4912:	2d 89       	ldd	r18, Y+21	; 0x15
    4914:	3e 89       	ldd	r19, Y+22	; 0x16
    4916:	3c 8b       	std	Y+20, r19	; 0x14
    4918:	2b 8b       	std	Y+19, r18	; 0x13
    491a:	4b 89       	ldd	r20, Y+19	; 0x13
    491c:	5c 89       	ldd	r21, Y+20	; 0x14
    491e:	5c 83       	std	Y+4, r21	; 0x04
    4920:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4922:	ef 81       	ldd	r30, Y+7	; 0x07
    4924:	f8 85       	ldd	r31, Y+8	; 0x08
    4926:	24 85       	ldd	r18, Z+12	; 0x0c
    4928:	35 85       	ldd	r19, Z+13	; 0x0d
    492a:	89 81       	ldd	r24, Y+1	; 0x01
    492c:	9a 81       	ldd	r25, Y+2	; 0x02
    492e:	a9 01       	movw	r20, r18
    4930:	48 0f       	add	r20, r24
    4932:	59 1f       	adc	r21, r25
    4934:	89 85       	ldd	r24, Y+9	; 0x09
    4936:	9a 85       	ldd	r25, Y+10	; 0x0a
    4938:	2b 81       	ldd	r18, Y+3	; 0x03
    493a:	3c 81       	ldd	r19, Y+4	; 0x04
    493c:	ba 01       	movw	r22, r20
    493e:	a9 01       	movw	r20, r18
    4940:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    4944:	2d 81       	ldd	r18, Y+5	; 0x05
    4946:	3e 81       	ldd	r19, Y+6	; 0x06
    4948:	8b 81       	ldd	r24, Y+3	; 0x03
    494a:	9c 81       	ldd	r25, Y+4	; 0x04
    494c:	82 17       	cp	r24, r18
    494e:	93 07       	cpc	r25, r19
    4950:	b0 f4       	brcc	.+44     	; 0x497e <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4952:	29 85       	ldd	r18, Y+9	; 0x09
    4954:	3a 85       	ldd	r19, Y+10	; 0x0a
    4956:	8b 81       	ldd	r24, Y+3	; 0x03
    4958:	9c 81       	ldd	r25, Y+4	; 0x04
    495a:	b9 01       	movw	r22, r18
    495c:	68 0f       	add	r22, r24
    495e:	79 1f       	adc	r23, r25
    4960:	ef 81       	ldd	r30, Y+7	; 0x07
    4962:	f8 85       	ldd	r31, Y+8	; 0x08
    4964:	44 85       	ldd	r20, Z+12	; 0x0c
    4966:	55 85       	ldd	r21, Z+13	; 0x0d
    4968:	2d 81       	ldd	r18, Y+5	; 0x05
    496a:	3e 81       	ldd	r19, Y+6	; 0x06
    496c:	8b 81       	ldd	r24, Y+3	; 0x03
    496e:	9c 81       	ldd	r25, Y+4	; 0x04
    4970:	28 1b       	sub	r18, r24
    4972:	39 0b       	sbc	r19, r25
    4974:	cb 01       	movw	r24, r22
    4976:	ba 01       	movw	r22, r20
    4978:	a9 01       	movw	r20, r18
    497a:	0e 94 ec 32 	call	0x65d8	; 0x65d8 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    497e:	29 81       	ldd	r18, Y+1	; 0x01
    4980:	3a 81       	ldd	r19, Y+2	; 0x02
    4982:	8d 81       	ldd	r24, Y+5	; 0x05
    4984:	9e 81       	ldd	r25, Y+6	; 0x06
    4986:	82 0f       	add	r24, r18
    4988:	93 1f       	adc	r25, r19
    498a:	9a 83       	std	Y+2, r25	; 0x02
    498c:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    498e:	ef 81       	ldd	r30, Y+7	; 0x07
    4990:	f8 85       	ldd	r31, Y+8	; 0x08
    4992:	24 81       	ldd	r18, Z+4	; 0x04
    4994:	35 81       	ldd	r19, Z+5	; 0x05
    4996:	89 81       	ldd	r24, Y+1	; 0x01
    4998:	9a 81       	ldd	r25, Y+2	; 0x02
    499a:	82 17       	cp	r24, r18
    499c:	93 07       	cpc	r25, r19
    499e:	50 f0       	brcs	.+20     	; 0x49b4 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    49a0:	ef 81       	ldd	r30, Y+7	; 0x07
    49a2:	f8 85       	ldd	r31, Y+8	; 0x08
    49a4:	24 81       	ldd	r18, Z+4	; 0x04
    49a6:	35 81       	ldd	r19, Z+5	; 0x05
    49a8:	89 81       	ldd	r24, Y+1	; 0x01
    49aa:	9a 81       	ldd	r25, Y+2	; 0x02
    49ac:	82 1b       	sub	r24, r18
    49ae:	93 0b       	sbc	r25, r19
    49b0:	9a 83       	std	Y+2, r25	; 0x02
    49b2:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    49b4:	ef 81       	ldd	r30, Y+7	; 0x07
    49b6:	f8 85       	ldd	r31, Y+8	; 0x08
    49b8:	89 81       	ldd	r24, Y+1	; 0x01
    49ba:	9a 81       	ldd	r25, Y+2	; 0x02
    49bc:	91 83       	std	Z+1, r25	; 0x01
    49be:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    49c0:	8d 81       	ldd	r24, Y+5	; 0x05
    49c2:	9e 81       	ldd	r25, Y+6	; 0x06
}
    49c4:	66 96       	adiw	r28, 0x16	; 22
    49c6:	0f b6       	in	r0, 0x3f	; 63
    49c8:	f8 94       	cli
    49ca:	de bf       	out	0x3e, r29	; 62
    49cc:	0f be       	out	0x3f, r0	; 63
    49ce:	cd bf       	out	0x3d, r28	; 61
    49d0:	cf 91       	pop	r28
    49d2:	df 91       	pop	r29
    49d4:	08 95       	ret

000049d6 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    49d6:	df 93       	push	r29
    49d8:	cf 93       	push	r28
    49da:	00 d0       	rcall	.+0      	; 0x49dc <prvBytesInBuffer+0x6>
    49dc:	00 d0       	rcall	.+0      	; 0x49de <prvBytesInBuffer+0x8>
    49de:	cd b7       	in	r28, 0x3d	; 61
    49e0:	de b7       	in	r29, 0x3e	; 62
    49e2:	9c 83       	std	Y+4, r25	; 0x04
    49e4:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    49e6:	eb 81       	ldd	r30, Y+3	; 0x03
    49e8:	fc 81       	ldd	r31, Y+4	; 0x04
    49ea:	24 81       	ldd	r18, Z+4	; 0x04
    49ec:	35 81       	ldd	r19, Z+5	; 0x05
    49ee:	eb 81       	ldd	r30, Y+3	; 0x03
    49f0:	fc 81       	ldd	r31, Y+4	; 0x04
    49f2:	82 81       	ldd	r24, Z+2	; 0x02
    49f4:	93 81       	ldd	r25, Z+3	; 0x03
    49f6:	82 0f       	add	r24, r18
    49f8:	93 1f       	adc	r25, r19
    49fa:	9a 83       	std	Y+2, r25	; 0x02
    49fc:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    49fe:	eb 81       	ldd	r30, Y+3	; 0x03
    4a00:	fc 81       	ldd	r31, Y+4	; 0x04
    4a02:	20 81       	ld	r18, Z
    4a04:	31 81       	ldd	r19, Z+1	; 0x01
    4a06:	89 81       	ldd	r24, Y+1	; 0x01
    4a08:	9a 81       	ldd	r25, Y+2	; 0x02
    4a0a:	82 1b       	sub	r24, r18
    4a0c:	93 0b       	sbc	r25, r19
    4a0e:	9a 83       	std	Y+2, r25	; 0x02
    4a10:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    4a12:	eb 81       	ldd	r30, Y+3	; 0x03
    4a14:	fc 81       	ldd	r31, Y+4	; 0x04
    4a16:	24 81       	ldd	r18, Z+4	; 0x04
    4a18:	35 81       	ldd	r19, Z+5	; 0x05
    4a1a:	89 81       	ldd	r24, Y+1	; 0x01
    4a1c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a1e:	82 17       	cp	r24, r18
    4a20:	93 07       	cpc	r25, r19
    4a22:	50 f0       	brcs	.+20     	; 0x4a38 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    4a24:	eb 81       	ldd	r30, Y+3	; 0x03
    4a26:	fc 81       	ldd	r31, Y+4	; 0x04
    4a28:	24 81       	ldd	r18, Z+4	; 0x04
    4a2a:	35 81       	ldd	r19, Z+5	; 0x05
    4a2c:	89 81       	ldd	r24, Y+1	; 0x01
    4a2e:	9a 81       	ldd	r25, Y+2	; 0x02
    4a30:	82 1b       	sub	r24, r18
    4a32:	93 0b       	sbc	r25, r19
    4a34:	9a 83       	std	Y+2, r25	; 0x02
    4a36:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    4a38:	89 81       	ldd	r24, Y+1	; 0x01
    4a3a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4a3c:	0f 90       	pop	r0
    4a3e:	0f 90       	pop	r0
    4a40:	0f 90       	pop	r0
    4a42:	0f 90       	pop	r0
    4a44:	cf 91       	pop	r28
    4a46:	df 91       	pop	r29
    4a48:	08 95       	ret

00004a4a <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    4a4a:	0f 93       	push	r16
    4a4c:	df 93       	push	r29
    4a4e:	cf 93       	push	r28
    4a50:	cd b7       	in	r28, 0x3d	; 61
    4a52:	de b7       	in	r29, 0x3e	; 62
    4a54:	29 97       	sbiw	r28, 0x09	; 9
    4a56:	0f b6       	in	r0, 0x3f	; 63
    4a58:	f8 94       	cli
    4a5a:	de bf       	out	0x3e, r29	; 62
    4a5c:	0f be       	out	0x3f, r0	; 63
    4a5e:	cd bf       	out	0x3d, r28	; 61
    4a60:	9a 83       	std	Y+2, r25	; 0x02
    4a62:	89 83       	std	Y+1, r24	; 0x01
    4a64:	7c 83       	std	Y+4, r23	; 0x04
    4a66:	6b 83       	std	Y+3, r22	; 0x03
    4a68:	5e 83       	std	Y+6, r21	; 0x06
    4a6a:	4d 83       	std	Y+5, r20	; 0x05
    4a6c:	38 87       	std	Y+8, r19	; 0x08
    4a6e:	2f 83       	std	Y+7, r18	; 0x07
    4a70:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    4a72:	89 81       	ldd	r24, Y+1	; 0x01
    4a74:	9a 81       	ldd	r25, Y+2	; 0x02
    4a76:	60 e0       	ldi	r22, 0x00	; 0
    4a78:	70 e0       	ldi	r23, 0x00	; 0
    4a7a:	4f e0       	ldi	r20, 0x0F	; 15
    4a7c:	50 e0       	ldi	r21, 0x00	; 0
    4a7e:	0e 94 f5 32 	call	0x65ea	; 0x65ea <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    4a82:	e9 81       	ldd	r30, Y+1	; 0x01
    4a84:	fa 81       	ldd	r31, Y+2	; 0x02
    4a86:	8b 81       	ldd	r24, Y+3	; 0x03
    4a88:	9c 81       	ldd	r25, Y+4	; 0x04
    4a8a:	95 87       	std	Z+13, r25	; 0x0d
    4a8c:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    4a8e:	e9 81       	ldd	r30, Y+1	; 0x01
    4a90:	fa 81       	ldd	r31, Y+2	; 0x02
    4a92:	8d 81       	ldd	r24, Y+5	; 0x05
    4a94:	9e 81       	ldd	r25, Y+6	; 0x06
    4a96:	95 83       	std	Z+5, r25	; 0x05
    4a98:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    4a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a9e:	8f 81       	ldd	r24, Y+7	; 0x07
    4aa0:	98 85       	ldd	r25, Y+8	; 0x08
    4aa2:	97 83       	std	Z+7, r25	; 0x07
    4aa4:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    4aa6:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa8:	fa 81       	ldd	r31, Y+2	; 0x02
    4aaa:	89 85       	ldd	r24, Y+9	; 0x09
    4aac:	86 87       	std	Z+14, r24	; 0x0e
}
    4aae:	29 96       	adiw	r28, 0x09	; 9
    4ab0:	0f b6       	in	r0, 0x3f	; 63
    4ab2:	f8 94       	cli
    4ab4:	de bf       	out	0x3e, r29	; 62
    4ab6:	0f be       	out	0x3f, r0	; 63
    4ab8:	cd bf       	out	0x3d, r28	; 61
    4aba:	cf 91       	pop	r28
    4abc:	df 91       	pop	r29
    4abe:	0f 91       	pop	r16
    4ac0:	08 95       	ret

00004ac2 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4ac2:	8f 92       	push	r8
    4ac4:	9f 92       	push	r9
    4ac6:	af 92       	push	r10
    4ac8:	bf 92       	push	r11
    4aca:	cf 92       	push	r12
    4acc:	df 92       	push	r13
    4ace:	ef 92       	push	r14
    4ad0:	ff 92       	push	r15
    4ad2:	0f 93       	push	r16
    4ad4:	1f 93       	push	r17
    4ad6:	df 93       	push	r29
    4ad8:	cf 93       	push	r28
    4ada:	cd b7       	in	r28, 0x3d	; 61
    4adc:	de b7       	in	r29, 0x3e	; 62
    4ade:	60 97       	sbiw	r28, 0x10	; 16
    4ae0:	0f b6       	in	r0, 0x3f	; 63
    4ae2:	f8 94       	cli
    4ae4:	de bf       	out	0x3e, r29	; 62
    4ae6:	0f be       	out	0x3f, r0	; 63
    4ae8:	cd bf       	out	0x3d, r28	; 61
    4aea:	9f 83       	std	Y+7, r25	; 0x07
    4aec:	8e 83       	std	Y+6, r24	; 0x06
    4aee:	79 87       	std	Y+9, r23	; 0x09
    4af0:	68 87       	std	Y+8, r22	; 0x08
    4af2:	5b 87       	std	Y+11, r21	; 0x0b
    4af4:	4a 87       	std	Y+10, r20	; 0x0a
    4af6:	3d 87       	std	Y+13, r19	; 0x0d
    4af8:	2c 87       	std	Y+12, r18	; 0x0c
    4afa:	0e 87       	std	Y+14, r16	; 0x0e
    4afc:	f8 8a       	std	Y+16, r15	; 0x10
    4afe:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    4b00:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b02:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b04:	0e 94 4f 11 	call	0x229e	; 0x229e <pvPortMalloc>
    4b08:	9a 83       	std	Y+2, r25	; 0x02
    4b0a:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    4b0c:	89 81       	ldd	r24, Y+1	; 0x01
    4b0e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b10:	00 97       	sbiw	r24, 0x00	; 0
    4b12:	b1 f0       	breq	.+44     	; 0x4b40 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    4b14:	86 e2       	ldi	r24, 0x26	; 38
    4b16:	90 e0       	ldi	r25, 0x00	; 0
    4b18:	0e 94 4f 11 	call	0x229e	; 0x229e <pvPortMalloc>
    4b1c:	9d 83       	std	Y+5, r25	; 0x05
    4b1e:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    4b20:	8c 81       	ldd	r24, Y+4	; 0x04
    4b22:	9d 81       	ldd	r25, Y+5	; 0x05
    4b24:	00 97       	sbiw	r24, 0x00	; 0
    4b26:	39 f0       	breq	.+14     	; 0x4b36 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    4b28:	ec 81       	ldd	r30, Y+4	; 0x04
    4b2a:	fd 81       	ldd	r31, Y+5	; 0x05
    4b2c:	89 81       	ldd	r24, Y+1	; 0x01
    4b2e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b30:	90 8f       	std	Z+24, r25	; 0x18
    4b32:	87 8b       	std	Z+23, r24	; 0x17
    4b34:	07 c0       	rjmp	.+14     	; 0x4b44 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    4b36:	89 81       	ldd	r24, Y+1	; 0x01
    4b38:	9a 81       	ldd	r25, Y+2	; 0x02
    4b3a:	0e 94 a5 11 	call	0x234a	; 0x234a <vPortFree>
    4b3e:	02 c0       	rjmp	.+4      	; 0x4b44 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    4b40:	1d 82       	std	Y+5, r1	; 0x05
    4b42:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    4b44:	8c 81       	ldd	r24, Y+4	; 0x04
    4b46:	9d 81       	ldd	r25, Y+5	; 0x05
    4b48:	00 97       	sbiw	r24, 0x00	; 0
    4b4a:	e9 f0       	breq	.+58     	; 0x4b86 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4b4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b4e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b50:	9c 01       	movw	r18, r24
    4b52:	40 e0       	ldi	r20, 0x00	; 0
    4b54:	50 e0       	ldi	r21, 0x00	; 0
    4b56:	8e 81       	ldd	r24, Y+6	; 0x06
    4b58:	9f 81       	ldd	r25, Y+7	; 0x07
    4b5a:	68 85       	ldd	r22, Y+8	; 0x08
    4b5c:	79 85       	ldd	r23, Y+9	; 0x09
    4b5e:	ec 85       	ldd	r30, Y+12	; 0x0c
    4b60:	fd 85       	ldd	r31, Y+13	; 0x0d
    4b62:	af 85       	ldd	r26, Y+15	; 0x0f
    4b64:	b8 89       	ldd	r27, Y+16	; 0x10
    4b66:	ac 80       	ldd	r10, Y+4	; 0x04
    4b68:	bd 80       	ldd	r11, Y+5	; 0x05
    4b6a:	8f 01       	movw	r16, r30
    4b6c:	ee 84       	ldd	r14, Y+14	; 0x0e
    4b6e:	6d 01       	movw	r12, r26
    4b70:	88 24       	eor	r8, r8
    4b72:	99 24       	eor	r9, r9
    4b74:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    4b78:	8c 81       	ldd	r24, Y+4	; 0x04
    4b7a:	9d 81       	ldd	r25, Y+5	; 0x05
    4b7c:	0e 94 95 26 	call	0x4d2a	; 0x4d2a <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    4b80:	81 e0       	ldi	r24, 0x01	; 1
    4b82:	8b 83       	std	Y+3, r24	; 0x03
    4b84:	02 c0       	rjmp	.+4      	; 0x4b8a <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4b86:	8f ef       	ldi	r24, 0xFF	; 255
    4b88:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    4b8a:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4b8c:	60 96       	adiw	r28, 0x10	; 16
    4b8e:	0f b6       	in	r0, 0x3f	; 63
    4b90:	f8 94       	cli
    4b92:	de bf       	out	0x3e, r29	; 62
    4b94:	0f be       	out	0x3f, r0	; 63
    4b96:	cd bf       	out	0x3d, r28	; 61
    4b98:	cf 91       	pop	r28
    4b9a:	df 91       	pop	r29
    4b9c:	1f 91       	pop	r17
    4b9e:	0f 91       	pop	r16
    4ba0:	ff 90       	pop	r15
    4ba2:	ef 90       	pop	r14
    4ba4:	df 90       	pop	r13
    4ba6:	cf 90       	pop	r12
    4ba8:	bf 90       	pop	r11
    4baa:	af 90       	pop	r10
    4bac:	9f 90       	pop	r9
    4bae:	8f 90       	pop	r8
    4bb0:	08 95       	ret

00004bb2 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    4bb2:	8f 92       	push	r8
    4bb4:	9f 92       	push	r9
    4bb6:	af 92       	push	r10
    4bb8:	bf 92       	push	r11
    4bba:	cf 92       	push	r12
    4bbc:	df 92       	push	r13
    4bbe:	ef 92       	push	r14
    4bc0:	0f 93       	push	r16
    4bc2:	1f 93       	push	r17
    4bc4:	df 93       	push	r29
    4bc6:	cf 93       	push	r28
    4bc8:	cd b7       	in	r28, 0x3d	; 61
    4bca:	de b7       	in	r29, 0x3e	; 62
    4bcc:	64 97       	sbiw	r28, 0x14	; 20
    4bce:	0f b6       	in	r0, 0x3f	; 63
    4bd0:	f8 94       	cli
    4bd2:	de bf       	out	0x3e, r29	; 62
    4bd4:	0f be       	out	0x3f, r0	; 63
    4bd6:	cd bf       	out	0x3d, r28	; 61
    4bd8:	9d 83       	std	Y+5, r25	; 0x05
    4bda:	8c 83       	std	Y+4, r24	; 0x04
    4bdc:	7f 83       	std	Y+7, r23	; 0x07
    4bde:	6e 83       	std	Y+6, r22	; 0x06
    4be0:	28 87       	std	Y+8, r18	; 0x08
    4be2:	39 87       	std	Y+9, r19	; 0x09
    4be4:	4a 87       	std	Y+10, r20	; 0x0a
    4be6:	5b 87       	std	Y+11, r21	; 0x0b
    4be8:	1d 87       	std	Y+13, r17	; 0x0d
    4bea:	0c 87       	std	Y+12, r16	; 0x0c
    4bec:	ee 86       	std	Y+14, r14	; 0x0e
    4bee:	d8 8a       	std	Y+16, r13	; 0x10
    4bf0:	cf 86       	std	Y+15, r12	; 0x0f
    4bf2:	ba 8a       	std	Y+18, r11	; 0x12
    4bf4:	a9 8a       	std	Y+17, r10	; 0x11
    4bf6:	9c 8a       	std	Y+20, r9	; 0x14
    4bf8:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    4bfa:	e9 89       	ldd	r30, Y+17	; 0x11
    4bfc:	fa 89       	ldd	r31, Y+18	; 0x12
    4bfe:	27 89       	ldd	r18, Z+23	; 0x17
    4c00:	30 8d       	ldd	r19, Z+24	; 0x18
    4c02:	88 85       	ldd	r24, Y+8	; 0x08
    4c04:	99 85       	ldd	r25, Y+9	; 0x09
    4c06:	01 97       	sbiw	r24, 0x01	; 1
    4c08:	82 0f       	add	r24, r18
    4c0a:	93 1f       	adc	r25, r19
    4c0c:	9b 83       	std	Y+3, r25	; 0x03
    4c0e:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    4c10:	8e 81       	ldd	r24, Y+6	; 0x06
    4c12:	9f 81       	ldd	r25, Y+7	; 0x07
    4c14:	00 97       	sbiw	r24, 0x00	; 0
    4c16:	51 f1       	breq	.+84     	; 0x4c6c <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4c18:	19 82       	std	Y+1, r1	; 0x01
    4c1a:	21 c0       	rjmp	.+66     	; 0x4c5e <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4c1c:	89 81       	ldd	r24, Y+1	; 0x01
    4c1e:	48 2f       	mov	r20, r24
    4c20:	50 e0       	ldi	r21, 0x00	; 0
    4c22:	89 81       	ldd	r24, Y+1	; 0x01
    4c24:	28 2f       	mov	r18, r24
    4c26:	30 e0       	ldi	r19, 0x00	; 0
    4c28:	8e 81       	ldd	r24, Y+6	; 0x06
    4c2a:	9f 81       	ldd	r25, Y+7	; 0x07
    4c2c:	fc 01       	movw	r30, r24
    4c2e:	e2 0f       	add	r30, r18
    4c30:	f3 1f       	adc	r31, r19
    4c32:	20 81       	ld	r18, Z
    4c34:	89 89       	ldd	r24, Y+17	; 0x11
    4c36:	9a 89       	ldd	r25, Y+18	; 0x12
    4c38:	84 0f       	add	r24, r20
    4c3a:	95 1f       	adc	r25, r21
    4c3c:	fc 01       	movw	r30, r24
    4c3e:	79 96       	adiw	r30, 0x19	; 25
    4c40:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4c42:	89 81       	ldd	r24, Y+1	; 0x01
    4c44:	28 2f       	mov	r18, r24
    4c46:	30 e0       	ldi	r19, 0x00	; 0
    4c48:	8e 81       	ldd	r24, Y+6	; 0x06
    4c4a:	9f 81       	ldd	r25, Y+7	; 0x07
    4c4c:	fc 01       	movw	r30, r24
    4c4e:	e2 0f       	add	r30, r18
    4c50:	f3 1f       	adc	r31, r19
    4c52:	80 81       	ld	r24, Z
    4c54:	88 23       	and	r24, r24
    4c56:	31 f0       	breq	.+12     	; 0x4c64 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4c58:	89 81       	ldd	r24, Y+1	; 0x01
    4c5a:	8f 5f       	subi	r24, 0xFF	; 255
    4c5c:	89 83       	std	Y+1, r24	; 0x01
    4c5e:	89 81       	ldd	r24, Y+1	; 0x01
    4c60:	88 30       	cpi	r24, 0x08	; 8
    4c62:	e0 f2       	brcs	.-72     	; 0x4c1c <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4c64:	e9 89       	ldd	r30, Y+17	; 0x11
    4c66:	fa 89       	ldd	r31, Y+18	; 0x12
    4c68:	10 a2       	std	Z+32, r1	; 0x20
    4c6a:	03 c0       	rjmp	.+6      	; 0x4c72 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4c6c:	e9 89       	ldd	r30, Y+17	; 0x11
    4c6e:	fa 89       	ldd	r31, Y+18	; 0x12
    4c70:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4c72:	8e 85       	ldd	r24, Y+14	; 0x0e
    4c74:	84 30       	cpi	r24, 0x04	; 4
    4c76:	10 f0       	brcs	.+4      	; 0x4c7c <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    4c78:	83 e0       	ldi	r24, 0x03	; 3
    4c7a:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4c7c:	e9 89       	ldd	r30, Y+17	; 0x11
    4c7e:	fa 89       	ldd	r31, Y+18	; 0x12
    4c80:	8e 85       	ldd	r24, Y+14	; 0x0e
    4c82:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4c84:	89 89       	ldd	r24, Y+17	; 0x11
    4c86:	9a 89       	ldd	r25, Y+18	; 0x12
    4c88:	02 96       	adiw	r24, 0x02	; 2
    4c8a:	0e 94 f5 11 	call	0x23ea	; 0x23ea <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4c8e:	89 89       	ldd	r24, Y+17	; 0x11
    4c90:	9a 89       	ldd	r25, Y+18	; 0x12
    4c92:	0c 96       	adiw	r24, 0x0c	; 12
    4c94:	0e 94 f5 11 	call	0x23ea	; 0x23ea <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4c98:	e9 89       	ldd	r30, Y+17	; 0x11
    4c9a:	fa 89       	ldd	r31, Y+18	; 0x12
    4c9c:	89 89       	ldd	r24, Y+17	; 0x11
    4c9e:	9a 89       	ldd	r25, Y+18	; 0x12
    4ca0:	91 87       	std	Z+9, r25	; 0x09
    4ca2:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4ca4:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ca6:	28 2f       	mov	r18, r24
    4ca8:	30 e0       	ldi	r19, 0x00	; 0
    4caa:	84 e0       	ldi	r24, 0x04	; 4
    4cac:	90 e0       	ldi	r25, 0x00	; 0
    4cae:	82 1b       	sub	r24, r18
    4cb0:	93 0b       	sbc	r25, r19
    4cb2:	e9 89       	ldd	r30, Y+17	; 0x11
    4cb4:	fa 89       	ldd	r31, Y+18	; 0x12
    4cb6:	95 87       	std	Z+13, r25	; 0x0d
    4cb8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4cba:	e9 89       	ldd	r30, Y+17	; 0x11
    4cbc:	fa 89       	ldd	r31, Y+18	; 0x12
    4cbe:	89 89       	ldd	r24, Y+17	; 0x11
    4cc0:	9a 89       	ldd	r25, Y+18	; 0x12
    4cc2:	93 8b       	std	Z+19, r25	; 0x13
    4cc4:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4cc6:	e9 89       	ldd	r30, Y+17	; 0x11
    4cc8:	fa 89       	ldd	r31, Y+18	; 0x12
    4cca:	11 a2       	std	Z+33, r1	; 0x21
    4ccc:	12 a2       	std	Z+34, r1	; 0x22
    4cce:	13 a2       	std	Z+35, r1	; 0x23
    4cd0:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4cd2:	e9 89       	ldd	r30, Y+17	; 0x11
    4cd4:	fa 89       	ldd	r31, Y+18	; 0x12
    4cd6:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4cd8:	8a 81       	ldd	r24, Y+2	; 0x02
    4cda:	9b 81       	ldd	r25, Y+3	; 0x03
    4cdc:	2c 81       	ldd	r18, Y+4	; 0x04
    4cde:	3d 81       	ldd	r19, Y+5	; 0x05
    4ce0:	4c 85       	ldd	r20, Y+12	; 0x0c
    4ce2:	5d 85       	ldd	r21, Y+13	; 0x0d
    4ce4:	b9 01       	movw	r22, r18
    4ce6:	0e 94 b7 13 	call	0x276e	; 0x276e <pxPortInitialiseStack>
    4cea:	e9 89       	ldd	r30, Y+17	; 0x11
    4cec:	fa 89       	ldd	r31, Y+18	; 0x12
    4cee:	91 83       	std	Z+1, r25	; 0x01
    4cf0:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    4cf2:	8f 85       	ldd	r24, Y+15	; 0x0f
    4cf4:	98 89       	ldd	r25, Y+16	; 0x10
    4cf6:	00 97       	sbiw	r24, 0x00	; 0
    4cf8:	31 f0       	breq	.+12     	; 0x4d06 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4cfa:	ef 85       	ldd	r30, Y+15	; 0x0f
    4cfc:	f8 89       	ldd	r31, Y+16	; 0x10
    4cfe:	89 89       	ldd	r24, Y+17	; 0x11
    4d00:	9a 89       	ldd	r25, Y+18	; 0x12
    4d02:	91 83       	std	Z+1, r25	; 0x01
    4d04:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4d06:	64 96       	adiw	r28, 0x14	; 20
    4d08:	0f b6       	in	r0, 0x3f	; 63
    4d0a:	f8 94       	cli
    4d0c:	de bf       	out	0x3e, r29	; 62
    4d0e:	0f be       	out	0x3f, r0	; 63
    4d10:	cd bf       	out	0x3d, r28	; 61
    4d12:	cf 91       	pop	r28
    4d14:	df 91       	pop	r29
    4d16:	1f 91       	pop	r17
    4d18:	0f 91       	pop	r16
    4d1a:	ef 90       	pop	r14
    4d1c:	df 90       	pop	r13
    4d1e:	cf 90       	pop	r12
    4d20:	bf 90       	pop	r11
    4d22:	af 90       	pop	r10
    4d24:	9f 90       	pop	r9
    4d26:	8f 90       	pop	r8
    4d28:	08 95       	ret

00004d2a <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4d2a:	df 93       	push	r29
    4d2c:	cf 93       	push	r28
    4d2e:	00 d0       	rcall	.+0      	; 0x4d30 <prvAddNewTaskToReadyList+0x6>
    4d30:	cd b7       	in	r28, 0x3d	; 61
    4d32:	de b7       	in	r29, 0x3e	; 62
    4d34:	9a 83       	std	Y+2, r25	; 0x02
    4d36:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4d38:	0f b6       	in	r0, 0x3f	; 63
    4d3a:	f8 94       	cli
    4d3c:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4d3e:	80 91 5f 06 	lds	r24, 0x065F
    4d42:	8f 5f       	subi	r24, 0xFF	; 255
    4d44:	80 93 5f 06 	sts	0x065F, r24
		if( pxCurrentTCB == NULL )
    4d48:	80 91 5c 06 	lds	r24, 0x065C
    4d4c:	90 91 5d 06 	lds	r25, 0x065D
    4d50:	00 97       	sbiw	r24, 0x00	; 0
    4d52:	69 f4       	brne	.+26     	; 0x4d6e <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4d54:	89 81       	ldd	r24, Y+1	; 0x01
    4d56:	9a 81       	ldd	r25, Y+2	; 0x02
    4d58:	90 93 5d 06 	sts	0x065D, r25
    4d5c:	80 93 5c 06 	sts	0x065C, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4d60:	80 91 5f 06 	lds	r24, 0x065F
    4d64:	81 30       	cpi	r24, 0x01	; 1
    4d66:	b9 f4       	brne	.+46     	; 0x4d96 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4d68:	0e 94 de 2d 	call	0x5bbc	; 0x5bbc <prvInitialiseTaskLists>
    4d6c:	14 c0       	rjmp	.+40     	; 0x4d96 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4d6e:	80 91 63 06 	lds	r24, 0x0663
    4d72:	88 23       	and	r24, r24
    4d74:	81 f4       	brne	.+32     	; 0x4d96 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4d76:	e0 91 5c 06 	lds	r30, 0x065C
    4d7a:	f0 91 5d 06 	lds	r31, 0x065D
    4d7e:	96 89       	ldd	r25, Z+22	; 0x16
    4d80:	e9 81       	ldd	r30, Y+1	; 0x01
    4d82:	fa 81       	ldd	r31, Y+2	; 0x02
    4d84:	86 89       	ldd	r24, Z+22	; 0x16
    4d86:	89 17       	cp	r24, r25
    4d88:	30 f0       	brcs	.+12     	; 0x4d96 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    4d8a:	89 81       	ldd	r24, Y+1	; 0x01
    4d8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d8e:	90 93 5d 06 	sts	0x065D, r25
    4d92:	80 93 5c 06 	sts	0x065C, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4d96:	80 91 67 06 	lds	r24, 0x0667
    4d9a:	8f 5f       	subi	r24, 0xFF	; 255
    4d9c:	80 93 67 06 	sts	0x0667, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4da0:	e9 81       	ldd	r30, Y+1	; 0x01
    4da2:	fa 81       	ldd	r31, Y+2	; 0x02
    4da4:	96 89       	ldd	r25, Z+22	; 0x16
    4da6:	80 91 62 06 	lds	r24, 0x0662
    4daa:	89 17       	cp	r24, r25
    4dac:	28 f4       	brcc	.+10     	; 0x4db8 <prvAddNewTaskToReadyList+0x8e>
    4dae:	e9 81       	ldd	r30, Y+1	; 0x01
    4db0:	fa 81       	ldd	r31, Y+2	; 0x02
    4db2:	86 89       	ldd	r24, Z+22	; 0x16
    4db4:	80 93 62 06 	sts	0x0662, r24
    4db8:	e9 81       	ldd	r30, Y+1	; 0x01
    4dba:	fa 81       	ldd	r31, Y+2	; 0x02
    4dbc:	86 89       	ldd	r24, Z+22	; 0x16
    4dbe:	28 2f       	mov	r18, r24
    4dc0:	30 e0       	ldi	r19, 0x00	; 0
    4dc2:	c9 01       	movw	r24, r18
    4dc4:	88 0f       	add	r24, r24
    4dc6:	99 1f       	adc	r25, r25
    4dc8:	88 0f       	add	r24, r24
    4dca:	99 1f       	adc	r25, r25
    4dcc:	88 0f       	add	r24, r24
    4dce:	99 1f       	adc	r25, r25
    4dd0:	82 0f       	add	r24, r18
    4dd2:	93 1f       	adc	r25, r19
    4dd4:	ac 01       	movw	r20, r24
    4dd6:	43 59       	subi	r20, 0x93	; 147
    4dd8:	59 4f       	sbci	r21, 0xF9	; 249
    4dda:	89 81       	ldd	r24, Y+1	; 0x01
    4ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dde:	9c 01       	movw	r18, r24
    4de0:	2e 5f       	subi	r18, 0xFE	; 254
    4de2:	3f 4f       	sbci	r19, 0xFF	; 255
    4de4:	ca 01       	movw	r24, r20
    4de6:	b9 01       	movw	r22, r18
    4de8:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4dec:	0f 90       	pop	r0
    4dee:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    4df0:	80 91 63 06 	lds	r24, 0x0663
    4df4:	88 23       	and	r24, r24
    4df6:	61 f0       	breq	.+24     	; 0x4e10 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4df8:	e0 91 5c 06 	lds	r30, 0x065C
    4dfc:	f0 91 5d 06 	lds	r31, 0x065D
    4e00:	96 89       	ldd	r25, Z+22	; 0x16
    4e02:	e9 81       	ldd	r30, Y+1	; 0x01
    4e04:	fa 81       	ldd	r31, Y+2	; 0x02
    4e06:	86 89       	ldd	r24, Z+22	; 0x16
    4e08:	98 17       	cp	r25, r24
    4e0a:	10 f4       	brcc	.+4      	; 0x4e10 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4e0c:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4e10:	0f 90       	pop	r0
    4e12:	0f 90       	pop	r0
    4e14:	cf 91       	pop	r28
    4e16:	df 91       	pop	r29
    4e18:	08 95       	ret

00004e1a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4e1a:	df 93       	push	r29
    4e1c:	cf 93       	push	r28
    4e1e:	00 d0       	rcall	.+0      	; 0x4e20 <vTaskDelete+0x6>
    4e20:	00 d0       	rcall	.+0      	; 0x4e22 <vTaskDelete+0x8>
    4e22:	00 d0       	rcall	.+0      	; 0x4e24 <vTaskDelete+0xa>
    4e24:	cd b7       	in	r28, 0x3d	; 61
    4e26:	de b7       	in	r29, 0x3e	; 62
    4e28:	9c 83       	std	Y+4, r25	; 0x04
    4e2a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4e2c:	0f b6       	in	r0, 0x3f	; 63
    4e2e:	f8 94       	cli
    4e30:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4e32:	8b 81       	ldd	r24, Y+3	; 0x03
    4e34:	9c 81       	ldd	r25, Y+4	; 0x04
    4e36:	00 97       	sbiw	r24, 0x00	; 0
    4e38:	39 f4       	brne	.+14     	; 0x4e48 <vTaskDelete+0x2e>
    4e3a:	80 91 5c 06 	lds	r24, 0x065C
    4e3e:	90 91 5d 06 	lds	r25, 0x065D
    4e42:	9e 83       	std	Y+6, r25	; 0x06
    4e44:	8d 83       	std	Y+5, r24	; 0x05
    4e46:	04 c0       	rjmp	.+8      	; 0x4e50 <vTaskDelete+0x36>
    4e48:	8b 81       	ldd	r24, Y+3	; 0x03
    4e4a:	9c 81       	ldd	r25, Y+4	; 0x04
    4e4c:	9e 83       	std	Y+6, r25	; 0x06
    4e4e:	8d 83       	std	Y+5, r24	; 0x05
    4e50:	8d 81       	ldd	r24, Y+5	; 0x05
    4e52:	9e 81       	ldd	r25, Y+6	; 0x06
    4e54:	9a 83       	std	Y+2, r25	; 0x02
    4e56:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4e58:	89 81       	ldd	r24, Y+1	; 0x01
    4e5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e5c:	02 96       	adiw	r24, 0x02	; 2
    4e5e:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4e62:	e9 81       	ldd	r30, Y+1	; 0x01
    4e64:	fa 81       	ldd	r31, Y+2	; 0x02
    4e66:	84 89       	ldd	r24, Z+20	; 0x14
    4e68:	95 89       	ldd	r25, Z+21	; 0x15
    4e6a:	00 97       	sbiw	r24, 0x00	; 0
    4e6c:	29 f0       	breq	.+10     	; 0x4e78 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4e6e:	89 81       	ldd	r24, Y+1	; 0x01
    4e70:	9a 81       	ldd	r25, Y+2	; 0x02
    4e72:	0c 96       	adiw	r24, 0x0c	; 12
    4e74:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4e78:	80 91 67 06 	lds	r24, 0x0667
    4e7c:	8f 5f       	subi	r24, 0xFF	; 255
    4e7e:	80 93 67 06 	sts	0x0667, r24

			if( pxTCB == pxCurrentTCB )
    4e82:	20 91 5c 06 	lds	r18, 0x065C
    4e86:	30 91 5d 06 	lds	r19, 0x065D
    4e8a:	89 81       	ldd	r24, Y+1	; 0x01
    4e8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4e8e:	82 17       	cp	r24, r18
    4e90:	93 07       	cpc	r25, r19
    4e92:	81 f4       	brne	.+32     	; 0x4eb4 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4e94:	89 81       	ldd	r24, Y+1	; 0x01
    4e96:	9a 81       	ldd	r25, Y+2	; 0x02
    4e98:	9c 01       	movw	r18, r24
    4e9a:	2e 5f       	subi	r18, 0xFE	; 254
    4e9c:	3f 4f       	sbci	r19, 0xFF	; 255
    4e9e:	80 eb       	ldi	r24, 0xB0	; 176
    4ea0:	96 e0       	ldi	r25, 0x06	; 6
    4ea2:	b9 01       	movw	r22, r18
    4ea4:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    4ea8:	80 91 5e 06 	lds	r24, 0x065E
    4eac:	8f 5f       	subi	r24, 0xFF	; 255
    4eae:	80 93 5e 06 	sts	0x065E, r24
    4eb2:	0b c0       	rjmp	.+22     	; 0x4eca <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    4eb4:	80 91 5f 06 	lds	r24, 0x065F
    4eb8:	81 50       	subi	r24, 0x01	; 1
    4eba:	80 93 5f 06 	sts	0x065F, r24
				prvDeleteTCB( pxTCB );
    4ebe:	89 81       	ldd	r24, Y+1	; 0x01
    4ec0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ec2:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    4ec6:	0e 94 64 2e 	call	0x5cc8	; 0x5cc8 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4eca:	0f 90       	pop	r0
    4ecc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4ece:	80 91 63 06 	lds	r24, 0x0663
    4ed2:	88 23       	and	r24, r24
    4ed4:	59 f0       	breq	.+22     	; 0x4eec <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    4ed6:	20 91 5c 06 	lds	r18, 0x065C
    4eda:	30 91 5d 06 	lds	r19, 0x065D
    4ede:	89 81       	ldd	r24, Y+1	; 0x01
    4ee0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ee2:	82 17       	cp	r24, r18
    4ee4:	93 07       	cpc	r25, r19
    4ee6:	11 f4       	brne	.+4      	; 0x4eec <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4ee8:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    4eec:	26 96       	adiw	r28, 0x06	; 6
    4eee:	0f b6       	in	r0, 0x3f	; 63
    4ef0:	f8 94       	cli
    4ef2:	de bf       	out	0x3e, r29	; 62
    4ef4:	0f be       	out	0x3f, r0	; 63
    4ef6:	cd bf       	out	0x3d, r28	; 61
    4ef8:	cf 91       	pop	r28
    4efa:	df 91       	pop	r29
    4efc:	08 95       	ret

00004efe <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    4efe:	df 93       	push	r29
    4f00:	cf 93       	push	r28
    4f02:	cd b7       	in	r28, 0x3d	; 61
    4f04:	de b7       	in	r29, 0x3e	; 62
    4f06:	2a 97       	sbiw	r28, 0x0a	; 10
    4f08:	0f b6       	in	r0, 0x3f	; 63
    4f0a:	f8 94       	cli
    4f0c:	de bf       	out	0x3e, r29	; 62
    4f0e:	0f be       	out	0x3f, r0	; 63
    4f10:	cd bf       	out	0x3d, r28	; 61
    4f12:	98 87       	std	Y+8, r25	; 0x08
    4f14:	8f 83       	std	Y+7, r24	; 0x07
    4f16:	7a 87       	std	Y+10, r23	; 0x0a
    4f18:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    4f1a:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    4f1c:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    4f20:	80 91 60 06 	lds	r24, 0x0660
    4f24:	90 91 61 06 	lds	r25, 0x0661
    4f28:	9a 83       	std	Y+2, r25	; 0x02
    4f2a:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4f2c:	ef 81       	ldd	r30, Y+7	; 0x07
    4f2e:	f8 85       	ldd	r31, Y+8	; 0x08
    4f30:	20 81       	ld	r18, Z
    4f32:	31 81       	ldd	r19, Z+1	; 0x01
    4f34:	89 85       	ldd	r24, Y+9	; 0x09
    4f36:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f38:	82 0f       	add	r24, r18
    4f3a:	93 1f       	adc	r25, r19
    4f3c:	9e 83       	std	Y+6, r25	; 0x06
    4f3e:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    4f40:	ef 81       	ldd	r30, Y+7	; 0x07
    4f42:	f8 85       	ldd	r31, Y+8	; 0x08
    4f44:	20 81       	ld	r18, Z
    4f46:	31 81       	ldd	r19, Z+1	; 0x01
    4f48:	89 81       	ldd	r24, Y+1	; 0x01
    4f4a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f4c:	82 17       	cp	r24, r18
    4f4e:	93 07       	cpc	r25, r19
    4f50:	98 f4       	brcc	.+38     	; 0x4f78 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    4f52:	ef 81       	ldd	r30, Y+7	; 0x07
    4f54:	f8 85       	ldd	r31, Y+8	; 0x08
    4f56:	20 81       	ld	r18, Z
    4f58:	31 81       	ldd	r19, Z+1	; 0x01
    4f5a:	8d 81       	ldd	r24, Y+5	; 0x05
    4f5c:	9e 81       	ldd	r25, Y+6	; 0x06
    4f5e:	82 17       	cp	r24, r18
    4f60:	93 07       	cpc	r25, r19
    4f62:	e0 f4       	brcc	.+56     	; 0x4f9c <vTaskDelayUntil+0x9e>
    4f64:	2d 81       	ldd	r18, Y+5	; 0x05
    4f66:	3e 81       	ldd	r19, Y+6	; 0x06
    4f68:	89 81       	ldd	r24, Y+1	; 0x01
    4f6a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f6c:	82 17       	cp	r24, r18
    4f6e:	93 07       	cpc	r25, r19
    4f70:	a8 f4       	brcc	.+42     	; 0x4f9c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4f72:	81 e0       	ldi	r24, 0x01	; 1
    4f74:	8b 83       	std	Y+3, r24	; 0x03
    4f76:	12 c0       	rjmp	.+36     	; 0x4f9c <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    4f78:	ef 81       	ldd	r30, Y+7	; 0x07
    4f7a:	f8 85       	ldd	r31, Y+8	; 0x08
    4f7c:	20 81       	ld	r18, Z
    4f7e:	31 81       	ldd	r19, Z+1	; 0x01
    4f80:	8d 81       	ldd	r24, Y+5	; 0x05
    4f82:	9e 81       	ldd	r25, Y+6	; 0x06
    4f84:	82 17       	cp	r24, r18
    4f86:	93 07       	cpc	r25, r19
    4f88:	38 f0       	brcs	.+14     	; 0x4f98 <vTaskDelayUntil+0x9a>
    4f8a:	2d 81       	ldd	r18, Y+5	; 0x05
    4f8c:	3e 81       	ldd	r19, Y+6	; 0x06
    4f8e:	89 81       	ldd	r24, Y+1	; 0x01
    4f90:	9a 81       	ldd	r25, Y+2	; 0x02
    4f92:	82 17       	cp	r24, r18
    4f94:	93 07       	cpc	r25, r19
    4f96:	10 f4       	brcc	.+4      	; 0x4f9c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4f98:	81 e0       	ldi	r24, 0x01	; 1
    4f9a:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4f9c:	ef 81       	ldd	r30, Y+7	; 0x07
    4f9e:	f8 85       	ldd	r31, Y+8	; 0x08
    4fa0:	8d 81       	ldd	r24, Y+5	; 0x05
    4fa2:	9e 81       	ldd	r25, Y+6	; 0x06
    4fa4:	91 83       	std	Z+1, r25	; 0x01
    4fa6:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4fa8:	8b 81       	ldd	r24, Y+3	; 0x03
    4faa:	88 23       	and	r24, r24
    4fac:	49 f0       	breq	.+18     	; 0x4fc0 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    4fae:	8d 81       	ldd	r24, Y+5	; 0x05
    4fb0:	9e 81       	ldd	r25, Y+6	; 0x06
    4fb2:	29 81       	ldd	r18, Y+1	; 0x01
    4fb4:	3a 81       	ldd	r19, Y+2	; 0x02
    4fb6:	82 1b       	sub	r24, r18
    4fb8:	93 0b       	sbc	r25, r19
    4fba:	60 e0       	ldi	r22, 0x00	; 0
    4fbc:	0e 94 70 32 	call	0x64e0	; 0x64e0 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4fc0:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    4fc4:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4fc6:	8c 81       	ldd	r24, Y+4	; 0x04
    4fc8:	88 23       	and	r24, r24
    4fca:	11 f4       	brne	.+4      	; 0x4fd0 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    4fcc:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4fd0:	2a 96       	adiw	r28, 0x0a	; 10
    4fd2:	0f b6       	in	r0, 0x3f	; 63
    4fd4:	f8 94       	cli
    4fd6:	de bf       	out	0x3e, r29	; 62
    4fd8:	0f be       	out	0x3f, r0	; 63
    4fda:	cd bf       	out	0x3d, r28	; 61
    4fdc:	cf 91       	pop	r28
    4fde:	df 91       	pop	r29
    4fe0:	08 95       	ret

00004fe2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4fe2:	df 93       	push	r29
    4fe4:	cf 93       	push	r28
    4fe6:	00 d0       	rcall	.+0      	; 0x4fe8 <vTaskDelay+0x6>
    4fe8:	0f 92       	push	r0
    4fea:	cd b7       	in	r28, 0x3d	; 61
    4fec:	de b7       	in	r29, 0x3e	; 62
    4fee:	9b 83       	std	Y+3, r25	; 0x03
    4ff0:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    4ff2:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4ff4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ff6:	9b 81       	ldd	r25, Y+3	; 0x03
    4ff8:	00 97       	sbiw	r24, 0x00	; 0
    4ffa:	51 f0       	breq	.+20     	; 0x5010 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4ffc:	0e 94 be 29 	call	0x537c	; 0x537c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    5000:	8a 81       	ldd	r24, Y+2	; 0x02
    5002:	9b 81       	ldd	r25, Y+3	; 0x03
    5004:	60 e0       	ldi	r22, 0x00	; 0
    5006:	0e 94 70 32 	call	0x64e0	; 0x64e0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    500a:	0e 94 ca 29 	call	0x5394	; 0x5394 <xTaskResumeAll>
    500e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5010:	89 81       	ldd	r24, Y+1	; 0x01
    5012:	88 23       	and	r24, r24
    5014:	11 f4       	brne	.+4      	; 0x501a <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    5016:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    501a:	0f 90       	pop	r0
    501c:	0f 90       	pop	r0
    501e:	0f 90       	pop	r0
    5020:	cf 91       	pop	r28
    5022:	df 91       	pop	r29
    5024:	08 95       	ret

00005026 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    5026:	df 93       	push	r29
    5028:	cf 93       	push	r28
    502a:	00 d0       	rcall	.+0      	; 0x502c <vTaskSuspend+0x6>
    502c:	00 d0       	rcall	.+0      	; 0x502e <vTaskSuspend+0x8>
    502e:	00 d0       	rcall	.+0      	; 0x5030 <vTaskSuspend+0xa>
    5030:	cd b7       	in	r28, 0x3d	; 61
    5032:	de b7       	in	r29, 0x3e	; 62
    5034:	9c 83       	std	Y+4, r25	; 0x04
    5036:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    5038:	0f b6       	in	r0, 0x3f	; 63
    503a:	f8 94       	cli
    503c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    503e:	8b 81       	ldd	r24, Y+3	; 0x03
    5040:	9c 81       	ldd	r25, Y+4	; 0x04
    5042:	00 97       	sbiw	r24, 0x00	; 0
    5044:	39 f4       	brne	.+14     	; 0x5054 <vTaskSuspend+0x2e>
    5046:	80 91 5c 06 	lds	r24, 0x065C
    504a:	90 91 5d 06 	lds	r25, 0x065D
    504e:	9e 83       	std	Y+6, r25	; 0x06
    5050:	8d 83       	std	Y+5, r24	; 0x05
    5052:	04 c0       	rjmp	.+8      	; 0x505c <vTaskSuspend+0x36>
    5054:	8b 81       	ldd	r24, Y+3	; 0x03
    5056:	9c 81       	ldd	r25, Y+4	; 0x04
    5058:	9e 83       	std	Y+6, r25	; 0x06
    505a:	8d 83       	std	Y+5, r24	; 0x05
    505c:	8d 81       	ldd	r24, Y+5	; 0x05
    505e:	9e 81       	ldd	r25, Y+6	; 0x06
    5060:	9a 83       	std	Y+2, r25	; 0x02
    5062:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5064:	89 81       	ldd	r24, Y+1	; 0x01
    5066:	9a 81       	ldd	r25, Y+2	; 0x02
    5068:	02 96       	adiw	r24, 0x02	; 2
    506a:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    506e:	e9 81       	ldd	r30, Y+1	; 0x01
    5070:	fa 81       	ldd	r31, Y+2	; 0x02
    5072:	84 89       	ldd	r24, Z+20	; 0x14
    5074:	95 89       	ldd	r25, Z+21	; 0x15
    5076:	00 97       	sbiw	r24, 0x00	; 0
    5078:	29 f0       	breq	.+10     	; 0x5084 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    507a:	89 81       	ldd	r24, Y+1	; 0x01
    507c:	9a 81       	ldd	r25, Y+2	; 0x02
    507e:	0c 96       	adiw	r24, 0x0c	; 12
    5080:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    5084:	89 81       	ldd	r24, Y+1	; 0x01
    5086:	9a 81       	ldd	r25, Y+2	; 0x02
    5088:	9c 01       	movw	r18, r24
    508a:	2e 5f       	subi	r18, 0xFE	; 254
    508c:	3f 4f       	sbci	r19, 0xFF	; 255
    508e:	89 eb       	ldi	r24, 0xB9	; 185
    5090:	96 e0       	ldi	r25, 0x06	; 6
    5092:	b9 01       	movw	r22, r18
    5094:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    5098:	e9 81       	ldd	r30, Y+1	; 0x01
    509a:	fa 81       	ldd	r31, Y+2	; 0x02
    509c:	85 a1       	ldd	r24, Z+37	; 0x25
    509e:	81 30       	cpi	r24, 0x01	; 1
    50a0:	19 f4       	brne	.+6      	; 0x50a8 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    50a2:	e9 81       	ldd	r30, Y+1	; 0x01
    50a4:	fa 81       	ldd	r31, Y+2	; 0x02
    50a6:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    50a8:	0f 90       	pop	r0
    50aa:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    50ac:	80 91 63 06 	lds	r24, 0x0663
    50b0:	88 23       	and	r24, r24
    50b2:	39 f0       	breq	.+14     	; 0x50c2 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    50b4:	0f b6       	in	r0, 0x3f	; 63
    50b6:	f8 94       	cli
    50b8:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    50ba:	0e 94 64 2e 	call	0x5cc8	; 0x5cc8 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    50be:	0f 90       	pop	r0
    50c0:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    50c2:	20 91 5c 06 	lds	r18, 0x065C
    50c6:	30 91 5d 06 	lds	r19, 0x065D
    50ca:	89 81       	ldd	r24, Y+1	; 0x01
    50cc:	9a 81       	ldd	r25, Y+2	; 0x02
    50ce:	82 17       	cp	r24, r18
    50d0:	93 07       	cpc	r25, r19
    50d2:	a1 f4       	brne	.+40     	; 0x50fc <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    50d4:	80 91 63 06 	lds	r24, 0x0663
    50d8:	88 23       	and	r24, r24
    50da:	19 f0       	breq	.+6      	; 0x50e2 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    50dc:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    50e0:	0d c0       	rjmp	.+26     	; 0x50fc <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    50e2:	90 91 b9 06 	lds	r25, 0x06B9
    50e6:	80 91 5f 06 	lds	r24, 0x065F
    50ea:	98 17       	cp	r25, r24
    50ec:	29 f4       	brne	.+10     	; 0x50f8 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    50ee:	10 92 5d 06 	sts	0x065D, r1
    50f2:	10 92 5c 06 	sts	0x065C, r1
    50f6:	02 c0       	rjmp	.+4      	; 0x50fc <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    50f8:	0e 94 9f 2b 	call	0x573e	; 0x573e <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    50fc:	26 96       	adiw	r28, 0x06	; 6
    50fe:	0f b6       	in	r0, 0x3f	; 63
    5100:	f8 94       	cli
    5102:	de bf       	out	0x3e, r29	; 62
    5104:	0f be       	out	0x3f, r0	; 63
    5106:	cd bf       	out	0x3d, r28	; 61
    5108:	cf 91       	pop	r28
    510a:	df 91       	pop	r29
    510c:	08 95       	ret

0000510e <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    510e:	df 93       	push	r29
    5110:	cf 93       	push	r28
    5112:	00 d0       	rcall	.+0      	; 0x5114 <prvTaskIsTaskSuspended+0x6>
    5114:	00 d0       	rcall	.+0      	; 0x5116 <prvTaskIsTaskSuspended+0x8>
    5116:	0f 92       	push	r0
    5118:	cd b7       	in	r28, 0x3d	; 61
    511a:	de b7       	in	r29, 0x3e	; 62
    511c:	9d 83       	std	Y+5, r25	; 0x05
    511e:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    5120:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    5122:	8c 81       	ldd	r24, Y+4	; 0x04
    5124:	9d 81       	ldd	r25, Y+5	; 0x05
    5126:	9a 83       	std	Y+2, r25	; 0x02
    5128:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    512a:	e9 81       	ldd	r30, Y+1	; 0x01
    512c:	fa 81       	ldd	r31, Y+2	; 0x02
    512e:	82 85       	ldd	r24, Z+10	; 0x0a
    5130:	93 85       	ldd	r25, Z+11	; 0x0b
    5132:	26 e0       	ldi	r18, 0x06	; 6
    5134:	89 3b       	cpi	r24, 0xB9	; 185
    5136:	92 07       	cpc	r25, r18
    5138:	81 f4       	brne	.+32     	; 0x515a <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    513a:	e9 81       	ldd	r30, Y+1	; 0x01
    513c:	fa 81       	ldd	r31, Y+2	; 0x02
    513e:	84 89       	ldd	r24, Z+20	; 0x14
    5140:	95 89       	ldd	r25, Z+21	; 0x15
    5142:	26 e0       	ldi	r18, 0x06	; 6
    5144:	87 3a       	cpi	r24, 0xA7	; 167
    5146:	92 07       	cpc	r25, r18
    5148:	41 f0       	breq	.+16     	; 0x515a <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    514a:	e9 81       	ldd	r30, Y+1	; 0x01
    514c:	fa 81       	ldd	r31, Y+2	; 0x02
    514e:	84 89       	ldd	r24, Z+20	; 0x14
    5150:	95 89       	ldd	r25, Z+21	; 0x15
    5152:	00 97       	sbiw	r24, 0x00	; 0
    5154:	11 f4       	brne	.+4      	; 0x515a <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    5156:	81 e0       	ldi	r24, 0x01	; 1
    5158:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    515a:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    515c:	0f 90       	pop	r0
    515e:	0f 90       	pop	r0
    5160:	0f 90       	pop	r0
    5162:	0f 90       	pop	r0
    5164:	0f 90       	pop	r0
    5166:	cf 91       	pop	r28
    5168:	df 91       	pop	r29
    516a:	08 95       	ret

0000516c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    516c:	df 93       	push	r29
    516e:	cf 93       	push	r28
    5170:	00 d0       	rcall	.+0      	; 0x5172 <vTaskResume+0x6>
    5172:	00 d0       	rcall	.+0      	; 0x5174 <vTaskResume+0x8>
    5174:	cd b7       	in	r28, 0x3d	; 61
    5176:	de b7       	in	r29, 0x3e	; 62
    5178:	9c 83       	std	Y+4, r25	; 0x04
    517a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    517c:	8b 81       	ldd	r24, Y+3	; 0x03
    517e:	9c 81       	ldd	r25, Y+4	; 0x04
    5180:	9a 83       	std	Y+2, r25	; 0x02
    5182:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    5184:	20 91 5c 06 	lds	r18, 0x065C
    5188:	30 91 5d 06 	lds	r19, 0x065D
    518c:	89 81       	ldd	r24, Y+1	; 0x01
    518e:	9a 81       	ldd	r25, Y+2	; 0x02
    5190:	82 17       	cp	r24, r18
    5192:	93 07       	cpc	r25, r19
    5194:	09 f4       	brne	.+2      	; 0x5198 <vTaskResume+0x2c>
    5196:	47 c0       	rjmp	.+142    	; 0x5226 <vTaskResume+0xba>
    5198:	89 81       	ldd	r24, Y+1	; 0x01
    519a:	9a 81       	ldd	r25, Y+2	; 0x02
    519c:	00 97       	sbiw	r24, 0x00	; 0
    519e:	09 f4       	brne	.+2      	; 0x51a2 <vTaskResume+0x36>
    51a0:	42 c0       	rjmp	.+132    	; 0x5226 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    51a2:	0f b6       	in	r0, 0x3f	; 63
    51a4:	f8 94       	cli
    51a6:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    51a8:	89 81       	ldd	r24, Y+1	; 0x01
    51aa:	9a 81       	ldd	r25, Y+2	; 0x02
    51ac:	0e 94 87 28 	call	0x510e	; 0x510e <prvTaskIsTaskSuspended>
    51b0:	88 23       	and	r24, r24
    51b2:	b9 f1       	breq	.+110    	; 0x5222 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    51b4:	89 81       	ldd	r24, Y+1	; 0x01
    51b6:	9a 81       	ldd	r25, Y+2	; 0x02
    51b8:	02 96       	adiw	r24, 0x02	; 2
    51ba:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    51be:	e9 81       	ldd	r30, Y+1	; 0x01
    51c0:	fa 81       	ldd	r31, Y+2	; 0x02
    51c2:	96 89       	ldd	r25, Z+22	; 0x16
    51c4:	80 91 62 06 	lds	r24, 0x0662
    51c8:	89 17       	cp	r24, r25
    51ca:	28 f4       	brcc	.+10     	; 0x51d6 <vTaskResume+0x6a>
    51cc:	e9 81       	ldd	r30, Y+1	; 0x01
    51ce:	fa 81       	ldd	r31, Y+2	; 0x02
    51d0:	86 89       	ldd	r24, Z+22	; 0x16
    51d2:	80 93 62 06 	sts	0x0662, r24
    51d6:	e9 81       	ldd	r30, Y+1	; 0x01
    51d8:	fa 81       	ldd	r31, Y+2	; 0x02
    51da:	86 89       	ldd	r24, Z+22	; 0x16
    51dc:	28 2f       	mov	r18, r24
    51de:	30 e0       	ldi	r19, 0x00	; 0
    51e0:	c9 01       	movw	r24, r18
    51e2:	88 0f       	add	r24, r24
    51e4:	99 1f       	adc	r25, r25
    51e6:	88 0f       	add	r24, r24
    51e8:	99 1f       	adc	r25, r25
    51ea:	88 0f       	add	r24, r24
    51ec:	99 1f       	adc	r25, r25
    51ee:	82 0f       	add	r24, r18
    51f0:	93 1f       	adc	r25, r19
    51f2:	ac 01       	movw	r20, r24
    51f4:	43 59       	subi	r20, 0x93	; 147
    51f6:	59 4f       	sbci	r21, 0xF9	; 249
    51f8:	89 81       	ldd	r24, Y+1	; 0x01
    51fa:	9a 81       	ldd	r25, Y+2	; 0x02
    51fc:	9c 01       	movw	r18, r24
    51fe:	2e 5f       	subi	r18, 0xFE	; 254
    5200:	3f 4f       	sbci	r19, 0xFF	; 255
    5202:	ca 01       	movw	r24, r20
    5204:	b9 01       	movw	r22, r18
    5206:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    520a:	e9 81       	ldd	r30, Y+1	; 0x01
    520c:	fa 81       	ldd	r31, Y+2	; 0x02
    520e:	96 89       	ldd	r25, Z+22	; 0x16
    5210:	e0 91 5c 06 	lds	r30, 0x065C
    5214:	f0 91 5d 06 	lds	r31, 0x065D
    5218:	86 89       	ldd	r24, Z+22	; 0x16
    521a:	98 17       	cp	r25, r24
    521c:	10 f0       	brcs	.+4      	; 0x5222 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    521e:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    5222:	0f 90       	pop	r0
    5224:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5226:	0f 90       	pop	r0
    5228:	0f 90       	pop	r0
    522a:	0f 90       	pop	r0
    522c:	0f 90       	pop	r0
    522e:	cf 91       	pop	r28
    5230:	df 91       	pop	r29
    5232:	08 95       	ret

00005234 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    5234:	df 93       	push	r29
    5236:	cf 93       	push	r28
    5238:	00 d0       	rcall	.+0      	; 0x523a <xTaskResumeFromISR+0x6>
    523a:	00 d0       	rcall	.+0      	; 0x523c <xTaskResumeFromISR+0x8>
    523c:	00 d0       	rcall	.+0      	; 0x523e <xTaskResumeFromISR+0xa>
    523e:	cd b7       	in	r28, 0x3d	; 61
    5240:	de b7       	in	r29, 0x3e	; 62
    5242:	9e 83       	std	Y+6, r25	; 0x06
    5244:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    5246:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    5248:	8d 81       	ldd	r24, Y+5	; 0x05
    524a:	9e 81       	ldd	r25, Y+6	; 0x06
    524c:	9b 83       	std	Y+3, r25	; 0x03
    524e:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5250:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    5252:	8a 81       	ldd	r24, Y+2	; 0x02
    5254:	9b 81       	ldd	r25, Y+3	; 0x03
    5256:	0e 94 87 28 	call	0x510e	; 0x510e <prvTaskIsTaskSuspended>
    525a:	88 23       	and	r24, r24
    525c:	09 f4       	brne	.+2      	; 0x5260 <xTaskResumeFromISR+0x2c>
    525e:	46 c0       	rjmp	.+140    	; 0x52ec <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5260:	80 91 6c 06 	lds	r24, 0x066C
    5264:	88 23       	and	r24, r24
    5266:	c1 f5       	brne	.+112    	; 0x52d8 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5268:	ea 81       	ldd	r30, Y+2	; 0x02
    526a:	fb 81       	ldd	r31, Y+3	; 0x03
    526c:	96 89       	ldd	r25, Z+22	; 0x16
    526e:	e0 91 5c 06 	lds	r30, 0x065C
    5272:	f0 91 5d 06 	lds	r31, 0x065D
    5276:	86 89       	ldd	r24, Z+22	; 0x16
    5278:	98 17       	cp	r25, r24
    527a:	10 f0       	brcs	.+4      	; 0x5280 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    527c:	81 e0       	ldi	r24, 0x01	; 1
    527e:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5280:	8a 81       	ldd	r24, Y+2	; 0x02
    5282:	9b 81       	ldd	r25, Y+3	; 0x03
    5284:	02 96       	adiw	r24, 0x02	; 2
    5286:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    528a:	ea 81       	ldd	r30, Y+2	; 0x02
    528c:	fb 81       	ldd	r31, Y+3	; 0x03
    528e:	96 89       	ldd	r25, Z+22	; 0x16
    5290:	80 91 62 06 	lds	r24, 0x0662
    5294:	89 17       	cp	r24, r25
    5296:	28 f4       	brcc	.+10     	; 0x52a2 <xTaskResumeFromISR+0x6e>
    5298:	ea 81       	ldd	r30, Y+2	; 0x02
    529a:	fb 81       	ldd	r31, Y+3	; 0x03
    529c:	86 89       	ldd	r24, Z+22	; 0x16
    529e:	80 93 62 06 	sts	0x0662, r24
    52a2:	ea 81       	ldd	r30, Y+2	; 0x02
    52a4:	fb 81       	ldd	r31, Y+3	; 0x03
    52a6:	86 89       	ldd	r24, Z+22	; 0x16
    52a8:	28 2f       	mov	r18, r24
    52aa:	30 e0       	ldi	r19, 0x00	; 0
    52ac:	c9 01       	movw	r24, r18
    52ae:	88 0f       	add	r24, r24
    52b0:	99 1f       	adc	r25, r25
    52b2:	88 0f       	add	r24, r24
    52b4:	99 1f       	adc	r25, r25
    52b6:	88 0f       	add	r24, r24
    52b8:	99 1f       	adc	r25, r25
    52ba:	82 0f       	add	r24, r18
    52bc:	93 1f       	adc	r25, r19
    52be:	ac 01       	movw	r20, r24
    52c0:	43 59       	subi	r20, 0x93	; 147
    52c2:	59 4f       	sbci	r21, 0xF9	; 249
    52c4:	8a 81       	ldd	r24, Y+2	; 0x02
    52c6:	9b 81       	ldd	r25, Y+3	; 0x03
    52c8:	9c 01       	movw	r18, r24
    52ca:	2e 5f       	subi	r18, 0xFE	; 254
    52cc:	3f 4f       	sbci	r19, 0xFF	; 255
    52ce:	ca 01       	movw	r24, r20
    52d0:	b9 01       	movw	r22, r18
    52d2:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
    52d6:	0a c0       	rjmp	.+20     	; 0x52ec <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    52d8:	8a 81       	ldd	r24, Y+2	; 0x02
    52da:	9b 81       	ldd	r25, Y+3	; 0x03
    52dc:	9c 01       	movw	r18, r24
    52de:	24 5f       	subi	r18, 0xF4	; 244
    52e0:	3f 4f       	sbci	r19, 0xFF	; 255
    52e2:	87 ea       	ldi	r24, 0xA7	; 167
    52e4:	96 e0       	ldi	r25, 0x06	; 6
    52e6:	b9 01       	movw	r22, r18
    52e8:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    52ec:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    52ee:	26 96       	adiw	r28, 0x06	; 6
    52f0:	0f b6       	in	r0, 0x3f	; 63
    52f2:	f8 94       	cli
    52f4:	de bf       	out	0x3e, r29	; 62
    52f6:	0f be       	out	0x3f, r0	; 63
    52f8:	cd bf       	out	0x3d, r28	; 61
    52fa:	cf 91       	pop	r28
    52fc:	df 91       	pop	r29
    52fe:	08 95       	ret

00005300 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    5300:	ef 92       	push	r14
    5302:	ff 92       	push	r15
    5304:	0f 93       	push	r16
    5306:	df 93       	push	r29
    5308:	cf 93       	push	r28
    530a:	0f 92       	push	r0
    530c:	cd b7       	in	r28, 0x3d	; 61
    530e:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    5310:	84 ed       	ldi	r24, 0xD4	; 212
    5312:	9d e2       	ldi	r25, 0x2D	; 45
    5314:	25 e7       	ldi	r18, 0x75	; 117
    5316:	30 e0       	ldi	r19, 0x00	; 0
    5318:	ea e6       	ldi	r30, 0x6A	; 106
    531a:	f6 e0       	ldi	r31, 0x06	; 6
    531c:	b9 01       	movw	r22, r18
    531e:	45 e5       	ldi	r20, 0x55	; 85
    5320:	50 e0       	ldi	r21, 0x00	; 0
    5322:	20 e0       	ldi	r18, 0x00	; 0
    5324:	30 e0       	ldi	r19, 0x00	; 0
    5326:	00 e0       	ldi	r16, 0x00	; 0
    5328:	7f 01       	movw	r14, r30
    532a:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <xTaskCreate>
    532e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    5330:	89 81       	ldd	r24, Y+1	; 0x01
    5332:	81 30       	cpi	r24, 0x01	; 1
    5334:	81 f4       	brne	.+32     	; 0x5356 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    5336:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    5338:	8f ef       	ldi	r24, 0xFF	; 255
    533a:	9f ef       	ldi	r25, 0xFF	; 255
    533c:	90 93 69 06 	sts	0x0669, r25
    5340:	80 93 68 06 	sts	0x0668, r24
		xSchedulerRunning = pdTRUE;
    5344:	81 e0       	ldi	r24, 0x01	; 1
    5346:	80 93 63 06 	sts	0x0663, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    534a:	10 92 61 06 	sts	0x0661, r1
    534e:	10 92 60 06 	sts	0x0660, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5352:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    5356:	0f 90       	pop	r0
    5358:	cf 91       	pop	r28
    535a:	df 91       	pop	r29
    535c:	0f 91       	pop	r16
    535e:	ff 90       	pop	r15
    5360:	ef 90       	pop	r14
    5362:	08 95       	ret

00005364 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    5364:	df 93       	push	r29
    5366:	cf 93       	push	r28
    5368:	cd b7       	in	r28, 0x3d	; 61
    536a:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    536c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    536e:	10 92 63 06 	sts	0x0663, r1
	vPortEndScheduler();
    5372:	0e 94 6f 15 	call	0x2ade	; 0x2ade <vPortEndScheduler>
}
    5376:	cf 91       	pop	r28
    5378:	df 91       	pop	r29
    537a:	08 95       	ret

0000537c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    537c:	df 93       	push	r29
    537e:	cf 93       	push	r28
    5380:	cd b7       	in	r28, 0x3d	; 61
    5382:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    5384:	80 91 6c 06 	lds	r24, 0x066C
    5388:	8f 5f       	subi	r24, 0xFF	; 255
    538a:	80 93 6c 06 	sts	0x066C, r24
}
    538e:	cf 91       	pop	r28
    5390:	df 91       	pop	r29
    5392:	08 95       	ret

00005394 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    5394:	df 93       	push	r29
    5396:	cf 93       	push	r28
    5398:	00 d0       	rcall	.+0      	; 0x539a <xTaskResumeAll+0x6>
    539a:	00 d0       	rcall	.+0      	; 0x539c <xTaskResumeAll+0x8>
    539c:	cd b7       	in	r28, 0x3d	; 61
    539e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    53a0:	1c 82       	std	Y+4, r1	; 0x04
    53a2:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    53a4:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    53a6:	0f b6       	in	r0, 0x3f	; 63
    53a8:	f8 94       	cli
    53aa:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    53ac:	80 91 6c 06 	lds	r24, 0x066C
    53b0:	81 50       	subi	r24, 0x01	; 1
    53b2:	80 93 6c 06 	sts	0x066C, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    53b6:	80 91 6c 06 	lds	r24, 0x066C
    53ba:	88 23       	and	r24, r24
    53bc:	09 f0       	breq	.+2      	; 0x53c0 <xTaskResumeAll+0x2c>
    53be:	73 c0       	rjmp	.+230    	; 0x54a6 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    53c0:	80 91 5f 06 	lds	r24, 0x065F
    53c4:	88 23       	and	r24, r24
    53c6:	09 f4       	brne	.+2      	; 0x53ca <xTaskResumeAll+0x36>
    53c8:	6e c0       	rjmp	.+220    	; 0x54a6 <xTaskResumeAll+0x112>
    53ca:	45 c0       	rjmp	.+138    	; 0x5456 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    53cc:	e0 91 ac 06 	lds	r30, 0x06AC
    53d0:	f0 91 ad 06 	lds	r31, 0x06AD
    53d4:	86 81       	ldd	r24, Z+6	; 0x06
    53d6:	97 81       	ldd	r25, Z+7	; 0x07
    53d8:	9c 83       	std	Y+4, r25	; 0x04
    53da:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    53dc:	8b 81       	ldd	r24, Y+3	; 0x03
    53de:	9c 81       	ldd	r25, Y+4	; 0x04
    53e0:	0c 96       	adiw	r24, 0x0c	; 12
    53e2:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    53e6:	8b 81       	ldd	r24, Y+3	; 0x03
    53e8:	9c 81       	ldd	r25, Y+4	; 0x04
    53ea:	02 96       	adiw	r24, 0x02	; 2
    53ec:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    53f0:	eb 81       	ldd	r30, Y+3	; 0x03
    53f2:	fc 81       	ldd	r31, Y+4	; 0x04
    53f4:	96 89       	ldd	r25, Z+22	; 0x16
    53f6:	80 91 62 06 	lds	r24, 0x0662
    53fa:	89 17       	cp	r24, r25
    53fc:	28 f4       	brcc	.+10     	; 0x5408 <xTaskResumeAll+0x74>
    53fe:	eb 81       	ldd	r30, Y+3	; 0x03
    5400:	fc 81       	ldd	r31, Y+4	; 0x04
    5402:	86 89       	ldd	r24, Z+22	; 0x16
    5404:	80 93 62 06 	sts	0x0662, r24
    5408:	eb 81       	ldd	r30, Y+3	; 0x03
    540a:	fc 81       	ldd	r31, Y+4	; 0x04
    540c:	86 89       	ldd	r24, Z+22	; 0x16
    540e:	28 2f       	mov	r18, r24
    5410:	30 e0       	ldi	r19, 0x00	; 0
    5412:	c9 01       	movw	r24, r18
    5414:	88 0f       	add	r24, r24
    5416:	99 1f       	adc	r25, r25
    5418:	88 0f       	add	r24, r24
    541a:	99 1f       	adc	r25, r25
    541c:	88 0f       	add	r24, r24
    541e:	99 1f       	adc	r25, r25
    5420:	82 0f       	add	r24, r18
    5422:	93 1f       	adc	r25, r19
    5424:	ac 01       	movw	r20, r24
    5426:	43 59       	subi	r20, 0x93	; 147
    5428:	59 4f       	sbci	r21, 0xF9	; 249
    542a:	8b 81       	ldd	r24, Y+3	; 0x03
    542c:	9c 81       	ldd	r25, Y+4	; 0x04
    542e:	9c 01       	movw	r18, r24
    5430:	2e 5f       	subi	r18, 0xFE	; 254
    5432:	3f 4f       	sbci	r19, 0xFF	; 255
    5434:	ca 01       	movw	r24, r20
    5436:	b9 01       	movw	r22, r18
    5438:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    543c:	eb 81       	ldd	r30, Y+3	; 0x03
    543e:	fc 81       	ldd	r31, Y+4	; 0x04
    5440:	96 89       	ldd	r25, Z+22	; 0x16
    5442:	e0 91 5c 06 	lds	r30, 0x065C
    5446:	f0 91 5d 06 	lds	r31, 0x065D
    544a:	86 89       	ldd	r24, Z+22	; 0x16
    544c:	98 17       	cp	r25, r24
    544e:	18 f0       	brcs	.+6      	; 0x5456 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    5450:	81 e0       	ldi	r24, 0x01	; 1
    5452:	80 93 65 06 	sts	0x0665, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    5456:	80 91 a7 06 	lds	r24, 0x06A7
    545a:	88 23       	and	r24, r24
    545c:	09 f0       	breq	.+2      	; 0x5460 <xTaskResumeAll+0xcc>
    545e:	b6 cf       	rjmp	.-148    	; 0x53cc <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    5460:	8b 81       	ldd	r24, Y+3	; 0x03
    5462:	9c 81       	ldd	r25, Y+4	; 0x04
    5464:	00 97       	sbiw	r24, 0x00	; 0
    5466:	11 f0       	breq	.+4      	; 0x546c <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    5468:	0e 94 64 2e 	call	0x5cc8	; 0x5cc8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    546c:	80 91 64 06 	lds	r24, 0x0664
    5470:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    5472:	89 81       	ldd	r24, Y+1	; 0x01
    5474:	88 23       	and	r24, r24
    5476:	79 f0       	breq	.+30     	; 0x5496 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    5478:	0e 94 ba 2a 	call	0x5574	; 0x5574 <xTaskIncrementTick>
    547c:	88 23       	and	r24, r24
    547e:	19 f0       	breq	.+6      	; 0x5486 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    5480:	81 e0       	ldi	r24, 0x01	; 1
    5482:	80 93 65 06 	sts	0x0665, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    5486:	89 81       	ldd	r24, Y+1	; 0x01
    5488:	81 50       	subi	r24, 0x01	; 1
    548a:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    548c:	89 81       	ldd	r24, Y+1	; 0x01
    548e:	88 23       	and	r24, r24
    5490:	99 f7       	brne	.-26     	; 0x5478 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    5492:	10 92 64 06 	sts	0x0664, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    5496:	80 91 65 06 	lds	r24, 0x0665
    549a:	88 23       	and	r24, r24
    549c:	21 f0       	breq	.+8      	; 0x54a6 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    549e:	81 e0       	ldi	r24, 0x01	; 1
    54a0:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    54a2:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    54a6:	0f 90       	pop	r0
    54a8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    54aa:	8a 81       	ldd	r24, Y+2	; 0x02
}
    54ac:	0f 90       	pop	r0
    54ae:	0f 90       	pop	r0
    54b0:	0f 90       	pop	r0
    54b2:	0f 90       	pop	r0
    54b4:	cf 91       	pop	r28
    54b6:	df 91       	pop	r29
    54b8:	08 95       	ret

000054ba <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    54ba:	df 93       	push	r29
    54bc:	cf 93       	push	r28
    54be:	00 d0       	rcall	.+0      	; 0x54c0 <xTaskGetTickCount+0x6>
    54c0:	cd b7       	in	r28, 0x3d	; 61
    54c2:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    54c4:	0f b6       	in	r0, 0x3f	; 63
    54c6:	f8 94       	cli
    54c8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    54ca:	80 91 60 06 	lds	r24, 0x0660
    54ce:	90 91 61 06 	lds	r25, 0x0661
    54d2:	9a 83       	std	Y+2, r25	; 0x02
    54d4:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    54d6:	0f 90       	pop	r0
    54d8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    54da:	89 81       	ldd	r24, Y+1	; 0x01
    54dc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    54de:	0f 90       	pop	r0
    54e0:	0f 90       	pop	r0
    54e2:	cf 91       	pop	r28
    54e4:	df 91       	pop	r29
    54e6:	08 95       	ret

000054e8 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    54e8:	df 93       	push	r29
    54ea:	cf 93       	push	r28
    54ec:	00 d0       	rcall	.+0      	; 0x54ee <xTaskGetTickCountFromISR+0x6>
    54ee:	0f 92       	push	r0
    54f0:	cd b7       	in	r28, 0x3d	; 61
    54f2:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    54f4:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    54f6:	80 91 60 06 	lds	r24, 0x0660
    54fa:	90 91 61 06 	lds	r25, 0x0661
    54fe:	9b 83       	std	Y+3, r25	; 0x03
    5500:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5502:	8a 81       	ldd	r24, Y+2	; 0x02
    5504:	9b 81       	ldd	r25, Y+3	; 0x03
}
    5506:	0f 90       	pop	r0
    5508:	0f 90       	pop	r0
    550a:	0f 90       	pop	r0
    550c:	cf 91       	pop	r28
    550e:	df 91       	pop	r29
    5510:	08 95       	ret

00005512 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    5512:	df 93       	push	r29
    5514:	cf 93       	push	r28
    5516:	cd b7       	in	r28, 0x3d	; 61
    5518:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    551a:	80 91 5f 06 	lds	r24, 0x065F
}
    551e:	cf 91       	pop	r28
    5520:	df 91       	pop	r29
    5522:	08 95       	ret

00005524 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5524:	df 93       	push	r29
    5526:	cf 93       	push	r28
    5528:	00 d0       	rcall	.+0      	; 0x552a <pcTaskGetName+0x6>
    552a:	00 d0       	rcall	.+0      	; 0x552c <pcTaskGetName+0x8>
    552c:	00 d0       	rcall	.+0      	; 0x552e <pcTaskGetName+0xa>
    552e:	cd b7       	in	r28, 0x3d	; 61
    5530:	de b7       	in	r29, 0x3e	; 62
    5532:	9c 83       	std	Y+4, r25	; 0x04
    5534:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    5536:	8b 81       	ldd	r24, Y+3	; 0x03
    5538:	9c 81       	ldd	r25, Y+4	; 0x04
    553a:	00 97       	sbiw	r24, 0x00	; 0
    553c:	39 f4       	brne	.+14     	; 0x554c <pcTaskGetName+0x28>
    553e:	80 91 5c 06 	lds	r24, 0x065C
    5542:	90 91 5d 06 	lds	r25, 0x065D
    5546:	9e 83       	std	Y+6, r25	; 0x06
    5548:	8d 83       	std	Y+5, r24	; 0x05
    554a:	04 c0       	rjmp	.+8      	; 0x5554 <pcTaskGetName+0x30>
    554c:	8b 81       	ldd	r24, Y+3	; 0x03
    554e:	9c 81       	ldd	r25, Y+4	; 0x04
    5550:	9e 83       	std	Y+6, r25	; 0x06
    5552:	8d 83       	std	Y+5, r24	; 0x05
    5554:	8d 81       	ldd	r24, Y+5	; 0x05
    5556:	9e 81       	ldd	r25, Y+6	; 0x06
    5558:	9a 83       	std	Y+2, r25	; 0x02
    555a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    555c:	89 81       	ldd	r24, Y+1	; 0x01
    555e:	9a 81       	ldd	r25, Y+2	; 0x02
    5560:	49 96       	adiw	r24, 0x19	; 25
}
    5562:	26 96       	adiw	r28, 0x06	; 6
    5564:	0f b6       	in	r0, 0x3f	; 63
    5566:	f8 94       	cli
    5568:	de bf       	out	0x3e, r29	; 62
    556a:	0f be       	out	0x3f, r0	; 63
    556c:	cd bf       	out	0x3d, r28	; 61
    556e:	cf 91       	pop	r28
    5570:	df 91       	pop	r29
    5572:	08 95       	ret

00005574 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5574:	df 93       	push	r29
    5576:	cf 93       	push	r28
    5578:	cd b7       	in	r28, 0x3d	; 61
    557a:	de b7       	in	r29, 0x3e	; 62
    557c:	29 97       	sbiw	r28, 0x09	; 9
    557e:	0f b6       	in	r0, 0x3f	; 63
    5580:	f8 94       	cli
    5582:	de bf       	out	0x3e, r29	; 62
    5584:	0f be       	out	0x3f, r0	; 63
    5586:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    5588:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    558a:	80 91 6c 06 	lds	r24, 0x066C
    558e:	88 23       	and	r24, r24
    5590:	09 f0       	breq	.+2      	; 0x5594 <xTaskIncrementTick+0x20>
    5592:	c0 c0       	rjmp	.+384    	; 0x5714 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    5594:	80 91 60 06 	lds	r24, 0x0660
    5598:	90 91 61 06 	lds	r25, 0x0661
    559c:	01 96       	adiw	r24, 0x01	; 1
    559e:	9c 83       	std	Y+4, r25	; 0x04
    55a0:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    55a2:	8b 81       	ldd	r24, Y+3	; 0x03
    55a4:	9c 81       	ldd	r25, Y+4	; 0x04
    55a6:	90 93 61 06 	sts	0x0661, r25
    55aa:	80 93 60 06 	sts	0x0660, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    55ae:	8b 81       	ldd	r24, Y+3	; 0x03
    55b0:	9c 81       	ldd	r25, Y+4	; 0x04
    55b2:	00 97       	sbiw	r24, 0x00	; 0
    55b4:	d9 f4       	brne	.+54     	; 0x55ec <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    55b6:	80 91 a3 06 	lds	r24, 0x06A3
    55ba:	90 91 a4 06 	lds	r25, 0x06A4
    55be:	9a 83       	std	Y+2, r25	; 0x02
    55c0:	89 83       	std	Y+1, r24	; 0x01
    55c2:	80 91 a5 06 	lds	r24, 0x06A5
    55c6:	90 91 a6 06 	lds	r25, 0x06A6
    55ca:	90 93 a4 06 	sts	0x06A4, r25
    55ce:	80 93 a3 06 	sts	0x06A3, r24
    55d2:	89 81       	ldd	r24, Y+1	; 0x01
    55d4:	9a 81       	ldd	r25, Y+2	; 0x02
    55d6:	90 93 a6 06 	sts	0x06A6, r25
    55da:	80 93 a5 06 	sts	0x06A5, r24
    55de:	80 91 66 06 	lds	r24, 0x0666
    55e2:	8f 5f       	subi	r24, 0xFF	; 255
    55e4:	80 93 66 06 	sts	0x0666, r24
    55e8:	0e 94 64 2e 	call	0x5cc8	; 0x5cc8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    55ec:	20 91 68 06 	lds	r18, 0x0668
    55f0:	30 91 69 06 	lds	r19, 0x0669
    55f4:	8b 81       	ldd	r24, Y+3	; 0x03
    55f6:	9c 81       	ldd	r25, Y+4	; 0x04
    55f8:	82 17       	cp	r24, r18
    55fa:	93 07       	cpc	r25, r19
    55fc:	08 f4       	brcc	.+2      	; 0x5600 <xTaskIncrementTick+0x8c>
    55fe:	71 c0       	rjmp	.+226    	; 0x56e2 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5600:	e0 91 a3 06 	lds	r30, 0x06A3
    5604:	f0 91 a4 06 	lds	r31, 0x06A4
    5608:	80 81       	ld	r24, Z
    560a:	88 23       	and	r24, r24
    560c:	39 f4       	brne	.+14     	; 0x561c <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    560e:	8f ef       	ldi	r24, 0xFF	; 255
    5610:	9f ef       	ldi	r25, 0xFF	; 255
    5612:	90 93 69 06 	sts	0x0669, r25
    5616:	80 93 68 06 	sts	0x0668, r24
    561a:	63 c0       	rjmp	.+198    	; 0x56e2 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    561c:	e0 91 a3 06 	lds	r30, 0x06A3
    5620:	f0 91 a4 06 	lds	r31, 0x06A4
    5624:	05 80       	ldd	r0, Z+5	; 0x05
    5626:	f6 81       	ldd	r31, Z+6	; 0x06
    5628:	e0 2d       	mov	r30, r0
    562a:	86 81       	ldd	r24, Z+6	; 0x06
    562c:	97 81       	ldd	r25, Z+7	; 0x07
    562e:	99 87       	std	Y+9, r25	; 0x09
    5630:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    5632:	e8 85       	ldd	r30, Y+8	; 0x08
    5634:	f9 85       	ldd	r31, Y+9	; 0x09
    5636:	82 81       	ldd	r24, Z+2	; 0x02
    5638:	93 81       	ldd	r25, Z+3	; 0x03
    563a:	9f 83       	std	Y+7, r25	; 0x07
    563c:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    563e:	2b 81       	ldd	r18, Y+3	; 0x03
    5640:	3c 81       	ldd	r19, Y+4	; 0x04
    5642:	8e 81       	ldd	r24, Y+6	; 0x06
    5644:	9f 81       	ldd	r25, Y+7	; 0x07
    5646:	28 17       	cp	r18, r24
    5648:	39 07       	cpc	r19, r25
    564a:	38 f4       	brcc	.+14     	; 0x565a <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    564c:	8e 81       	ldd	r24, Y+6	; 0x06
    564e:	9f 81       	ldd	r25, Y+7	; 0x07
    5650:	90 93 69 06 	sts	0x0669, r25
    5654:	80 93 68 06 	sts	0x0668, r24
    5658:	44 c0       	rjmp	.+136    	; 0x56e2 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    565a:	88 85       	ldd	r24, Y+8	; 0x08
    565c:	99 85       	ldd	r25, Y+9	; 0x09
    565e:	02 96       	adiw	r24, 0x02	; 2
    5660:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5664:	e8 85       	ldd	r30, Y+8	; 0x08
    5666:	f9 85       	ldd	r31, Y+9	; 0x09
    5668:	84 89       	ldd	r24, Z+20	; 0x14
    566a:	95 89       	ldd	r25, Z+21	; 0x15
    566c:	00 97       	sbiw	r24, 0x00	; 0
    566e:	29 f0       	breq	.+10     	; 0x567a <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5670:	88 85       	ldd	r24, Y+8	; 0x08
    5672:	99 85       	ldd	r25, Y+9	; 0x09
    5674:	0c 96       	adiw	r24, 0x0c	; 12
    5676:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    567a:	e8 85       	ldd	r30, Y+8	; 0x08
    567c:	f9 85       	ldd	r31, Y+9	; 0x09
    567e:	96 89       	ldd	r25, Z+22	; 0x16
    5680:	80 91 62 06 	lds	r24, 0x0662
    5684:	89 17       	cp	r24, r25
    5686:	28 f4       	brcc	.+10     	; 0x5692 <xTaskIncrementTick+0x11e>
    5688:	e8 85       	ldd	r30, Y+8	; 0x08
    568a:	f9 85       	ldd	r31, Y+9	; 0x09
    568c:	86 89       	ldd	r24, Z+22	; 0x16
    568e:	80 93 62 06 	sts	0x0662, r24
    5692:	e8 85       	ldd	r30, Y+8	; 0x08
    5694:	f9 85       	ldd	r31, Y+9	; 0x09
    5696:	86 89       	ldd	r24, Z+22	; 0x16
    5698:	28 2f       	mov	r18, r24
    569a:	30 e0       	ldi	r19, 0x00	; 0
    569c:	c9 01       	movw	r24, r18
    569e:	88 0f       	add	r24, r24
    56a0:	99 1f       	adc	r25, r25
    56a2:	88 0f       	add	r24, r24
    56a4:	99 1f       	adc	r25, r25
    56a6:	88 0f       	add	r24, r24
    56a8:	99 1f       	adc	r25, r25
    56aa:	82 0f       	add	r24, r18
    56ac:	93 1f       	adc	r25, r19
    56ae:	ac 01       	movw	r20, r24
    56b0:	43 59       	subi	r20, 0x93	; 147
    56b2:	59 4f       	sbci	r21, 0xF9	; 249
    56b4:	88 85       	ldd	r24, Y+8	; 0x08
    56b6:	99 85       	ldd	r25, Y+9	; 0x09
    56b8:	9c 01       	movw	r18, r24
    56ba:	2e 5f       	subi	r18, 0xFE	; 254
    56bc:	3f 4f       	sbci	r19, 0xFF	; 255
    56be:	ca 01       	movw	r24, r20
    56c0:	b9 01       	movw	r22, r18
    56c2:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    56c6:	e8 85       	ldd	r30, Y+8	; 0x08
    56c8:	f9 85       	ldd	r31, Y+9	; 0x09
    56ca:	96 89       	ldd	r25, Z+22	; 0x16
    56cc:	e0 91 5c 06 	lds	r30, 0x065C
    56d0:	f0 91 5d 06 	lds	r31, 0x065D
    56d4:	86 89       	ldd	r24, Z+22	; 0x16
    56d6:	98 17       	cp	r25, r24
    56d8:	08 f4       	brcc	.+2      	; 0x56dc <xTaskIncrementTick+0x168>
    56da:	92 cf       	rjmp	.-220    	; 0x5600 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    56dc:	81 e0       	ldi	r24, 0x01	; 1
    56de:	8d 83       	std	Y+5, r24	; 0x05
    56e0:	8f cf       	rjmp	.-226    	; 0x5600 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    56e2:	e0 91 5c 06 	lds	r30, 0x065C
    56e6:	f0 91 5d 06 	lds	r31, 0x065D
    56ea:	86 89       	ldd	r24, Z+22	; 0x16
    56ec:	28 2f       	mov	r18, r24
    56ee:	30 e0       	ldi	r19, 0x00	; 0
    56f0:	c9 01       	movw	r24, r18
    56f2:	88 0f       	add	r24, r24
    56f4:	99 1f       	adc	r25, r25
    56f6:	88 0f       	add	r24, r24
    56f8:	99 1f       	adc	r25, r25
    56fa:	88 0f       	add	r24, r24
    56fc:	99 1f       	adc	r25, r25
    56fe:	82 0f       	add	r24, r18
    5700:	93 1f       	adc	r25, r19
    5702:	fc 01       	movw	r30, r24
    5704:	e3 59       	subi	r30, 0x93	; 147
    5706:	f9 4f       	sbci	r31, 0xF9	; 249
    5708:	80 81       	ld	r24, Z
    570a:	82 30       	cpi	r24, 0x02	; 2
    570c:	40 f0       	brcs	.+16     	; 0x571e <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    570e:	81 e0       	ldi	r24, 0x01	; 1
    5710:	8d 83       	std	Y+5, r24	; 0x05
    5712:	05 c0       	rjmp	.+10     	; 0x571e <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    5714:	80 91 64 06 	lds	r24, 0x0664
    5718:	8f 5f       	subi	r24, 0xFF	; 255
    571a:	80 93 64 06 	sts	0x0664, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    571e:	80 91 65 06 	lds	r24, 0x0665
    5722:	88 23       	and	r24, r24
    5724:	11 f0       	breq	.+4      	; 0x572a <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    5726:	81 e0       	ldi	r24, 0x01	; 1
    5728:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    572a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    572c:	29 96       	adiw	r28, 0x09	; 9
    572e:	0f b6       	in	r0, 0x3f	; 63
    5730:	f8 94       	cli
    5732:	de bf       	out	0x3e, r29	; 62
    5734:	0f be       	out	0x3f, r0	; 63
    5736:	cd bf       	out	0x3d, r28	; 61
    5738:	cf 91       	pop	r28
    573a:	df 91       	pop	r29
    573c:	08 95       	ret

0000573e <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    573e:	df 93       	push	r29
    5740:	cf 93       	push	r28
    5742:	00 d0       	rcall	.+0      	; 0x5744 <vTaskSwitchContext+0x6>
    5744:	0f 92       	push	r0
    5746:	cd b7       	in	r28, 0x3d	; 61
    5748:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    574a:	80 91 6c 06 	lds	r24, 0x066C
    574e:	88 23       	and	r24, r24
    5750:	21 f0       	breq	.+8      	; 0x575a <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    5752:	81 e0       	ldi	r24, 0x01	; 1
    5754:	80 93 65 06 	sts	0x0665, r24
    5758:	59 c0       	rjmp	.+178    	; 0x580c <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    575a:	10 92 65 06 	sts	0x0665, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    575e:	80 91 62 06 	lds	r24, 0x0662
    5762:	8b 83       	std	Y+3, r24	; 0x03
    5764:	03 c0       	rjmp	.+6      	; 0x576c <vTaskSwitchContext+0x2e>
    5766:	8b 81       	ldd	r24, Y+3	; 0x03
    5768:	81 50       	subi	r24, 0x01	; 1
    576a:	8b 83       	std	Y+3, r24	; 0x03
    576c:	8b 81       	ldd	r24, Y+3	; 0x03
    576e:	28 2f       	mov	r18, r24
    5770:	30 e0       	ldi	r19, 0x00	; 0
    5772:	c9 01       	movw	r24, r18
    5774:	88 0f       	add	r24, r24
    5776:	99 1f       	adc	r25, r25
    5778:	88 0f       	add	r24, r24
    577a:	99 1f       	adc	r25, r25
    577c:	88 0f       	add	r24, r24
    577e:	99 1f       	adc	r25, r25
    5780:	82 0f       	add	r24, r18
    5782:	93 1f       	adc	r25, r19
    5784:	fc 01       	movw	r30, r24
    5786:	e3 59       	subi	r30, 0x93	; 147
    5788:	f9 4f       	sbci	r31, 0xF9	; 249
    578a:	80 81       	ld	r24, Z
    578c:	88 23       	and	r24, r24
    578e:	59 f3       	breq	.-42     	; 0x5766 <vTaskSwitchContext+0x28>
    5790:	8b 81       	ldd	r24, Y+3	; 0x03
    5792:	28 2f       	mov	r18, r24
    5794:	30 e0       	ldi	r19, 0x00	; 0
    5796:	c9 01       	movw	r24, r18
    5798:	88 0f       	add	r24, r24
    579a:	99 1f       	adc	r25, r25
    579c:	88 0f       	add	r24, r24
    579e:	99 1f       	adc	r25, r25
    57a0:	88 0f       	add	r24, r24
    57a2:	99 1f       	adc	r25, r25
    57a4:	82 0f       	add	r24, r18
    57a6:	93 1f       	adc	r25, r19
    57a8:	83 59       	subi	r24, 0x93	; 147
    57aa:	99 4f       	sbci	r25, 0xF9	; 249
    57ac:	9a 83       	std	Y+2, r25	; 0x02
    57ae:	89 83       	std	Y+1, r24	; 0x01
    57b0:	e9 81       	ldd	r30, Y+1	; 0x01
    57b2:	fa 81       	ldd	r31, Y+2	; 0x02
    57b4:	01 80       	ldd	r0, Z+1	; 0x01
    57b6:	f2 81       	ldd	r31, Z+2	; 0x02
    57b8:	e0 2d       	mov	r30, r0
    57ba:	82 81       	ldd	r24, Z+2	; 0x02
    57bc:	93 81       	ldd	r25, Z+3	; 0x03
    57be:	e9 81       	ldd	r30, Y+1	; 0x01
    57c0:	fa 81       	ldd	r31, Y+2	; 0x02
    57c2:	92 83       	std	Z+2, r25	; 0x02
    57c4:	81 83       	std	Z+1, r24	; 0x01
    57c6:	e9 81       	ldd	r30, Y+1	; 0x01
    57c8:	fa 81       	ldd	r31, Y+2	; 0x02
    57ca:	21 81       	ldd	r18, Z+1	; 0x01
    57cc:	32 81       	ldd	r19, Z+2	; 0x02
    57ce:	89 81       	ldd	r24, Y+1	; 0x01
    57d0:	9a 81       	ldd	r25, Y+2	; 0x02
    57d2:	03 96       	adiw	r24, 0x03	; 3
    57d4:	28 17       	cp	r18, r24
    57d6:	39 07       	cpc	r19, r25
    57d8:	59 f4       	brne	.+22     	; 0x57f0 <vTaskSwitchContext+0xb2>
    57da:	e9 81       	ldd	r30, Y+1	; 0x01
    57dc:	fa 81       	ldd	r31, Y+2	; 0x02
    57de:	01 80       	ldd	r0, Z+1	; 0x01
    57e0:	f2 81       	ldd	r31, Z+2	; 0x02
    57e2:	e0 2d       	mov	r30, r0
    57e4:	82 81       	ldd	r24, Z+2	; 0x02
    57e6:	93 81       	ldd	r25, Z+3	; 0x03
    57e8:	e9 81       	ldd	r30, Y+1	; 0x01
    57ea:	fa 81       	ldd	r31, Y+2	; 0x02
    57ec:	92 83       	std	Z+2, r25	; 0x02
    57ee:	81 83       	std	Z+1, r24	; 0x01
    57f0:	e9 81       	ldd	r30, Y+1	; 0x01
    57f2:	fa 81       	ldd	r31, Y+2	; 0x02
    57f4:	01 80       	ldd	r0, Z+1	; 0x01
    57f6:	f2 81       	ldd	r31, Z+2	; 0x02
    57f8:	e0 2d       	mov	r30, r0
    57fa:	86 81       	ldd	r24, Z+6	; 0x06
    57fc:	97 81       	ldd	r25, Z+7	; 0x07
    57fe:	90 93 5d 06 	sts	0x065D, r25
    5802:	80 93 5c 06 	sts	0x065C, r24
    5806:	8b 81       	ldd	r24, Y+3	; 0x03
    5808:	80 93 62 06 	sts	0x0662, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    580c:	0f 90       	pop	r0
    580e:	0f 90       	pop	r0
    5810:	0f 90       	pop	r0
    5812:	cf 91       	pop	r28
    5814:	df 91       	pop	r29
    5816:	08 95       	ret

00005818 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    5818:	df 93       	push	r29
    581a:	cf 93       	push	r28
    581c:	00 d0       	rcall	.+0      	; 0x581e <vTaskPlaceOnEventList+0x6>
    581e:	00 d0       	rcall	.+0      	; 0x5820 <vTaskPlaceOnEventList+0x8>
    5820:	cd b7       	in	r28, 0x3d	; 61
    5822:	de b7       	in	r29, 0x3e	; 62
    5824:	9a 83       	std	Y+2, r25	; 0x02
    5826:	89 83       	std	Y+1, r24	; 0x01
    5828:	7c 83       	std	Y+4, r23	; 0x04
    582a:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    582c:	80 91 5c 06 	lds	r24, 0x065C
    5830:	90 91 5d 06 	lds	r25, 0x065D
    5834:	9c 01       	movw	r18, r24
    5836:	24 5f       	subi	r18, 0xF4	; 244
    5838:	3f 4f       	sbci	r19, 0xFF	; 255
    583a:	89 81       	ldd	r24, Y+1	; 0x01
    583c:	9a 81       	ldd	r25, Y+2	; 0x02
    583e:	b9 01       	movw	r22, r18
    5840:	0e 94 49 12 	call	0x2492	; 0x2492 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5844:	8b 81       	ldd	r24, Y+3	; 0x03
    5846:	9c 81       	ldd	r25, Y+4	; 0x04
    5848:	61 e0       	ldi	r22, 0x01	; 1
    584a:	0e 94 70 32 	call	0x64e0	; 0x64e0 <prvAddCurrentTaskToDelayedList>
}
    584e:	0f 90       	pop	r0
    5850:	0f 90       	pop	r0
    5852:	0f 90       	pop	r0
    5854:	0f 90       	pop	r0
    5856:	cf 91       	pop	r28
    5858:	df 91       	pop	r29
    585a:	08 95       	ret

0000585c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    585c:	df 93       	push	r29
    585e:	cf 93       	push	r28
    5860:	00 d0       	rcall	.+0      	; 0x5862 <vTaskPlaceOnUnorderedEventList+0x6>
    5862:	00 d0       	rcall	.+0      	; 0x5864 <vTaskPlaceOnUnorderedEventList+0x8>
    5864:	00 d0       	rcall	.+0      	; 0x5866 <vTaskPlaceOnUnorderedEventList+0xa>
    5866:	cd b7       	in	r28, 0x3d	; 61
    5868:	de b7       	in	r29, 0x3e	; 62
    586a:	9a 83       	std	Y+2, r25	; 0x02
    586c:	89 83       	std	Y+1, r24	; 0x01
    586e:	7c 83       	std	Y+4, r23	; 0x04
    5870:	6b 83       	std	Y+3, r22	; 0x03
    5872:	5e 83       	std	Y+6, r21	; 0x06
    5874:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5876:	e0 91 5c 06 	lds	r30, 0x065C
    587a:	f0 91 5d 06 	lds	r31, 0x065D
    587e:	8b 81       	ldd	r24, Y+3	; 0x03
    5880:	9c 81       	ldd	r25, Y+4	; 0x04
    5882:	90 68       	ori	r25, 0x80	; 128
    5884:	95 87       	std	Z+13, r25	; 0x0d
    5886:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5888:	80 91 5c 06 	lds	r24, 0x065C
    588c:	90 91 5d 06 	lds	r25, 0x065D
    5890:	9c 01       	movw	r18, r24
    5892:	24 5f       	subi	r18, 0xF4	; 244
    5894:	3f 4f       	sbci	r19, 0xFF	; 255
    5896:	89 81       	ldd	r24, Y+1	; 0x01
    5898:	9a 81       	ldd	r25, Y+2	; 0x02
    589a:	b9 01       	movw	r22, r18
    589c:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    58a0:	8d 81       	ldd	r24, Y+5	; 0x05
    58a2:	9e 81       	ldd	r25, Y+6	; 0x06
    58a4:	61 e0       	ldi	r22, 0x01	; 1
    58a6:	0e 94 70 32 	call	0x64e0	; 0x64e0 <prvAddCurrentTaskToDelayedList>
}
    58aa:	26 96       	adiw	r28, 0x06	; 6
    58ac:	0f b6       	in	r0, 0x3f	; 63
    58ae:	f8 94       	cli
    58b0:	de bf       	out	0x3e, r29	; 62
    58b2:	0f be       	out	0x3f, r0	; 63
    58b4:	cd bf       	out	0x3d, r28	; 61
    58b6:	cf 91       	pop	r28
    58b8:	df 91       	pop	r29
    58ba:	08 95       	ret

000058bc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    58bc:	df 93       	push	r29
    58be:	cf 93       	push	r28
    58c0:	00 d0       	rcall	.+0      	; 0x58c2 <xTaskRemoveFromEventList+0x6>
    58c2:	00 d0       	rcall	.+0      	; 0x58c4 <xTaskRemoveFromEventList+0x8>
    58c4:	0f 92       	push	r0
    58c6:	cd b7       	in	r28, 0x3d	; 61
    58c8:	de b7       	in	r29, 0x3e	; 62
    58ca:	9d 83       	std	Y+5, r25	; 0x05
    58cc:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    58ce:	ec 81       	ldd	r30, Y+4	; 0x04
    58d0:	fd 81       	ldd	r31, Y+5	; 0x05
    58d2:	05 80       	ldd	r0, Z+5	; 0x05
    58d4:	f6 81       	ldd	r31, Z+6	; 0x06
    58d6:	e0 2d       	mov	r30, r0
    58d8:	86 81       	ldd	r24, Z+6	; 0x06
    58da:	97 81       	ldd	r25, Z+7	; 0x07
    58dc:	9b 83       	std	Y+3, r25	; 0x03
    58de:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    58e0:	8a 81       	ldd	r24, Y+2	; 0x02
    58e2:	9b 81       	ldd	r25, Y+3	; 0x03
    58e4:	0c 96       	adiw	r24, 0x0c	; 12
    58e6:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    58ea:	80 91 6c 06 	lds	r24, 0x066C
    58ee:	88 23       	and	r24, r24
    58f0:	61 f5       	brne	.+88     	; 0x594a <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    58f2:	8a 81       	ldd	r24, Y+2	; 0x02
    58f4:	9b 81       	ldd	r25, Y+3	; 0x03
    58f6:	02 96       	adiw	r24, 0x02	; 2
    58f8:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    58fc:	ea 81       	ldd	r30, Y+2	; 0x02
    58fe:	fb 81       	ldd	r31, Y+3	; 0x03
    5900:	96 89       	ldd	r25, Z+22	; 0x16
    5902:	80 91 62 06 	lds	r24, 0x0662
    5906:	89 17       	cp	r24, r25
    5908:	28 f4       	brcc	.+10     	; 0x5914 <xTaskRemoveFromEventList+0x58>
    590a:	ea 81       	ldd	r30, Y+2	; 0x02
    590c:	fb 81       	ldd	r31, Y+3	; 0x03
    590e:	86 89       	ldd	r24, Z+22	; 0x16
    5910:	80 93 62 06 	sts	0x0662, r24
    5914:	ea 81       	ldd	r30, Y+2	; 0x02
    5916:	fb 81       	ldd	r31, Y+3	; 0x03
    5918:	86 89       	ldd	r24, Z+22	; 0x16
    591a:	28 2f       	mov	r18, r24
    591c:	30 e0       	ldi	r19, 0x00	; 0
    591e:	c9 01       	movw	r24, r18
    5920:	88 0f       	add	r24, r24
    5922:	99 1f       	adc	r25, r25
    5924:	88 0f       	add	r24, r24
    5926:	99 1f       	adc	r25, r25
    5928:	88 0f       	add	r24, r24
    592a:	99 1f       	adc	r25, r25
    592c:	82 0f       	add	r24, r18
    592e:	93 1f       	adc	r25, r19
    5930:	ac 01       	movw	r20, r24
    5932:	43 59       	subi	r20, 0x93	; 147
    5934:	59 4f       	sbci	r21, 0xF9	; 249
    5936:	8a 81       	ldd	r24, Y+2	; 0x02
    5938:	9b 81       	ldd	r25, Y+3	; 0x03
    593a:	9c 01       	movw	r18, r24
    593c:	2e 5f       	subi	r18, 0xFE	; 254
    593e:	3f 4f       	sbci	r19, 0xFF	; 255
    5940:	ca 01       	movw	r24, r20
    5942:	b9 01       	movw	r22, r18
    5944:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
    5948:	0a c0       	rjmp	.+20     	; 0x595e <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    594a:	8a 81       	ldd	r24, Y+2	; 0x02
    594c:	9b 81       	ldd	r25, Y+3	; 0x03
    594e:	9c 01       	movw	r18, r24
    5950:	24 5f       	subi	r18, 0xF4	; 244
    5952:	3f 4f       	sbci	r19, 0xFF	; 255
    5954:	87 ea       	ldi	r24, 0xA7	; 167
    5956:	96 e0       	ldi	r25, 0x06	; 6
    5958:	b9 01       	movw	r22, r18
    595a:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    595e:	ea 81       	ldd	r30, Y+2	; 0x02
    5960:	fb 81       	ldd	r31, Y+3	; 0x03
    5962:	96 89       	ldd	r25, Z+22	; 0x16
    5964:	e0 91 5c 06 	lds	r30, 0x065C
    5968:	f0 91 5d 06 	lds	r31, 0x065D
    596c:	86 89       	ldd	r24, Z+22	; 0x16
    596e:	89 17       	cp	r24, r25
    5970:	30 f4       	brcc	.+12     	; 0x597e <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    5972:	81 e0       	ldi	r24, 0x01	; 1
    5974:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5976:	81 e0       	ldi	r24, 0x01	; 1
    5978:	80 93 65 06 	sts	0x0665, r24
    597c:	01 c0       	rjmp	.+2      	; 0x5980 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    597e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5980:	89 81       	ldd	r24, Y+1	; 0x01
}
    5982:	0f 90       	pop	r0
    5984:	0f 90       	pop	r0
    5986:	0f 90       	pop	r0
    5988:	0f 90       	pop	r0
    598a:	0f 90       	pop	r0
    598c:	cf 91       	pop	r28
    598e:	df 91       	pop	r29
    5990:	08 95       	ret

00005992 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5992:	df 93       	push	r29
    5994:	cf 93       	push	r28
    5996:	00 d0       	rcall	.+0      	; 0x5998 <vTaskRemoveFromUnorderedEventList+0x6>
    5998:	00 d0       	rcall	.+0      	; 0x599a <vTaskRemoveFromUnorderedEventList+0x8>
    599a:	00 d0       	rcall	.+0      	; 0x599c <vTaskRemoveFromUnorderedEventList+0xa>
    599c:	cd b7       	in	r28, 0x3d	; 61
    599e:	de b7       	in	r29, 0x3e	; 62
    59a0:	9c 83       	std	Y+4, r25	; 0x04
    59a2:	8b 83       	std	Y+3, r24	; 0x03
    59a4:	7e 83       	std	Y+6, r23	; 0x06
    59a6:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    59a8:	8d 81       	ldd	r24, Y+5	; 0x05
    59aa:	9e 81       	ldd	r25, Y+6	; 0x06
    59ac:	90 68       	ori	r25, 0x80	; 128
    59ae:	eb 81       	ldd	r30, Y+3	; 0x03
    59b0:	fc 81       	ldd	r31, Y+4	; 0x04
    59b2:	91 83       	std	Z+1, r25	; 0x01
    59b4:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    59b6:	eb 81       	ldd	r30, Y+3	; 0x03
    59b8:	fc 81       	ldd	r31, Y+4	; 0x04
    59ba:	86 81       	ldd	r24, Z+6	; 0x06
    59bc:	97 81       	ldd	r25, Z+7	; 0x07
    59be:	9a 83       	std	Y+2, r25	; 0x02
    59c0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    59c2:	8b 81       	ldd	r24, Y+3	; 0x03
    59c4:	9c 81       	ldd	r25, Y+4	; 0x04
    59c6:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    59ca:	89 81       	ldd	r24, Y+1	; 0x01
    59cc:	9a 81       	ldd	r25, Y+2	; 0x02
    59ce:	02 96       	adiw	r24, 0x02	; 2
    59d0:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    59d4:	e9 81       	ldd	r30, Y+1	; 0x01
    59d6:	fa 81       	ldd	r31, Y+2	; 0x02
    59d8:	96 89       	ldd	r25, Z+22	; 0x16
    59da:	80 91 62 06 	lds	r24, 0x0662
    59de:	89 17       	cp	r24, r25
    59e0:	28 f4       	brcc	.+10     	; 0x59ec <vTaskRemoveFromUnorderedEventList+0x5a>
    59e2:	e9 81       	ldd	r30, Y+1	; 0x01
    59e4:	fa 81       	ldd	r31, Y+2	; 0x02
    59e6:	86 89       	ldd	r24, Z+22	; 0x16
    59e8:	80 93 62 06 	sts	0x0662, r24
    59ec:	e9 81       	ldd	r30, Y+1	; 0x01
    59ee:	fa 81       	ldd	r31, Y+2	; 0x02
    59f0:	86 89       	ldd	r24, Z+22	; 0x16
    59f2:	28 2f       	mov	r18, r24
    59f4:	30 e0       	ldi	r19, 0x00	; 0
    59f6:	c9 01       	movw	r24, r18
    59f8:	88 0f       	add	r24, r24
    59fa:	99 1f       	adc	r25, r25
    59fc:	88 0f       	add	r24, r24
    59fe:	99 1f       	adc	r25, r25
    5a00:	88 0f       	add	r24, r24
    5a02:	99 1f       	adc	r25, r25
    5a04:	82 0f       	add	r24, r18
    5a06:	93 1f       	adc	r25, r19
    5a08:	ac 01       	movw	r20, r24
    5a0a:	43 59       	subi	r20, 0x93	; 147
    5a0c:	59 4f       	sbci	r21, 0xF9	; 249
    5a0e:	89 81       	ldd	r24, Y+1	; 0x01
    5a10:	9a 81       	ldd	r25, Y+2	; 0x02
    5a12:	9c 01       	movw	r18, r24
    5a14:	2e 5f       	subi	r18, 0xFE	; 254
    5a16:	3f 4f       	sbci	r19, 0xFF	; 255
    5a18:	ca 01       	movw	r24, r20
    5a1a:	b9 01       	movw	r22, r18
    5a1c:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5a20:	e9 81       	ldd	r30, Y+1	; 0x01
    5a22:	fa 81       	ldd	r31, Y+2	; 0x02
    5a24:	96 89       	ldd	r25, Z+22	; 0x16
    5a26:	e0 91 5c 06 	lds	r30, 0x065C
    5a2a:	f0 91 5d 06 	lds	r31, 0x065D
    5a2e:	86 89       	ldd	r24, Z+22	; 0x16
    5a30:	89 17       	cp	r24, r25
    5a32:	18 f4       	brcc	.+6      	; 0x5a3a <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    5a34:	81 e0       	ldi	r24, 0x01	; 1
    5a36:	80 93 65 06 	sts	0x0665, r24
	}
}
    5a3a:	26 96       	adiw	r28, 0x06	; 6
    5a3c:	0f b6       	in	r0, 0x3f	; 63
    5a3e:	f8 94       	cli
    5a40:	de bf       	out	0x3e, r29	; 62
    5a42:	0f be       	out	0x3f, r0	; 63
    5a44:	cd bf       	out	0x3d, r28	; 61
    5a46:	cf 91       	pop	r28
    5a48:	df 91       	pop	r29
    5a4a:	08 95       	ret

00005a4c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5a4c:	df 93       	push	r29
    5a4e:	cf 93       	push	r28
    5a50:	00 d0       	rcall	.+0      	; 0x5a52 <vTaskSetTimeOutState+0x6>
    5a52:	cd b7       	in	r28, 0x3d	; 61
    5a54:	de b7       	in	r29, 0x3e	; 62
    5a56:	9a 83       	std	Y+2, r25	; 0x02
    5a58:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    5a5a:	0f b6       	in	r0, 0x3f	; 63
    5a5c:	f8 94       	cli
    5a5e:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    5a60:	80 91 66 06 	lds	r24, 0x0666
    5a64:	e9 81       	ldd	r30, Y+1	; 0x01
    5a66:	fa 81       	ldd	r31, Y+2	; 0x02
    5a68:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    5a6a:	80 91 60 06 	lds	r24, 0x0660
    5a6e:	90 91 61 06 	lds	r25, 0x0661
    5a72:	e9 81       	ldd	r30, Y+1	; 0x01
    5a74:	fa 81       	ldd	r31, Y+2	; 0x02
    5a76:	92 83       	std	Z+2, r25	; 0x02
    5a78:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5a7a:	0f 90       	pop	r0
    5a7c:	0f be       	out	0x3f, r0	; 63
}
    5a7e:	0f 90       	pop	r0
    5a80:	0f 90       	pop	r0
    5a82:	cf 91       	pop	r28
    5a84:	df 91       	pop	r29
    5a86:	08 95       	ret

00005a88 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5a88:	df 93       	push	r29
    5a8a:	cf 93       	push	r28
    5a8c:	00 d0       	rcall	.+0      	; 0x5a8e <vTaskInternalSetTimeOutState+0x6>
    5a8e:	cd b7       	in	r28, 0x3d	; 61
    5a90:	de b7       	in	r29, 0x3e	; 62
    5a92:	9a 83       	std	Y+2, r25	; 0x02
    5a94:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5a96:	80 91 66 06 	lds	r24, 0x0666
    5a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a9e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5aa0:	80 91 60 06 	lds	r24, 0x0660
    5aa4:	90 91 61 06 	lds	r25, 0x0661
    5aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    5aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    5aac:	92 83       	std	Z+2, r25	; 0x02
    5aae:	81 83       	std	Z+1, r24	; 0x01
}
    5ab0:	0f 90       	pop	r0
    5ab2:	0f 90       	pop	r0
    5ab4:	cf 91       	pop	r28
    5ab6:	df 91       	pop	r29
    5ab8:	08 95       	ret

00005aba <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5aba:	df 93       	push	r29
    5abc:	cf 93       	push	r28
    5abe:	cd b7       	in	r28, 0x3d	; 61
    5ac0:	de b7       	in	r29, 0x3e	; 62
    5ac2:	29 97       	sbiw	r28, 0x09	; 9
    5ac4:	0f b6       	in	r0, 0x3f	; 63
    5ac6:	f8 94       	cli
    5ac8:	de bf       	out	0x3e, r29	; 62
    5aca:	0f be       	out	0x3f, r0	; 63
    5acc:	cd bf       	out	0x3d, r28	; 61
    5ace:	9f 83       	std	Y+7, r25	; 0x07
    5ad0:	8e 83       	std	Y+6, r24	; 0x06
    5ad2:	79 87       	std	Y+9, r23	; 0x09
    5ad4:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5ad6:	0f b6       	in	r0, 0x3f	; 63
    5ad8:	f8 94       	cli
    5ada:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5adc:	80 91 60 06 	lds	r24, 0x0660
    5ae0:	90 91 61 06 	lds	r25, 0x0661
    5ae4:	9c 83       	std	Y+4, r25	; 0x04
    5ae6:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5ae8:	ee 81       	ldd	r30, Y+6	; 0x06
    5aea:	ff 81       	ldd	r31, Y+7	; 0x07
    5aec:	21 81       	ldd	r18, Z+1	; 0x01
    5aee:	32 81       	ldd	r19, Z+2	; 0x02
    5af0:	8b 81       	ldd	r24, Y+3	; 0x03
    5af2:	9c 81       	ldd	r25, Y+4	; 0x04
    5af4:	82 1b       	sub	r24, r18
    5af6:	93 0b       	sbc	r25, r19
    5af8:	9a 83       	std	Y+2, r25	; 0x02
    5afa:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    5afc:	e8 85       	ldd	r30, Y+8	; 0x08
    5afe:	f9 85       	ldd	r31, Y+9	; 0x09
    5b00:	80 81       	ld	r24, Z
    5b02:	91 81       	ldd	r25, Z+1	; 0x01
    5b04:	2f ef       	ldi	r18, 0xFF	; 255
    5b06:	8f 3f       	cpi	r24, 0xFF	; 255
    5b08:	92 07       	cpc	r25, r18
    5b0a:	11 f4       	brne	.+4      	; 0x5b10 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5b0c:	1d 82       	std	Y+5, r1	; 0x05
    5b0e:	36 c0       	rjmp	.+108    	; 0x5b7c <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5b10:	ee 81       	ldd	r30, Y+6	; 0x06
    5b12:	ff 81       	ldd	r31, Y+7	; 0x07
    5b14:	90 81       	ld	r25, Z
    5b16:	80 91 66 06 	lds	r24, 0x0666
    5b1a:	98 17       	cp	r25, r24
    5b1c:	61 f0       	breq	.+24     	; 0x5b36 <xTaskCheckForTimeOut+0x7c>
    5b1e:	ee 81       	ldd	r30, Y+6	; 0x06
    5b20:	ff 81       	ldd	r31, Y+7	; 0x07
    5b22:	21 81       	ldd	r18, Z+1	; 0x01
    5b24:	32 81       	ldd	r19, Z+2	; 0x02
    5b26:	8b 81       	ldd	r24, Y+3	; 0x03
    5b28:	9c 81       	ldd	r25, Y+4	; 0x04
    5b2a:	82 17       	cp	r24, r18
    5b2c:	93 07       	cpc	r25, r19
    5b2e:	18 f0       	brcs	.+6      	; 0x5b36 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    5b30:	81 e0       	ldi	r24, 0x01	; 1
    5b32:	8d 83       	std	Y+5, r24	; 0x05
    5b34:	23 c0       	rjmp	.+70     	; 0x5b7c <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5b36:	e8 85       	ldd	r30, Y+8	; 0x08
    5b38:	f9 85       	ldd	r31, Y+9	; 0x09
    5b3a:	20 81       	ld	r18, Z
    5b3c:	31 81       	ldd	r19, Z+1	; 0x01
    5b3e:	89 81       	ldd	r24, Y+1	; 0x01
    5b40:	9a 81       	ldd	r25, Y+2	; 0x02
    5b42:	82 17       	cp	r24, r18
    5b44:	93 07       	cpc	r25, r19
    5b46:	a0 f4       	brcc	.+40     	; 0x5b70 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    5b48:	e8 85       	ldd	r30, Y+8	; 0x08
    5b4a:	f9 85       	ldd	r31, Y+9	; 0x09
    5b4c:	20 81       	ld	r18, Z
    5b4e:	31 81       	ldd	r19, Z+1	; 0x01
    5b50:	89 81       	ldd	r24, Y+1	; 0x01
    5b52:	9a 81       	ldd	r25, Y+2	; 0x02
    5b54:	a9 01       	movw	r20, r18
    5b56:	48 1b       	sub	r20, r24
    5b58:	59 0b       	sbc	r21, r25
    5b5a:	ca 01       	movw	r24, r20
    5b5c:	e8 85       	ldd	r30, Y+8	; 0x08
    5b5e:	f9 85       	ldd	r31, Y+9	; 0x09
    5b60:	91 83       	std	Z+1, r25	; 0x01
    5b62:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    5b64:	8e 81       	ldd	r24, Y+6	; 0x06
    5b66:	9f 81       	ldd	r25, Y+7	; 0x07
    5b68:	0e 94 44 2d 	call	0x5a88	; 0x5a88 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    5b6c:	1d 82       	std	Y+5, r1	; 0x05
    5b6e:	06 c0       	rjmp	.+12     	; 0x5b7c <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    5b70:	e8 85       	ldd	r30, Y+8	; 0x08
    5b72:	f9 85       	ldd	r31, Y+9	; 0x09
    5b74:	11 82       	std	Z+1, r1	; 0x01
    5b76:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    5b78:	81 e0       	ldi	r24, 0x01	; 1
    5b7a:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    5b7c:	0f 90       	pop	r0
    5b7e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5b80:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5b82:	29 96       	adiw	r28, 0x09	; 9
    5b84:	0f b6       	in	r0, 0x3f	; 63
    5b86:	f8 94       	cli
    5b88:	de bf       	out	0x3e, r29	; 62
    5b8a:	0f be       	out	0x3f, r0	; 63
    5b8c:	cd bf       	out	0x3d, r28	; 61
    5b8e:	cf 91       	pop	r28
    5b90:	df 91       	pop	r29
    5b92:	08 95       	ret

00005b94 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5b94:	df 93       	push	r29
    5b96:	cf 93       	push	r28
    5b98:	cd b7       	in	r28, 0x3d	; 61
    5b9a:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5b9c:	81 e0       	ldi	r24, 0x01	; 1
    5b9e:	80 93 65 06 	sts	0x0665, r24
}
    5ba2:	cf 91       	pop	r28
    5ba4:	df 91       	pop	r29
    5ba6:	08 95       	ret

00005ba8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5ba8:	df 93       	push	r29
    5baa:	cf 93       	push	r28
    5bac:	00 d0       	rcall	.+0      	; 0x5bae <prvIdleTask+0x6>
    5bae:	cd b7       	in	r28, 0x3d	; 61
    5bb0:	de b7       	in	r29, 0x3e	; 62
    5bb2:	9a 83       	std	Y+2, r25	; 0x02
    5bb4:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    5bb6:	0e 94 1f 2e 	call	0x5c3e	; 0x5c3e <prvCheckTasksWaitingTermination>
    5bba:	fd cf       	rjmp	.-6      	; 0x5bb6 <prvIdleTask+0xe>

00005bbc <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5bbc:	df 93       	push	r29
    5bbe:	cf 93       	push	r28
    5bc0:	0f 92       	push	r0
    5bc2:	cd b7       	in	r28, 0x3d	; 61
    5bc4:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5bc6:	19 82       	std	Y+1, r1	; 0x01
    5bc8:	13 c0       	rjmp	.+38     	; 0x5bf0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5bca:	89 81       	ldd	r24, Y+1	; 0x01
    5bcc:	28 2f       	mov	r18, r24
    5bce:	30 e0       	ldi	r19, 0x00	; 0
    5bd0:	c9 01       	movw	r24, r18
    5bd2:	88 0f       	add	r24, r24
    5bd4:	99 1f       	adc	r25, r25
    5bd6:	88 0f       	add	r24, r24
    5bd8:	99 1f       	adc	r25, r25
    5bda:	88 0f       	add	r24, r24
    5bdc:	99 1f       	adc	r25, r25
    5bde:	82 0f       	add	r24, r18
    5be0:	93 1f       	adc	r25, r19
    5be2:	83 59       	subi	r24, 0x93	; 147
    5be4:	99 4f       	sbci	r25, 0xF9	; 249
    5be6:	0e 94 cb 11 	call	0x2396	; 0x2396 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5bea:	89 81       	ldd	r24, Y+1	; 0x01
    5bec:	8f 5f       	subi	r24, 0xFF	; 255
    5bee:	89 83       	std	Y+1, r24	; 0x01
    5bf0:	89 81       	ldd	r24, Y+1	; 0x01
    5bf2:	84 30       	cpi	r24, 0x04	; 4
    5bf4:	50 f3       	brcs	.-44     	; 0x5bca <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5bf6:	81 e9       	ldi	r24, 0x91	; 145
    5bf8:	96 e0       	ldi	r25, 0x06	; 6
    5bfa:	0e 94 cb 11 	call	0x2396	; 0x2396 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5bfe:	8a e9       	ldi	r24, 0x9A	; 154
    5c00:	96 e0       	ldi	r25, 0x06	; 6
    5c02:	0e 94 cb 11 	call	0x2396	; 0x2396 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5c06:	87 ea       	ldi	r24, 0xA7	; 167
    5c08:	96 e0       	ldi	r25, 0x06	; 6
    5c0a:	0e 94 cb 11 	call	0x2396	; 0x2396 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    5c0e:	80 eb       	ldi	r24, 0xB0	; 176
    5c10:	96 e0       	ldi	r25, 0x06	; 6
    5c12:	0e 94 cb 11 	call	0x2396	; 0x2396 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    5c16:	89 eb       	ldi	r24, 0xB9	; 185
    5c18:	96 e0       	ldi	r25, 0x06	; 6
    5c1a:	0e 94 cb 11 	call	0x2396	; 0x2396 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5c1e:	81 e9       	ldi	r24, 0x91	; 145
    5c20:	96 e0       	ldi	r25, 0x06	; 6
    5c22:	90 93 a4 06 	sts	0x06A4, r25
    5c26:	80 93 a3 06 	sts	0x06A3, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5c2a:	8a e9       	ldi	r24, 0x9A	; 154
    5c2c:	96 e0       	ldi	r25, 0x06	; 6
    5c2e:	90 93 a6 06 	sts	0x06A6, r25
    5c32:	80 93 a5 06 	sts	0x06A5, r24
}
    5c36:	0f 90       	pop	r0
    5c38:	cf 91       	pop	r28
    5c3a:	df 91       	pop	r29
    5c3c:	08 95       	ret

00005c3e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5c3e:	df 93       	push	r29
    5c40:	cf 93       	push	r28
    5c42:	00 d0       	rcall	.+0      	; 0x5c44 <prvCheckTasksWaitingTermination+0x6>
    5c44:	cd b7       	in	r28, 0x3d	; 61
    5c46:	de b7       	in	r29, 0x3e	; 62
    5c48:	20 c0       	rjmp	.+64     	; 0x5c8a <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    5c4a:	0f b6       	in	r0, 0x3f	; 63
    5c4c:	f8 94       	cli
    5c4e:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5c50:	e0 91 b5 06 	lds	r30, 0x06B5
    5c54:	f0 91 b6 06 	lds	r31, 0x06B6
    5c58:	86 81       	ldd	r24, Z+6	; 0x06
    5c5a:	97 81       	ldd	r25, Z+7	; 0x07
    5c5c:	9a 83       	std	Y+2, r25	; 0x02
    5c5e:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5c60:	89 81       	ldd	r24, Y+1	; 0x01
    5c62:	9a 81       	ldd	r25, Y+2	; 0x02
    5c64:	02 96       	adiw	r24, 0x02	; 2
    5c66:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
				--uxCurrentNumberOfTasks;
    5c6a:	80 91 5f 06 	lds	r24, 0x065F
    5c6e:	81 50       	subi	r24, 0x01	; 1
    5c70:	80 93 5f 06 	sts	0x065F, r24
				--uxDeletedTasksWaitingCleanUp;
    5c74:	80 91 5e 06 	lds	r24, 0x065E
    5c78:	81 50       	subi	r24, 0x01	; 1
    5c7a:	80 93 5e 06 	sts	0x065E, r24
			}
			taskEXIT_CRITICAL();
    5c7e:	0f 90       	pop	r0
    5c80:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    5c82:	89 81       	ldd	r24, Y+1	; 0x01
    5c84:	9a 81       	ldd	r25, Y+2	; 0x02
    5c86:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5c8a:	80 91 5e 06 	lds	r24, 0x065E
    5c8e:	88 23       	and	r24, r24
    5c90:	e1 f6       	brne	.-72     	; 0x5c4a <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    5c92:	0f 90       	pop	r0
    5c94:	0f 90       	pop	r0
    5c96:	cf 91       	pop	r28
    5c98:	df 91       	pop	r29
    5c9a:	08 95       	ret

00005c9c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    5c9c:	df 93       	push	r29
    5c9e:	cf 93       	push	r28
    5ca0:	00 d0       	rcall	.+0      	; 0x5ca2 <prvDeleteTCB+0x6>
    5ca2:	cd b7       	in	r28, 0x3d	; 61
    5ca4:	de b7       	in	r29, 0x3e	; 62
    5ca6:	9a 83       	std	Y+2, r25	; 0x02
    5ca8:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    5caa:	e9 81       	ldd	r30, Y+1	; 0x01
    5cac:	fa 81       	ldd	r31, Y+2	; 0x02
    5cae:	87 89       	ldd	r24, Z+23	; 0x17
    5cb0:	90 8d       	ldd	r25, Z+24	; 0x18
    5cb2:	0e 94 a5 11 	call	0x234a	; 0x234a <vPortFree>
			vPortFree( pxTCB );
    5cb6:	89 81       	ldd	r24, Y+1	; 0x01
    5cb8:	9a 81       	ldd	r25, Y+2	; 0x02
    5cba:	0e 94 a5 11 	call	0x234a	; 0x234a <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    5cbe:	0f 90       	pop	r0
    5cc0:	0f 90       	pop	r0
    5cc2:	cf 91       	pop	r28
    5cc4:	df 91       	pop	r29
    5cc6:	08 95       	ret

00005cc8 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5cc8:	df 93       	push	r29
    5cca:	cf 93       	push	r28
    5ccc:	00 d0       	rcall	.+0      	; 0x5cce <prvResetNextTaskUnblockTime+0x6>
    5cce:	cd b7       	in	r28, 0x3d	; 61
    5cd0:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5cd2:	e0 91 a3 06 	lds	r30, 0x06A3
    5cd6:	f0 91 a4 06 	lds	r31, 0x06A4
    5cda:	80 81       	ld	r24, Z
    5cdc:	88 23       	and	r24, r24
    5cde:	39 f4       	brne	.+14     	; 0x5cee <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    5ce0:	8f ef       	ldi	r24, 0xFF	; 255
    5ce2:	9f ef       	ldi	r25, 0xFF	; 255
    5ce4:	90 93 69 06 	sts	0x0669, r25
    5ce8:	80 93 68 06 	sts	0x0668, r24
    5cec:	13 c0       	rjmp	.+38     	; 0x5d14 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5cee:	e0 91 a3 06 	lds	r30, 0x06A3
    5cf2:	f0 91 a4 06 	lds	r31, 0x06A4
    5cf6:	05 80       	ldd	r0, Z+5	; 0x05
    5cf8:	f6 81       	ldd	r31, Z+6	; 0x06
    5cfa:	e0 2d       	mov	r30, r0
    5cfc:	86 81       	ldd	r24, Z+6	; 0x06
    5cfe:	97 81       	ldd	r25, Z+7	; 0x07
    5d00:	9a 83       	std	Y+2, r25	; 0x02
    5d02:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    5d04:	e9 81       	ldd	r30, Y+1	; 0x01
    5d06:	fa 81       	ldd	r31, Y+2	; 0x02
    5d08:	82 81       	ldd	r24, Z+2	; 0x02
    5d0a:	93 81       	ldd	r25, Z+3	; 0x03
    5d0c:	90 93 69 06 	sts	0x0669, r25
    5d10:	80 93 68 06 	sts	0x0668, r24
	}
}
    5d14:	0f 90       	pop	r0
    5d16:	0f 90       	pop	r0
    5d18:	cf 91       	pop	r28
    5d1a:	df 91       	pop	r29
    5d1c:	08 95       	ret

00005d1e <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    5d1e:	df 93       	push	r29
    5d20:	cf 93       	push	r28
    5d22:	00 d0       	rcall	.+0      	; 0x5d24 <xTaskGetCurrentTaskHandle+0x6>
    5d24:	cd b7       	in	r28, 0x3d	; 61
    5d26:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    5d28:	80 91 5c 06 	lds	r24, 0x065C
    5d2c:	90 91 5d 06 	lds	r25, 0x065D
    5d30:	9a 83       	std	Y+2, r25	; 0x02
    5d32:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    5d34:	89 81       	ldd	r24, Y+1	; 0x01
    5d36:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    5d38:	0f 90       	pop	r0
    5d3a:	0f 90       	pop	r0
    5d3c:	cf 91       	pop	r28
    5d3e:	df 91       	pop	r29
    5d40:	08 95       	ret

00005d42 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5d42:	df 93       	push	r29
    5d44:	cf 93       	push	r28
    5d46:	00 d0       	rcall	.+0      	; 0x5d48 <uxTaskResetEventItemValue+0x6>
    5d48:	cd b7       	in	r28, 0x3d	; 61
    5d4a:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5d4c:	e0 91 5c 06 	lds	r30, 0x065C
    5d50:	f0 91 5d 06 	lds	r31, 0x065D
    5d54:	84 85       	ldd	r24, Z+12	; 0x0c
    5d56:	95 85       	ldd	r25, Z+13	; 0x0d
    5d58:	9a 83       	std	Y+2, r25	; 0x02
    5d5a:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5d5c:	a0 91 5c 06 	lds	r26, 0x065C
    5d60:	b0 91 5d 06 	lds	r27, 0x065D
    5d64:	e0 91 5c 06 	lds	r30, 0x065C
    5d68:	f0 91 5d 06 	lds	r31, 0x065D
    5d6c:	86 89       	ldd	r24, Z+22	; 0x16
    5d6e:	28 2f       	mov	r18, r24
    5d70:	30 e0       	ldi	r19, 0x00	; 0
    5d72:	84 e0       	ldi	r24, 0x04	; 4
    5d74:	90 e0       	ldi	r25, 0x00	; 0
    5d76:	82 1b       	sub	r24, r18
    5d78:	93 0b       	sbc	r25, r19
    5d7a:	1d 96       	adiw	r26, 0x0d	; 13
    5d7c:	9c 93       	st	X, r25
    5d7e:	8e 93       	st	-X, r24
    5d80:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    5d82:	89 81       	ldd	r24, Y+1	; 0x01
    5d84:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5d86:	0f 90       	pop	r0
    5d88:	0f 90       	pop	r0
    5d8a:	cf 91       	pop	r28
    5d8c:	df 91       	pop	r29
    5d8e:	08 95       	ret

00005d90 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    5d90:	df 93       	push	r29
    5d92:	cf 93       	push	r28
    5d94:	cd b7       	in	r28, 0x3d	; 61
    5d96:	de b7       	in	r29, 0x3e	; 62
    5d98:	27 97       	sbiw	r28, 0x07	; 7
    5d9a:	0f b6       	in	r0, 0x3f	; 63
    5d9c:	f8 94       	cli
    5d9e:	de bf       	out	0x3e, r29	; 62
    5da0:	0f be       	out	0x3f, r0	; 63
    5da2:	cd bf       	out	0x3d, r28	; 61
    5da4:	8d 83       	std	Y+5, r24	; 0x05
    5da6:	7f 83       	std	Y+7, r23	; 0x07
    5da8:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    5daa:	0f b6       	in	r0, 0x3f	; 63
    5dac:	f8 94       	cli
    5dae:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    5db0:	e0 91 5c 06 	lds	r30, 0x065C
    5db4:	f0 91 5d 06 	lds	r31, 0x065D
    5db8:	81 a1       	ldd	r24, Z+33	; 0x21
    5dba:	92 a1       	ldd	r25, Z+34	; 0x22
    5dbc:	a3 a1       	ldd	r26, Z+35	; 0x23
    5dbe:	b4 a1       	ldd	r27, Z+36	; 0x24
    5dc0:	00 97       	sbiw	r24, 0x00	; 0
    5dc2:	a1 05       	cpc	r26, r1
    5dc4:	b1 05       	cpc	r27, r1
    5dc6:	89 f4       	brne	.+34     	; 0x5dea <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5dc8:	e0 91 5c 06 	lds	r30, 0x065C
    5dcc:	f0 91 5d 06 	lds	r31, 0x065D
    5dd0:	81 e0       	ldi	r24, 0x01	; 1
    5dd2:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    5dd4:	8e 81       	ldd	r24, Y+6	; 0x06
    5dd6:	9f 81       	ldd	r25, Y+7	; 0x07
    5dd8:	00 97       	sbiw	r24, 0x00	; 0
    5dda:	39 f0       	breq	.+14     	; 0x5dea <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5ddc:	8e 81       	ldd	r24, Y+6	; 0x06
    5dde:	9f 81       	ldd	r25, Y+7	; 0x07
    5de0:	61 e0       	ldi	r22, 0x01	; 1
    5de2:	0e 94 70 32 	call	0x64e0	; 0x64e0 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5de6:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5dea:	0f 90       	pop	r0
    5dec:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5dee:	0f b6       	in	r0, 0x3f	; 63
    5df0:	f8 94       	cli
    5df2:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5df4:	e0 91 5c 06 	lds	r30, 0x065C
    5df8:	f0 91 5d 06 	lds	r31, 0x065D
    5dfc:	81 a1       	ldd	r24, Z+33	; 0x21
    5dfe:	92 a1       	ldd	r25, Z+34	; 0x22
    5e00:	a3 a1       	ldd	r26, Z+35	; 0x23
    5e02:	b4 a1       	ldd	r27, Z+36	; 0x24
    5e04:	89 83       	std	Y+1, r24	; 0x01
    5e06:	9a 83       	std	Y+2, r25	; 0x02
    5e08:	ab 83       	std	Y+3, r26	; 0x03
    5e0a:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5e0c:	89 81       	ldd	r24, Y+1	; 0x01
    5e0e:	9a 81       	ldd	r25, Y+2	; 0x02
    5e10:	ab 81       	ldd	r26, Y+3	; 0x03
    5e12:	bc 81       	ldd	r27, Y+4	; 0x04
    5e14:	00 97       	sbiw	r24, 0x00	; 0
    5e16:	a1 05       	cpc	r26, r1
    5e18:	b1 05       	cpc	r27, r1
    5e1a:	d9 f0       	breq	.+54     	; 0x5e52 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    5e1c:	8d 81       	ldd	r24, Y+5	; 0x05
    5e1e:	88 23       	and	r24, r24
    5e20:	49 f0       	breq	.+18     	; 0x5e34 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    5e22:	e0 91 5c 06 	lds	r30, 0x065C
    5e26:	f0 91 5d 06 	lds	r31, 0x065D
    5e2a:	11 a2       	std	Z+33, r1	; 0x21
    5e2c:	12 a2       	std	Z+34, r1	; 0x22
    5e2e:	13 a2       	std	Z+35, r1	; 0x23
    5e30:	14 a2       	std	Z+36, r1	; 0x24
    5e32:	0f c0       	rjmp	.+30     	; 0x5e52 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    5e34:	e0 91 5c 06 	lds	r30, 0x065C
    5e38:	f0 91 5d 06 	lds	r31, 0x065D
    5e3c:	89 81       	ldd	r24, Y+1	; 0x01
    5e3e:	9a 81       	ldd	r25, Y+2	; 0x02
    5e40:	ab 81       	ldd	r26, Y+3	; 0x03
    5e42:	bc 81       	ldd	r27, Y+4	; 0x04
    5e44:	01 97       	sbiw	r24, 0x01	; 1
    5e46:	a1 09       	sbc	r26, r1
    5e48:	b1 09       	sbc	r27, r1
    5e4a:	81 a3       	std	Z+33, r24	; 0x21
    5e4c:	92 a3       	std	Z+34, r25	; 0x22
    5e4e:	a3 a3       	std	Z+35, r26	; 0x23
    5e50:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5e52:	e0 91 5c 06 	lds	r30, 0x065C
    5e56:	f0 91 5d 06 	lds	r31, 0x065D
    5e5a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    5e5c:	0f 90       	pop	r0
    5e5e:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    5e60:	89 81       	ldd	r24, Y+1	; 0x01
    5e62:	9a 81       	ldd	r25, Y+2	; 0x02
    5e64:	ab 81       	ldd	r26, Y+3	; 0x03
    5e66:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    5e68:	bc 01       	movw	r22, r24
    5e6a:	cd 01       	movw	r24, r26
    5e6c:	27 96       	adiw	r28, 0x07	; 7
    5e6e:	0f b6       	in	r0, 0x3f	; 63
    5e70:	f8 94       	cli
    5e72:	de bf       	out	0x3e, r29	; 62
    5e74:	0f be       	out	0x3f, r0	; 63
    5e76:	cd bf       	out	0x3d, r28	; 61
    5e78:	cf 91       	pop	r28
    5e7a:	df 91       	pop	r29
    5e7c:	08 95       	ret

00005e7e <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    5e7e:	ef 92       	push	r14
    5e80:	ff 92       	push	r15
    5e82:	0f 93       	push	r16
    5e84:	1f 93       	push	r17
    5e86:	df 93       	push	r29
    5e88:	cf 93       	push	r28
    5e8a:	cd b7       	in	r28, 0x3d	; 61
    5e8c:	de b7       	in	r29, 0x3e	; 62
    5e8e:	2d 97       	sbiw	r28, 0x0d	; 13
    5e90:	0f b6       	in	r0, 0x3f	; 63
    5e92:	f8 94       	cli
    5e94:	de bf       	out	0x3e, r29	; 62
    5e96:	0f be       	out	0x3f, r0	; 63
    5e98:	cd bf       	out	0x3d, r28	; 61
    5e9a:	6a 83       	std	Y+2, r22	; 0x02
    5e9c:	7b 83       	std	Y+3, r23	; 0x03
    5e9e:	8c 83       	std	Y+4, r24	; 0x04
    5ea0:	9d 83       	std	Y+5, r25	; 0x05
    5ea2:	2e 83       	std	Y+6, r18	; 0x06
    5ea4:	3f 83       	std	Y+7, r19	; 0x07
    5ea6:	48 87       	std	Y+8, r20	; 0x08
    5ea8:	59 87       	std	Y+9, r21	; 0x09
    5eaa:	1b 87       	std	Y+11, r17	; 0x0b
    5eac:	0a 87       	std	Y+10, r16	; 0x0a
    5eae:	fd 86       	std	Y+13, r15	; 0x0d
    5eb0:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    5eb2:	0f b6       	in	r0, 0x3f	; 63
    5eb4:	f8 94       	cli
    5eb6:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5eb8:	e0 91 5c 06 	lds	r30, 0x065C
    5ebc:	f0 91 5d 06 	lds	r31, 0x065D
    5ec0:	85 a1       	ldd	r24, Z+37	; 0x25
    5ec2:	82 30       	cpi	r24, 0x02	; 2
    5ec4:	49 f1       	breq	.+82     	; 0x5f18 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5ec6:	e0 91 5c 06 	lds	r30, 0x065C
    5eca:	f0 91 5d 06 	lds	r31, 0x065D
    5ece:	21 a1       	ldd	r18, Z+33	; 0x21
    5ed0:	32 a1       	ldd	r19, Z+34	; 0x22
    5ed2:	43 a1       	ldd	r20, Z+35	; 0x23
    5ed4:	54 a1       	ldd	r21, Z+36	; 0x24
    5ed6:	8a 81       	ldd	r24, Y+2	; 0x02
    5ed8:	9b 81       	ldd	r25, Y+3	; 0x03
    5eda:	ac 81       	ldd	r26, Y+4	; 0x04
    5edc:	bd 81       	ldd	r27, Y+5	; 0x05
    5ede:	80 95       	com	r24
    5ee0:	90 95       	com	r25
    5ee2:	a0 95       	com	r26
    5ee4:	b0 95       	com	r27
    5ee6:	82 23       	and	r24, r18
    5ee8:	93 23       	and	r25, r19
    5eea:	a4 23       	and	r26, r20
    5eec:	b5 23       	and	r27, r21
    5eee:	81 a3       	std	Z+33, r24	; 0x21
    5ef0:	92 a3       	std	Z+34, r25	; 0x22
    5ef2:	a3 a3       	std	Z+35, r26	; 0x23
    5ef4:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5ef6:	e0 91 5c 06 	lds	r30, 0x065C
    5efa:	f0 91 5d 06 	lds	r31, 0x065D
    5efe:	81 e0       	ldi	r24, 0x01	; 1
    5f00:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    5f02:	8c 85       	ldd	r24, Y+12	; 0x0c
    5f04:	9d 85       	ldd	r25, Y+13	; 0x0d
    5f06:	00 97       	sbiw	r24, 0x00	; 0
    5f08:	39 f0       	breq	.+14     	; 0x5f18 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5f0a:	8c 85       	ldd	r24, Y+12	; 0x0c
    5f0c:	9d 85       	ldd	r25, Y+13	; 0x0d
    5f0e:	61 e0       	ldi	r22, 0x01	; 1
    5f10:	0e 94 70 32 	call	0x64e0	; 0x64e0 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5f14:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5f18:	0f 90       	pop	r0
    5f1a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5f1c:	0f b6       	in	r0, 0x3f	; 63
    5f1e:	f8 94       	cli
    5f20:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    5f22:	8a 85       	ldd	r24, Y+10	; 0x0a
    5f24:	9b 85       	ldd	r25, Y+11	; 0x0b
    5f26:	00 97       	sbiw	r24, 0x00	; 0
    5f28:	71 f0       	breq	.+28     	; 0x5f46 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    5f2a:	e0 91 5c 06 	lds	r30, 0x065C
    5f2e:	f0 91 5d 06 	lds	r31, 0x065D
    5f32:	81 a1       	ldd	r24, Z+33	; 0x21
    5f34:	92 a1       	ldd	r25, Z+34	; 0x22
    5f36:	a3 a1       	ldd	r26, Z+35	; 0x23
    5f38:	b4 a1       	ldd	r27, Z+36	; 0x24
    5f3a:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f3c:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f3e:	80 83       	st	Z, r24
    5f40:	91 83       	std	Z+1, r25	; 0x01
    5f42:	a2 83       	std	Z+2, r26	; 0x02
    5f44:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5f46:	e0 91 5c 06 	lds	r30, 0x065C
    5f4a:	f0 91 5d 06 	lds	r31, 0x065D
    5f4e:	85 a1       	ldd	r24, Z+37	; 0x25
    5f50:	82 30       	cpi	r24, 0x02	; 2
    5f52:	11 f0       	breq	.+4      	; 0x5f58 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    5f54:	19 82       	std	Y+1, r1	; 0x01
    5f56:	1a c0       	rjmp	.+52     	; 0x5f8c <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    5f58:	e0 91 5c 06 	lds	r30, 0x065C
    5f5c:	f0 91 5d 06 	lds	r31, 0x065D
    5f60:	21 a1       	ldd	r18, Z+33	; 0x21
    5f62:	32 a1       	ldd	r19, Z+34	; 0x22
    5f64:	43 a1       	ldd	r20, Z+35	; 0x23
    5f66:	54 a1       	ldd	r21, Z+36	; 0x24
    5f68:	8e 81       	ldd	r24, Y+6	; 0x06
    5f6a:	9f 81       	ldd	r25, Y+7	; 0x07
    5f6c:	a8 85       	ldd	r26, Y+8	; 0x08
    5f6e:	b9 85       	ldd	r27, Y+9	; 0x09
    5f70:	80 95       	com	r24
    5f72:	90 95       	com	r25
    5f74:	a0 95       	com	r26
    5f76:	b0 95       	com	r27
    5f78:	82 23       	and	r24, r18
    5f7a:	93 23       	and	r25, r19
    5f7c:	a4 23       	and	r26, r20
    5f7e:	b5 23       	and	r27, r21
    5f80:	81 a3       	std	Z+33, r24	; 0x21
    5f82:	92 a3       	std	Z+34, r25	; 0x22
    5f84:	a3 a3       	std	Z+35, r26	; 0x23
    5f86:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    5f88:	81 e0       	ldi	r24, 0x01	; 1
    5f8a:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5f8c:	e0 91 5c 06 	lds	r30, 0x065C
    5f90:	f0 91 5d 06 	lds	r31, 0x065D
    5f94:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    5f96:	0f 90       	pop	r0
    5f98:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5f9a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5f9c:	2d 96       	adiw	r28, 0x0d	; 13
    5f9e:	0f b6       	in	r0, 0x3f	; 63
    5fa0:	f8 94       	cli
    5fa2:	de bf       	out	0x3e, r29	; 62
    5fa4:	0f be       	out	0x3f, r0	; 63
    5fa6:	cd bf       	out	0x3d, r28	; 61
    5fa8:	cf 91       	pop	r28
    5faa:	df 91       	pop	r29
    5fac:	1f 91       	pop	r17
    5fae:	0f 91       	pop	r16
    5fb0:	ff 90       	pop	r15
    5fb2:	ef 90       	pop	r14
    5fb4:	08 95       	ret

00005fb6 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5fb6:	0f 93       	push	r16
    5fb8:	1f 93       	push	r17
    5fba:	df 93       	push	r29
    5fbc:	cf 93       	push	r28
    5fbe:	cd b7       	in	r28, 0x3d	; 61
    5fc0:	de b7       	in	r29, 0x3e	; 62
    5fc2:	2f 97       	sbiw	r28, 0x0f	; 15
    5fc4:	0f b6       	in	r0, 0x3f	; 63
    5fc6:	f8 94       	cli
    5fc8:	de bf       	out	0x3e, r29	; 62
    5fca:	0f be       	out	0x3f, r0	; 63
    5fcc:	cd bf       	out	0x3d, r28	; 61
    5fce:	9e 83       	std	Y+6, r25	; 0x06
    5fd0:	8d 83       	std	Y+5, r24	; 0x05
    5fd2:	4f 83       	std	Y+7, r20	; 0x07
    5fd4:	58 87       	std	Y+8, r21	; 0x08
    5fd6:	69 87       	std	Y+9, r22	; 0x09
    5fd8:	7a 87       	std	Y+10, r23	; 0x0a
    5fda:	2b 87       	std	Y+11, r18	; 0x0b
    5fdc:	1d 87       	std	Y+13, r17	; 0x0d
    5fde:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    5fe0:	81 e0       	ldi	r24, 0x01	; 1
    5fe2:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    5fe4:	8d 81       	ldd	r24, Y+5	; 0x05
    5fe6:	9e 81       	ldd	r25, Y+6	; 0x06
    5fe8:	9c 83       	std	Y+4, r25	; 0x04
    5fea:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    5fec:	0f b6       	in	r0, 0x3f	; 63
    5fee:	f8 94       	cli
    5ff0:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    5ff2:	8c 85       	ldd	r24, Y+12	; 0x0c
    5ff4:	9d 85       	ldd	r25, Y+13	; 0x0d
    5ff6:	00 97       	sbiw	r24, 0x00	; 0
    5ff8:	61 f0       	breq	.+24     	; 0x6012 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5ffa:	eb 81       	ldd	r30, Y+3	; 0x03
    5ffc:	fc 81       	ldd	r31, Y+4	; 0x04
    5ffe:	81 a1       	ldd	r24, Z+33	; 0x21
    6000:	92 a1       	ldd	r25, Z+34	; 0x22
    6002:	a3 a1       	ldd	r26, Z+35	; 0x23
    6004:	b4 a1       	ldd	r27, Z+36	; 0x24
    6006:	ec 85       	ldd	r30, Y+12	; 0x0c
    6008:	fd 85       	ldd	r31, Y+13	; 0x0d
    600a:	80 83       	st	Z, r24
    600c:	91 83       	std	Z+1, r25	; 0x01
    600e:	a2 83       	std	Z+2, r26	; 0x02
    6010:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    6012:	eb 81       	ldd	r30, Y+3	; 0x03
    6014:	fc 81       	ldd	r31, Y+4	; 0x04
    6016:	85 a1       	ldd	r24, Z+37	; 0x25
    6018:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    601a:	eb 81       	ldd	r30, Y+3	; 0x03
    601c:	fc 81       	ldd	r31, Y+4	; 0x04
    601e:	82 e0       	ldi	r24, 0x02	; 2
    6020:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    6022:	8b 85       	ldd	r24, Y+11	; 0x0b
    6024:	28 2f       	mov	r18, r24
    6026:	30 e0       	ldi	r19, 0x00	; 0
    6028:	3f 87       	std	Y+15, r19	; 0x0f
    602a:	2e 87       	std	Y+14, r18	; 0x0e
    602c:	8e 85       	ldd	r24, Y+14	; 0x0e
    602e:	9f 85       	ldd	r25, Y+15	; 0x0f
    6030:	82 30       	cpi	r24, 0x02	; 2
    6032:	91 05       	cpc	r25, r1
    6034:	59 f1       	breq	.+86     	; 0x608c <xTaskGenericNotify+0xd6>
    6036:	2e 85       	ldd	r18, Y+14	; 0x0e
    6038:	3f 85       	ldd	r19, Y+15	; 0x0f
    603a:	23 30       	cpi	r18, 0x03	; 3
    603c:	31 05       	cpc	r19, r1
    603e:	34 f4       	brge	.+12     	; 0x604c <xTaskGenericNotify+0x96>
    6040:	8e 85       	ldd	r24, Y+14	; 0x0e
    6042:	9f 85       	ldd	r25, Y+15	; 0x0f
    6044:	81 30       	cpi	r24, 0x01	; 1
    6046:	91 05       	cpc	r25, r1
    6048:	61 f0       	breq	.+24     	; 0x6062 <xTaskGenericNotify+0xac>
    604a:	4a c0       	rjmp	.+148    	; 0x60e0 <xTaskGenericNotify+0x12a>
    604c:	2e 85       	ldd	r18, Y+14	; 0x0e
    604e:	3f 85       	ldd	r19, Y+15	; 0x0f
    6050:	23 30       	cpi	r18, 0x03	; 3
    6052:	31 05       	cpc	r19, r1
    6054:	59 f1       	breq	.+86     	; 0x60ac <xTaskGenericNotify+0xf6>
    6056:	8e 85       	ldd	r24, Y+14	; 0x0e
    6058:	9f 85       	ldd	r25, Y+15	; 0x0f
    605a:	84 30       	cpi	r24, 0x04	; 4
    605c:	91 05       	cpc	r25, r1
    605e:	89 f1       	breq	.+98     	; 0x60c2 <xTaskGenericNotify+0x10c>
    6060:	3f c0       	rjmp	.+126    	; 0x60e0 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    6062:	eb 81       	ldd	r30, Y+3	; 0x03
    6064:	fc 81       	ldd	r31, Y+4	; 0x04
    6066:	21 a1       	ldd	r18, Z+33	; 0x21
    6068:	32 a1       	ldd	r19, Z+34	; 0x22
    606a:	43 a1       	ldd	r20, Z+35	; 0x23
    606c:	54 a1       	ldd	r21, Z+36	; 0x24
    606e:	8f 81       	ldd	r24, Y+7	; 0x07
    6070:	98 85       	ldd	r25, Y+8	; 0x08
    6072:	a9 85       	ldd	r26, Y+9	; 0x09
    6074:	ba 85       	ldd	r27, Y+10	; 0x0a
    6076:	82 2b       	or	r24, r18
    6078:	93 2b       	or	r25, r19
    607a:	a4 2b       	or	r26, r20
    607c:	b5 2b       	or	r27, r21
    607e:	eb 81       	ldd	r30, Y+3	; 0x03
    6080:	fc 81       	ldd	r31, Y+4	; 0x04
    6082:	81 a3       	std	Z+33, r24	; 0x21
    6084:	92 a3       	std	Z+34, r25	; 0x22
    6086:	a3 a3       	std	Z+35, r26	; 0x23
    6088:	b4 a3       	std	Z+36, r27	; 0x24
    608a:	2a c0       	rjmp	.+84     	; 0x60e0 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    608c:	eb 81       	ldd	r30, Y+3	; 0x03
    608e:	fc 81       	ldd	r31, Y+4	; 0x04
    6090:	81 a1       	ldd	r24, Z+33	; 0x21
    6092:	92 a1       	ldd	r25, Z+34	; 0x22
    6094:	a3 a1       	ldd	r26, Z+35	; 0x23
    6096:	b4 a1       	ldd	r27, Z+36	; 0x24
    6098:	01 96       	adiw	r24, 0x01	; 1
    609a:	a1 1d       	adc	r26, r1
    609c:	b1 1d       	adc	r27, r1
    609e:	eb 81       	ldd	r30, Y+3	; 0x03
    60a0:	fc 81       	ldd	r31, Y+4	; 0x04
    60a2:	81 a3       	std	Z+33, r24	; 0x21
    60a4:	92 a3       	std	Z+34, r25	; 0x22
    60a6:	a3 a3       	std	Z+35, r26	; 0x23
    60a8:	b4 a3       	std	Z+36, r27	; 0x24
    60aa:	1a c0       	rjmp	.+52     	; 0x60e0 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    60ac:	eb 81       	ldd	r30, Y+3	; 0x03
    60ae:	fc 81       	ldd	r31, Y+4	; 0x04
    60b0:	8f 81       	ldd	r24, Y+7	; 0x07
    60b2:	98 85       	ldd	r25, Y+8	; 0x08
    60b4:	a9 85       	ldd	r26, Y+9	; 0x09
    60b6:	ba 85       	ldd	r27, Y+10	; 0x0a
    60b8:	81 a3       	std	Z+33, r24	; 0x21
    60ba:	92 a3       	std	Z+34, r25	; 0x22
    60bc:	a3 a3       	std	Z+35, r26	; 0x23
    60be:	b4 a3       	std	Z+36, r27	; 0x24
    60c0:	0f c0       	rjmp	.+30     	; 0x60e0 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    60c2:	89 81       	ldd	r24, Y+1	; 0x01
    60c4:	82 30       	cpi	r24, 0x02	; 2
    60c6:	59 f0       	breq	.+22     	; 0x60de <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    60c8:	eb 81       	ldd	r30, Y+3	; 0x03
    60ca:	fc 81       	ldd	r31, Y+4	; 0x04
    60cc:	8f 81       	ldd	r24, Y+7	; 0x07
    60ce:	98 85       	ldd	r25, Y+8	; 0x08
    60d0:	a9 85       	ldd	r26, Y+9	; 0x09
    60d2:	ba 85       	ldd	r27, Y+10	; 0x0a
    60d4:	81 a3       	std	Z+33, r24	; 0x21
    60d6:	92 a3       	std	Z+34, r25	; 0x22
    60d8:	a3 a3       	std	Z+35, r26	; 0x23
    60da:	b4 a3       	std	Z+36, r27	; 0x24
    60dc:	01 c0       	rjmp	.+2      	; 0x60e0 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    60de:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    60e0:	89 81       	ldd	r24, Y+1	; 0x01
    60e2:	81 30       	cpi	r24, 0x01	; 1
    60e4:	b9 f5       	brne	.+110    	; 0x6154 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    60e6:	8b 81       	ldd	r24, Y+3	; 0x03
    60e8:	9c 81       	ldd	r25, Y+4	; 0x04
    60ea:	02 96       	adiw	r24, 0x02	; 2
    60ec:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    60f0:	eb 81       	ldd	r30, Y+3	; 0x03
    60f2:	fc 81       	ldd	r31, Y+4	; 0x04
    60f4:	96 89       	ldd	r25, Z+22	; 0x16
    60f6:	80 91 62 06 	lds	r24, 0x0662
    60fa:	89 17       	cp	r24, r25
    60fc:	28 f4       	brcc	.+10     	; 0x6108 <xTaskGenericNotify+0x152>
    60fe:	eb 81       	ldd	r30, Y+3	; 0x03
    6100:	fc 81       	ldd	r31, Y+4	; 0x04
    6102:	86 89       	ldd	r24, Z+22	; 0x16
    6104:	80 93 62 06 	sts	0x0662, r24
    6108:	eb 81       	ldd	r30, Y+3	; 0x03
    610a:	fc 81       	ldd	r31, Y+4	; 0x04
    610c:	86 89       	ldd	r24, Z+22	; 0x16
    610e:	28 2f       	mov	r18, r24
    6110:	30 e0       	ldi	r19, 0x00	; 0
    6112:	c9 01       	movw	r24, r18
    6114:	88 0f       	add	r24, r24
    6116:	99 1f       	adc	r25, r25
    6118:	88 0f       	add	r24, r24
    611a:	99 1f       	adc	r25, r25
    611c:	88 0f       	add	r24, r24
    611e:	99 1f       	adc	r25, r25
    6120:	82 0f       	add	r24, r18
    6122:	93 1f       	adc	r25, r19
    6124:	ac 01       	movw	r20, r24
    6126:	43 59       	subi	r20, 0x93	; 147
    6128:	59 4f       	sbci	r21, 0xF9	; 249
    612a:	8b 81       	ldd	r24, Y+3	; 0x03
    612c:	9c 81       	ldd	r25, Y+4	; 0x04
    612e:	9c 01       	movw	r18, r24
    6130:	2e 5f       	subi	r18, 0xFE	; 254
    6132:	3f 4f       	sbci	r19, 0xFF	; 255
    6134:	ca 01       	movw	r24, r20
    6136:	b9 01       	movw	r22, r18
    6138:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    613c:	eb 81       	ldd	r30, Y+3	; 0x03
    613e:	fc 81       	ldd	r31, Y+4	; 0x04
    6140:	96 89       	ldd	r25, Z+22	; 0x16
    6142:	e0 91 5c 06 	lds	r30, 0x065C
    6146:	f0 91 5d 06 	lds	r31, 0x065D
    614a:	86 89       	ldd	r24, Z+22	; 0x16
    614c:	89 17       	cp	r24, r25
    614e:	10 f4       	brcc	.+4      	; 0x6154 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    6150:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    6154:	0f 90       	pop	r0
    6156:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    6158:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    615a:	2f 96       	adiw	r28, 0x0f	; 15
    615c:	0f b6       	in	r0, 0x3f	; 63
    615e:	f8 94       	cli
    6160:	de bf       	out	0x3e, r29	; 62
    6162:	0f be       	out	0x3f, r0	; 63
    6164:	cd bf       	out	0x3d, r28	; 61
    6166:	cf 91       	pop	r28
    6168:	df 91       	pop	r29
    616a:	1f 91       	pop	r17
    616c:	0f 91       	pop	r16
    616e:	08 95       	ret

00006170 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    6170:	ef 92       	push	r14
    6172:	ff 92       	push	r15
    6174:	0f 93       	push	r16
    6176:	1f 93       	push	r17
    6178:	df 93       	push	r29
    617a:	cf 93       	push	r28
    617c:	cd b7       	in	r28, 0x3d	; 61
    617e:	de b7       	in	r29, 0x3e	; 62
    6180:	62 97       	sbiw	r28, 0x12	; 18
    6182:	0f b6       	in	r0, 0x3f	; 63
    6184:	f8 94       	cli
    6186:	de bf       	out	0x3e, r29	; 62
    6188:	0f be       	out	0x3f, r0	; 63
    618a:	cd bf       	out	0x3d, r28	; 61
    618c:	9f 83       	std	Y+7, r25	; 0x07
    618e:	8e 83       	std	Y+6, r24	; 0x06
    6190:	48 87       	std	Y+8, r20	; 0x08
    6192:	59 87       	std	Y+9, r21	; 0x09
    6194:	6a 87       	std	Y+10, r22	; 0x0a
    6196:	7b 87       	std	Y+11, r23	; 0x0b
    6198:	2c 87       	std	Y+12, r18	; 0x0c
    619a:	1e 87       	std	Y+14, r17	; 0x0e
    619c:	0d 87       	std	Y+13, r16	; 0x0d
    619e:	f8 8a       	std	Y+16, r15	; 0x10
    61a0:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    61a2:	81 e0       	ldi	r24, 0x01	; 1
    61a4:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    61a6:	8e 81       	ldd	r24, Y+6	; 0x06
    61a8:	9f 81       	ldd	r25, Y+7	; 0x07
    61aa:	9d 83       	std	Y+5, r25	; 0x05
    61ac:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    61ae:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    61b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    61b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    61b4:	00 97       	sbiw	r24, 0x00	; 0
    61b6:	61 f0       	breq	.+24     	; 0x61d0 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    61b8:	ec 81       	ldd	r30, Y+4	; 0x04
    61ba:	fd 81       	ldd	r31, Y+5	; 0x05
    61bc:	81 a1       	ldd	r24, Z+33	; 0x21
    61be:	92 a1       	ldd	r25, Z+34	; 0x22
    61c0:	a3 a1       	ldd	r26, Z+35	; 0x23
    61c2:	b4 a1       	ldd	r27, Z+36	; 0x24
    61c4:	ed 85       	ldd	r30, Y+13	; 0x0d
    61c6:	fe 85       	ldd	r31, Y+14	; 0x0e
    61c8:	80 83       	st	Z, r24
    61ca:	91 83       	std	Z+1, r25	; 0x01
    61cc:	a2 83       	std	Z+2, r26	; 0x02
    61ce:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    61d0:	ec 81       	ldd	r30, Y+4	; 0x04
    61d2:	fd 81       	ldd	r31, Y+5	; 0x05
    61d4:	85 a1       	ldd	r24, Z+37	; 0x25
    61d6:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    61d8:	ec 81       	ldd	r30, Y+4	; 0x04
    61da:	fd 81       	ldd	r31, Y+5	; 0x05
    61dc:	82 e0       	ldi	r24, 0x02	; 2
    61de:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    61e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    61e2:	28 2f       	mov	r18, r24
    61e4:	30 e0       	ldi	r19, 0x00	; 0
    61e6:	3a 8b       	std	Y+18, r19	; 0x12
    61e8:	29 8b       	std	Y+17, r18	; 0x11
    61ea:	89 89       	ldd	r24, Y+17	; 0x11
    61ec:	9a 89       	ldd	r25, Y+18	; 0x12
    61ee:	82 30       	cpi	r24, 0x02	; 2
    61f0:	91 05       	cpc	r25, r1
    61f2:	59 f1       	breq	.+86     	; 0x624a <xTaskGenericNotifyFromISR+0xda>
    61f4:	29 89       	ldd	r18, Y+17	; 0x11
    61f6:	3a 89       	ldd	r19, Y+18	; 0x12
    61f8:	23 30       	cpi	r18, 0x03	; 3
    61fa:	31 05       	cpc	r19, r1
    61fc:	34 f4       	brge	.+12     	; 0x620a <xTaskGenericNotifyFromISR+0x9a>
    61fe:	89 89       	ldd	r24, Y+17	; 0x11
    6200:	9a 89       	ldd	r25, Y+18	; 0x12
    6202:	81 30       	cpi	r24, 0x01	; 1
    6204:	91 05       	cpc	r25, r1
    6206:	61 f0       	breq	.+24     	; 0x6220 <xTaskGenericNotifyFromISR+0xb0>
    6208:	4a c0       	rjmp	.+148    	; 0x629e <xTaskGenericNotifyFromISR+0x12e>
    620a:	29 89       	ldd	r18, Y+17	; 0x11
    620c:	3a 89       	ldd	r19, Y+18	; 0x12
    620e:	23 30       	cpi	r18, 0x03	; 3
    6210:	31 05       	cpc	r19, r1
    6212:	59 f1       	breq	.+86     	; 0x626a <xTaskGenericNotifyFromISR+0xfa>
    6214:	89 89       	ldd	r24, Y+17	; 0x11
    6216:	9a 89       	ldd	r25, Y+18	; 0x12
    6218:	84 30       	cpi	r24, 0x04	; 4
    621a:	91 05       	cpc	r25, r1
    621c:	89 f1       	breq	.+98     	; 0x6280 <xTaskGenericNotifyFromISR+0x110>
    621e:	3f c0       	rjmp	.+126    	; 0x629e <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    6220:	ec 81       	ldd	r30, Y+4	; 0x04
    6222:	fd 81       	ldd	r31, Y+5	; 0x05
    6224:	21 a1       	ldd	r18, Z+33	; 0x21
    6226:	32 a1       	ldd	r19, Z+34	; 0x22
    6228:	43 a1       	ldd	r20, Z+35	; 0x23
    622a:	54 a1       	ldd	r21, Z+36	; 0x24
    622c:	88 85       	ldd	r24, Y+8	; 0x08
    622e:	99 85       	ldd	r25, Y+9	; 0x09
    6230:	aa 85       	ldd	r26, Y+10	; 0x0a
    6232:	bb 85       	ldd	r27, Y+11	; 0x0b
    6234:	82 2b       	or	r24, r18
    6236:	93 2b       	or	r25, r19
    6238:	a4 2b       	or	r26, r20
    623a:	b5 2b       	or	r27, r21
    623c:	ec 81       	ldd	r30, Y+4	; 0x04
    623e:	fd 81       	ldd	r31, Y+5	; 0x05
    6240:	81 a3       	std	Z+33, r24	; 0x21
    6242:	92 a3       	std	Z+34, r25	; 0x22
    6244:	a3 a3       	std	Z+35, r26	; 0x23
    6246:	b4 a3       	std	Z+36, r27	; 0x24
    6248:	2a c0       	rjmp	.+84     	; 0x629e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    624a:	ec 81       	ldd	r30, Y+4	; 0x04
    624c:	fd 81       	ldd	r31, Y+5	; 0x05
    624e:	81 a1       	ldd	r24, Z+33	; 0x21
    6250:	92 a1       	ldd	r25, Z+34	; 0x22
    6252:	a3 a1       	ldd	r26, Z+35	; 0x23
    6254:	b4 a1       	ldd	r27, Z+36	; 0x24
    6256:	01 96       	adiw	r24, 0x01	; 1
    6258:	a1 1d       	adc	r26, r1
    625a:	b1 1d       	adc	r27, r1
    625c:	ec 81       	ldd	r30, Y+4	; 0x04
    625e:	fd 81       	ldd	r31, Y+5	; 0x05
    6260:	81 a3       	std	Z+33, r24	; 0x21
    6262:	92 a3       	std	Z+34, r25	; 0x22
    6264:	a3 a3       	std	Z+35, r26	; 0x23
    6266:	b4 a3       	std	Z+36, r27	; 0x24
    6268:	1a c0       	rjmp	.+52     	; 0x629e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    626a:	ec 81       	ldd	r30, Y+4	; 0x04
    626c:	fd 81       	ldd	r31, Y+5	; 0x05
    626e:	88 85       	ldd	r24, Y+8	; 0x08
    6270:	99 85       	ldd	r25, Y+9	; 0x09
    6272:	aa 85       	ldd	r26, Y+10	; 0x0a
    6274:	bb 85       	ldd	r27, Y+11	; 0x0b
    6276:	81 a3       	std	Z+33, r24	; 0x21
    6278:	92 a3       	std	Z+34, r25	; 0x22
    627a:	a3 a3       	std	Z+35, r26	; 0x23
    627c:	b4 a3       	std	Z+36, r27	; 0x24
    627e:	0f c0       	rjmp	.+30     	; 0x629e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    6280:	8b 81       	ldd	r24, Y+3	; 0x03
    6282:	82 30       	cpi	r24, 0x02	; 2
    6284:	59 f0       	breq	.+22     	; 0x629c <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    6286:	ec 81       	ldd	r30, Y+4	; 0x04
    6288:	fd 81       	ldd	r31, Y+5	; 0x05
    628a:	88 85       	ldd	r24, Y+8	; 0x08
    628c:	99 85       	ldd	r25, Y+9	; 0x09
    628e:	aa 85       	ldd	r26, Y+10	; 0x0a
    6290:	bb 85       	ldd	r27, Y+11	; 0x0b
    6292:	81 a3       	std	Z+33, r24	; 0x21
    6294:	92 a3       	std	Z+34, r25	; 0x22
    6296:	a3 a3       	std	Z+35, r26	; 0x23
    6298:	b4 a3       	std	Z+36, r27	; 0x24
    629a:	01 c0       	rjmp	.+2      	; 0x629e <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    629c:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    629e:	8b 81       	ldd	r24, Y+3	; 0x03
    62a0:	81 30       	cpi	r24, 0x01	; 1
    62a2:	09 f0       	breq	.+2      	; 0x62a6 <xTaskGenericNotifyFromISR+0x136>
    62a4:	4f c0       	rjmp	.+158    	; 0x6344 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    62a6:	80 91 6c 06 	lds	r24, 0x066C
    62aa:	88 23       	and	r24, r24
    62ac:	61 f5       	brne	.+88     	; 0x6306 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    62ae:	8c 81       	ldd	r24, Y+4	; 0x04
    62b0:	9d 81       	ldd	r25, Y+5	; 0x05
    62b2:	02 96       	adiw	r24, 0x02	; 2
    62b4:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    62b8:	ec 81       	ldd	r30, Y+4	; 0x04
    62ba:	fd 81       	ldd	r31, Y+5	; 0x05
    62bc:	96 89       	ldd	r25, Z+22	; 0x16
    62be:	80 91 62 06 	lds	r24, 0x0662
    62c2:	89 17       	cp	r24, r25
    62c4:	28 f4       	brcc	.+10     	; 0x62d0 <xTaskGenericNotifyFromISR+0x160>
    62c6:	ec 81       	ldd	r30, Y+4	; 0x04
    62c8:	fd 81       	ldd	r31, Y+5	; 0x05
    62ca:	86 89       	ldd	r24, Z+22	; 0x16
    62cc:	80 93 62 06 	sts	0x0662, r24
    62d0:	ec 81       	ldd	r30, Y+4	; 0x04
    62d2:	fd 81       	ldd	r31, Y+5	; 0x05
    62d4:	86 89       	ldd	r24, Z+22	; 0x16
    62d6:	28 2f       	mov	r18, r24
    62d8:	30 e0       	ldi	r19, 0x00	; 0
    62da:	c9 01       	movw	r24, r18
    62dc:	88 0f       	add	r24, r24
    62de:	99 1f       	adc	r25, r25
    62e0:	88 0f       	add	r24, r24
    62e2:	99 1f       	adc	r25, r25
    62e4:	88 0f       	add	r24, r24
    62e6:	99 1f       	adc	r25, r25
    62e8:	82 0f       	add	r24, r18
    62ea:	93 1f       	adc	r25, r19
    62ec:	ac 01       	movw	r20, r24
    62ee:	43 59       	subi	r20, 0x93	; 147
    62f0:	59 4f       	sbci	r21, 0xF9	; 249
    62f2:	8c 81       	ldd	r24, Y+4	; 0x04
    62f4:	9d 81       	ldd	r25, Y+5	; 0x05
    62f6:	9c 01       	movw	r18, r24
    62f8:	2e 5f       	subi	r18, 0xFE	; 254
    62fa:	3f 4f       	sbci	r19, 0xFF	; 255
    62fc:	ca 01       	movw	r24, r20
    62fe:	b9 01       	movw	r22, r18
    6300:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
    6304:	0a c0       	rjmp	.+20     	; 0x631a <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6306:	8c 81       	ldd	r24, Y+4	; 0x04
    6308:	9d 81       	ldd	r25, Y+5	; 0x05
    630a:	9c 01       	movw	r18, r24
    630c:	24 5f       	subi	r18, 0xF4	; 244
    630e:	3f 4f       	sbci	r19, 0xFF	; 255
    6310:	87 ea       	ldi	r24, 0xA7	; 167
    6312:	96 e0       	ldi	r25, 0x06	; 6
    6314:	b9 01       	movw	r22, r18
    6316:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    631a:	ec 81       	ldd	r30, Y+4	; 0x04
    631c:	fd 81       	ldd	r31, Y+5	; 0x05
    631e:	96 89       	ldd	r25, Z+22	; 0x16
    6320:	e0 91 5c 06 	lds	r30, 0x065C
    6324:	f0 91 5d 06 	lds	r31, 0x065D
    6328:	86 89       	ldd	r24, Z+22	; 0x16
    632a:	89 17       	cp	r24, r25
    632c:	58 f4       	brcc	.+22     	; 0x6344 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    632e:	8f 85       	ldd	r24, Y+15	; 0x0f
    6330:	98 89       	ldd	r25, Y+16	; 0x10
    6332:	00 97       	sbiw	r24, 0x00	; 0
    6334:	21 f0       	breq	.+8      	; 0x633e <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    6336:	ef 85       	ldd	r30, Y+15	; 0x0f
    6338:	f8 89       	ldd	r31, Y+16	; 0x10
    633a:	81 e0       	ldi	r24, 0x01	; 1
    633c:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    633e:	81 e0       	ldi	r24, 0x01	; 1
    6340:	80 93 65 06 	sts	0x0665, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    6344:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    6346:	62 96       	adiw	r28, 0x12	; 18
    6348:	0f b6       	in	r0, 0x3f	; 63
    634a:	f8 94       	cli
    634c:	de bf       	out	0x3e, r29	; 62
    634e:	0f be       	out	0x3f, r0	; 63
    6350:	cd bf       	out	0x3d, r28	; 61
    6352:	cf 91       	pop	r28
    6354:	df 91       	pop	r29
    6356:	1f 91       	pop	r17
    6358:	0f 91       	pop	r16
    635a:	ff 90       	pop	r15
    635c:	ef 90       	pop	r14
    635e:	08 95       	ret

00006360 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    6360:	df 93       	push	r29
    6362:	cf 93       	push	r28
    6364:	cd b7       	in	r28, 0x3d	; 61
    6366:	de b7       	in	r29, 0x3e	; 62
    6368:	28 97       	sbiw	r28, 0x08	; 8
    636a:	0f b6       	in	r0, 0x3f	; 63
    636c:	f8 94       	cli
    636e:	de bf       	out	0x3e, r29	; 62
    6370:	0f be       	out	0x3f, r0	; 63
    6372:	cd bf       	out	0x3d, r28	; 61
    6374:	9e 83       	std	Y+6, r25	; 0x06
    6376:	8d 83       	std	Y+5, r24	; 0x05
    6378:	78 87       	std	Y+8, r23	; 0x08
    637a:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    637c:	8d 81       	ldd	r24, Y+5	; 0x05
    637e:	9e 81       	ldd	r25, Y+6	; 0x06
    6380:	9c 83       	std	Y+4, r25	; 0x04
    6382:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6384:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    6386:	eb 81       	ldd	r30, Y+3	; 0x03
    6388:	fc 81       	ldd	r31, Y+4	; 0x04
    638a:	85 a1       	ldd	r24, Z+37	; 0x25
    638c:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    638e:	eb 81       	ldd	r30, Y+3	; 0x03
    6390:	fc 81       	ldd	r31, Y+4	; 0x04
    6392:	82 e0       	ldi	r24, 0x02	; 2
    6394:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    6396:	eb 81       	ldd	r30, Y+3	; 0x03
    6398:	fc 81       	ldd	r31, Y+4	; 0x04
    639a:	81 a1       	ldd	r24, Z+33	; 0x21
    639c:	92 a1       	ldd	r25, Z+34	; 0x22
    639e:	a3 a1       	ldd	r26, Z+35	; 0x23
    63a0:	b4 a1       	ldd	r27, Z+36	; 0x24
    63a2:	01 96       	adiw	r24, 0x01	; 1
    63a4:	a1 1d       	adc	r26, r1
    63a6:	b1 1d       	adc	r27, r1
    63a8:	eb 81       	ldd	r30, Y+3	; 0x03
    63aa:	fc 81       	ldd	r31, Y+4	; 0x04
    63ac:	81 a3       	std	Z+33, r24	; 0x21
    63ae:	92 a3       	std	Z+34, r25	; 0x22
    63b0:	a3 a3       	std	Z+35, r26	; 0x23
    63b2:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    63b4:	8a 81       	ldd	r24, Y+2	; 0x02
    63b6:	81 30       	cpi	r24, 0x01	; 1
    63b8:	09 f0       	breq	.+2      	; 0x63bc <vTaskNotifyGiveFromISR+0x5c>
    63ba:	4f c0       	rjmp	.+158    	; 0x645a <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    63bc:	80 91 6c 06 	lds	r24, 0x066C
    63c0:	88 23       	and	r24, r24
    63c2:	61 f5       	brne	.+88     	; 0x641c <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    63c4:	8b 81       	ldd	r24, Y+3	; 0x03
    63c6:	9c 81       	ldd	r25, Y+4	; 0x04
    63c8:	02 96       	adiw	r24, 0x02	; 2
    63ca:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    63ce:	eb 81       	ldd	r30, Y+3	; 0x03
    63d0:	fc 81       	ldd	r31, Y+4	; 0x04
    63d2:	96 89       	ldd	r25, Z+22	; 0x16
    63d4:	80 91 62 06 	lds	r24, 0x0662
    63d8:	89 17       	cp	r24, r25
    63da:	28 f4       	brcc	.+10     	; 0x63e6 <vTaskNotifyGiveFromISR+0x86>
    63dc:	eb 81       	ldd	r30, Y+3	; 0x03
    63de:	fc 81       	ldd	r31, Y+4	; 0x04
    63e0:	86 89       	ldd	r24, Z+22	; 0x16
    63e2:	80 93 62 06 	sts	0x0662, r24
    63e6:	eb 81       	ldd	r30, Y+3	; 0x03
    63e8:	fc 81       	ldd	r31, Y+4	; 0x04
    63ea:	86 89       	ldd	r24, Z+22	; 0x16
    63ec:	28 2f       	mov	r18, r24
    63ee:	30 e0       	ldi	r19, 0x00	; 0
    63f0:	c9 01       	movw	r24, r18
    63f2:	88 0f       	add	r24, r24
    63f4:	99 1f       	adc	r25, r25
    63f6:	88 0f       	add	r24, r24
    63f8:	99 1f       	adc	r25, r25
    63fa:	88 0f       	add	r24, r24
    63fc:	99 1f       	adc	r25, r25
    63fe:	82 0f       	add	r24, r18
    6400:	93 1f       	adc	r25, r19
    6402:	ac 01       	movw	r20, r24
    6404:	43 59       	subi	r20, 0x93	; 147
    6406:	59 4f       	sbci	r21, 0xF9	; 249
    6408:	8b 81       	ldd	r24, Y+3	; 0x03
    640a:	9c 81       	ldd	r25, Y+4	; 0x04
    640c:	9c 01       	movw	r18, r24
    640e:	2e 5f       	subi	r18, 0xFE	; 254
    6410:	3f 4f       	sbci	r19, 0xFF	; 255
    6412:	ca 01       	movw	r24, r20
    6414:	b9 01       	movw	r22, r18
    6416:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
    641a:	0a c0       	rjmp	.+20     	; 0x6430 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    641c:	8b 81       	ldd	r24, Y+3	; 0x03
    641e:	9c 81       	ldd	r25, Y+4	; 0x04
    6420:	9c 01       	movw	r18, r24
    6422:	24 5f       	subi	r18, 0xF4	; 244
    6424:	3f 4f       	sbci	r19, 0xFF	; 255
    6426:	87 ea       	ldi	r24, 0xA7	; 167
    6428:	96 e0       	ldi	r25, 0x06	; 6
    642a:	b9 01       	movw	r22, r18
    642c:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6430:	eb 81       	ldd	r30, Y+3	; 0x03
    6432:	fc 81       	ldd	r31, Y+4	; 0x04
    6434:	96 89       	ldd	r25, Z+22	; 0x16
    6436:	e0 91 5c 06 	lds	r30, 0x065C
    643a:	f0 91 5d 06 	lds	r31, 0x065D
    643e:	86 89       	ldd	r24, Z+22	; 0x16
    6440:	89 17       	cp	r24, r25
    6442:	58 f4       	brcc	.+22     	; 0x645a <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    6444:	8f 81       	ldd	r24, Y+7	; 0x07
    6446:	98 85       	ldd	r25, Y+8	; 0x08
    6448:	00 97       	sbiw	r24, 0x00	; 0
    644a:	21 f0       	breq	.+8      	; 0x6454 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    644c:	ef 81       	ldd	r30, Y+7	; 0x07
    644e:	f8 85       	ldd	r31, Y+8	; 0x08
    6450:	81 e0       	ldi	r24, 0x01	; 1
    6452:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    6454:	81 e0       	ldi	r24, 0x01	; 1
    6456:	80 93 65 06 	sts	0x0665, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    645a:	28 96       	adiw	r28, 0x08	; 8
    645c:	0f b6       	in	r0, 0x3f	; 63
    645e:	f8 94       	cli
    6460:	de bf       	out	0x3e, r29	; 62
    6462:	0f be       	out	0x3f, r0	; 63
    6464:	cd bf       	out	0x3d, r28	; 61
    6466:	cf 91       	pop	r28
    6468:	df 91       	pop	r29
    646a:	08 95       	ret

0000646c <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    646c:	df 93       	push	r29
    646e:	cf 93       	push	r28
    6470:	cd b7       	in	r28, 0x3d	; 61
    6472:	de b7       	in	r29, 0x3e	; 62
    6474:	27 97       	sbiw	r28, 0x07	; 7
    6476:	0f b6       	in	r0, 0x3f	; 63
    6478:	f8 94       	cli
    647a:	de bf       	out	0x3e, r29	; 62
    647c:	0f be       	out	0x3f, r0	; 63
    647e:	cd bf       	out	0x3d, r28	; 61
    6480:	9d 83       	std	Y+5, r25	; 0x05
    6482:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    6484:	8c 81       	ldd	r24, Y+4	; 0x04
    6486:	9d 81       	ldd	r25, Y+5	; 0x05
    6488:	00 97       	sbiw	r24, 0x00	; 0
    648a:	39 f4       	brne	.+14     	; 0x649a <xTaskNotifyStateClear+0x2e>
    648c:	80 91 5c 06 	lds	r24, 0x065C
    6490:	90 91 5d 06 	lds	r25, 0x065D
    6494:	9f 83       	std	Y+7, r25	; 0x07
    6496:	8e 83       	std	Y+6, r24	; 0x06
    6498:	04 c0       	rjmp	.+8      	; 0x64a2 <xTaskNotifyStateClear+0x36>
    649a:	8c 81       	ldd	r24, Y+4	; 0x04
    649c:	9d 81       	ldd	r25, Y+5	; 0x05
    649e:	9f 83       	std	Y+7, r25	; 0x07
    64a0:	8e 83       	std	Y+6, r24	; 0x06
    64a2:	8e 81       	ldd	r24, Y+6	; 0x06
    64a4:	9f 81       	ldd	r25, Y+7	; 0x07
    64a6:	9b 83       	std	Y+3, r25	; 0x03
    64a8:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    64aa:	0f b6       	in	r0, 0x3f	; 63
    64ac:	f8 94       	cli
    64ae:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    64b0:	ea 81       	ldd	r30, Y+2	; 0x02
    64b2:	fb 81       	ldd	r31, Y+3	; 0x03
    64b4:	85 a1       	ldd	r24, Z+37	; 0x25
    64b6:	82 30       	cpi	r24, 0x02	; 2
    64b8:	31 f4       	brne	.+12     	; 0x64c6 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    64ba:	ea 81       	ldd	r30, Y+2	; 0x02
    64bc:	fb 81       	ldd	r31, Y+3	; 0x03
    64be:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    64c0:	81 e0       	ldi	r24, 0x01	; 1
    64c2:	89 83       	std	Y+1, r24	; 0x01
    64c4:	01 c0       	rjmp	.+2      	; 0x64c8 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    64c6:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    64c8:	0f 90       	pop	r0
    64ca:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    64cc:	89 81       	ldd	r24, Y+1	; 0x01
	}
    64ce:	27 96       	adiw	r28, 0x07	; 7
    64d0:	0f b6       	in	r0, 0x3f	; 63
    64d2:	f8 94       	cli
    64d4:	de bf       	out	0x3e, r29	; 62
    64d6:	0f be       	out	0x3f, r0	; 63
    64d8:	cd bf       	out	0x3d, r28	; 61
    64da:	cf 91       	pop	r28
    64dc:	df 91       	pop	r29
    64de:	08 95       	ret

000064e0 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    64e0:	df 93       	push	r29
    64e2:	cf 93       	push	r28
    64e4:	cd b7       	in	r28, 0x3d	; 61
    64e6:	de b7       	in	r29, 0x3e	; 62
    64e8:	27 97       	sbiw	r28, 0x07	; 7
    64ea:	0f b6       	in	r0, 0x3f	; 63
    64ec:	f8 94       	cli
    64ee:	de bf       	out	0x3e, r29	; 62
    64f0:	0f be       	out	0x3f, r0	; 63
    64f2:	cd bf       	out	0x3d, r28	; 61
    64f4:	9e 83       	std	Y+6, r25	; 0x06
    64f6:	8d 83       	std	Y+5, r24	; 0x05
    64f8:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    64fa:	80 91 60 06 	lds	r24, 0x0660
    64fe:	90 91 61 06 	lds	r25, 0x0661
    6502:	9a 83       	std	Y+2, r25	; 0x02
    6504:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6506:	80 91 5c 06 	lds	r24, 0x065C
    650a:	90 91 5d 06 	lds	r25, 0x065D
    650e:	02 96       	adiw	r24, 0x02	; 2
    6510:	0e 94 b5 12 	call	0x256a	; 0x256a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    6514:	8d 81       	ldd	r24, Y+5	; 0x05
    6516:	9e 81       	ldd	r25, Y+6	; 0x06
    6518:	2f ef       	ldi	r18, 0xFF	; 255
    651a:	8f 3f       	cpi	r24, 0xFF	; 255
    651c:	92 07       	cpc	r25, r18
    651e:	81 f4       	brne	.+32     	; 0x6540 <prvAddCurrentTaskToDelayedList+0x60>
    6520:	8f 81       	ldd	r24, Y+7	; 0x07
    6522:	88 23       	and	r24, r24
    6524:	69 f0       	breq	.+26     	; 0x6540 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6526:	80 91 5c 06 	lds	r24, 0x065C
    652a:	90 91 5d 06 	lds	r25, 0x065D
    652e:	9c 01       	movw	r18, r24
    6530:	2e 5f       	subi	r18, 0xFE	; 254
    6532:	3f 4f       	sbci	r19, 0xFF	; 255
    6534:	89 eb       	ldi	r24, 0xB9	; 185
    6536:	96 e0       	ldi	r25, 0x06	; 6
    6538:	b9 01       	movw	r22, r18
    653a:	0e 94 05 12 	call	0x240a	; 0x240a <vListInsertEnd>
    653e:	43 c0       	rjmp	.+134    	; 0x65c6 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    6540:	29 81       	ldd	r18, Y+1	; 0x01
    6542:	3a 81       	ldd	r19, Y+2	; 0x02
    6544:	8d 81       	ldd	r24, Y+5	; 0x05
    6546:	9e 81       	ldd	r25, Y+6	; 0x06
    6548:	82 0f       	add	r24, r18
    654a:	93 1f       	adc	r25, r19
    654c:	9c 83       	std	Y+4, r25	; 0x04
    654e:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    6550:	e0 91 5c 06 	lds	r30, 0x065C
    6554:	f0 91 5d 06 	lds	r31, 0x065D
    6558:	8b 81       	ldd	r24, Y+3	; 0x03
    655a:	9c 81       	ldd	r25, Y+4	; 0x04
    655c:	93 83       	std	Z+3, r25	; 0x03
    655e:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    6560:	2b 81       	ldd	r18, Y+3	; 0x03
    6562:	3c 81       	ldd	r19, Y+4	; 0x04
    6564:	89 81       	ldd	r24, Y+1	; 0x01
    6566:	9a 81       	ldd	r25, Y+2	; 0x02
    6568:	28 17       	cp	r18, r24
    656a:	39 07       	cpc	r19, r25
    656c:	70 f4       	brcc	.+28     	; 0x658a <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    656e:	80 91 a5 06 	lds	r24, 0x06A5
    6572:	90 91 a6 06 	lds	r25, 0x06A6
    6576:	20 91 5c 06 	lds	r18, 0x065C
    657a:	30 91 5d 06 	lds	r19, 0x065D
    657e:	2e 5f       	subi	r18, 0xFE	; 254
    6580:	3f 4f       	sbci	r19, 0xFF	; 255
    6582:	b9 01       	movw	r22, r18
    6584:	0e 94 49 12 	call	0x2492	; 0x2492 <vListInsert>
    6588:	1e c0       	rjmp	.+60     	; 0x65c6 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    658a:	40 91 a3 06 	lds	r20, 0x06A3
    658e:	50 91 a4 06 	lds	r21, 0x06A4
    6592:	80 91 5c 06 	lds	r24, 0x065C
    6596:	90 91 5d 06 	lds	r25, 0x065D
    659a:	9c 01       	movw	r18, r24
    659c:	2e 5f       	subi	r18, 0xFE	; 254
    659e:	3f 4f       	sbci	r19, 0xFF	; 255
    65a0:	ca 01       	movw	r24, r20
    65a2:	b9 01       	movw	r22, r18
    65a4:	0e 94 49 12 	call	0x2492	; 0x2492 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    65a8:	20 91 68 06 	lds	r18, 0x0668
    65ac:	30 91 69 06 	lds	r19, 0x0669
    65b0:	8b 81       	ldd	r24, Y+3	; 0x03
    65b2:	9c 81       	ldd	r25, Y+4	; 0x04
    65b4:	82 17       	cp	r24, r18
    65b6:	93 07       	cpc	r25, r19
    65b8:	30 f4       	brcc	.+12     	; 0x65c6 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    65ba:	8b 81       	ldd	r24, Y+3	; 0x03
    65bc:	9c 81       	ldd	r25, Y+4	; 0x04
    65be:	90 93 69 06 	sts	0x0669, r25
    65c2:	80 93 68 06 	sts	0x0668, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    65c6:	27 96       	adiw	r28, 0x07	; 7
    65c8:	0f b6       	in	r0, 0x3f	; 63
    65ca:	f8 94       	cli
    65cc:	de bf       	out	0x3e, r29	; 62
    65ce:	0f be       	out	0x3f, r0	; 63
    65d0:	cd bf       	out	0x3d, r28	; 61
    65d2:	cf 91       	pop	r28
    65d4:	df 91       	pop	r29
    65d6:	08 95       	ret

000065d8 <memcpy>:
    65d8:	fb 01       	movw	r30, r22
    65da:	dc 01       	movw	r26, r24
    65dc:	02 c0       	rjmp	.+4      	; 0x65e2 <memcpy+0xa>
    65de:	01 90       	ld	r0, Z+
    65e0:	0d 92       	st	X+, r0
    65e2:	41 50       	subi	r20, 0x01	; 1
    65e4:	50 40       	sbci	r21, 0x00	; 0
    65e6:	d8 f7       	brcc	.-10     	; 0x65de <memcpy+0x6>
    65e8:	08 95       	ret

000065ea <memset>:
    65ea:	dc 01       	movw	r26, r24
    65ec:	01 c0       	rjmp	.+2      	; 0x65f0 <memset+0x6>
    65ee:	6d 93       	st	X+, r22
    65f0:	41 50       	subi	r20, 0x01	; 1
    65f2:	50 40       	sbci	r21, 0x00	; 0
    65f4:	e0 f7       	brcc	.-8      	; 0x65ee <memset+0x4>
    65f6:	08 95       	ret

000065f8 <_exit>:
    65f8:	f8 94       	cli

000065fa <__stop_program>:
    65fa:	ff cf       	rjmp	.-2      	; 0x65fa <__stop_program>
