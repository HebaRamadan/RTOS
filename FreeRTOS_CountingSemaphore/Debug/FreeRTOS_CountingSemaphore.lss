
FreeRTOS_CountingSemaphore.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006af8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000024  00800060  00006af8  00006b8c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064d  00800084  00800084  00006bb0  2**0
                  ALLOC
  3 .stab         00009060  00000000  00000000  00006bb0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004970  00000000  00000000  0000fc10  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00014580  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  000146c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00014830  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00016479  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00017364  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00018114  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00018274  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00018501  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00018ccf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 b3 0c 	jmp	0x1966	; 0x1966 <__vector_1>
       8:	0c 94 e0 0c 	jmp	0x19c0	; 0x19c0 <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 cf 18 	jmp	0x319e	; 0x319e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ef       	ldi	r30, 0xF8	; 248
      68:	fa e6       	ldi	r31, 0x6A	; 106
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 38       	cpi	r26, 0x84	; 132
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a4 e8       	ldi	r26, 0x84	; 132
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 3d       	cpi	r26, 0xD1	; 209
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <main>
      8a:	0c 94 7a 35 	jmp	0x6af4	; 0x6af4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 33 35 	jmp	0x6a66	; 0x6a66 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ab e7       	ldi	r26, 0x7B	; 123
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 4f 35 	jmp	0x6a9e	; 0x6a9e <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 3f 35 	jmp	0x6a7e	; 0x6a7e <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 5b 35 	jmp	0x6ab6	; 0x6ab6 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 3f 35 	jmp	0x6a7e	; 0x6a7e <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 5b 35 	jmp	0x6ab6	; 0x6ab6 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 33 35 	jmp	0x6a66	; 0x6a66 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8b e7       	ldi	r24, 0x7B	; 123
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 4f 35 	jmp	0x6a9e	; 0x6a9e <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 3f 35 	jmp	0x6a7e	; 0x6a7e <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 5b 35 	jmp	0x6ab6	; 0x6ab6 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 3f 35 	jmp	0x6a7e	; 0x6a7e <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 5b 35 	jmp	0x6ab6	; 0x6ab6 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 3f 35 	jmp	0x6a7e	; 0x6a7e <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 5b 35 	jmp	0x6ab6	; 0x6ab6 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 43 35 	jmp	0x6a86	; 0x6a86 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 5f 35 	jmp	0x6abe	; 0x6abe <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <Dio_vidSetPinDir>:
#include "../Lib/Bit_math.h"
#include "Dio_int.h"
#include "Dio_priv.h"

void Dio_vidSetPinDir(u8 Pin , u8 Dir)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
     b4e:	66 97       	sbiw	r28, 0x16	; 22
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	de bf       	out	0x3e, r29	; 62
     b56:	0f be       	out	0x3f, r0	; 63
     b58:	cd bf       	out	0x3d, r28	; 61
     b5a:	8b 83       	std	Y+3, r24	; 0x03
     b5c:	6c 83       	std	Y+4, r22	; 0x04
	u8 PortId;
	u8 PinLoc;

	PortId = Pin/8;
     b5e:	8b 81       	ldd	r24, Y+3	; 0x03
     b60:	86 95       	lsr	r24
     b62:	86 95       	lsr	r24
     b64:	86 95       	lsr	r24
     b66:	8a 83       	std	Y+2, r24	; 0x02
	PinLoc = Pin%8;
     b68:	8b 81       	ldd	r24, Y+3	; 0x03
     b6a:	87 70       	andi	r24, 0x07	; 7
     b6c:	89 83       	std	Y+1, r24	; 0x01

	switch(PortId){
     b6e:	8a 81       	ldd	r24, Y+2	; 0x02
     b70:	28 2f       	mov	r18, r24
     b72:	30 e0       	ldi	r19, 0x00	; 0
     b74:	3e 8b       	std	Y+22, r19	; 0x16
     b76:	2d 8b       	std	Y+21, r18	; 0x15
     b78:	8d 89       	ldd	r24, Y+21	; 0x15
     b7a:	9e 89       	ldd	r25, Y+22	; 0x16
     b7c:	81 30       	cpi	r24, 0x01	; 1
     b7e:	91 05       	cpc	r25, r1
     b80:	09 f4       	brne	.+2      	; 0xb84 <Dio_vidSetPinDir+0x3e>
     b82:	e1 c0       	rjmp	.+450    	; 0xd46 <Dio_vidSetPinDir+0x200>
     b84:	2d 89       	ldd	r18, Y+21	; 0x15
     b86:	3e 89       	ldd	r19, Y+22	; 0x16
     b88:	22 30       	cpi	r18, 0x02	; 2
     b8a:	31 05       	cpc	r19, r1
     b8c:	2c f4       	brge	.+10     	; 0xb98 <Dio_vidSetPinDir+0x52>
     b8e:	8d 89       	ldd	r24, Y+21	; 0x15
     b90:	9e 89       	ldd	r25, Y+22	; 0x16
     b92:	00 97       	sbiw	r24, 0x00	; 0
     b94:	71 f0       	breq	.+28     	; 0xbb2 <Dio_vidSetPinDir+0x6c>
     b96:	34 c3       	rjmp	.+1640   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
     b98:	2d 89       	ldd	r18, Y+21	; 0x15
     b9a:	3e 89       	ldd	r19, Y+22	; 0x16
     b9c:	22 30       	cpi	r18, 0x02	; 2
     b9e:	31 05       	cpc	r19, r1
     ba0:	09 f4       	brne	.+2      	; 0xba4 <Dio_vidSetPinDir+0x5e>
     ba2:	9b c1       	rjmp	.+822    	; 0xeda <Dio_vidSetPinDir+0x394>
     ba4:	8d 89       	ldd	r24, Y+21	; 0x15
     ba6:	9e 89       	ldd	r25, Y+22	; 0x16
     ba8:	83 30       	cpi	r24, 0x03	; 3
     baa:	91 05       	cpc	r25, r1
     bac:	09 f4       	brne	.+2      	; 0xbb0 <Dio_vidSetPinDir+0x6a>
     bae:	5f c2       	rjmp	.+1214   	; 0x106e <Dio_vidSetPinDir+0x528>
     bb0:	27 c3       	rjmp	.+1614   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
		case 0:
			if(Dir ==1)
     bb2:	8c 81       	ldd	r24, Y+4	; 0x04
     bb4:	81 30       	cpi	r24, 0x01	; 1
     bb6:	09 f0       	breq	.+2      	; 0xbba <Dio_vidSetPinDir+0x74>
     bb8:	63 c0       	rjmp	.+198    	; 0xc80 <Dio_vidSetPinDir+0x13a>
				{
					switch(PinLoc)
     bba:	89 81       	ldd	r24, Y+1	; 0x01
     bbc:	28 2f       	mov	r18, r24
     bbe:	30 e0       	ldi	r19, 0x00	; 0
     bc0:	3c 8b       	std	Y+20, r19	; 0x14
     bc2:	2b 8b       	std	Y+19, r18	; 0x13
     bc4:	8b 89       	ldd	r24, Y+19	; 0x13
     bc6:	9c 89       	ldd	r25, Y+20	; 0x14
     bc8:	83 30       	cpi	r24, 0x03	; 3
     bca:	91 05       	cpc	r25, r1
     bcc:	d9 f1       	breq	.+118    	; 0xc44 <Dio_vidSetPinDir+0xfe>
     bce:	2b 89       	ldd	r18, Y+19	; 0x13
     bd0:	3c 89       	ldd	r19, Y+20	; 0x14
     bd2:	24 30       	cpi	r18, 0x04	; 4
     bd4:	31 05       	cpc	r19, r1
     bd6:	7c f4       	brge	.+30     	; 0xbf6 <Dio_vidSetPinDir+0xb0>
     bd8:	8b 89       	ldd	r24, Y+19	; 0x13
     bda:	9c 89       	ldd	r25, Y+20	; 0x14
     bdc:	81 30       	cpi	r24, 0x01	; 1
     bde:	91 05       	cpc	r25, r1
     be0:	29 f1       	breq	.+74     	; 0xc2c <Dio_vidSetPinDir+0xe6>
     be2:	2b 89       	ldd	r18, Y+19	; 0x13
     be4:	3c 89       	ldd	r19, Y+20	; 0x14
     be6:	22 30       	cpi	r18, 0x02	; 2
     be8:	31 05       	cpc	r19, r1
     bea:	34 f5       	brge	.+76     	; 0xc38 <Dio_vidSetPinDir+0xf2>
     bec:	8b 89       	ldd	r24, Y+19	; 0x13
     bee:	9c 89       	ldd	r25, Y+20	; 0x14
     bf0:	00 97       	sbiw	r24, 0x00	; 0
     bf2:	b1 f0       	breq	.+44     	; 0xc20 <Dio_vidSetPinDir+0xda>
     bf4:	05 c3       	rjmp	.+1546   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
     bf6:	2b 89       	ldd	r18, Y+19	; 0x13
     bf8:	3c 89       	ldd	r19, Y+20	; 0x14
     bfa:	25 30       	cpi	r18, 0x05	; 5
     bfc:	31 05       	cpc	r19, r1
     bfe:	71 f1       	breq	.+92     	; 0xc5c <Dio_vidSetPinDir+0x116>
     c00:	8b 89       	ldd	r24, Y+19	; 0x13
     c02:	9c 89       	ldd	r25, Y+20	; 0x14
     c04:	85 30       	cpi	r24, 0x05	; 5
     c06:	91 05       	cpc	r25, r1
     c08:	1c f1       	brlt	.+70     	; 0xc50 <Dio_vidSetPinDir+0x10a>
     c0a:	2b 89       	ldd	r18, Y+19	; 0x13
     c0c:	3c 89       	ldd	r19, Y+20	; 0x14
     c0e:	26 30       	cpi	r18, 0x06	; 6
     c10:	31 05       	cpc	r19, r1
     c12:	51 f1       	breq	.+84     	; 0xc68 <Dio_vidSetPinDir+0x122>
     c14:	8b 89       	ldd	r24, Y+19	; 0x13
     c16:	9c 89       	ldd	r25, Y+20	; 0x14
     c18:	87 30       	cpi	r24, 0x07	; 7
     c1a:	91 05       	cpc	r25, r1
     c1c:	59 f1       	breq	.+86     	; 0xc74 <Dio_vidSetPinDir+0x12e>
     c1e:	f0 c2       	rjmp	.+1504   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					{
						case 0:
							DDRA.Bits.Pin0 =1;
     c20:	ea e3       	ldi	r30, 0x3A	; 58
     c22:	f0 e0       	ldi	r31, 0x00	; 0
     c24:	80 81       	ld	r24, Z
     c26:	81 60       	ori	r24, 0x01	; 1
     c28:	80 83       	st	Z, r24
     c2a:	ea c2       	rjmp	.+1492   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 1:
							DDRA.Bits.Pin1 =1;
     c2c:	ea e3       	ldi	r30, 0x3A	; 58
     c2e:	f0 e0       	ldi	r31, 0x00	; 0
     c30:	80 81       	ld	r24, Z
     c32:	82 60       	ori	r24, 0x02	; 2
     c34:	80 83       	st	Z, r24
     c36:	e4 c2       	rjmp	.+1480   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 2:
							DDRA.Bits.Pin2 =1;
     c38:	ea e3       	ldi	r30, 0x3A	; 58
     c3a:	f0 e0       	ldi	r31, 0x00	; 0
     c3c:	80 81       	ld	r24, Z
     c3e:	84 60       	ori	r24, 0x04	; 4
     c40:	80 83       	st	Z, r24
     c42:	de c2       	rjmp	.+1468   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 3:
							DDRA.Bits.Pin3 =1;
     c44:	ea e3       	ldi	r30, 0x3A	; 58
     c46:	f0 e0       	ldi	r31, 0x00	; 0
     c48:	80 81       	ld	r24, Z
     c4a:	88 60       	ori	r24, 0x08	; 8
     c4c:	80 83       	st	Z, r24
     c4e:	d8 c2       	rjmp	.+1456   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 4:
							DDRA.Bits.Pin4 =1;
     c50:	ea e3       	ldi	r30, 0x3A	; 58
     c52:	f0 e0       	ldi	r31, 0x00	; 0
     c54:	80 81       	ld	r24, Z
     c56:	80 61       	ori	r24, 0x10	; 16
     c58:	80 83       	st	Z, r24
     c5a:	d2 c2       	rjmp	.+1444   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 5:
							DDRA.Bits.Pin5 =1;
     c5c:	ea e3       	ldi	r30, 0x3A	; 58
     c5e:	f0 e0       	ldi	r31, 0x00	; 0
     c60:	80 81       	ld	r24, Z
     c62:	80 62       	ori	r24, 0x20	; 32
     c64:	80 83       	st	Z, r24
     c66:	cc c2       	rjmp	.+1432   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 6:
							DDRA.Bits.Pin6 =1;
     c68:	ea e3       	ldi	r30, 0x3A	; 58
     c6a:	f0 e0       	ldi	r31, 0x00	; 0
     c6c:	80 81       	ld	r24, Z
     c6e:	80 64       	ori	r24, 0x40	; 64
     c70:	80 83       	st	Z, r24
     c72:	c6 c2       	rjmp	.+1420   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 7:
							DDRA.Bits.Pin7 =1;
     c74:	ea e3       	ldi	r30, 0x3A	; 58
     c76:	f0 e0       	ldi	r31, 0x00	; 0
     c78:	80 81       	ld	r24, Z
     c7a:	80 68       	ori	r24, 0x80	; 128
     c7c:	80 83       	st	Z, r24
     c7e:	c0 c2       	rjmp	.+1408   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;
					}
				}
			else
			{
				switch(PinLoc)
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	28 2f       	mov	r18, r24
     c84:	30 e0       	ldi	r19, 0x00	; 0
     c86:	3a 8b       	std	Y+18, r19	; 0x12
     c88:	29 8b       	std	Y+17, r18	; 0x11
     c8a:	89 89       	ldd	r24, Y+17	; 0x11
     c8c:	9a 89       	ldd	r25, Y+18	; 0x12
     c8e:	83 30       	cpi	r24, 0x03	; 3
     c90:	91 05       	cpc	r25, r1
     c92:	d9 f1       	breq	.+118    	; 0xd0a <Dio_vidSetPinDir+0x1c4>
     c94:	29 89       	ldd	r18, Y+17	; 0x11
     c96:	3a 89       	ldd	r19, Y+18	; 0x12
     c98:	24 30       	cpi	r18, 0x04	; 4
     c9a:	31 05       	cpc	r19, r1
     c9c:	7c f4       	brge	.+30     	; 0xcbc <Dio_vidSetPinDir+0x176>
     c9e:	89 89       	ldd	r24, Y+17	; 0x11
     ca0:	9a 89       	ldd	r25, Y+18	; 0x12
     ca2:	81 30       	cpi	r24, 0x01	; 1
     ca4:	91 05       	cpc	r25, r1
     ca6:	29 f1       	breq	.+74     	; 0xcf2 <Dio_vidSetPinDir+0x1ac>
     ca8:	29 89       	ldd	r18, Y+17	; 0x11
     caa:	3a 89       	ldd	r19, Y+18	; 0x12
     cac:	22 30       	cpi	r18, 0x02	; 2
     cae:	31 05       	cpc	r19, r1
     cb0:	34 f5       	brge	.+76     	; 0xcfe <Dio_vidSetPinDir+0x1b8>
     cb2:	89 89       	ldd	r24, Y+17	; 0x11
     cb4:	9a 89       	ldd	r25, Y+18	; 0x12
     cb6:	00 97       	sbiw	r24, 0x00	; 0
     cb8:	b1 f0       	breq	.+44     	; 0xce6 <Dio_vidSetPinDir+0x1a0>
     cba:	a2 c2       	rjmp	.+1348   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
     cbc:	29 89       	ldd	r18, Y+17	; 0x11
     cbe:	3a 89       	ldd	r19, Y+18	; 0x12
     cc0:	25 30       	cpi	r18, 0x05	; 5
     cc2:	31 05       	cpc	r19, r1
     cc4:	71 f1       	breq	.+92     	; 0xd22 <Dio_vidSetPinDir+0x1dc>
     cc6:	89 89       	ldd	r24, Y+17	; 0x11
     cc8:	9a 89       	ldd	r25, Y+18	; 0x12
     cca:	85 30       	cpi	r24, 0x05	; 5
     ccc:	91 05       	cpc	r25, r1
     cce:	1c f1       	brlt	.+70     	; 0xd16 <Dio_vidSetPinDir+0x1d0>
     cd0:	29 89       	ldd	r18, Y+17	; 0x11
     cd2:	3a 89       	ldd	r19, Y+18	; 0x12
     cd4:	26 30       	cpi	r18, 0x06	; 6
     cd6:	31 05       	cpc	r19, r1
     cd8:	51 f1       	breq	.+84     	; 0xd2e <Dio_vidSetPinDir+0x1e8>
     cda:	89 89       	ldd	r24, Y+17	; 0x11
     cdc:	9a 89       	ldd	r25, Y+18	; 0x12
     cde:	87 30       	cpi	r24, 0x07	; 7
     ce0:	91 05       	cpc	r25, r1
     ce2:	59 f1       	breq	.+86     	; 0xd3a <Dio_vidSetPinDir+0x1f4>
     ce4:	8d c2       	rjmp	.+1306   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
				{
					case 0:
						DDRA.Bits.Pin0 =0;
     ce6:	ea e3       	ldi	r30, 0x3A	; 58
     ce8:	f0 e0       	ldi	r31, 0x00	; 0
     cea:	80 81       	ld	r24, Z
     cec:	8e 7f       	andi	r24, 0xFE	; 254
     cee:	80 83       	st	Z, r24
     cf0:	87 c2       	rjmp	.+1294   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 1:
						DDRA.Bits.Pin1 =0;
     cf2:	ea e3       	ldi	r30, 0x3A	; 58
     cf4:	f0 e0       	ldi	r31, 0x00	; 0
     cf6:	80 81       	ld	r24, Z
     cf8:	8d 7f       	andi	r24, 0xFD	; 253
     cfa:	80 83       	st	Z, r24
     cfc:	81 c2       	rjmp	.+1282   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 2:
						DDRA.Bits.Pin2 =0;
     cfe:	ea e3       	ldi	r30, 0x3A	; 58
     d00:	f0 e0       	ldi	r31, 0x00	; 0
     d02:	80 81       	ld	r24, Z
     d04:	8b 7f       	andi	r24, 0xFB	; 251
     d06:	80 83       	st	Z, r24
     d08:	7b c2       	rjmp	.+1270   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 3:
						DDRA.Bits.Pin3 =0;
     d0a:	ea e3       	ldi	r30, 0x3A	; 58
     d0c:	f0 e0       	ldi	r31, 0x00	; 0
     d0e:	80 81       	ld	r24, Z
     d10:	87 7f       	andi	r24, 0xF7	; 247
     d12:	80 83       	st	Z, r24
     d14:	75 c2       	rjmp	.+1258   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 4:
						DDRA.Bits.Pin4 =0;
     d16:	ea e3       	ldi	r30, 0x3A	; 58
     d18:	f0 e0       	ldi	r31, 0x00	; 0
     d1a:	80 81       	ld	r24, Z
     d1c:	8f 7e       	andi	r24, 0xEF	; 239
     d1e:	80 83       	st	Z, r24
     d20:	6f c2       	rjmp	.+1246   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 5:
						DDRA.Bits.Pin5 =0;
     d22:	ea e3       	ldi	r30, 0x3A	; 58
     d24:	f0 e0       	ldi	r31, 0x00	; 0
     d26:	80 81       	ld	r24, Z
     d28:	8f 7d       	andi	r24, 0xDF	; 223
     d2a:	80 83       	st	Z, r24
     d2c:	69 c2       	rjmp	.+1234   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 6:
						DDRA.Bits.Pin6 =0;
     d2e:	ea e3       	ldi	r30, 0x3A	; 58
     d30:	f0 e0       	ldi	r31, 0x00	; 0
     d32:	80 81       	ld	r24, Z
     d34:	8f 7b       	andi	r24, 0xBF	; 191
     d36:	80 83       	st	Z, r24
     d38:	63 c2       	rjmp	.+1222   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 7:
						DDRA.Bits.Pin7 =0;
     d3a:	ea e3       	ldi	r30, 0x3A	; 58
     d3c:	f0 e0       	ldi	r31, 0x00	; 0
     d3e:	80 81       	ld	r24, Z
     d40:	8f 77       	andi	r24, 0x7F	; 127
     d42:	80 83       	st	Z, r24
     d44:	5d c2       	rjmp	.+1210   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
				}
			}
		break;

		case 1:
			if(Dir ==1)
     d46:	8c 81       	ldd	r24, Y+4	; 0x04
     d48:	81 30       	cpi	r24, 0x01	; 1
     d4a:	09 f0       	breq	.+2      	; 0xd4e <Dio_vidSetPinDir+0x208>
     d4c:	63 c0       	rjmp	.+198    	; 0xe14 <Dio_vidSetPinDir+0x2ce>
				{
					switch(PinLoc)
     d4e:	89 81       	ldd	r24, Y+1	; 0x01
     d50:	28 2f       	mov	r18, r24
     d52:	30 e0       	ldi	r19, 0x00	; 0
     d54:	38 8b       	std	Y+16, r19	; 0x10
     d56:	2f 87       	std	Y+15, r18	; 0x0f
     d58:	8f 85       	ldd	r24, Y+15	; 0x0f
     d5a:	98 89       	ldd	r25, Y+16	; 0x10
     d5c:	83 30       	cpi	r24, 0x03	; 3
     d5e:	91 05       	cpc	r25, r1
     d60:	d9 f1       	breq	.+118    	; 0xdd8 <Dio_vidSetPinDir+0x292>
     d62:	2f 85       	ldd	r18, Y+15	; 0x0f
     d64:	38 89       	ldd	r19, Y+16	; 0x10
     d66:	24 30       	cpi	r18, 0x04	; 4
     d68:	31 05       	cpc	r19, r1
     d6a:	7c f4       	brge	.+30     	; 0xd8a <Dio_vidSetPinDir+0x244>
     d6c:	8f 85       	ldd	r24, Y+15	; 0x0f
     d6e:	98 89       	ldd	r25, Y+16	; 0x10
     d70:	81 30       	cpi	r24, 0x01	; 1
     d72:	91 05       	cpc	r25, r1
     d74:	29 f1       	breq	.+74     	; 0xdc0 <Dio_vidSetPinDir+0x27a>
     d76:	2f 85       	ldd	r18, Y+15	; 0x0f
     d78:	38 89       	ldd	r19, Y+16	; 0x10
     d7a:	22 30       	cpi	r18, 0x02	; 2
     d7c:	31 05       	cpc	r19, r1
     d7e:	34 f5       	brge	.+76     	; 0xdcc <Dio_vidSetPinDir+0x286>
     d80:	8f 85       	ldd	r24, Y+15	; 0x0f
     d82:	98 89       	ldd	r25, Y+16	; 0x10
     d84:	00 97       	sbiw	r24, 0x00	; 0
     d86:	b1 f0       	breq	.+44     	; 0xdb4 <Dio_vidSetPinDir+0x26e>
     d88:	3b c2       	rjmp	.+1142   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
     d8a:	2f 85       	ldd	r18, Y+15	; 0x0f
     d8c:	38 89       	ldd	r19, Y+16	; 0x10
     d8e:	25 30       	cpi	r18, 0x05	; 5
     d90:	31 05       	cpc	r19, r1
     d92:	71 f1       	breq	.+92     	; 0xdf0 <Dio_vidSetPinDir+0x2aa>
     d94:	8f 85       	ldd	r24, Y+15	; 0x0f
     d96:	98 89       	ldd	r25, Y+16	; 0x10
     d98:	85 30       	cpi	r24, 0x05	; 5
     d9a:	91 05       	cpc	r25, r1
     d9c:	1c f1       	brlt	.+70     	; 0xde4 <Dio_vidSetPinDir+0x29e>
     d9e:	2f 85       	ldd	r18, Y+15	; 0x0f
     da0:	38 89       	ldd	r19, Y+16	; 0x10
     da2:	26 30       	cpi	r18, 0x06	; 6
     da4:	31 05       	cpc	r19, r1
     da6:	51 f1       	breq	.+84     	; 0xdfc <Dio_vidSetPinDir+0x2b6>
     da8:	8f 85       	ldd	r24, Y+15	; 0x0f
     daa:	98 89       	ldd	r25, Y+16	; 0x10
     dac:	87 30       	cpi	r24, 0x07	; 7
     dae:	91 05       	cpc	r25, r1
     db0:	59 f1       	breq	.+86     	; 0xe08 <Dio_vidSetPinDir+0x2c2>
     db2:	26 c2       	rjmp	.+1100   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					{
						case 0:
							DDRB.Bits.Pin0 =1;
     db4:	e7 e3       	ldi	r30, 0x37	; 55
     db6:	f0 e0       	ldi	r31, 0x00	; 0
     db8:	80 81       	ld	r24, Z
     dba:	81 60       	ori	r24, 0x01	; 1
     dbc:	80 83       	st	Z, r24
     dbe:	20 c2       	rjmp	.+1088   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 1:
							DDRB.Bits.Pin1 =1;
     dc0:	e7 e3       	ldi	r30, 0x37	; 55
     dc2:	f0 e0       	ldi	r31, 0x00	; 0
     dc4:	80 81       	ld	r24, Z
     dc6:	82 60       	ori	r24, 0x02	; 2
     dc8:	80 83       	st	Z, r24
     dca:	1a c2       	rjmp	.+1076   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 2:
							DDRB.Bits.Pin2 =1;
     dcc:	e7 e3       	ldi	r30, 0x37	; 55
     dce:	f0 e0       	ldi	r31, 0x00	; 0
     dd0:	80 81       	ld	r24, Z
     dd2:	84 60       	ori	r24, 0x04	; 4
     dd4:	80 83       	st	Z, r24
     dd6:	14 c2       	rjmp	.+1064   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 3:
							DDRB.Bits.Pin3 =1;
     dd8:	e7 e3       	ldi	r30, 0x37	; 55
     dda:	f0 e0       	ldi	r31, 0x00	; 0
     ddc:	80 81       	ld	r24, Z
     dde:	88 60       	ori	r24, 0x08	; 8
     de0:	80 83       	st	Z, r24
     de2:	0e c2       	rjmp	.+1052   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 4:
							DDRB.Bits.Pin4 =1;
     de4:	e7 e3       	ldi	r30, 0x37	; 55
     de6:	f0 e0       	ldi	r31, 0x00	; 0
     de8:	80 81       	ld	r24, Z
     dea:	80 61       	ori	r24, 0x10	; 16
     dec:	80 83       	st	Z, r24
     dee:	08 c2       	rjmp	.+1040   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 5:
							DDRB.Bits.Pin5 =1;
     df0:	e7 e3       	ldi	r30, 0x37	; 55
     df2:	f0 e0       	ldi	r31, 0x00	; 0
     df4:	80 81       	ld	r24, Z
     df6:	80 62       	ori	r24, 0x20	; 32
     df8:	80 83       	st	Z, r24
     dfa:	02 c2       	rjmp	.+1028   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 6:
							DDRB.Bits.Pin6 =1;
     dfc:	e7 e3       	ldi	r30, 0x37	; 55
     dfe:	f0 e0       	ldi	r31, 0x00	; 0
     e00:	80 81       	ld	r24, Z
     e02:	80 64       	ori	r24, 0x40	; 64
     e04:	80 83       	st	Z, r24
     e06:	fc c1       	rjmp	.+1016   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 7:
							DDRB.Bits.Pin7 =1;
     e08:	e7 e3       	ldi	r30, 0x37	; 55
     e0a:	f0 e0       	ldi	r31, 0x00	; 0
     e0c:	80 81       	ld	r24, Z
     e0e:	80 68       	ori	r24, 0x80	; 128
     e10:	80 83       	st	Z, r24
     e12:	f6 c1       	rjmp	.+1004   	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;
					}
				}
			else
			{
				switch(PinLoc)
     e14:	89 81       	ldd	r24, Y+1	; 0x01
     e16:	28 2f       	mov	r18, r24
     e18:	30 e0       	ldi	r19, 0x00	; 0
     e1a:	3e 87       	std	Y+14, r19	; 0x0e
     e1c:	2d 87       	std	Y+13, r18	; 0x0d
     e1e:	8d 85       	ldd	r24, Y+13	; 0x0d
     e20:	9e 85       	ldd	r25, Y+14	; 0x0e
     e22:	83 30       	cpi	r24, 0x03	; 3
     e24:	91 05       	cpc	r25, r1
     e26:	d9 f1       	breq	.+118    	; 0xe9e <Dio_vidSetPinDir+0x358>
     e28:	2d 85       	ldd	r18, Y+13	; 0x0d
     e2a:	3e 85       	ldd	r19, Y+14	; 0x0e
     e2c:	24 30       	cpi	r18, 0x04	; 4
     e2e:	31 05       	cpc	r19, r1
     e30:	7c f4       	brge	.+30     	; 0xe50 <Dio_vidSetPinDir+0x30a>
     e32:	8d 85       	ldd	r24, Y+13	; 0x0d
     e34:	9e 85       	ldd	r25, Y+14	; 0x0e
     e36:	81 30       	cpi	r24, 0x01	; 1
     e38:	91 05       	cpc	r25, r1
     e3a:	29 f1       	breq	.+74     	; 0xe86 <Dio_vidSetPinDir+0x340>
     e3c:	2d 85       	ldd	r18, Y+13	; 0x0d
     e3e:	3e 85       	ldd	r19, Y+14	; 0x0e
     e40:	22 30       	cpi	r18, 0x02	; 2
     e42:	31 05       	cpc	r19, r1
     e44:	34 f5       	brge	.+76     	; 0xe92 <Dio_vidSetPinDir+0x34c>
     e46:	8d 85       	ldd	r24, Y+13	; 0x0d
     e48:	9e 85       	ldd	r25, Y+14	; 0x0e
     e4a:	00 97       	sbiw	r24, 0x00	; 0
     e4c:	b1 f0       	breq	.+44     	; 0xe7a <Dio_vidSetPinDir+0x334>
     e4e:	d8 c1       	rjmp	.+944    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
     e50:	2d 85       	ldd	r18, Y+13	; 0x0d
     e52:	3e 85       	ldd	r19, Y+14	; 0x0e
     e54:	25 30       	cpi	r18, 0x05	; 5
     e56:	31 05       	cpc	r19, r1
     e58:	71 f1       	breq	.+92     	; 0xeb6 <Dio_vidSetPinDir+0x370>
     e5a:	8d 85       	ldd	r24, Y+13	; 0x0d
     e5c:	9e 85       	ldd	r25, Y+14	; 0x0e
     e5e:	85 30       	cpi	r24, 0x05	; 5
     e60:	91 05       	cpc	r25, r1
     e62:	1c f1       	brlt	.+70     	; 0xeaa <Dio_vidSetPinDir+0x364>
     e64:	2d 85       	ldd	r18, Y+13	; 0x0d
     e66:	3e 85       	ldd	r19, Y+14	; 0x0e
     e68:	26 30       	cpi	r18, 0x06	; 6
     e6a:	31 05       	cpc	r19, r1
     e6c:	51 f1       	breq	.+84     	; 0xec2 <Dio_vidSetPinDir+0x37c>
     e6e:	8d 85       	ldd	r24, Y+13	; 0x0d
     e70:	9e 85       	ldd	r25, Y+14	; 0x0e
     e72:	87 30       	cpi	r24, 0x07	; 7
     e74:	91 05       	cpc	r25, r1
     e76:	59 f1       	breq	.+86     	; 0xece <Dio_vidSetPinDir+0x388>
     e78:	c3 c1       	rjmp	.+902    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
				{
					case 0:
						DDRB.Bits.Pin0 =0;
     e7a:	e7 e3       	ldi	r30, 0x37	; 55
     e7c:	f0 e0       	ldi	r31, 0x00	; 0
     e7e:	80 81       	ld	r24, Z
     e80:	8e 7f       	andi	r24, 0xFE	; 254
     e82:	80 83       	st	Z, r24
     e84:	bd c1       	rjmp	.+890    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 1:
						DDRB.Bits.Pin1 =0;
     e86:	e7 e3       	ldi	r30, 0x37	; 55
     e88:	f0 e0       	ldi	r31, 0x00	; 0
     e8a:	80 81       	ld	r24, Z
     e8c:	8d 7f       	andi	r24, 0xFD	; 253
     e8e:	80 83       	st	Z, r24
     e90:	b7 c1       	rjmp	.+878    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 2:
						DDRB.Bits.Pin2 =0;
     e92:	e7 e3       	ldi	r30, 0x37	; 55
     e94:	f0 e0       	ldi	r31, 0x00	; 0
     e96:	80 81       	ld	r24, Z
     e98:	8b 7f       	andi	r24, 0xFB	; 251
     e9a:	80 83       	st	Z, r24
     e9c:	b1 c1       	rjmp	.+866    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 3:
						DDRB.Bits.Pin3 =0;
     e9e:	e7 e3       	ldi	r30, 0x37	; 55
     ea0:	f0 e0       	ldi	r31, 0x00	; 0
     ea2:	80 81       	ld	r24, Z
     ea4:	87 7f       	andi	r24, 0xF7	; 247
     ea6:	80 83       	st	Z, r24
     ea8:	ab c1       	rjmp	.+854    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 4:
						DDRB.Bits.Pin4 =0;
     eaa:	e7 e3       	ldi	r30, 0x37	; 55
     eac:	f0 e0       	ldi	r31, 0x00	; 0
     eae:	80 81       	ld	r24, Z
     eb0:	8f 7e       	andi	r24, 0xEF	; 239
     eb2:	80 83       	st	Z, r24
     eb4:	a5 c1       	rjmp	.+842    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 5:
						DDRB.Bits.Pin5 =0;
     eb6:	e7 e3       	ldi	r30, 0x37	; 55
     eb8:	f0 e0       	ldi	r31, 0x00	; 0
     eba:	80 81       	ld	r24, Z
     ebc:	8f 7d       	andi	r24, 0xDF	; 223
     ebe:	80 83       	st	Z, r24
     ec0:	9f c1       	rjmp	.+830    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 6:
						DDRB.Bits.Pin6 =0;
     ec2:	e7 e3       	ldi	r30, 0x37	; 55
     ec4:	f0 e0       	ldi	r31, 0x00	; 0
     ec6:	80 81       	ld	r24, Z
     ec8:	8f 7b       	andi	r24, 0xBF	; 191
     eca:	80 83       	st	Z, r24
     ecc:	99 c1       	rjmp	.+818    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 7:
						DDRB.Bits.Pin7 =0;
     ece:	e7 e3       	ldi	r30, 0x37	; 55
     ed0:	f0 e0       	ldi	r31, 0x00	; 0
     ed2:	80 81       	ld	r24, Z
     ed4:	8f 77       	andi	r24, 0x7F	; 127
     ed6:	80 83       	st	Z, r24
     ed8:	93 c1       	rjmp	.+806    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
				}
			}
			break;

		case 2:
			if(Dir ==1)
     eda:	8c 81       	ldd	r24, Y+4	; 0x04
     edc:	81 30       	cpi	r24, 0x01	; 1
     ede:	09 f0       	breq	.+2      	; 0xee2 <Dio_vidSetPinDir+0x39c>
     ee0:	63 c0       	rjmp	.+198    	; 0xfa8 <Dio_vidSetPinDir+0x462>
				{
					switch(PinLoc)
     ee2:	89 81       	ldd	r24, Y+1	; 0x01
     ee4:	28 2f       	mov	r18, r24
     ee6:	30 e0       	ldi	r19, 0x00	; 0
     ee8:	3c 87       	std	Y+12, r19	; 0x0c
     eea:	2b 87       	std	Y+11, r18	; 0x0b
     eec:	8b 85       	ldd	r24, Y+11	; 0x0b
     eee:	9c 85       	ldd	r25, Y+12	; 0x0c
     ef0:	83 30       	cpi	r24, 0x03	; 3
     ef2:	91 05       	cpc	r25, r1
     ef4:	d9 f1       	breq	.+118    	; 0xf6c <Dio_vidSetPinDir+0x426>
     ef6:	2b 85       	ldd	r18, Y+11	; 0x0b
     ef8:	3c 85       	ldd	r19, Y+12	; 0x0c
     efa:	24 30       	cpi	r18, 0x04	; 4
     efc:	31 05       	cpc	r19, r1
     efe:	7c f4       	brge	.+30     	; 0xf1e <Dio_vidSetPinDir+0x3d8>
     f00:	8b 85       	ldd	r24, Y+11	; 0x0b
     f02:	9c 85       	ldd	r25, Y+12	; 0x0c
     f04:	81 30       	cpi	r24, 0x01	; 1
     f06:	91 05       	cpc	r25, r1
     f08:	29 f1       	breq	.+74     	; 0xf54 <Dio_vidSetPinDir+0x40e>
     f0a:	2b 85       	ldd	r18, Y+11	; 0x0b
     f0c:	3c 85       	ldd	r19, Y+12	; 0x0c
     f0e:	22 30       	cpi	r18, 0x02	; 2
     f10:	31 05       	cpc	r19, r1
     f12:	34 f5       	brge	.+76     	; 0xf60 <Dio_vidSetPinDir+0x41a>
     f14:	8b 85       	ldd	r24, Y+11	; 0x0b
     f16:	9c 85       	ldd	r25, Y+12	; 0x0c
     f18:	00 97       	sbiw	r24, 0x00	; 0
     f1a:	b1 f0       	breq	.+44     	; 0xf48 <Dio_vidSetPinDir+0x402>
     f1c:	71 c1       	rjmp	.+738    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
     f1e:	2b 85       	ldd	r18, Y+11	; 0x0b
     f20:	3c 85       	ldd	r19, Y+12	; 0x0c
     f22:	25 30       	cpi	r18, 0x05	; 5
     f24:	31 05       	cpc	r19, r1
     f26:	71 f1       	breq	.+92     	; 0xf84 <Dio_vidSetPinDir+0x43e>
     f28:	8b 85       	ldd	r24, Y+11	; 0x0b
     f2a:	9c 85       	ldd	r25, Y+12	; 0x0c
     f2c:	85 30       	cpi	r24, 0x05	; 5
     f2e:	91 05       	cpc	r25, r1
     f30:	1c f1       	brlt	.+70     	; 0xf78 <Dio_vidSetPinDir+0x432>
     f32:	2b 85       	ldd	r18, Y+11	; 0x0b
     f34:	3c 85       	ldd	r19, Y+12	; 0x0c
     f36:	26 30       	cpi	r18, 0x06	; 6
     f38:	31 05       	cpc	r19, r1
     f3a:	51 f1       	breq	.+84     	; 0xf90 <Dio_vidSetPinDir+0x44a>
     f3c:	8b 85       	ldd	r24, Y+11	; 0x0b
     f3e:	9c 85       	ldd	r25, Y+12	; 0x0c
     f40:	87 30       	cpi	r24, 0x07	; 7
     f42:	91 05       	cpc	r25, r1
     f44:	59 f1       	breq	.+86     	; 0xf9c <Dio_vidSetPinDir+0x456>
     f46:	5c c1       	rjmp	.+696    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					{
						case 0:
							DDRC.Bits.Pin0 =1;
     f48:	e4 e3       	ldi	r30, 0x34	; 52
     f4a:	f0 e0       	ldi	r31, 0x00	; 0
     f4c:	80 81       	ld	r24, Z
     f4e:	81 60       	ori	r24, 0x01	; 1
     f50:	80 83       	st	Z, r24
     f52:	56 c1       	rjmp	.+684    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 1:
							DDRC.Bits.Pin1 =1;
     f54:	e4 e3       	ldi	r30, 0x34	; 52
     f56:	f0 e0       	ldi	r31, 0x00	; 0
     f58:	80 81       	ld	r24, Z
     f5a:	82 60       	ori	r24, 0x02	; 2
     f5c:	80 83       	st	Z, r24
     f5e:	50 c1       	rjmp	.+672    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 2:
							DDRC.Bits.Pin2 =1;
     f60:	e4 e3       	ldi	r30, 0x34	; 52
     f62:	f0 e0       	ldi	r31, 0x00	; 0
     f64:	80 81       	ld	r24, Z
     f66:	84 60       	ori	r24, 0x04	; 4
     f68:	80 83       	st	Z, r24
     f6a:	4a c1       	rjmp	.+660    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 3:
							DDRC.Bits.Pin3 =1;
     f6c:	e4 e3       	ldi	r30, 0x34	; 52
     f6e:	f0 e0       	ldi	r31, 0x00	; 0
     f70:	80 81       	ld	r24, Z
     f72:	88 60       	ori	r24, 0x08	; 8
     f74:	80 83       	st	Z, r24
     f76:	44 c1       	rjmp	.+648    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 4:
							DDRC.Bits.Pin4 =1;
     f78:	e4 e3       	ldi	r30, 0x34	; 52
     f7a:	f0 e0       	ldi	r31, 0x00	; 0
     f7c:	80 81       	ld	r24, Z
     f7e:	80 61       	ori	r24, 0x10	; 16
     f80:	80 83       	st	Z, r24
     f82:	3e c1       	rjmp	.+636    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 5:
							DDRC.Bits.Pin5 =1;
     f84:	e4 e3       	ldi	r30, 0x34	; 52
     f86:	f0 e0       	ldi	r31, 0x00	; 0
     f88:	80 81       	ld	r24, Z
     f8a:	80 62       	ori	r24, 0x20	; 32
     f8c:	80 83       	st	Z, r24
     f8e:	38 c1       	rjmp	.+624    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 6:
							DDRC.Bits.Pin6 =1;
     f90:	e4 e3       	ldi	r30, 0x34	; 52
     f92:	f0 e0       	ldi	r31, 0x00	; 0
     f94:	80 81       	ld	r24, Z
     f96:	80 64       	ori	r24, 0x40	; 64
     f98:	80 83       	st	Z, r24
     f9a:	32 c1       	rjmp	.+612    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 7:
							DDRC.Bits.Pin7 =1;
     f9c:	e4 e3       	ldi	r30, 0x34	; 52
     f9e:	f0 e0       	ldi	r31, 0x00	; 0
     fa0:	80 81       	ld	r24, Z
     fa2:	80 68       	ori	r24, 0x80	; 128
     fa4:	80 83       	st	Z, r24
     fa6:	2c c1       	rjmp	.+600    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;
					}
				}
			else
			{
				switch(PinLoc)
     fa8:	89 81       	ldd	r24, Y+1	; 0x01
     faa:	28 2f       	mov	r18, r24
     fac:	30 e0       	ldi	r19, 0x00	; 0
     fae:	3a 87       	std	Y+10, r19	; 0x0a
     fb0:	29 87       	std	Y+9, r18	; 0x09
     fb2:	89 85       	ldd	r24, Y+9	; 0x09
     fb4:	9a 85       	ldd	r25, Y+10	; 0x0a
     fb6:	83 30       	cpi	r24, 0x03	; 3
     fb8:	91 05       	cpc	r25, r1
     fba:	d9 f1       	breq	.+118    	; 0x1032 <Dio_vidSetPinDir+0x4ec>
     fbc:	29 85       	ldd	r18, Y+9	; 0x09
     fbe:	3a 85       	ldd	r19, Y+10	; 0x0a
     fc0:	24 30       	cpi	r18, 0x04	; 4
     fc2:	31 05       	cpc	r19, r1
     fc4:	7c f4       	brge	.+30     	; 0xfe4 <Dio_vidSetPinDir+0x49e>
     fc6:	89 85       	ldd	r24, Y+9	; 0x09
     fc8:	9a 85       	ldd	r25, Y+10	; 0x0a
     fca:	81 30       	cpi	r24, 0x01	; 1
     fcc:	91 05       	cpc	r25, r1
     fce:	29 f1       	breq	.+74     	; 0x101a <Dio_vidSetPinDir+0x4d4>
     fd0:	29 85       	ldd	r18, Y+9	; 0x09
     fd2:	3a 85       	ldd	r19, Y+10	; 0x0a
     fd4:	22 30       	cpi	r18, 0x02	; 2
     fd6:	31 05       	cpc	r19, r1
     fd8:	34 f5       	brge	.+76     	; 0x1026 <Dio_vidSetPinDir+0x4e0>
     fda:	89 85       	ldd	r24, Y+9	; 0x09
     fdc:	9a 85       	ldd	r25, Y+10	; 0x0a
     fde:	00 97       	sbiw	r24, 0x00	; 0
     fe0:	b1 f0       	breq	.+44     	; 0x100e <Dio_vidSetPinDir+0x4c8>
     fe2:	0e c1       	rjmp	.+540    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
     fe4:	29 85       	ldd	r18, Y+9	; 0x09
     fe6:	3a 85       	ldd	r19, Y+10	; 0x0a
     fe8:	25 30       	cpi	r18, 0x05	; 5
     fea:	31 05       	cpc	r19, r1
     fec:	71 f1       	breq	.+92     	; 0x104a <Dio_vidSetPinDir+0x504>
     fee:	89 85       	ldd	r24, Y+9	; 0x09
     ff0:	9a 85       	ldd	r25, Y+10	; 0x0a
     ff2:	85 30       	cpi	r24, 0x05	; 5
     ff4:	91 05       	cpc	r25, r1
     ff6:	1c f1       	brlt	.+70     	; 0x103e <Dio_vidSetPinDir+0x4f8>
     ff8:	29 85       	ldd	r18, Y+9	; 0x09
     ffa:	3a 85       	ldd	r19, Y+10	; 0x0a
     ffc:	26 30       	cpi	r18, 0x06	; 6
     ffe:	31 05       	cpc	r19, r1
    1000:	51 f1       	breq	.+84     	; 0x1056 <Dio_vidSetPinDir+0x510>
    1002:	89 85       	ldd	r24, Y+9	; 0x09
    1004:	9a 85       	ldd	r25, Y+10	; 0x0a
    1006:	87 30       	cpi	r24, 0x07	; 7
    1008:	91 05       	cpc	r25, r1
    100a:	59 f1       	breq	.+86     	; 0x1062 <Dio_vidSetPinDir+0x51c>
    100c:	f9 c0       	rjmp	.+498    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
				{
					case 0:
						DDRC.Bits.Pin0 =0;
    100e:	e4 e3       	ldi	r30, 0x34	; 52
    1010:	f0 e0       	ldi	r31, 0x00	; 0
    1012:	80 81       	ld	r24, Z
    1014:	8e 7f       	andi	r24, 0xFE	; 254
    1016:	80 83       	st	Z, r24
    1018:	f3 c0       	rjmp	.+486    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 1:
						DDRC.Bits.Pin1 =0;
    101a:	e4 e3       	ldi	r30, 0x34	; 52
    101c:	f0 e0       	ldi	r31, 0x00	; 0
    101e:	80 81       	ld	r24, Z
    1020:	8d 7f       	andi	r24, 0xFD	; 253
    1022:	80 83       	st	Z, r24
    1024:	ed c0       	rjmp	.+474    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 2:
						DDRC.Bits.Pin2 =0;
    1026:	e4 e3       	ldi	r30, 0x34	; 52
    1028:	f0 e0       	ldi	r31, 0x00	; 0
    102a:	80 81       	ld	r24, Z
    102c:	8b 7f       	andi	r24, 0xFB	; 251
    102e:	80 83       	st	Z, r24
    1030:	e7 c0       	rjmp	.+462    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 3:
						DDRC.Bits.Pin3 =0;
    1032:	e4 e3       	ldi	r30, 0x34	; 52
    1034:	f0 e0       	ldi	r31, 0x00	; 0
    1036:	80 81       	ld	r24, Z
    1038:	87 7f       	andi	r24, 0xF7	; 247
    103a:	80 83       	st	Z, r24
    103c:	e1 c0       	rjmp	.+450    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 4:
						DDRC.Bits.Pin4 =0;
    103e:	e4 e3       	ldi	r30, 0x34	; 52
    1040:	f0 e0       	ldi	r31, 0x00	; 0
    1042:	80 81       	ld	r24, Z
    1044:	8f 7e       	andi	r24, 0xEF	; 239
    1046:	80 83       	st	Z, r24
    1048:	db c0       	rjmp	.+438    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 5:
						DDRC.Bits.Pin5 =0;
    104a:	e4 e3       	ldi	r30, 0x34	; 52
    104c:	f0 e0       	ldi	r31, 0x00	; 0
    104e:	80 81       	ld	r24, Z
    1050:	8f 7d       	andi	r24, 0xDF	; 223
    1052:	80 83       	st	Z, r24
    1054:	d5 c0       	rjmp	.+426    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 6:
						DDRC.Bits.Pin6 =0;
    1056:	e4 e3       	ldi	r30, 0x34	; 52
    1058:	f0 e0       	ldi	r31, 0x00	; 0
    105a:	80 81       	ld	r24, Z
    105c:	8f 7b       	andi	r24, 0xBF	; 191
    105e:	80 83       	st	Z, r24
    1060:	cf c0       	rjmp	.+414    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 7:
						DDRC.Bits.Pin7 =0;
    1062:	e4 e3       	ldi	r30, 0x34	; 52
    1064:	f0 e0       	ldi	r31, 0x00	; 0
    1066:	80 81       	ld	r24, Z
    1068:	8f 77       	andi	r24, 0x7F	; 127
    106a:	80 83       	st	Z, r24
    106c:	c9 c0       	rjmp	.+402    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
			}
		break;


		case 3:
			if(Dir ==1)
    106e:	8c 81       	ldd	r24, Y+4	; 0x04
    1070:	81 30       	cpi	r24, 0x01	; 1
    1072:	09 f0       	breq	.+2      	; 0x1076 <Dio_vidSetPinDir+0x530>
    1074:	63 c0       	rjmp	.+198    	; 0x113c <Dio_vidSetPinDir+0x5f6>
				{
					switch(PinLoc)
    1076:	89 81       	ldd	r24, Y+1	; 0x01
    1078:	28 2f       	mov	r18, r24
    107a:	30 e0       	ldi	r19, 0x00	; 0
    107c:	38 87       	std	Y+8, r19	; 0x08
    107e:	2f 83       	std	Y+7, r18	; 0x07
    1080:	8f 81       	ldd	r24, Y+7	; 0x07
    1082:	98 85       	ldd	r25, Y+8	; 0x08
    1084:	83 30       	cpi	r24, 0x03	; 3
    1086:	91 05       	cpc	r25, r1
    1088:	d9 f1       	breq	.+118    	; 0x1100 <Dio_vidSetPinDir+0x5ba>
    108a:	2f 81       	ldd	r18, Y+7	; 0x07
    108c:	38 85       	ldd	r19, Y+8	; 0x08
    108e:	24 30       	cpi	r18, 0x04	; 4
    1090:	31 05       	cpc	r19, r1
    1092:	7c f4       	brge	.+30     	; 0x10b2 <Dio_vidSetPinDir+0x56c>
    1094:	8f 81       	ldd	r24, Y+7	; 0x07
    1096:	98 85       	ldd	r25, Y+8	; 0x08
    1098:	81 30       	cpi	r24, 0x01	; 1
    109a:	91 05       	cpc	r25, r1
    109c:	29 f1       	breq	.+74     	; 0x10e8 <Dio_vidSetPinDir+0x5a2>
    109e:	2f 81       	ldd	r18, Y+7	; 0x07
    10a0:	38 85       	ldd	r19, Y+8	; 0x08
    10a2:	22 30       	cpi	r18, 0x02	; 2
    10a4:	31 05       	cpc	r19, r1
    10a6:	34 f5       	brge	.+76     	; 0x10f4 <Dio_vidSetPinDir+0x5ae>
    10a8:	8f 81       	ldd	r24, Y+7	; 0x07
    10aa:	98 85       	ldd	r25, Y+8	; 0x08
    10ac:	00 97       	sbiw	r24, 0x00	; 0
    10ae:	b1 f0       	breq	.+44     	; 0x10dc <Dio_vidSetPinDir+0x596>
    10b0:	a7 c0       	rjmp	.+334    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
    10b2:	2f 81       	ldd	r18, Y+7	; 0x07
    10b4:	38 85       	ldd	r19, Y+8	; 0x08
    10b6:	25 30       	cpi	r18, 0x05	; 5
    10b8:	31 05       	cpc	r19, r1
    10ba:	71 f1       	breq	.+92     	; 0x1118 <Dio_vidSetPinDir+0x5d2>
    10bc:	8f 81       	ldd	r24, Y+7	; 0x07
    10be:	98 85       	ldd	r25, Y+8	; 0x08
    10c0:	85 30       	cpi	r24, 0x05	; 5
    10c2:	91 05       	cpc	r25, r1
    10c4:	1c f1       	brlt	.+70     	; 0x110c <Dio_vidSetPinDir+0x5c6>
    10c6:	2f 81       	ldd	r18, Y+7	; 0x07
    10c8:	38 85       	ldd	r19, Y+8	; 0x08
    10ca:	26 30       	cpi	r18, 0x06	; 6
    10cc:	31 05       	cpc	r19, r1
    10ce:	51 f1       	breq	.+84     	; 0x1124 <Dio_vidSetPinDir+0x5de>
    10d0:	8f 81       	ldd	r24, Y+7	; 0x07
    10d2:	98 85       	ldd	r25, Y+8	; 0x08
    10d4:	87 30       	cpi	r24, 0x07	; 7
    10d6:	91 05       	cpc	r25, r1
    10d8:	59 f1       	breq	.+86     	; 0x1130 <Dio_vidSetPinDir+0x5ea>
    10da:	92 c0       	rjmp	.+292    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					{
						case 0:
							DDRD.Bits.Pin0 =1;
    10dc:	e1 e3       	ldi	r30, 0x31	; 49
    10de:	f0 e0       	ldi	r31, 0x00	; 0
    10e0:	80 81       	ld	r24, Z
    10e2:	81 60       	ori	r24, 0x01	; 1
    10e4:	80 83       	st	Z, r24
    10e6:	8c c0       	rjmp	.+280    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 1:
							DDRD.Bits.Pin1 =1;
    10e8:	e1 e3       	ldi	r30, 0x31	; 49
    10ea:	f0 e0       	ldi	r31, 0x00	; 0
    10ec:	80 81       	ld	r24, Z
    10ee:	82 60       	ori	r24, 0x02	; 2
    10f0:	80 83       	st	Z, r24
    10f2:	86 c0       	rjmp	.+268    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 2:
							DDRD.Bits.Pin2 =1;
    10f4:	e1 e3       	ldi	r30, 0x31	; 49
    10f6:	f0 e0       	ldi	r31, 0x00	; 0
    10f8:	80 81       	ld	r24, Z
    10fa:	84 60       	ori	r24, 0x04	; 4
    10fc:	80 83       	st	Z, r24
    10fe:	80 c0       	rjmp	.+256    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 3:
							DDRD.Bits.Pin3 =1;
    1100:	e1 e3       	ldi	r30, 0x31	; 49
    1102:	f0 e0       	ldi	r31, 0x00	; 0
    1104:	80 81       	ld	r24, Z
    1106:	88 60       	ori	r24, 0x08	; 8
    1108:	80 83       	st	Z, r24
    110a:	7a c0       	rjmp	.+244    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 4:
							DDRD.Bits.Pin4 =1;
    110c:	e1 e3       	ldi	r30, 0x31	; 49
    110e:	f0 e0       	ldi	r31, 0x00	; 0
    1110:	80 81       	ld	r24, Z
    1112:	80 61       	ori	r24, 0x10	; 16
    1114:	80 83       	st	Z, r24
    1116:	74 c0       	rjmp	.+232    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 5:
							DDRD.Bits.Pin5 =1;
    1118:	e1 e3       	ldi	r30, 0x31	; 49
    111a:	f0 e0       	ldi	r31, 0x00	; 0
    111c:	80 81       	ld	r24, Z
    111e:	80 62       	ori	r24, 0x20	; 32
    1120:	80 83       	st	Z, r24
    1122:	6e c0       	rjmp	.+220    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 6:
							DDRD.Bits.Pin6 =1;
    1124:	e1 e3       	ldi	r30, 0x31	; 49
    1126:	f0 e0       	ldi	r31, 0x00	; 0
    1128:	80 81       	ld	r24, Z
    112a:	80 64       	ori	r24, 0x40	; 64
    112c:	80 83       	st	Z, r24
    112e:	68 c0       	rjmp	.+208    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;

						case 7:
							DDRD.Bits.Pin7 =1;
    1130:	e1 e3       	ldi	r30, 0x31	; 49
    1132:	f0 e0       	ldi	r31, 0x00	; 0
    1134:	80 81       	ld	r24, Z
    1136:	80 68       	ori	r24, 0x80	; 128
    1138:	80 83       	st	Z, r24
    113a:	62 c0       	rjmp	.+196    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
						break;
					}
				}
			else
			{
				switch(PinLoc)
    113c:	89 81       	ldd	r24, Y+1	; 0x01
    113e:	28 2f       	mov	r18, r24
    1140:	30 e0       	ldi	r19, 0x00	; 0
    1142:	3e 83       	std	Y+6, r19	; 0x06
    1144:	2d 83       	std	Y+5, r18	; 0x05
    1146:	8d 81       	ldd	r24, Y+5	; 0x05
    1148:	9e 81       	ldd	r25, Y+6	; 0x06
    114a:	83 30       	cpi	r24, 0x03	; 3
    114c:	91 05       	cpc	r25, r1
    114e:	d9 f1       	breq	.+118    	; 0x11c6 <Dio_vidSetPinDir+0x680>
    1150:	2d 81       	ldd	r18, Y+5	; 0x05
    1152:	3e 81       	ldd	r19, Y+6	; 0x06
    1154:	24 30       	cpi	r18, 0x04	; 4
    1156:	31 05       	cpc	r19, r1
    1158:	7c f4       	brge	.+30     	; 0x1178 <Dio_vidSetPinDir+0x632>
    115a:	8d 81       	ldd	r24, Y+5	; 0x05
    115c:	9e 81       	ldd	r25, Y+6	; 0x06
    115e:	81 30       	cpi	r24, 0x01	; 1
    1160:	91 05       	cpc	r25, r1
    1162:	29 f1       	breq	.+74     	; 0x11ae <Dio_vidSetPinDir+0x668>
    1164:	2d 81       	ldd	r18, Y+5	; 0x05
    1166:	3e 81       	ldd	r19, Y+6	; 0x06
    1168:	22 30       	cpi	r18, 0x02	; 2
    116a:	31 05       	cpc	r19, r1
    116c:	34 f5       	brge	.+76     	; 0x11ba <Dio_vidSetPinDir+0x674>
    116e:	8d 81       	ldd	r24, Y+5	; 0x05
    1170:	9e 81       	ldd	r25, Y+6	; 0x06
    1172:	00 97       	sbiw	r24, 0x00	; 0
    1174:	b1 f0       	breq	.+44     	; 0x11a2 <Dio_vidSetPinDir+0x65c>
    1176:	44 c0       	rjmp	.+136    	; 0x1200 <Dio_vidSetPinDir+0x6ba>
    1178:	2d 81       	ldd	r18, Y+5	; 0x05
    117a:	3e 81       	ldd	r19, Y+6	; 0x06
    117c:	25 30       	cpi	r18, 0x05	; 5
    117e:	31 05       	cpc	r19, r1
    1180:	71 f1       	breq	.+92     	; 0x11de <Dio_vidSetPinDir+0x698>
    1182:	8d 81       	ldd	r24, Y+5	; 0x05
    1184:	9e 81       	ldd	r25, Y+6	; 0x06
    1186:	85 30       	cpi	r24, 0x05	; 5
    1188:	91 05       	cpc	r25, r1
    118a:	1c f1       	brlt	.+70     	; 0x11d2 <Dio_vidSetPinDir+0x68c>
    118c:	2d 81       	ldd	r18, Y+5	; 0x05
    118e:	3e 81       	ldd	r19, Y+6	; 0x06
    1190:	26 30       	cpi	r18, 0x06	; 6
    1192:	31 05       	cpc	r19, r1
    1194:	51 f1       	breq	.+84     	; 0x11ea <Dio_vidSetPinDir+0x6a4>
    1196:	8d 81       	ldd	r24, Y+5	; 0x05
    1198:	9e 81       	ldd	r25, Y+6	; 0x06
    119a:	87 30       	cpi	r24, 0x07	; 7
    119c:	91 05       	cpc	r25, r1
    119e:	59 f1       	breq	.+86     	; 0x11f6 <Dio_vidSetPinDir+0x6b0>
    11a0:	2f c0       	rjmp	.+94     	; 0x1200 <Dio_vidSetPinDir+0x6ba>
				{
					case 0:
						DDRD.Bits.Pin0 =0;
    11a2:	e1 e3       	ldi	r30, 0x31	; 49
    11a4:	f0 e0       	ldi	r31, 0x00	; 0
    11a6:	80 81       	ld	r24, Z
    11a8:	8e 7f       	andi	r24, 0xFE	; 254
    11aa:	80 83       	st	Z, r24
    11ac:	29 c0       	rjmp	.+82     	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 1:
						DDRD.Bits.Pin1 =0;
    11ae:	e1 e3       	ldi	r30, 0x31	; 49
    11b0:	f0 e0       	ldi	r31, 0x00	; 0
    11b2:	80 81       	ld	r24, Z
    11b4:	8d 7f       	andi	r24, 0xFD	; 253
    11b6:	80 83       	st	Z, r24
    11b8:	23 c0       	rjmp	.+70     	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 2:
						DDRD.Bits.Pin2 =0;
    11ba:	e1 e3       	ldi	r30, 0x31	; 49
    11bc:	f0 e0       	ldi	r31, 0x00	; 0
    11be:	80 81       	ld	r24, Z
    11c0:	8b 7f       	andi	r24, 0xFB	; 251
    11c2:	80 83       	st	Z, r24
    11c4:	1d c0       	rjmp	.+58     	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 3:
						DDRD.Bits.Pin3 =0;
    11c6:	e1 e3       	ldi	r30, 0x31	; 49
    11c8:	f0 e0       	ldi	r31, 0x00	; 0
    11ca:	80 81       	ld	r24, Z
    11cc:	87 7f       	andi	r24, 0xF7	; 247
    11ce:	80 83       	st	Z, r24
    11d0:	17 c0       	rjmp	.+46     	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 4:
						DDRD.Bits.Pin4 =0;
    11d2:	e1 e3       	ldi	r30, 0x31	; 49
    11d4:	f0 e0       	ldi	r31, 0x00	; 0
    11d6:	80 81       	ld	r24, Z
    11d8:	8f 7e       	andi	r24, 0xEF	; 239
    11da:	80 83       	st	Z, r24
    11dc:	11 c0       	rjmp	.+34     	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 5:
						DDRD.Bits.Pin5 =0;
    11de:	e1 e3       	ldi	r30, 0x31	; 49
    11e0:	f0 e0       	ldi	r31, 0x00	; 0
    11e2:	80 81       	ld	r24, Z
    11e4:	8f 7d       	andi	r24, 0xDF	; 223
    11e6:	80 83       	st	Z, r24
    11e8:	0b c0       	rjmp	.+22     	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 6:
						DDRD.Bits.Pin6 =0;
    11ea:	e1 e3       	ldi	r30, 0x31	; 49
    11ec:	f0 e0       	ldi	r31, 0x00	; 0
    11ee:	80 81       	ld	r24, Z
    11f0:	8f 7b       	andi	r24, 0xBF	; 191
    11f2:	80 83       	st	Z, r24
    11f4:	05 c0       	rjmp	.+10     	; 0x1200 <Dio_vidSetPinDir+0x6ba>
					break;

					case 7:
						DDRD.Bits.Pin7 =0;
    11f6:	e1 e3       	ldi	r30, 0x31	; 49
    11f8:	f0 e0       	ldi	r31, 0x00	; 0
    11fa:	80 81       	ld	r24, Z
    11fc:	8f 77       	andi	r24, 0x7F	; 127
    11fe:	80 83       	st	Z, r24
					break;
				}
			}
		break;
	}
}
    1200:	66 96       	adiw	r28, 0x16	; 22
    1202:	0f b6       	in	r0, 0x3f	; 63
    1204:	f8 94       	cli
    1206:	de bf       	out	0x3e, r29	; 62
    1208:	0f be       	out	0x3f, r0	; 63
    120a:	cd bf       	out	0x3d, r28	; 61
    120c:	cf 91       	pop	r28
    120e:	df 91       	pop	r29
    1210:	08 95       	ret

00001212 <Dio_vidSetPinVal>:

void Dio_vidSetPinVal(u8 Pin , u8 Val)
{
    1212:	df 93       	push	r29
    1214:	cf 93       	push	r28
    1216:	cd b7       	in	r28, 0x3d	; 61
    1218:	de b7       	in	r29, 0x3e	; 62
    121a:	66 97       	sbiw	r28, 0x16	; 22
    121c:	0f b6       	in	r0, 0x3f	; 63
    121e:	f8 94       	cli
    1220:	de bf       	out	0x3e, r29	; 62
    1222:	0f be       	out	0x3f, r0	; 63
    1224:	cd bf       	out	0x3d, r28	; 61
    1226:	8b 83       	std	Y+3, r24	; 0x03
    1228:	6c 83       	std	Y+4, r22	; 0x04
	u8 PortId;
	u8 PinLoc;

	PortId = Pin/8;
    122a:	8b 81       	ldd	r24, Y+3	; 0x03
    122c:	86 95       	lsr	r24
    122e:	86 95       	lsr	r24
    1230:	86 95       	lsr	r24
    1232:	8a 83       	std	Y+2, r24	; 0x02
	PinLoc = Pin%8;
    1234:	8b 81       	ldd	r24, Y+3	; 0x03
    1236:	87 70       	andi	r24, 0x07	; 7
    1238:	89 83       	std	Y+1, r24	; 0x01

	switch(PortId){
    123a:	8a 81       	ldd	r24, Y+2	; 0x02
    123c:	28 2f       	mov	r18, r24
    123e:	30 e0       	ldi	r19, 0x00	; 0
    1240:	3e 8b       	std	Y+22, r19	; 0x16
    1242:	2d 8b       	std	Y+21, r18	; 0x15
    1244:	8d 89       	ldd	r24, Y+21	; 0x15
    1246:	9e 89       	ldd	r25, Y+22	; 0x16
    1248:	81 30       	cpi	r24, 0x01	; 1
    124a:	91 05       	cpc	r25, r1
    124c:	09 f4       	brne	.+2      	; 0x1250 <Dio_vidSetPinVal+0x3e>
    124e:	e1 c0       	rjmp	.+450    	; 0x1412 <Dio_vidSetPinVal+0x200>
    1250:	2d 89       	ldd	r18, Y+21	; 0x15
    1252:	3e 89       	ldd	r19, Y+22	; 0x16
    1254:	22 30       	cpi	r18, 0x02	; 2
    1256:	31 05       	cpc	r19, r1
    1258:	2c f4       	brge	.+10     	; 0x1264 <Dio_vidSetPinVal+0x52>
    125a:	8d 89       	ldd	r24, Y+21	; 0x15
    125c:	9e 89       	ldd	r25, Y+22	; 0x16
    125e:	00 97       	sbiw	r24, 0x00	; 0
    1260:	71 f0       	breq	.+28     	; 0x127e <Dio_vidSetPinVal+0x6c>
    1262:	34 c3       	rjmp	.+1640   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
    1264:	2d 89       	ldd	r18, Y+21	; 0x15
    1266:	3e 89       	ldd	r19, Y+22	; 0x16
    1268:	22 30       	cpi	r18, 0x02	; 2
    126a:	31 05       	cpc	r19, r1
    126c:	09 f4       	brne	.+2      	; 0x1270 <Dio_vidSetPinVal+0x5e>
    126e:	9b c1       	rjmp	.+822    	; 0x15a6 <Dio_vidSetPinVal+0x394>
    1270:	8d 89       	ldd	r24, Y+21	; 0x15
    1272:	9e 89       	ldd	r25, Y+22	; 0x16
    1274:	83 30       	cpi	r24, 0x03	; 3
    1276:	91 05       	cpc	r25, r1
    1278:	09 f4       	brne	.+2      	; 0x127c <Dio_vidSetPinVal+0x6a>
    127a:	5f c2       	rjmp	.+1214   	; 0x173a <Dio_vidSetPinVal+0x528>
    127c:	27 c3       	rjmp	.+1614   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
		case 0:
			if(Val ==1)
    127e:	8c 81       	ldd	r24, Y+4	; 0x04
    1280:	81 30       	cpi	r24, 0x01	; 1
    1282:	09 f0       	breq	.+2      	; 0x1286 <Dio_vidSetPinVal+0x74>
    1284:	63 c0       	rjmp	.+198    	; 0x134c <Dio_vidSetPinVal+0x13a>
				{
					switch(PinLoc)
    1286:	89 81       	ldd	r24, Y+1	; 0x01
    1288:	28 2f       	mov	r18, r24
    128a:	30 e0       	ldi	r19, 0x00	; 0
    128c:	3c 8b       	std	Y+20, r19	; 0x14
    128e:	2b 8b       	std	Y+19, r18	; 0x13
    1290:	8b 89       	ldd	r24, Y+19	; 0x13
    1292:	9c 89       	ldd	r25, Y+20	; 0x14
    1294:	83 30       	cpi	r24, 0x03	; 3
    1296:	91 05       	cpc	r25, r1
    1298:	d9 f1       	breq	.+118    	; 0x1310 <Dio_vidSetPinVal+0xfe>
    129a:	2b 89       	ldd	r18, Y+19	; 0x13
    129c:	3c 89       	ldd	r19, Y+20	; 0x14
    129e:	24 30       	cpi	r18, 0x04	; 4
    12a0:	31 05       	cpc	r19, r1
    12a2:	7c f4       	brge	.+30     	; 0x12c2 <Dio_vidSetPinVal+0xb0>
    12a4:	8b 89       	ldd	r24, Y+19	; 0x13
    12a6:	9c 89       	ldd	r25, Y+20	; 0x14
    12a8:	81 30       	cpi	r24, 0x01	; 1
    12aa:	91 05       	cpc	r25, r1
    12ac:	29 f1       	breq	.+74     	; 0x12f8 <Dio_vidSetPinVal+0xe6>
    12ae:	2b 89       	ldd	r18, Y+19	; 0x13
    12b0:	3c 89       	ldd	r19, Y+20	; 0x14
    12b2:	22 30       	cpi	r18, 0x02	; 2
    12b4:	31 05       	cpc	r19, r1
    12b6:	34 f5       	brge	.+76     	; 0x1304 <Dio_vidSetPinVal+0xf2>
    12b8:	8b 89       	ldd	r24, Y+19	; 0x13
    12ba:	9c 89       	ldd	r25, Y+20	; 0x14
    12bc:	00 97       	sbiw	r24, 0x00	; 0
    12be:	b1 f0       	breq	.+44     	; 0x12ec <Dio_vidSetPinVal+0xda>
    12c0:	05 c3       	rjmp	.+1546   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
    12c2:	2b 89       	ldd	r18, Y+19	; 0x13
    12c4:	3c 89       	ldd	r19, Y+20	; 0x14
    12c6:	25 30       	cpi	r18, 0x05	; 5
    12c8:	31 05       	cpc	r19, r1
    12ca:	71 f1       	breq	.+92     	; 0x1328 <Dio_vidSetPinVal+0x116>
    12cc:	8b 89       	ldd	r24, Y+19	; 0x13
    12ce:	9c 89       	ldd	r25, Y+20	; 0x14
    12d0:	85 30       	cpi	r24, 0x05	; 5
    12d2:	91 05       	cpc	r25, r1
    12d4:	1c f1       	brlt	.+70     	; 0x131c <Dio_vidSetPinVal+0x10a>
    12d6:	2b 89       	ldd	r18, Y+19	; 0x13
    12d8:	3c 89       	ldd	r19, Y+20	; 0x14
    12da:	26 30       	cpi	r18, 0x06	; 6
    12dc:	31 05       	cpc	r19, r1
    12de:	51 f1       	breq	.+84     	; 0x1334 <Dio_vidSetPinVal+0x122>
    12e0:	8b 89       	ldd	r24, Y+19	; 0x13
    12e2:	9c 89       	ldd	r25, Y+20	; 0x14
    12e4:	87 30       	cpi	r24, 0x07	; 7
    12e6:	91 05       	cpc	r25, r1
    12e8:	59 f1       	breq	.+86     	; 0x1340 <Dio_vidSetPinVal+0x12e>
    12ea:	f0 c2       	rjmp	.+1504   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					{
						case 0:
							PORTA.Bits.Pin0 =1;
    12ec:	eb e3       	ldi	r30, 0x3B	; 59
    12ee:	f0 e0       	ldi	r31, 0x00	; 0
    12f0:	80 81       	ld	r24, Z
    12f2:	81 60       	ori	r24, 0x01	; 1
    12f4:	80 83       	st	Z, r24
    12f6:	ea c2       	rjmp	.+1492   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 1:
							PORTA.Bits.Pin1 =1;
    12f8:	eb e3       	ldi	r30, 0x3B	; 59
    12fa:	f0 e0       	ldi	r31, 0x00	; 0
    12fc:	80 81       	ld	r24, Z
    12fe:	82 60       	ori	r24, 0x02	; 2
    1300:	80 83       	st	Z, r24
    1302:	e4 c2       	rjmp	.+1480   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 2:
							PORTA.Bits.Pin2 =1;
    1304:	eb e3       	ldi	r30, 0x3B	; 59
    1306:	f0 e0       	ldi	r31, 0x00	; 0
    1308:	80 81       	ld	r24, Z
    130a:	84 60       	ori	r24, 0x04	; 4
    130c:	80 83       	st	Z, r24
    130e:	de c2       	rjmp	.+1468   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 3:
							PORTA.Bits.Pin3 =1;
    1310:	eb e3       	ldi	r30, 0x3B	; 59
    1312:	f0 e0       	ldi	r31, 0x00	; 0
    1314:	80 81       	ld	r24, Z
    1316:	88 60       	ori	r24, 0x08	; 8
    1318:	80 83       	st	Z, r24
    131a:	d8 c2       	rjmp	.+1456   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 4:
							PORTA.Bits.Pin4 =1;
    131c:	eb e3       	ldi	r30, 0x3B	; 59
    131e:	f0 e0       	ldi	r31, 0x00	; 0
    1320:	80 81       	ld	r24, Z
    1322:	80 61       	ori	r24, 0x10	; 16
    1324:	80 83       	st	Z, r24
    1326:	d2 c2       	rjmp	.+1444   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 5:
							PORTA.Bits.Pin5 =1;
    1328:	eb e3       	ldi	r30, 0x3B	; 59
    132a:	f0 e0       	ldi	r31, 0x00	; 0
    132c:	80 81       	ld	r24, Z
    132e:	80 62       	ori	r24, 0x20	; 32
    1330:	80 83       	st	Z, r24
    1332:	cc c2       	rjmp	.+1432   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 6:
							PORTA.Bits.Pin6 =1;
    1334:	eb e3       	ldi	r30, 0x3B	; 59
    1336:	f0 e0       	ldi	r31, 0x00	; 0
    1338:	80 81       	ld	r24, Z
    133a:	80 64       	ori	r24, 0x40	; 64
    133c:	80 83       	st	Z, r24
    133e:	c6 c2       	rjmp	.+1420   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 7:
							PORTA.Bits.Pin7 =1;
    1340:	eb e3       	ldi	r30, 0x3B	; 59
    1342:	f0 e0       	ldi	r31, 0x00	; 0
    1344:	80 81       	ld	r24, Z
    1346:	80 68       	ori	r24, 0x80	; 128
    1348:	80 83       	st	Z, r24
    134a:	c0 c2       	rjmp	.+1408   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;
					}
				}
			else
			{
				switch(PinLoc)
    134c:	89 81       	ldd	r24, Y+1	; 0x01
    134e:	28 2f       	mov	r18, r24
    1350:	30 e0       	ldi	r19, 0x00	; 0
    1352:	3a 8b       	std	Y+18, r19	; 0x12
    1354:	29 8b       	std	Y+17, r18	; 0x11
    1356:	89 89       	ldd	r24, Y+17	; 0x11
    1358:	9a 89       	ldd	r25, Y+18	; 0x12
    135a:	83 30       	cpi	r24, 0x03	; 3
    135c:	91 05       	cpc	r25, r1
    135e:	d9 f1       	breq	.+118    	; 0x13d6 <Dio_vidSetPinVal+0x1c4>
    1360:	29 89       	ldd	r18, Y+17	; 0x11
    1362:	3a 89       	ldd	r19, Y+18	; 0x12
    1364:	24 30       	cpi	r18, 0x04	; 4
    1366:	31 05       	cpc	r19, r1
    1368:	7c f4       	brge	.+30     	; 0x1388 <Dio_vidSetPinVal+0x176>
    136a:	89 89       	ldd	r24, Y+17	; 0x11
    136c:	9a 89       	ldd	r25, Y+18	; 0x12
    136e:	81 30       	cpi	r24, 0x01	; 1
    1370:	91 05       	cpc	r25, r1
    1372:	29 f1       	breq	.+74     	; 0x13be <Dio_vidSetPinVal+0x1ac>
    1374:	29 89       	ldd	r18, Y+17	; 0x11
    1376:	3a 89       	ldd	r19, Y+18	; 0x12
    1378:	22 30       	cpi	r18, 0x02	; 2
    137a:	31 05       	cpc	r19, r1
    137c:	34 f5       	brge	.+76     	; 0x13ca <Dio_vidSetPinVal+0x1b8>
    137e:	89 89       	ldd	r24, Y+17	; 0x11
    1380:	9a 89       	ldd	r25, Y+18	; 0x12
    1382:	00 97       	sbiw	r24, 0x00	; 0
    1384:	b1 f0       	breq	.+44     	; 0x13b2 <Dio_vidSetPinVal+0x1a0>
    1386:	a2 c2       	rjmp	.+1348   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
    1388:	29 89       	ldd	r18, Y+17	; 0x11
    138a:	3a 89       	ldd	r19, Y+18	; 0x12
    138c:	25 30       	cpi	r18, 0x05	; 5
    138e:	31 05       	cpc	r19, r1
    1390:	71 f1       	breq	.+92     	; 0x13ee <Dio_vidSetPinVal+0x1dc>
    1392:	89 89       	ldd	r24, Y+17	; 0x11
    1394:	9a 89       	ldd	r25, Y+18	; 0x12
    1396:	85 30       	cpi	r24, 0x05	; 5
    1398:	91 05       	cpc	r25, r1
    139a:	1c f1       	brlt	.+70     	; 0x13e2 <Dio_vidSetPinVal+0x1d0>
    139c:	29 89       	ldd	r18, Y+17	; 0x11
    139e:	3a 89       	ldd	r19, Y+18	; 0x12
    13a0:	26 30       	cpi	r18, 0x06	; 6
    13a2:	31 05       	cpc	r19, r1
    13a4:	51 f1       	breq	.+84     	; 0x13fa <Dio_vidSetPinVal+0x1e8>
    13a6:	89 89       	ldd	r24, Y+17	; 0x11
    13a8:	9a 89       	ldd	r25, Y+18	; 0x12
    13aa:	87 30       	cpi	r24, 0x07	; 7
    13ac:	91 05       	cpc	r25, r1
    13ae:	59 f1       	breq	.+86     	; 0x1406 <Dio_vidSetPinVal+0x1f4>
    13b0:	8d c2       	rjmp	.+1306   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
				{
					case 0:
						PORTA.Bits.Pin0 =0;
    13b2:	eb e3       	ldi	r30, 0x3B	; 59
    13b4:	f0 e0       	ldi	r31, 0x00	; 0
    13b6:	80 81       	ld	r24, Z
    13b8:	8e 7f       	andi	r24, 0xFE	; 254
    13ba:	80 83       	st	Z, r24
    13bc:	87 c2       	rjmp	.+1294   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 1:
						PORTA.Bits.Pin1 =0;
    13be:	eb e3       	ldi	r30, 0x3B	; 59
    13c0:	f0 e0       	ldi	r31, 0x00	; 0
    13c2:	80 81       	ld	r24, Z
    13c4:	8d 7f       	andi	r24, 0xFD	; 253
    13c6:	80 83       	st	Z, r24
    13c8:	81 c2       	rjmp	.+1282   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 2:
						PORTA.Bits.Pin2 =0;
    13ca:	eb e3       	ldi	r30, 0x3B	; 59
    13cc:	f0 e0       	ldi	r31, 0x00	; 0
    13ce:	80 81       	ld	r24, Z
    13d0:	8b 7f       	andi	r24, 0xFB	; 251
    13d2:	80 83       	st	Z, r24
    13d4:	7b c2       	rjmp	.+1270   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 3:
						PORTA.Bits.Pin3 =0;
    13d6:	eb e3       	ldi	r30, 0x3B	; 59
    13d8:	f0 e0       	ldi	r31, 0x00	; 0
    13da:	80 81       	ld	r24, Z
    13dc:	87 7f       	andi	r24, 0xF7	; 247
    13de:	80 83       	st	Z, r24
    13e0:	75 c2       	rjmp	.+1258   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 4:
						PORTA.Bits.Pin4 =0;
    13e2:	eb e3       	ldi	r30, 0x3B	; 59
    13e4:	f0 e0       	ldi	r31, 0x00	; 0
    13e6:	80 81       	ld	r24, Z
    13e8:	8f 7e       	andi	r24, 0xEF	; 239
    13ea:	80 83       	st	Z, r24
    13ec:	6f c2       	rjmp	.+1246   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 5:
						PORTA.Bits.Pin5 =0;
    13ee:	eb e3       	ldi	r30, 0x3B	; 59
    13f0:	f0 e0       	ldi	r31, 0x00	; 0
    13f2:	80 81       	ld	r24, Z
    13f4:	8f 7d       	andi	r24, 0xDF	; 223
    13f6:	80 83       	st	Z, r24
    13f8:	69 c2       	rjmp	.+1234   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 6:
						PORTA.Bits.Pin6 =0;
    13fa:	eb e3       	ldi	r30, 0x3B	; 59
    13fc:	f0 e0       	ldi	r31, 0x00	; 0
    13fe:	80 81       	ld	r24, Z
    1400:	8f 7b       	andi	r24, 0xBF	; 191
    1402:	80 83       	st	Z, r24
    1404:	63 c2       	rjmp	.+1222   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 7:
						PORTA.Bits.Pin7 =0;
    1406:	eb e3       	ldi	r30, 0x3B	; 59
    1408:	f0 e0       	ldi	r31, 0x00	; 0
    140a:	80 81       	ld	r24, Z
    140c:	8f 77       	andi	r24, 0x7F	; 127
    140e:	80 83       	st	Z, r24
    1410:	5d c2       	rjmp	.+1210   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
				}
			}
		break;

		case 1:
			if(Val ==1)
    1412:	8c 81       	ldd	r24, Y+4	; 0x04
    1414:	81 30       	cpi	r24, 0x01	; 1
    1416:	09 f0       	breq	.+2      	; 0x141a <Dio_vidSetPinVal+0x208>
    1418:	63 c0       	rjmp	.+198    	; 0x14e0 <Dio_vidSetPinVal+0x2ce>
				{
					switch(PinLoc)
    141a:	89 81       	ldd	r24, Y+1	; 0x01
    141c:	28 2f       	mov	r18, r24
    141e:	30 e0       	ldi	r19, 0x00	; 0
    1420:	38 8b       	std	Y+16, r19	; 0x10
    1422:	2f 87       	std	Y+15, r18	; 0x0f
    1424:	8f 85       	ldd	r24, Y+15	; 0x0f
    1426:	98 89       	ldd	r25, Y+16	; 0x10
    1428:	83 30       	cpi	r24, 0x03	; 3
    142a:	91 05       	cpc	r25, r1
    142c:	d9 f1       	breq	.+118    	; 0x14a4 <Dio_vidSetPinVal+0x292>
    142e:	2f 85       	ldd	r18, Y+15	; 0x0f
    1430:	38 89       	ldd	r19, Y+16	; 0x10
    1432:	24 30       	cpi	r18, 0x04	; 4
    1434:	31 05       	cpc	r19, r1
    1436:	7c f4       	brge	.+30     	; 0x1456 <Dio_vidSetPinVal+0x244>
    1438:	8f 85       	ldd	r24, Y+15	; 0x0f
    143a:	98 89       	ldd	r25, Y+16	; 0x10
    143c:	81 30       	cpi	r24, 0x01	; 1
    143e:	91 05       	cpc	r25, r1
    1440:	29 f1       	breq	.+74     	; 0x148c <Dio_vidSetPinVal+0x27a>
    1442:	2f 85       	ldd	r18, Y+15	; 0x0f
    1444:	38 89       	ldd	r19, Y+16	; 0x10
    1446:	22 30       	cpi	r18, 0x02	; 2
    1448:	31 05       	cpc	r19, r1
    144a:	34 f5       	brge	.+76     	; 0x1498 <Dio_vidSetPinVal+0x286>
    144c:	8f 85       	ldd	r24, Y+15	; 0x0f
    144e:	98 89       	ldd	r25, Y+16	; 0x10
    1450:	00 97       	sbiw	r24, 0x00	; 0
    1452:	b1 f0       	breq	.+44     	; 0x1480 <Dio_vidSetPinVal+0x26e>
    1454:	3b c2       	rjmp	.+1142   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
    1456:	2f 85       	ldd	r18, Y+15	; 0x0f
    1458:	38 89       	ldd	r19, Y+16	; 0x10
    145a:	25 30       	cpi	r18, 0x05	; 5
    145c:	31 05       	cpc	r19, r1
    145e:	71 f1       	breq	.+92     	; 0x14bc <Dio_vidSetPinVal+0x2aa>
    1460:	8f 85       	ldd	r24, Y+15	; 0x0f
    1462:	98 89       	ldd	r25, Y+16	; 0x10
    1464:	85 30       	cpi	r24, 0x05	; 5
    1466:	91 05       	cpc	r25, r1
    1468:	1c f1       	brlt	.+70     	; 0x14b0 <Dio_vidSetPinVal+0x29e>
    146a:	2f 85       	ldd	r18, Y+15	; 0x0f
    146c:	38 89       	ldd	r19, Y+16	; 0x10
    146e:	26 30       	cpi	r18, 0x06	; 6
    1470:	31 05       	cpc	r19, r1
    1472:	51 f1       	breq	.+84     	; 0x14c8 <Dio_vidSetPinVal+0x2b6>
    1474:	8f 85       	ldd	r24, Y+15	; 0x0f
    1476:	98 89       	ldd	r25, Y+16	; 0x10
    1478:	87 30       	cpi	r24, 0x07	; 7
    147a:	91 05       	cpc	r25, r1
    147c:	59 f1       	breq	.+86     	; 0x14d4 <Dio_vidSetPinVal+0x2c2>
    147e:	26 c2       	rjmp	.+1100   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					{
						case 0:
							PORTB.Bits.Pin0 =1;
    1480:	e8 e3       	ldi	r30, 0x38	; 56
    1482:	f0 e0       	ldi	r31, 0x00	; 0
    1484:	80 81       	ld	r24, Z
    1486:	81 60       	ori	r24, 0x01	; 1
    1488:	80 83       	st	Z, r24
    148a:	20 c2       	rjmp	.+1088   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 1:
							PORTB.Bits.Pin1 =1;
    148c:	e8 e3       	ldi	r30, 0x38	; 56
    148e:	f0 e0       	ldi	r31, 0x00	; 0
    1490:	80 81       	ld	r24, Z
    1492:	82 60       	ori	r24, 0x02	; 2
    1494:	80 83       	st	Z, r24
    1496:	1a c2       	rjmp	.+1076   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 2:
							PORTB.Bits.Pin2 =1;
    1498:	e8 e3       	ldi	r30, 0x38	; 56
    149a:	f0 e0       	ldi	r31, 0x00	; 0
    149c:	80 81       	ld	r24, Z
    149e:	84 60       	ori	r24, 0x04	; 4
    14a0:	80 83       	st	Z, r24
    14a2:	14 c2       	rjmp	.+1064   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 3:
							PORTB.Bits.Pin3 =1;
    14a4:	e8 e3       	ldi	r30, 0x38	; 56
    14a6:	f0 e0       	ldi	r31, 0x00	; 0
    14a8:	80 81       	ld	r24, Z
    14aa:	88 60       	ori	r24, 0x08	; 8
    14ac:	80 83       	st	Z, r24
    14ae:	0e c2       	rjmp	.+1052   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 4:
							PORTB.Bits.Pin4 =1;
    14b0:	e8 e3       	ldi	r30, 0x38	; 56
    14b2:	f0 e0       	ldi	r31, 0x00	; 0
    14b4:	80 81       	ld	r24, Z
    14b6:	80 61       	ori	r24, 0x10	; 16
    14b8:	80 83       	st	Z, r24
    14ba:	08 c2       	rjmp	.+1040   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 5:
							PORTB.Bits.Pin5 =1;
    14bc:	e8 e3       	ldi	r30, 0x38	; 56
    14be:	f0 e0       	ldi	r31, 0x00	; 0
    14c0:	80 81       	ld	r24, Z
    14c2:	80 62       	ori	r24, 0x20	; 32
    14c4:	80 83       	st	Z, r24
    14c6:	02 c2       	rjmp	.+1028   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 6:
							PORTB.Bits.Pin6 =1;
    14c8:	e8 e3       	ldi	r30, 0x38	; 56
    14ca:	f0 e0       	ldi	r31, 0x00	; 0
    14cc:	80 81       	ld	r24, Z
    14ce:	80 64       	ori	r24, 0x40	; 64
    14d0:	80 83       	st	Z, r24
    14d2:	fc c1       	rjmp	.+1016   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 7:
							PORTB.Bits.Pin7 =1;
    14d4:	e8 e3       	ldi	r30, 0x38	; 56
    14d6:	f0 e0       	ldi	r31, 0x00	; 0
    14d8:	80 81       	ld	r24, Z
    14da:	80 68       	ori	r24, 0x80	; 128
    14dc:	80 83       	st	Z, r24
    14de:	f6 c1       	rjmp	.+1004   	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;
					}
				}
			else
			{
				switch(PinLoc)
    14e0:	89 81       	ldd	r24, Y+1	; 0x01
    14e2:	28 2f       	mov	r18, r24
    14e4:	30 e0       	ldi	r19, 0x00	; 0
    14e6:	3e 87       	std	Y+14, r19	; 0x0e
    14e8:	2d 87       	std	Y+13, r18	; 0x0d
    14ea:	8d 85       	ldd	r24, Y+13	; 0x0d
    14ec:	9e 85       	ldd	r25, Y+14	; 0x0e
    14ee:	83 30       	cpi	r24, 0x03	; 3
    14f0:	91 05       	cpc	r25, r1
    14f2:	d9 f1       	breq	.+118    	; 0x156a <Dio_vidSetPinVal+0x358>
    14f4:	2d 85       	ldd	r18, Y+13	; 0x0d
    14f6:	3e 85       	ldd	r19, Y+14	; 0x0e
    14f8:	24 30       	cpi	r18, 0x04	; 4
    14fa:	31 05       	cpc	r19, r1
    14fc:	7c f4       	brge	.+30     	; 0x151c <Dio_vidSetPinVal+0x30a>
    14fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1500:	9e 85       	ldd	r25, Y+14	; 0x0e
    1502:	81 30       	cpi	r24, 0x01	; 1
    1504:	91 05       	cpc	r25, r1
    1506:	29 f1       	breq	.+74     	; 0x1552 <Dio_vidSetPinVal+0x340>
    1508:	2d 85       	ldd	r18, Y+13	; 0x0d
    150a:	3e 85       	ldd	r19, Y+14	; 0x0e
    150c:	22 30       	cpi	r18, 0x02	; 2
    150e:	31 05       	cpc	r19, r1
    1510:	34 f5       	brge	.+76     	; 0x155e <Dio_vidSetPinVal+0x34c>
    1512:	8d 85       	ldd	r24, Y+13	; 0x0d
    1514:	9e 85       	ldd	r25, Y+14	; 0x0e
    1516:	00 97       	sbiw	r24, 0x00	; 0
    1518:	b1 f0       	breq	.+44     	; 0x1546 <Dio_vidSetPinVal+0x334>
    151a:	d8 c1       	rjmp	.+944    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
    151c:	2d 85       	ldd	r18, Y+13	; 0x0d
    151e:	3e 85       	ldd	r19, Y+14	; 0x0e
    1520:	25 30       	cpi	r18, 0x05	; 5
    1522:	31 05       	cpc	r19, r1
    1524:	71 f1       	breq	.+92     	; 0x1582 <Dio_vidSetPinVal+0x370>
    1526:	8d 85       	ldd	r24, Y+13	; 0x0d
    1528:	9e 85       	ldd	r25, Y+14	; 0x0e
    152a:	85 30       	cpi	r24, 0x05	; 5
    152c:	91 05       	cpc	r25, r1
    152e:	1c f1       	brlt	.+70     	; 0x1576 <Dio_vidSetPinVal+0x364>
    1530:	2d 85       	ldd	r18, Y+13	; 0x0d
    1532:	3e 85       	ldd	r19, Y+14	; 0x0e
    1534:	26 30       	cpi	r18, 0x06	; 6
    1536:	31 05       	cpc	r19, r1
    1538:	51 f1       	breq	.+84     	; 0x158e <Dio_vidSetPinVal+0x37c>
    153a:	8d 85       	ldd	r24, Y+13	; 0x0d
    153c:	9e 85       	ldd	r25, Y+14	; 0x0e
    153e:	87 30       	cpi	r24, 0x07	; 7
    1540:	91 05       	cpc	r25, r1
    1542:	59 f1       	breq	.+86     	; 0x159a <Dio_vidSetPinVal+0x388>
    1544:	c3 c1       	rjmp	.+902    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
				{
					case 0:
						PORTB.Bits.Pin0 =0;
    1546:	e8 e3       	ldi	r30, 0x38	; 56
    1548:	f0 e0       	ldi	r31, 0x00	; 0
    154a:	80 81       	ld	r24, Z
    154c:	8e 7f       	andi	r24, 0xFE	; 254
    154e:	80 83       	st	Z, r24
    1550:	bd c1       	rjmp	.+890    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 1:
						PORTB.Bits.Pin1 =0;
    1552:	e8 e3       	ldi	r30, 0x38	; 56
    1554:	f0 e0       	ldi	r31, 0x00	; 0
    1556:	80 81       	ld	r24, Z
    1558:	8d 7f       	andi	r24, 0xFD	; 253
    155a:	80 83       	st	Z, r24
    155c:	b7 c1       	rjmp	.+878    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 2:
						PORTB.Bits.Pin2 =0;
    155e:	e8 e3       	ldi	r30, 0x38	; 56
    1560:	f0 e0       	ldi	r31, 0x00	; 0
    1562:	80 81       	ld	r24, Z
    1564:	8b 7f       	andi	r24, 0xFB	; 251
    1566:	80 83       	st	Z, r24
    1568:	b1 c1       	rjmp	.+866    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 3:
						PORTB.Bits.Pin3 =0;
    156a:	e8 e3       	ldi	r30, 0x38	; 56
    156c:	f0 e0       	ldi	r31, 0x00	; 0
    156e:	80 81       	ld	r24, Z
    1570:	87 7f       	andi	r24, 0xF7	; 247
    1572:	80 83       	st	Z, r24
    1574:	ab c1       	rjmp	.+854    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 4:
						PORTB.Bits.Pin4 =0;
    1576:	e8 e3       	ldi	r30, 0x38	; 56
    1578:	f0 e0       	ldi	r31, 0x00	; 0
    157a:	80 81       	ld	r24, Z
    157c:	8f 7e       	andi	r24, 0xEF	; 239
    157e:	80 83       	st	Z, r24
    1580:	a5 c1       	rjmp	.+842    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 5:
						PORTB.Bits.Pin5 =0;
    1582:	e8 e3       	ldi	r30, 0x38	; 56
    1584:	f0 e0       	ldi	r31, 0x00	; 0
    1586:	80 81       	ld	r24, Z
    1588:	8f 7d       	andi	r24, 0xDF	; 223
    158a:	80 83       	st	Z, r24
    158c:	9f c1       	rjmp	.+830    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 6:
						PORTB.Bits.Pin6 =0;
    158e:	e8 e3       	ldi	r30, 0x38	; 56
    1590:	f0 e0       	ldi	r31, 0x00	; 0
    1592:	80 81       	ld	r24, Z
    1594:	8f 7b       	andi	r24, 0xBF	; 191
    1596:	80 83       	st	Z, r24
    1598:	99 c1       	rjmp	.+818    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 7:
						PORTB.Bits.Pin7 =0;
    159a:	e8 e3       	ldi	r30, 0x38	; 56
    159c:	f0 e0       	ldi	r31, 0x00	; 0
    159e:	80 81       	ld	r24, Z
    15a0:	8f 77       	andi	r24, 0x7F	; 127
    15a2:	80 83       	st	Z, r24
    15a4:	93 c1       	rjmp	.+806    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
				}
			}
			break;

		case 2:
			if(Val ==1)
    15a6:	8c 81       	ldd	r24, Y+4	; 0x04
    15a8:	81 30       	cpi	r24, 0x01	; 1
    15aa:	09 f0       	breq	.+2      	; 0x15ae <Dio_vidSetPinVal+0x39c>
    15ac:	63 c0       	rjmp	.+198    	; 0x1674 <Dio_vidSetPinVal+0x462>
				{
					switch(PinLoc)
    15ae:	89 81       	ldd	r24, Y+1	; 0x01
    15b0:	28 2f       	mov	r18, r24
    15b2:	30 e0       	ldi	r19, 0x00	; 0
    15b4:	3c 87       	std	Y+12, r19	; 0x0c
    15b6:	2b 87       	std	Y+11, r18	; 0x0b
    15b8:	8b 85       	ldd	r24, Y+11	; 0x0b
    15ba:	9c 85       	ldd	r25, Y+12	; 0x0c
    15bc:	83 30       	cpi	r24, 0x03	; 3
    15be:	91 05       	cpc	r25, r1
    15c0:	d9 f1       	breq	.+118    	; 0x1638 <Dio_vidSetPinVal+0x426>
    15c2:	2b 85       	ldd	r18, Y+11	; 0x0b
    15c4:	3c 85       	ldd	r19, Y+12	; 0x0c
    15c6:	24 30       	cpi	r18, 0x04	; 4
    15c8:	31 05       	cpc	r19, r1
    15ca:	7c f4       	brge	.+30     	; 0x15ea <Dio_vidSetPinVal+0x3d8>
    15cc:	8b 85       	ldd	r24, Y+11	; 0x0b
    15ce:	9c 85       	ldd	r25, Y+12	; 0x0c
    15d0:	81 30       	cpi	r24, 0x01	; 1
    15d2:	91 05       	cpc	r25, r1
    15d4:	29 f1       	breq	.+74     	; 0x1620 <Dio_vidSetPinVal+0x40e>
    15d6:	2b 85       	ldd	r18, Y+11	; 0x0b
    15d8:	3c 85       	ldd	r19, Y+12	; 0x0c
    15da:	22 30       	cpi	r18, 0x02	; 2
    15dc:	31 05       	cpc	r19, r1
    15de:	34 f5       	brge	.+76     	; 0x162c <Dio_vidSetPinVal+0x41a>
    15e0:	8b 85       	ldd	r24, Y+11	; 0x0b
    15e2:	9c 85       	ldd	r25, Y+12	; 0x0c
    15e4:	00 97       	sbiw	r24, 0x00	; 0
    15e6:	b1 f0       	breq	.+44     	; 0x1614 <Dio_vidSetPinVal+0x402>
    15e8:	71 c1       	rjmp	.+738    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
    15ea:	2b 85       	ldd	r18, Y+11	; 0x0b
    15ec:	3c 85       	ldd	r19, Y+12	; 0x0c
    15ee:	25 30       	cpi	r18, 0x05	; 5
    15f0:	31 05       	cpc	r19, r1
    15f2:	71 f1       	breq	.+92     	; 0x1650 <Dio_vidSetPinVal+0x43e>
    15f4:	8b 85       	ldd	r24, Y+11	; 0x0b
    15f6:	9c 85       	ldd	r25, Y+12	; 0x0c
    15f8:	85 30       	cpi	r24, 0x05	; 5
    15fa:	91 05       	cpc	r25, r1
    15fc:	1c f1       	brlt	.+70     	; 0x1644 <Dio_vidSetPinVal+0x432>
    15fe:	2b 85       	ldd	r18, Y+11	; 0x0b
    1600:	3c 85       	ldd	r19, Y+12	; 0x0c
    1602:	26 30       	cpi	r18, 0x06	; 6
    1604:	31 05       	cpc	r19, r1
    1606:	51 f1       	breq	.+84     	; 0x165c <Dio_vidSetPinVal+0x44a>
    1608:	8b 85       	ldd	r24, Y+11	; 0x0b
    160a:	9c 85       	ldd	r25, Y+12	; 0x0c
    160c:	87 30       	cpi	r24, 0x07	; 7
    160e:	91 05       	cpc	r25, r1
    1610:	59 f1       	breq	.+86     	; 0x1668 <Dio_vidSetPinVal+0x456>
    1612:	5c c1       	rjmp	.+696    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					{
						case 0:
							PORTC.Bits.Pin0 =1;
    1614:	e5 e3       	ldi	r30, 0x35	; 53
    1616:	f0 e0       	ldi	r31, 0x00	; 0
    1618:	80 81       	ld	r24, Z
    161a:	81 60       	ori	r24, 0x01	; 1
    161c:	80 83       	st	Z, r24
    161e:	56 c1       	rjmp	.+684    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 1:
							PORTC.Bits.Pin1 =1;
    1620:	e5 e3       	ldi	r30, 0x35	; 53
    1622:	f0 e0       	ldi	r31, 0x00	; 0
    1624:	80 81       	ld	r24, Z
    1626:	82 60       	ori	r24, 0x02	; 2
    1628:	80 83       	st	Z, r24
    162a:	50 c1       	rjmp	.+672    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 2:
							PORTC.Bits.Pin2 =1;
    162c:	e5 e3       	ldi	r30, 0x35	; 53
    162e:	f0 e0       	ldi	r31, 0x00	; 0
    1630:	80 81       	ld	r24, Z
    1632:	84 60       	ori	r24, 0x04	; 4
    1634:	80 83       	st	Z, r24
    1636:	4a c1       	rjmp	.+660    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 3:
							PORTC.Bits.Pin3 =1;
    1638:	e5 e3       	ldi	r30, 0x35	; 53
    163a:	f0 e0       	ldi	r31, 0x00	; 0
    163c:	80 81       	ld	r24, Z
    163e:	88 60       	ori	r24, 0x08	; 8
    1640:	80 83       	st	Z, r24
    1642:	44 c1       	rjmp	.+648    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 4:
							PORTC.Bits.Pin4 =1;
    1644:	e5 e3       	ldi	r30, 0x35	; 53
    1646:	f0 e0       	ldi	r31, 0x00	; 0
    1648:	80 81       	ld	r24, Z
    164a:	80 61       	ori	r24, 0x10	; 16
    164c:	80 83       	st	Z, r24
    164e:	3e c1       	rjmp	.+636    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 5:
							PORTC.Bits.Pin5 =1;
    1650:	e5 e3       	ldi	r30, 0x35	; 53
    1652:	f0 e0       	ldi	r31, 0x00	; 0
    1654:	80 81       	ld	r24, Z
    1656:	80 62       	ori	r24, 0x20	; 32
    1658:	80 83       	st	Z, r24
    165a:	38 c1       	rjmp	.+624    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 6:
							PORTC.Bits.Pin6 =1;
    165c:	e5 e3       	ldi	r30, 0x35	; 53
    165e:	f0 e0       	ldi	r31, 0x00	; 0
    1660:	80 81       	ld	r24, Z
    1662:	80 64       	ori	r24, 0x40	; 64
    1664:	80 83       	st	Z, r24
    1666:	32 c1       	rjmp	.+612    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 7:
							PORTC.Bits.Pin7 =1;
    1668:	e5 e3       	ldi	r30, 0x35	; 53
    166a:	f0 e0       	ldi	r31, 0x00	; 0
    166c:	80 81       	ld	r24, Z
    166e:	80 68       	ori	r24, 0x80	; 128
    1670:	80 83       	st	Z, r24
    1672:	2c c1       	rjmp	.+600    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;
					}
				}
			else
			{
				switch(PinLoc)
    1674:	89 81       	ldd	r24, Y+1	; 0x01
    1676:	28 2f       	mov	r18, r24
    1678:	30 e0       	ldi	r19, 0x00	; 0
    167a:	3a 87       	std	Y+10, r19	; 0x0a
    167c:	29 87       	std	Y+9, r18	; 0x09
    167e:	89 85       	ldd	r24, Y+9	; 0x09
    1680:	9a 85       	ldd	r25, Y+10	; 0x0a
    1682:	83 30       	cpi	r24, 0x03	; 3
    1684:	91 05       	cpc	r25, r1
    1686:	d9 f1       	breq	.+118    	; 0x16fe <Dio_vidSetPinVal+0x4ec>
    1688:	29 85       	ldd	r18, Y+9	; 0x09
    168a:	3a 85       	ldd	r19, Y+10	; 0x0a
    168c:	24 30       	cpi	r18, 0x04	; 4
    168e:	31 05       	cpc	r19, r1
    1690:	7c f4       	brge	.+30     	; 0x16b0 <Dio_vidSetPinVal+0x49e>
    1692:	89 85       	ldd	r24, Y+9	; 0x09
    1694:	9a 85       	ldd	r25, Y+10	; 0x0a
    1696:	81 30       	cpi	r24, 0x01	; 1
    1698:	91 05       	cpc	r25, r1
    169a:	29 f1       	breq	.+74     	; 0x16e6 <Dio_vidSetPinVal+0x4d4>
    169c:	29 85       	ldd	r18, Y+9	; 0x09
    169e:	3a 85       	ldd	r19, Y+10	; 0x0a
    16a0:	22 30       	cpi	r18, 0x02	; 2
    16a2:	31 05       	cpc	r19, r1
    16a4:	34 f5       	brge	.+76     	; 0x16f2 <Dio_vidSetPinVal+0x4e0>
    16a6:	89 85       	ldd	r24, Y+9	; 0x09
    16a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    16aa:	00 97       	sbiw	r24, 0x00	; 0
    16ac:	b1 f0       	breq	.+44     	; 0x16da <Dio_vidSetPinVal+0x4c8>
    16ae:	0e c1       	rjmp	.+540    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
    16b0:	29 85       	ldd	r18, Y+9	; 0x09
    16b2:	3a 85       	ldd	r19, Y+10	; 0x0a
    16b4:	25 30       	cpi	r18, 0x05	; 5
    16b6:	31 05       	cpc	r19, r1
    16b8:	71 f1       	breq	.+92     	; 0x1716 <Dio_vidSetPinVal+0x504>
    16ba:	89 85       	ldd	r24, Y+9	; 0x09
    16bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    16be:	85 30       	cpi	r24, 0x05	; 5
    16c0:	91 05       	cpc	r25, r1
    16c2:	1c f1       	brlt	.+70     	; 0x170a <Dio_vidSetPinVal+0x4f8>
    16c4:	29 85       	ldd	r18, Y+9	; 0x09
    16c6:	3a 85       	ldd	r19, Y+10	; 0x0a
    16c8:	26 30       	cpi	r18, 0x06	; 6
    16ca:	31 05       	cpc	r19, r1
    16cc:	51 f1       	breq	.+84     	; 0x1722 <Dio_vidSetPinVal+0x510>
    16ce:	89 85       	ldd	r24, Y+9	; 0x09
    16d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    16d2:	87 30       	cpi	r24, 0x07	; 7
    16d4:	91 05       	cpc	r25, r1
    16d6:	59 f1       	breq	.+86     	; 0x172e <Dio_vidSetPinVal+0x51c>
    16d8:	f9 c0       	rjmp	.+498    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
				{
					case 0:
						PORTC.Bits.Pin0 =0;
    16da:	e5 e3       	ldi	r30, 0x35	; 53
    16dc:	f0 e0       	ldi	r31, 0x00	; 0
    16de:	80 81       	ld	r24, Z
    16e0:	8e 7f       	andi	r24, 0xFE	; 254
    16e2:	80 83       	st	Z, r24
    16e4:	f3 c0       	rjmp	.+486    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 1:
						PORTC.Bits.Pin1 =0;
    16e6:	e5 e3       	ldi	r30, 0x35	; 53
    16e8:	f0 e0       	ldi	r31, 0x00	; 0
    16ea:	80 81       	ld	r24, Z
    16ec:	8d 7f       	andi	r24, 0xFD	; 253
    16ee:	80 83       	st	Z, r24
    16f0:	ed c0       	rjmp	.+474    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 2:
						PORTC.Bits.Pin2 =0;
    16f2:	e5 e3       	ldi	r30, 0x35	; 53
    16f4:	f0 e0       	ldi	r31, 0x00	; 0
    16f6:	80 81       	ld	r24, Z
    16f8:	8b 7f       	andi	r24, 0xFB	; 251
    16fa:	80 83       	st	Z, r24
    16fc:	e7 c0       	rjmp	.+462    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 3:
						PORTC.Bits.Pin3 =0;
    16fe:	e5 e3       	ldi	r30, 0x35	; 53
    1700:	f0 e0       	ldi	r31, 0x00	; 0
    1702:	80 81       	ld	r24, Z
    1704:	87 7f       	andi	r24, 0xF7	; 247
    1706:	80 83       	st	Z, r24
    1708:	e1 c0       	rjmp	.+450    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 4:
						PORTC.Bits.Pin4 =0;
    170a:	e5 e3       	ldi	r30, 0x35	; 53
    170c:	f0 e0       	ldi	r31, 0x00	; 0
    170e:	80 81       	ld	r24, Z
    1710:	8f 7e       	andi	r24, 0xEF	; 239
    1712:	80 83       	st	Z, r24
    1714:	db c0       	rjmp	.+438    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 5:
						PORTC.Bits.Pin5 =0;
    1716:	e5 e3       	ldi	r30, 0x35	; 53
    1718:	f0 e0       	ldi	r31, 0x00	; 0
    171a:	80 81       	ld	r24, Z
    171c:	8f 7d       	andi	r24, 0xDF	; 223
    171e:	80 83       	st	Z, r24
    1720:	d5 c0       	rjmp	.+426    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 6:
						PORTC.Bits.Pin6 =0;
    1722:	e5 e3       	ldi	r30, 0x35	; 53
    1724:	f0 e0       	ldi	r31, 0x00	; 0
    1726:	80 81       	ld	r24, Z
    1728:	8f 7b       	andi	r24, 0xBF	; 191
    172a:	80 83       	st	Z, r24
    172c:	cf c0       	rjmp	.+414    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 7:
						PORTC.Bits.Pin7 =0;
    172e:	e5 e3       	ldi	r30, 0x35	; 53
    1730:	f0 e0       	ldi	r31, 0x00	; 0
    1732:	80 81       	ld	r24, Z
    1734:	8f 77       	andi	r24, 0x7F	; 127
    1736:	80 83       	st	Z, r24
    1738:	c9 c0       	rjmp	.+402    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
			}
		break;


		case 3:
			if(Val ==1)
    173a:	8c 81       	ldd	r24, Y+4	; 0x04
    173c:	81 30       	cpi	r24, 0x01	; 1
    173e:	09 f0       	breq	.+2      	; 0x1742 <Dio_vidSetPinVal+0x530>
    1740:	63 c0       	rjmp	.+198    	; 0x1808 <Dio_vidSetPinVal+0x5f6>
				{
					switch(PinLoc)
    1742:	89 81       	ldd	r24, Y+1	; 0x01
    1744:	28 2f       	mov	r18, r24
    1746:	30 e0       	ldi	r19, 0x00	; 0
    1748:	38 87       	std	Y+8, r19	; 0x08
    174a:	2f 83       	std	Y+7, r18	; 0x07
    174c:	8f 81       	ldd	r24, Y+7	; 0x07
    174e:	98 85       	ldd	r25, Y+8	; 0x08
    1750:	83 30       	cpi	r24, 0x03	; 3
    1752:	91 05       	cpc	r25, r1
    1754:	d9 f1       	breq	.+118    	; 0x17cc <Dio_vidSetPinVal+0x5ba>
    1756:	2f 81       	ldd	r18, Y+7	; 0x07
    1758:	38 85       	ldd	r19, Y+8	; 0x08
    175a:	24 30       	cpi	r18, 0x04	; 4
    175c:	31 05       	cpc	r19, r1
    175e:	7c f4       	brge	.+30     	; 0x177e <Dio_vidSetPinVal+0x56c>
    1760:	8f 81       	ldd	r24, Y+7	; 0x07
    1762:	98 85       	ldd	r25, Y+8	; 0x08
    1764:	81 30       	cpi	r24, 0x01	; 1
    1766:	91 05       	cpc	r25, r1
    1768:	29 f1       	breq	.+74     	; 0x17b4 <Dio_vidSetPinVal+0x5a2>
    176a:	2f 81       	ldd	r18, Y+7	; 0x07
    176c:	38 85       	ldd	r19, Y+8	; 0x08
    176e:	22 30       	cpi	r18, 0x02	; 2
    1770:	31 05       	cpc	r19, r1
    1772:	34 f5       	brge	.+76     	; 0x17c0 <Dio_vidSetPinVal+0x5ae>
    1774:	8f 81       	ldd	r24, Y+7	; 0x07
    1776:	98 85       	ldd	r25, Y+8	; 0x08
    1778:	00 97       	sbiw	r24, 0x00	; 0
    177a:	b1 f0       	breq	.+44     	; 0x17a8 <Dio_vidSetPinVal+0x596>
    177c:	a7 c0       	rjmp	.+334    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
    177e:	2f 81       	ldd	r18, Y+7	; 0x07
    1780:	38 85       	ldd	r19, Y+8	; 0x08
    1782:	25 30       	cpi	r18, 0x05	; 5
    1784:	31 05       	cpc	r19, r1
    1786:	71 f1       	breq	.+92     	; 0x17e4 <Dio_vidSetPinVal+0x5d2>
    1788:	8f 81       	ldd	r24, Y+7	; 0x07
    178a:	98 85       	ldd	r25, Y+8	; 0x08
    178c:	85 30       	cpi	r24, 0x05	; 5
    178e:	91 05       	cpc	r25, r1
    1790:	1c f1       	brlt	.+70     	; 0x17d8 <Dio_vidSetPinVal+0x5c6>
    1792:	2f 81       	ldd	r18, Y+7	; 0x07
    1794:	38 85       	ldd	r19, Y+8	; 0x08
    1796:	26 30       	cpi	r18, 0x06	; 6
    1798:	31 05       	cpc	r19, r1
    179a:	51 f1       	breq	.+84     	; 0x17f0 <Dio_vidSetPinVal+0x5de>
    179c:	8f 81       	ldd	r24, Y+7	; 0x07
    179e:	98 85       	ldd	r25, Y+8	; 0x08
    17a0:	87 30       	cpi	r24, 0x07	; 7
    17a2:	91 05       	cpc	r25, r1
    17a4:	59 f1       	breq	.+86     	; 0x17fc <Dio_vidSetPinVal+0x5ea>
    17a6:	92 c0       	rjmp	.+292    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					{
						case 0:
							PORTD.Bits.Pin0 =1;
    17a8:	e2 e3       	ldi	r30, 0x32	; 50
    17aa:	f0 e0       	ldi	r31, 0x00	; 0
    17ac:	80 81       	ld	r24, Z
    17ae:	81 60       	ori	r24, 0x01	; 1
    17b0:	80 83       	st	Z, r24
    17b2:	8c c0       	rjmp	.+280    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 1:
							PORTD.Bits.Pin1 =1;
    17b4:	e2 e3       	ldi	r30, 0x32	; 50
    17b6:	f0 e0       	ldi	r31, 0x00	; 0
    17b8:	80 81       	ld	r24, Z
    17ba:	82 60       	ori	r24, 0x02	; 2
    17bc:	80 83       	st	Z, r24
    17be:	86 c0       	rjmp	.+268    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 2:
							PORTD.Bits.Pin2 =1;
    17c0:	e2 e3       	ldi	r30, 0x32	; 50
    17c2:	f0 e0       	ldi	r31, 0x00	; 0
    17c4:	80 81       	ld	r24, Z
    17c6:	84 60       	ori	r24, 0x04	; 4
    17c8:	80 83       	st	Z, r24
    17ca:	80 c0       	rjmp	.+256    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 3:
							PORTD.Bits.Pin3 =1;
    17cc:	e2 e3       	ldi	r30, 0x32	; 50
    17ce:	f0 e0       	ldi	r31, 0x00	; 0
    17d0:	80 81       	ld	r24, Z
    17d2:	88 60       	ori	r24, 0x08	; 8
    17d4:	80 83       	st	Z, r24
    17d6:	7a c0       	rjmp	.+244    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 4:
							PORTD.Bits.Pin4 =1;
    17d8:	e2 e3       	ldi	r30, 0x32	; 50
    17da:	f0 e0       	ldi	r31, 0x00	; 0
    17dc:	80 81       	ld	r24, Z
    17de:	80 61       	ori	r24, 0x10	; 16
    17e0:	80 83       	st	Z, r24
    17e2:	74 c0       	rjmp	.+232    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 5:
							PORTD.Bits.Pin5 =1;
    17e4:	e2 e3       	ldi	r30, 0x32	; 50
    17e6:	f0 e0       	ldi	r31, 0x00	; 0
    17e8:	80 81       	ld	r24, Z
    17ea:	80 62       	ori	r24, 0x20	; 32
    17ec:	80 83       	st	Z, r24
    17ee:	6e c0       	rjmp	.+220    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 6:
							PORTD.Bits.Pin6 =1;
    17f0:	e2 e3       	ldi	r30, 0x32	; 50
    17f2:	f0 e0       	ldi	r31, 0x00	; 0
    17f4:	80 81       	ld	r24, Z
    17f6:	80 64       	ori	r24, 0x40	; 64
    17f8:	80 83       	st	Z, r24
    17fa:	68 c0       	rjmp	.+208    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;

						case 7:
							PORTD.Bits.Pin7 =1;
    17fc:	e2 e3       	ldi	r30, 0x32	; 50
    17fe:	f0 e0       	ldi	r31, 0x00	; 0
    1800:	80 81       	ld	r24, Z
    1802:	80 68       	ori	r24, 0x80	; 128
    1804:	80 83       	st	Z, r24
    1806:	62 c0       	rjmp	.+196    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
						break;
					}
				}
			else
			{
				switch(PinLoc)
    1808:	89 81       	ldd	r24, Y+1	; 0x01
    180a:	28 2f       	mov	r18, r24
    180c:	30 e0       	ldi	r19, 0x00	; 0
    180e:	3e 83       	std	Y+6, r19	; 0x06
    1810:	2d 83       	std	Y+5, r18	; 0x05
    1812:	8d 81       	ldd	r24, Y+5	; 0x05
    1814:	9e 81       	ldd	r25, Y+6	; 0x06
    1816:	83 30       	cpi	r24, 0x03	; 3
    1818:	91 05       	cpc	r25, r1
    181a:	d9 f1       	breq	.+118    	; 0x1892 <Dio_vidSetPinVal+0x680>
    181c:	2d 81       	ldd	r18, Y+5	; 0x05
    181e:	3e 81       	ldd	r19, Y+6	; 0x06
    1820:	24 30       	cpi	r18, 0x04	; 4
    1822:	31 05       	cpc	r19, r1
    1824:	7c f4       	brge	.+30     	; 0x1844 <Dio_vidSetPinVal+0x632>
    1826:	8d 81       	ldd	r24, Y+5	; 0x05
    1828:	9e 81       	ldd	r25, Y+6	; 0x06
    182a:	81 30       	cpi	r24, 0x01	; 1
    182c:	91 05       	cpc	r25, r1
    182e:	29 f1       	breq	.+74     	; 0x187a <Dio_vidSetPinVal+0x668>
    1830:	2d 81       	ldd	r18, Y+5	; 0x05
    1832:	3e 81       	ldd	r19, Y+6	; 0x06
    1834:	22 30       	cpi	r18, 0x02	; 2
    1836:	31 05       	cpc	r19, r1
    1838:	34 f5       	brge	.+76     	; 0x1886 <Dio_vidSetPinVal+0x674>
    183a:	8d 81       	ldd	r24, Y+5	; 0x05
    183c:	9e 81       	ldd	r25, Y+6	; 0x06
    183e:	00 97       	sbiw	r24, 0x00	; 0
    1840:	b1 f0       	breq	.+44     	; 0x186e <Dio_vidSetPinVal+0x65c>
    1842:	44 c0       	rjmp	.+136    	; 0x18cc <Dio_vidSetPinVal+0x6ba>
    1844:	2d 81       	ldd	r18, Y+5	; 0x05
    1846:	3e 81       	ldd	r19, Y+6	; 0x06
    1848:	25 30       	cpi	r18, 0x05	; 5
    184a:	31 05       	cpc	r19, r1
    184c:	71 f1       	breq	.+92     	; 0x18aa <Dio_vidSetPinVal+0x698>
    184e:	8d 81       	ldd	r24, Y+5	; 0x05
    1850:	9e 81       	ldd	r25, Y+6	; 0x06
    1852:	85 30       	cpi	r24, 0x05	; 5
    1854:	91 05       	cpc	r25, r1
    1856:	1c f1       	brlt	.+70     	; 0x189e <Dio_vidSetPinVal+0x68c>
    1858:	2d 81       	ldd	r18, Y+5	; 0x05
    185a:	3e 81       	ldd	r19, Y+6	; 0x06
    185c:	26 30       	cpi	r18, 0x06	; 6
    185e:	31 05       	cpc	r19, r1
    1860:	51 f1       	breq	.+84     	; 0x18b6 <Dio_vidSetPinVal+0x6a4>
    1862:	8d 81       	ldd	r24, Y+5	; 0x05
    1864:	9e 81       	ldd	r25, Y+6	; 0x06
    1866:	87 30       	cpi	r24, 0x07	; 7
    1868:	91 05       	cpc	r25, r1
    186a:	59 f1       	breq	.+86     	; 0x18c2 <Dio_vidSetPinVal+0x6b0>
    186c:	2f c0       	rjmp	.+94     	; 0x18cc <Dio_vidSetPinVal+0x6ba>
				{
					case 0:
						PORTD.Bits.Pin0 =0;
    186e:	e2 e3       	ldi	r30, 0x32	; 50
    1870:	f0 e0       	ldi	r31, 0x00	; 0
    1872:	80 81       	ld	r24, Z
    1874:	8e 7f       	andi	r24, 0xFE	; 254
    1876:	80 83       	st	Z, r24
    1878:	29 c0       	rjmp	.+82     	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 1:
						PORTD.Bits.Pin1 =0;
    187a:	e2 e3       	ldi	r30, 0x32	; 50
    187c:	f0 e0       	ldi	r31, 0x00	; 0
    187e:	80 81       	ld	r24, Z
    1880:	8d 7f       	andi	r24, 0xFD	; 253
    1882:	80 83       	st	Z, r24
    1884:	23 c0       	rjmp	.+70     	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 2:
						PORTD.Bits.Pin2 =0;
    1886:	e2 e3       	ldi	r30, 0x32	; 50
    1888:	f0 e0       	ldi	r31, 0x00	; 0
    188a:	80 81       	ld	r24, Z
    188c:	8b 7f       	andi	r24, 0xFB	; 251
    188e:	80 83       	st	Z, r24
    1890:	1d c0       	rjmp	.+58     	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 3:
						PORTD.Bits.Pin3 =0;
    1892:	e2 e3       	ldi	r30, 0x32	; 50
    1894:	f0 e0       	ldi	r31, 0x00	; 0
    1896:	80 81       	ld	r24, Z
    1898:	87 7f       	andi	r24, 0xF7	; 247
    189a:	80 83       	st	Z, r24
    189c:	17 c0       	rjmp	.+46     	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 4:
						PORTD.Bits.Pin4 =0;
    189e:	e2 e3       	ldi	r30, 0x32	; 50
    18a0:	f0 e0       	ldi	r31, 0x00	; 0
    18a2:	80 81       	ld	r24, Z
    18a4:	8f 7e       	andi	r24, 0xEF	; 239
    18a6:	80 83       	st	Z, r24
    18a8:	11 c0       	rjmp	.+34     	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 5:
						PORTD.Bits.Pin5 =0;
    18aa:	e2 e3       	ldi	r30, 0x32	; 50
    18ac:	f0 e0       	ldi	r31, 0x00	; 0
    18ae:	80 81       	ld	r24, Z
    18b0:	8f 7d       	andi	r24, 0xDF	; 223
    18b2:	80 83       	st	Z, r24
    18b4:	0b c0       	rjmp	.+22     	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 6:
						PORTD.Bits.Pin6 =0;
    18b6:	e2 e3       	ldi	r30, 0x32	; 50
    18b8:	f0 e0       	ldi	r31, 0x00	; 0
    18ba:	80 81       	ld	r24, Z
    18bc:	8f 7b       	andi	r24, 0xBF	; 191
    18be:	80 83       	st	Z, r24
    18c0:	05 c0       	rjmp	.+10     	; 0x18cc <Dio_vidSetPinVal+0x6ba>
					break;

					case 7:
						PORTD.Bits.Pin7 =0;
    18c2:	e2 e3       	ldi	r30, 0x32	; 50
    18c4:	f0 e0       	ldi	r31, 0x00	; 0
    18c6:	80 81       	ld	r24, Z
    18c8:	8f 77       	andi	r24, 0x7F	; 127
    18ca:	80 83       	st	Z, r24
					break;
				}
			}
		break;
	}
}
    18cc:	66 96       	adiw	r28, 0x16	; 22
    18ce:	0f b6       	in	r0, 0x3f	; 63
    18d0:	f8 94       	cli
    18d2:	de bf       	out	0x3e, r29	; 62
    18d4:	0f be       	out	0x3f, r0	; 63
    18d6:	cd bf       	out	0x3d, r28	; 61
    18d8:	cf 91       	pop	r28
    18da:	df 91       	pop	r29
    18dc:	08 95       	ret

000018de <INT_vidInit>:

void(*pfun_0)(void);   //pointer to function
void(*pfun_1)(void);

void INT_vidInit(void)
{
    18de:	df 93       	push	r29
    18e0:	cf 93       	push	r28
    18e2:	cd b7       	in	r28, 0x3d	; 61
    18e4:	de b7       	in	r29, 0x3e	; 62
	//global Interrupt Enable
	SREG.Bits.I_bit = 1;
    18e6:	ef e5       	ldi	r30, 0x5F	; 95
    18e8:	f0 e0       	ldi	r31, 0x00	; 0
    18ea:	80 81       	ld	r24, Z
    18ec:	80 68       	ori	r24, 0x80	; 128
    18ee:	80 83       	st	Z, r24

	#if INT_u8INTERRUPT_0_CFG == INT_u8INTERRUPT_0_ENABLE  //INT0
	 //Enable Interrupt 0
		GICR.Bits.INT_0 = 1;
    18f0:	eb e5       	ldi	r30, 0x5B	; 91
    18f2:	f0 e0       	ldi	r31, 0x00	; 0
    18f4:	80 81       	ld	r24, Z
    18f6:	80 64       	ori	r24, 0x40	; 64
    18f8:	80 83       	st	Z, r24

			//select interrupt 0 sense control
			#if INT0_u8INTERRUPT_SOURCE == INT_PIF_LOW_LEVEL
				//Rise Interrupt Flag At LOW_LEVEL Event
				MCUCR.Bits.ISC00 = 0;
    18fa:	e5 e5       	ldi	r30, 0x55	; 85
    18fc:	f0 e0       	ldi	r31, 0x00	; 0
    18fe:	80 81       	ld	r24, Z
    1900:	8e 7f       	andi	r24, 0xFE	; 254
    1902:	80 83       	st	Z, r24
				MCUCR.Bits.ISC01 = 0;
    1904:	e5 e5       	ldi	r30, 0x55	; 85
    1906:	f0 e0       	ldi	r31, 0x00	; 0
    1908:	80 81       	ld	r24, Z
    190a:	8d 7f       	andi	r24, 0xFD	; 253
    190c:	80 83       	st	Z, r24

			#endif

	#elif INT_u8INTERRUPT_1_CFG == INT_u8INTERRUPT_1_DISABLE
		//Disable Interrupt 1
		GICR.Bits.INT_1 = 0;
    190e:	eb e5       	ldi	r30, 0x5B	; 91
    1910:	f0 e0       	ldi	r31, 0x00	; 0
    1912:	80 81       	ld	r24, Z
    1914:	8f 77       	andi	r24, 0x7F	; 127
    1916:	80 83       	st	Z, r24
	#endif


}
    1918:	cf 91       	pop	r28
    191a:	df 91       	pop	r29
    191c:	08 95       	ret

0000191e <INT0_vidSetCB>:

//Call_Back function has an address of another function in main.c for INT0
void INT0_vidSetCB(void(*pf)(void))
{
    191e:	df 93       	push	r29
    1920:	cf 93       	push	r28
    1922:	00 d0       	rcall	.+0      	; 0x1924 <INT0_vidSetCB+0x6>
    1924:	cd b7       	in	r28, 0x3d	; 61
    1926:	de b7       	in	r29, 0x3e	; 62
    1928:	9a 83       	std	Y+2, r25	; 0x02
    192a:	89 83       	std	Y+1, r24	; 0x01
	pfun_0 = pf;
    192c:	89 81       	ldd	r24, Y+1	; 0x01
    192e:	9a 81       	ldd	r25, Y+2	; 0x02
    1930:	90 93 cc 06 	sts	0x06CC, r25
    1934:	80 93 cb 06 	sts	0x06CB, r24
}
    1938:	0f 90       	pop	r0
    193a:	0f 90       	pop	r0
    193c:	cf 91       	pop	r28
    193e:	df 91       	pop	r29
    1940:	08 95       	ret

00001942 <INT1_vidSetCB>:
//function has an address of another function in main.c for INT1
void INT1_vidSetCB(void(*pf)(void))
{
    1942:	df 93       	push	r29
    1944:	cf 93       	push	r28
    1946:	00 d0       	rcall	.+0      	; 0x1948 <INT1_vidSetCB+0x6>
    1948:	cd b7       	in	r28, 0x3d	; 61
    194a:	de b7       	in	r29, 0x3e	; 62
    194c:	9a 83       	std	Y+2, r25	; 0x02
    194e:	89 83       	std	Y+1, r24	; 0x01
	pfun_1 = pf;
    1950:	89 81       	ldd	r24, Y+1	; 0x01
    1952:	9a 81       	ldd	r25, Y+2	; 0x02
    1954:	90 93 ce 06 	sts	0x06CE, r25
    1958:	80 93 cd 06 	sts	0x06CD, r24
}
    195c:	0f 90       	pop	r0
    195e:	0f 90       	pop	r0
    1960:	cf 91       	pop	r28
    1962:	df 91       	pop	r29
    1964:	08 95       	ret

00001966 <__vector_1>:
//ISR OF INT0
void __vector_1 (void)
{
    1966:	1f 92       	push	r1
    1968:	0f 92       	push	r0
    196a:	0f b6       	in	r0, 0x3f	; 63
    196c:	0f 92       	push	r0
    196e:	11 24       	eor	r1, r1
    1970:	2f 93       	push	r18
    1972:	3f 93       	push	r19
    1974:	4f 93       	push	r20
    1976:	5f 93       	push	r21
    1978:	6f 93       	push	r22
    197a:	7f 93       	push	r23
    197c:	8f 93       	push	r24
    197e:	9f 93       	push	r25
    1980:	af 93       	push	r26
    1982:	bf 93       	push	r27
    1984:	ef 93       	push	r30
    1986:	ff 93       	push	r31
    1988:	df 93       	push	r29
    198a:	cf 93       	push	r28
    198c:	cd b7       	in	r28, 0x3d	; 61
    198e:	de b7       	in	r29, 0x3e	; 62
	pfun_0();
    1990:	e0 91 cb 06 	lds	r30, 0x06CB
    1994:	f0 91 cc 06 	lds	r31, 0x06CC
    1998:	09 95       	icall
}
    199a:	cf 91       	pop	r28
    199c:	df 91       	pop	r29
    199e:	ff 91       	pop	r31
    19a0:	ef 91       	pop	r30
    19a2:	bf 91       	pop	r27
    19a4:	af 91       	pop	r26
    19a6:	9f 91       	pop	r25
    19a8:	8f 91       	pop	r24
    19aa:	7f 91       	pop	r23
    19ac:	6f 91       	pop	r22
    19ae:	5f 91       	pop	r21
    19b0:	4f 91       	pop	r20
    19b2:	3f 91       	pop	r19
    19b4:	2f 91       	pop	r18
    19b6:	0f 90       	pop	r0
    19b8:	0f be       	out	0x3f, r0	; 63
    19ba:	0f 90       	pop	r0
    19bc:	1f 90       	pop	r1
    19be:	18 95       	reti

000019c0 <__vector_2>:
//ISR OF INT1
void __vector_2 (void)
{
    19c0:	1f 92       	push	r1
    19c2:	0f 92       	push	r0
    19c4:	0f b6       	in	r0, 0x3f	; 63
    19c6:	0f 92       	push	r0
    19c8:	11 24       	eor	r1, r1
    19ca:	2f 93       	push	r18
    19cc:	3f 93       	push	r19
    19ce:	4f 93       	push	r20
    19d0:	5f 93       	push	r21
    19d2:	6f 93       	push	r22
    19d4:	7f 93       	push	r23
    19d6:	8f 93       	push	r24
    19d8:	9f 93       	push	r25
    19da:	af 93       	push	r26
    19dc:	bf 93       	push	r27
    19de:	ef 93       	push	r30
    19e0:	ff 93       	push	r31
    19e2:	df 93       	push	r29
    19e4:	cf 93       	push	r28
    19e6:	cd b7       	in	r28, 0x3d	; 61
    19e8:	de b7       	in	r29, 0x3e	; 62
	pfun_1();
    19ea:	e0 91 cd 06 	lds	r30, 0x06CD
    19ee:	f0 91 ce 06 	lds	r31, 0x06CE
    19f2:	09 95       	icall
}
    19f4:	cf 91       	pop	r28
    19f6:	df 91       	pop	r29
    19f8:	ff 91       	pop	r31
    19fa:	ef 91       	pop	r30
    19fc:	bf 91       	pop	r27
    19fe:	af 91       	pop	r26
    1a00:	9f 91       	pop	r25
    1a02:	8f 91       	pop	r24
    1a04:	7f 91       	pop	r23
    1a06:	6f 91       	pop	r22
    1a08:	5f 91       	pop	r21
    1a0a:	4f 91       	pop	r20
    1a0c:	3f 91       	pop	r19
    1a0e:	2f 91       	pop	r18
    1a10:	0f 90       	pop	r0
    1a12:	0f be       	out	0x3f, r0	; 63
    1a14:	0f 90       	pop	r0
    1a16:	1f 90       	pop	r1
    1a18:	18 95       	reti

00001a1a <Lcd_vidSendCommand>:
#include <util/delay.h>
#include "Lcd_int.h"
#include "Dio_int.h"
#include "Lcd_cfg.h"
void Lcd_vidSendCommand(u8 Cmd)
{
    1a1a:	df 93       	push	r29
    1a1c:	cf 93       	push	r28
    1a1e:	cd b7       	in	r28, 0x3d	; 61
    1a20:	de b7       	in	r29, 0x3e	; 62
    1a22:	2f 97       	sbiw	r28, 0x0f	; 15
    1a24:	0f b6       	in	r0, 0x3f	; 63
    1a26:	f8 94       	cli
    1a28:	de bf       	out	0x3e, r29	; 62
    1a2a:	0f be       	out	0x3f, r0	; 63
    1a2c:	cd bf       	out	0x3d, r28	; 61
    1a2e:	8f 87       	std	Y+15, r24	; 0x0f
	//Start to change in LCD control Reg to indicate it that you will receive command
	Dio_vidSetPinVal(LCD_u8RS_PIN , DIO_u8LOW);  //make RS->0 to indicate LCD "you will receive command not data"
    1a30:	80 e0       	ldi	r24, 0x00	; 0
    1a32:	60 e0       	ldi	r22, 0x00	; 0
    1a34:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8RW_PIN , DIO_u8LOW);  //make RW->0 to indicate LCD "you will write in command Register"
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	60 e0       	ldi	r22, 0x00	; 0
    1a3c:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8EN_PIN , DIO_u8HIGH); //make EN->1 to indicate LCD "Please LCD don't save any thing in your buffer until be sure all data sent "
    1a40:	82 e0       	ldi	r24, 0x02	; 2
    1a42:	61 e0       	ldi	r22, 0x01	; 1
    1a44:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>

	//In prof_code we can't send all data '8_bit'  for PORT at the same time so we use GET_BIT
	Dio_vidSetPinVal(LCD_u8D0_PIN , GET_BIT(Cmd,0));
    1a48:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a4a:	98 2f       	mov	r25, r24
    1a4c:	91 70       	andi	r25, 0x01	; 1
    1a4e:	88 e1       	ldi	r24, 0x18	; 24
    1a50:	69 2f       	mov	r22, r25
    1a52:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D1_PIN , GET_BIT(Cmd,1));
    1a56:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a58:	86 95       	lsr	r24
    1a5a:	98 2f       	mov	r25, r24
    1a5c:	91 70       	andi	r25, 0x01	; 1
    1a5e:	89 e1       	ldi	r24, 0x19	; 25
    1a60:	69 2f       	mov	r22, r25
    1a62:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D2_PIN , GET_BIT(Cmd,2));
    1a66:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a68:	86 95       	lsr	r24
    1a6a:	86 95       	lsr	r24
    1a6c:	98 2f       	mov	r25, r24
    1a6e:	91 70       	andi	r25, 0x01	; 1
    1a70:	83 e0       	ldi	r24, 0x03	; 3
    1a72:	69 2f       	mov	r22, r25
    1a74:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D3_PIN , GET_BIT(Cmd,3));
    1a78:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a7a:	86 95       	lsr	r24
    1a7c:	86 95       	lsr	r24
    1a7e:	86 95       	lsr	r24
    1a80:	98 2f       	mov	r25, r24
    1a82:	91 70       	andi	r25, 0x01	; 1
    1a84:	8b e1       	ldi	r24, 0x1B	; 27
    1a86:	69 2f       	mov	r22, r25
    1a88:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D4_PIN , GET_BIT(Cmd,4));
    1a8c:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a8e:	82 95       	swap	r24
    1a90:	8f 70       	andi	r24, 0x0F	; 15
    1a92:	98 2f       	mov	r25, r24
    1a94:	91 70       	andi	r25, 0x01	; 1
    1a96:	8c e1       	ldi	r24, 0x1C	; 28
    1a98:	69 2f       	mov	r22, r25
    1a9a:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D5_PIN , GET_BIT(Cmd,5));
    1a9e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1aa0:	82 95       	swap	r24
    1aa2:	86 95       	lsr	r24
    1aa4:	87 70       	andi	r24, 0x07	; 7
    1aa6:	98 2f       	mov	r25, r24
    1aa8:	91 70       	andi	r25, 0x01	; 1
    1aaa:	8d e1       	ldi	r24, 0x1D	; 29
    1aac:	69 2f       	mov	r22, r25
    1aae:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D6_PIN , GET_BIT(Cmd,6));
    1ab2:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ab4:	82 95       	swap	r24
    1ab6:	86 95       	lsr	r24
    1ab8:	86 95       	lsr	r24
    1aba:	83 70       	andi	r24, 0x03	; 3
    1abc:	98 2f       	mov	r25, r24
    1abe:	91 70       	andi	r25, 0x01	; 1
    1ac0:	8e e1       	ldi	r24, 0x1E	; 30
    1ac2:	69 2f       	mov	r22, r25
    1ac4:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D7_PIN , GET_BIT(Cmd,7));
    1ac8:	8f 85       	ldd	r24, Y+15	; 0x0f
    1aca:	98 2f       	mov	r25, r24
    1acc:	99 1f       	adc	r25, r25
    1ace:	99 27       	eor	r25, r25
    1ad0:	99 1f       	adc	r25, r25
    1ad2:	8f e1       	ldi	r24, 0x1F	; 31
    1ad4:	69 2f       	mov	r22, r25
    1ad6:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
    1ada:	80 e0       	ldi	r24, 0x00	; 0
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	a0 e0       	ldi	r26, 0x00	; 0
    1ae0:	b0 e4       	ldi	r27, 0x40	; 64
    1ae2:	8b 87       	std	Y+11, r24	; 0x0b
    1ae4:	9c 87       	std	Y+12, r25	; 0x0c
    1ae6:	ad 87       	std	Y+13, r26	; 0x0d
    1ae8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1aea:	6b 85       	ldd	r22, Y+11	; 0x0b
    1aec:	7c 85       	ldd	r23, Y+12	; 0x0c
    1aee:	8d 85       	ldd	r24, Y+13	; 0x0d
    1af0:	9e 85       	ldd	r25, Y+14	; 0x0e
    1af2:	20 e0       	ldi	r18, 0x00	; 0
    1af4:	30 e0       	ldi	r19, 0x00	; 0
    1af6:	4a ef       	ldi	r20, 0xFA	; 250
    1af8:	54 e4       	ldi	r21, 0x44	; 68
    1afa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1afe:	dc 01       	movw	r26, r24
    1b00:	cb 01       	movw	r24, r22
    1b02:	8f 83       	std	Y+7, r24	; 0x07
    1b04:	98 87       	std	Y+8, r25	; 0x08
    1b06:	a9 87       	std	Y+9, r26	; 0x09
    1b08:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1b0a:	6f 81       	ldd	r22, Y+7	; 0x07
    1b0c:	78 85       	ldd	r23, Y+8	; 0x08
    1b0e:	89 85       	ldd	r24, Y+9	; 0x09
    1b10:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b12:	20 e0       	ldi	r18, 0x00	; 0
    1b14:	30 e0       	ldi	r19, 0x00	; 0
    1b16:	40 e8       	ldi	r20, 0x80	; 128
    1b18:	5f e3       	ldi	r21, 0x3F	; 63
    1b1a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1b1e:	88 23       	and	r24, r24
    1b20:	2c f4       	brge	.+10     	; 0x1b2c <Lcd_vidSendCommand+0x112>
		__ticks = 1;
    1b22:	81 e0       	ldi	r24, 0x01	; 1
    1b24:	90 e0       	ldi	r25, 0x00	; 0
    1b26:	9e 83       	std	Y+6, r25	; 0x06
    1b28:	8d 83       	std	Y+5, r24	; 0x05
    1b2a:	3f c0       	rjmp	.+126    	; 0x1baa <Lcd_vidSendCommand+0x190>
	else if (__tmp > 65535)
    1b2c:	6f 81       	ldd	r22, Y+7	; 0x07
    1b2e:	78 85       	ldd	r23, Y+8	; 0x08
    1b30:	89 85       	ldd	r24, Y+9	; 0x09
    1b32:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b34:	20 e0       	ldi	r18, 0x00	; 0
    1b36:	3f ef       	ldi	r19, 0xFF	; 255
    1b38:	4f e7       	ldi	r20, 0x7F	; 127
    1b3a:	57 e4       	ldi	r21, 0x47	; 71
    1b3c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1b40:	18 16       	cp	r1, r24
    1b42:	4c f5       	brge	.+82     	; 0x1b96 <Lcd_vidSendCommand+0x17c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b44:	6b 85       	ldd	r22, Y+11	; 0x0b
    1b46:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b48:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b4a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b4c:	20 e0       	ldi	r18, 0x00	; 0
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	40 e2       	ldi	r20, 0x20	; 32
    1b52:	51 e4       	ldi	r21, 0x41	; 65
    1b54:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b58:	dc 01       	movw	r26, r24
    1b5a:	cb 01       	movw	r24, r22
    1b5c:	bc 01       	movw	r22, r24
    1b5e:	cd 01       	movw	r24, r26
    1b60:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b64:	dc 01       	movw	r26, r24
    1b66:	cb 01       	movw	r24, r22
    1b68:	9e 83       	std	Y+6, r25	; 0x06
    1b6a:	8d 83       	std	Y+5, r24	; 0x05
    1b6c:	0f c0       	rjmp	.+30     	; 0x1b8c <Lcd_vidSendCommand+0x172>
    1b6e:	88 ec       	ldi	r24, 0xC8	; 200
    1b70:	90 e0       	ldi	r25, 0x00	; 0
    1b72:	9c 83       	std	Y+4, r25	; 0x04
    1b74:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1b76:	8b 81       	ldd	r24, Y+3	; 0x03
    1b78:	9c 81       	ldd	r25, Y+4	; 0x04
    1b7a:	01 97       	sbiw	r24, 0x01	; 1
    1b7c:	f1 f7       	brne	.-4      	; 0x1b7a <Lcd_vidSendCommand+0x160>
    1b7e:	9c 83       	std	Y+4, r25	; 0x04
    1b80:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b82:	8d 81       	ldd	r24, Y+5	; 0x05
    1b84:	9e 81       	ldd	r25, Y+6	; 0x06
    1b86:	01 97       	sbiw	r24, 0x01	; 1
    1b88:	9e 83       	std	Y+6, r25	; 0x06
    1b8a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b8c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b8e:	9e 81       	ldd	r25, Y+6	; 0x06
    1b90:	00 97       	sbiw	r24, 0x00	; 0
    1b92:	69 f7       	brne	.-38     	; 0x1b6e <Lcd_vidSendCommand+0x154>
    1b94:	14 c0       	rjmp	.+40     	; 0x1bbe <Lcd_vidSendCommand+0x1a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1b96:	6f 81       	ldd	r22, Y+7	; 0x07
    1b98:	78 85       	ldd	r23, Y+8	; 0x08
    1b9a:	89 85       	ldd	r24, Y+9	; 0x09
    1b9c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b9e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ba2:	dc 01       	movw	r26, r24
    1ba4:	cb 01       	movw	r24, r22
    1ba6:	9e 83       	std	Y+6, r25	; 0x06
    1ba8:	8d 83       	std	Y+5, r24	; 0x05
    1baa:	8d 81       	ldd	r24, Y+5	; 0x05
    1bac:	9e 81       	ldd	r25, Y+6	; 0x06
    1bae:	9a 83       	std	Y+2, r25	; 0x02
    1bb0:	89 83       	std	Y+1, r24	; 0x01
    1bb2:	89 81       	ldd	r24, Y+1	; 0x01
    1bb4:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb6:	01 97       	sbiw	r24, 0x01	; 1
    1bb8:	f1 f7       	brne	.-4      	; 0x1bb6 <Lcd_vidSendCommand+0x19c>
    1bba:	9a 83       	std	Y+2, r25	; 0x02
    1bbc:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(2);

	Dio_vidSetPinVal(LCD_u8EN_PIN , DIO_u8LOW);  //make EN->0 to indicate LCD "NOW you can save bits in your buffer all data sent"
    1bbe:	82 e0       	ldi	r24, 0x02	; 2
    1bc0:	60 e0       	ldi	r22, 0x00	; 0
    1bc2:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>

}
    1bc6:	2f 96       	adiw	r28, 0x0f	; 15
    1bc8:	0f b6       	in	r0, 0x3f	; 63
    1bca:	f8 94       	cli
    1bcc:	de bf       	out	0x3e, r29	; 62
    1bce:	0f be       	out	0x3f, r0	; 63
    1bd0:	cd bf       	out	0x3d, r28	; 61
    1bd2:	cf 91       	pop	r28
    1bd4:	df 91       	pop	r29
    1bd6:	08 95       	ret

00001bd8 <Lcd_vidInit>:

void Lcd_vidInit(void)
{
    1bd8:	df 93       	push	r29
    1bda:	cf 93       	push	r28
    1bdc:	cd b7       	in	r28, 0x3d	; 61
    1bde:	de b7       	in	r29, 0x3e	; 62
    1be0:	aa 97       	sbiw	r28, 0x2a	; 42
    1be2:	0f b6       	in	r0, 0x3f	; 63
    1be4:	f8 94       	cli
    1be6:	de bf       	out	0x3e, r29	; 62
    1be8:	0f be       	out	0x3f, r0	; 63
    1bea:	cd bf       	out	0x3d, r28	; 61
	 Dio_vidSetPinDir(LCD_u8RS_PIN , DIO_u8OUTPUT);
    1bec:	80 e0       	ldi	r24, 0x00	; 0
    1bee:	61 e0       	ldi	r22, 0x01	; 1
    1bf0:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8RW_PIN , DIO_u8OUTPUT);
    1bf4:	81 e0       	ldi	r24, 0x01	; 1
    1bf6:	61 e0       	ldi	r22, 0x01	; 1
    1bf8:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8EN_PIN , DIO_u8OUTPUT);
    1bfc:	82 e0       	ldi	r24, 0x02	; 2
    1bfe:	61 e0       	ldi	r22, 0x01	; 1
    1c00:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>

	 Dio_vidSetPinDir(LCD_u8D0_PIN , DIO_u8OUTPUT);
    1c04:	88 e1       	ldi	r24, 0x18	; 24
    1c06:	61 e0       	ldi	r22, 0x01	; 1
    1c08:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D1_PIN , DIO_u8OUTPUT);
    1c0c:	89 e1       	ldi	r24, 0x19	; 25
    1c0e:	61 e0       	ldi	r22, 0x01	; 1
    1c10:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D2_PIN , DIO_u8OUTPUT);
    1c14:	83 e0       	ldi	r24, 0x03	; 3
    1c16:	61 e0       	ldi	r22, 0x01	; 1
    1c18:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D3_PIN , DIO_u8OUTPUT);
    1c1c:	8b e1       	ldi	r24, 0x1B	; 27
    1c1e:	61 e0       	ldi	r22, 0x01	; 1
    1c20:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D4_PIN , DIO_u8OUTPUT);
    1c24:	8c e1       	ldi	r24, 0x1C	; 28
    1c26:	61 e0       	ldi	r22, 0x01	; 1
    1c28:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D5_PIN , DIO_u8OUTPUT);
    1c2c:	8d e1       	ldi	r24, 0x1D	; 29
    1c2e:	61 e0       	ldi	r22, 0x01	; 1
    1c30:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D6_PIN , DIO_u8OUTPUT);
    1c34:	8e e1       	ldi	r24, 0x1E	; 30
    1c36:	61 e0       	ldi	r22, 0x01	; 1
    1c38:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>
	 Dio_vidSetPinDir(LCD_u8D7_PIN , DIO_u8OUTPUT);
    1c3c:	8f e1       	ldi	r24, 0x1F	; 31
    1c3e:	61 e0       	ldi	r22, 0x01	; 1
    1c40:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>

	Lcd_vidSendCommand(LCD_u8CMD_8_BIT_2x16_5x7); //LCD_8BIT_2x16_5x7
    1c44:	88 e3       	ldi	r24, 0x38	; 56
    1c46:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <Lcd_vidSendCommand>
    1c4a:	80 e0       	ldi	r24, 0x00	; 0
    1c4c:	90 e0       	ldi	r25, 0x00	; 0
    1c4e:	a0 e0       	ldi	r26, 0x00	; 0
    1c50:	b0 e4       	ldi	r27, 0x40	; 64
    1c52:	8f a3       	std	Y+39, r24	; 0x27
    1c54:	98 a7       	std	Y+40, r25	; 0x28
    1c56:	a9 a7       	std	Y+41, r26	; 0x29
    1c58:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c5a:	6f a1       	ldd	r22, Y+39	; 0x27
    1c5c:	78 a5       	ldd	r23, Y+40	; 0x28
    1c5e:	89 a5       	ldd	r24, Y+41	; 0x29
    1c60:	9a a5       	ldd	r25, Y+42	; 0x2a
    1c62:	20 e0       	ldi	r18, 0x00	; 0
    1c64:	30 e0       	ldi	r19, 0x00	; 0
    1c66:	4a ef       	ldi	r20, 0xFA	; 250
    1c68:	54 e4       	ldi	r21, 0x44	; 68
    1c6a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c6e:	dc 01       	movw	r26, r24
    1c70:	cb 01       	movw	r24, r22
    1c72:	8b a3       	std	Y+35, r24	; 0x23
    1c74:	9c a3       	std	Y+36, r25	; 0x24
    1c76:	ad a3       	std	Y+37, r26	; 0x25
    1c78:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1c7a:	6b a1       	ldd	r22, Y+35	; 0x23
    1c7c:	7c a1       	ldd	r23, Y+36	; 0x24
    1c7e:	8d a1       	ldd	r24, Y+37	; 0x25
    1c80:	9e a1       	ldd	r25, Y+38	; 0x26
    1c82:	20 e0       	ldi	r18, 0x00	; 0
    1c84:	30 e0       	ldi	r19, 0x00	; 0
    1c86:	40 e8       	ldi	r20, 0x80	; 128
    1c88:	5f e3       	ldi	r21, 0x3F	; 63
    1c8a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1c8e:	88 23       	and	r24, r24
    1c90:	2c f4       	brge	.+10     	; 0x1c9c <Lcd_vidInit+0xc4>
		__ticks = 1;
    1c92:	81 e0       	ldi	r24, 0x01	; 1
    1c94:	90 e0       	ldi	r25, 0x00	; 0
    1c96:	9a a3       	std	Y+34, r25	; 0x22
    1c98:	89 a3       	std	Y+33, r24	; 0x21
    1c9a:	3f c0       	rjmp	.+126    	; 0x1d1a <Lcd_vidInit+0x142>
	else if (__tmp > 65535)
    1c9c:	6b a1       	ldd	r22, Y+35	; 0x23
    1c9e:	7c a1       	ldd	r23, Y+36	; 0x24
    1ca0:	8d a1       	ldd	r24, Y+37	; 0x25
    1ca2:	9e a1       	ldd	r25, Y+38	; 0x26
    1ca4:	20 e0       	ldi	r18, 0x00	; 0
    1ca6:	3f ef       	ldi	r19, 0xFF	; 255
    1ca8:	4f e7       	ldi	r20, 0x7F	; 127
    1caa:	57 e4       	ldi	r21, 0x47	; 71
    1cac:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1cb0:	18 16       	cp	r1, r24
    1cb2:	4c f5       	brge	.+82     	; 0x1d06 <Lcd_vidInit+0x12e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1cb4:	6f a1       	ldd	r22, Y+39	; 0x27
    1cb6:	78 a5       	ldd	r23, Y+40	; 0x28
    1cb8:	89 a5       	ldd	r24, Y+41	; 0x29
    1cba:	9a a5       	ldd	r25, Y+42	; 0x2a
    1cbc:	20 e0       	ldi	r18, 0x00	; 0
    1cbe:	30 e0       	ldi	r19, 0x00	; 0
    1cc0:	40 e2       	ldi	r20, 0x20	; 32
    1cc2:	51 e4       	ldi	r21, 0x41	; 65
    1cc4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cc8:	dc 01       	movw	r26, r24
    1cca:	cb 01       	movw	r24, r22
    1ccc:	bc 01       	movw	r22, r24
    1cce:	cd 01       	movw	r24, r26
    1cd0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cd4:	dc 01       	movw	r26, r24
    1cd6:	cb 01       	movw	r24, r22
    1cd8:	9a a3       	std	Y+34, r25	; 0x22
    1cda:	89 a3       	std	Y+33, r24	; 0x21
    1cdc:	0f c0       	rjmp	.+30     	; 0x1cfc <Lcd_vidInit+0x124>
    1cde:	88 ec       	ldi	r24, 0xC8	; 200
    1ce0:	90 e0       	ldi	r25, 0x00	; 0
    1ce2:	98 a3       	std	Y+32, r25	; 0x20
    1ce4:	8f 8f       	std	Y+31, r24	; 0x1f
    1ce6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1ce8:	98 a1       	ldd	r25, Y+32	; 0x20
    1cea:	01 97       	sbiw	r24, 0x01	; 1
    1cec:	f1 f7       	brne	.-4      	; 0x1cea <Lcd_vidInit+0x112>
    1cee:	98 a3       	std	Y+32, r25	; 0x20
    1cf0:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cf2:	89 a1       	ldd	r24, Y+33	; 0x21
    1cf4:	9a a1       	ldd	r25, Y+34	; 0x22
    1cf6:	01 97       	sbiw	r24, 0x01	; 1
    1cf8:	9a a3       	std	Y+34, r25	; 0x22
    1cfa:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1cfc:	89 a1       	ldd	r24, Y+33	; 0x21
    1cfe:	9a a1       	ldd	r25, Y+34	; 0x22
    1d00:	00 97       	sbiw	r24, 0x00	; 0
    1d02:	69 f7       	brne	.-38     	; 0x1cde <Lcd_vidInit+0x106>
    1d04:	14 c0       	rjmp	.+40     	; 0x1d2e <Lcd_vidInit+0x156>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d06:	6b a1       	ldd	r22, Y+35	; 0x23
    1d08:	7c a1       	ldd	r23, Y+36	; 0x24
    1d0a:	8d a1       	ldd	r24, Y+37	; 0x25
    1d0c:	9e a1       	ldd	r25, Y+38	; 0x26
    1d0e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d12:	dc 01       	movw	r26, r24
    1d14:	cb 01       	movw	r24, r22
    1d16:	9a a3       	std	Y+34, r25	; 0x22
    1d18:	89 a3       	std	Y+33, r24	; 0x21
    1d1a:	89 a1       	ldd	r24, Y+33	; 0x21
    1d1c:	9a a1       	ldd	r25, Y+34	; 0x22
    1d1e:	9e 8f       	std	Y+30, r25	; 0x1e
    1d20:	8d 8f       	std	Y+29, r24	; 0x1d
    1d22:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d24:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1d26:	01 97       	sbiw	r24, 0x01	; 1
    1d28:	f1 f7       	brne	.-4      	; 0x1d26 <Lcd_vidInit+0x14e>
    1d2a:	9e 8f       	std	Y+30, r25	; 0x1e
    1d2c:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(2);
	Lcd_vidSendCommand(LCD_u8CMD_DISP_ON_CURS_OFF);
    1d2e:	8c e0       	ldi	r24, 0x0C	; 12
    1d30:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <Lcd_vidSendCommand>
    1d34:	80 e0       	ldi	r24, 0x00	; 0
    1d36:	90 e0       	ldi	r25, 0x00	; 0
    1d38:	a0 e0       	ldi	r26, 0x00	; 0
    1d3a:	b0 e4       	ldi	r27, 0x40	; 64
    1d3c:	89 8f       	std	Y+25, r24	; 0x19
    1d3e:	9a 8f       	std	Y+26, r25	; 0x1a
    1d40:	ab 8f       	std	Y+27, r26	; 0x1b
    1d42:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d44:	69 8d       	ldd	r22, Y+25	; 0x19
    1d46:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1d48:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d4a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1d4c:	20 e0       	ldi	r18, 0x00	; 0
    1d4e:	30 e0       	ldi	r19, 0x00	; 0
    1d50:	4a ef       	ldi	r20, 0xFA	; 250
    1d52:	54 e4       	ldi	r21, 0x44	; 68
    1d54:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d58:	dc 01       	movw	r26, r24
    1d5a:	cb 01       	movw	r24, r22
    1d5c:	8d 8b       	std	Y+21, r24	; 0x15
    1d5e:	9e 8b       	std	Y+22, r25	; 0x16
    1d60:	af 8b       	std	Y+23, r26	; 0x17
    1d62:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1d64:	6d 89       	ldd	r22, Y+21	; 0x15
    1d66:	7e 89       	ldd	r23, Y+22	; 0x16
    1d68:	8f 89       	ldd	r24, Y+23	; 0x17
    1d6a:	98 8d       	ldd	r25, Y+24	; 0x18
    1d6c:	20 e0       	ldi	r18, 0x00	; 0
    1d6e:	30 e0       	ldi	r19, 0x00	; 0
    1d70:	40 e8       	ldi	r20, 0x80	; 128
    1d72:	5f e3       	ldi	r21, 0x3F	; 63
    1d74:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1d78:	88 23       	and	r24, r24
    1d7a:	2c f4       	brge	.+10     	; 0x1d86 <Lcd_vidInit+0x1ae>
		__ticks = 1;
    1d7c:	81 e0       	ldi	r24, 0x01	; 1
    1d7e:	90 e0       	ldi	r25, 0x00	; 0
    1d80:	9c 8b       	std	Y+20, r25	; 0x14
    1d82:	8b 8b       	std	Y+19, r24	; 0x13
    1d84:	3f c0       	rjmp	.+126    	; 0x1e04 <Lcd_vidInit+0x22c>
	else if (__tmp > 65535)
    1d86:	6d 89       	ldd	r22, Y+21	; 0x15
    1d88:	7e 89       	ldd	r23, Y+22	; 0x16
    1d8a:	8f 89       	ldd	r24, Y+23	; 0x17
    1d8c:	98 8d       	ldd	r25, Y+24	; 0x18
    1d8e:	20 e0       	ldi	r18, 0x00	; 0
    1d90:	3f ef       	ldi	r19, 0xFF	; 255
    1d92:	4f e7       	ldi	r20, 0x7F	; 127
    1d94:	57 e4       	ldi	r21, 0x47	; 71
    1d96:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1d9a:	18 16       	cp	r1, r24
    1d9c:	4c f5       	brge	.+82     	; 0x1df0 <Lcd_vidInit+0x218>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1d9e:	69 8d       	ldd	r22, Y+25	; 0x19
    1da0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1da2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1da4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1da6:	20 e0       	ldi	r18, 0x00	; 0
    1da8:	30 e0       	ldi	r19, 0x00	; 0
    1daa:	40 e2       	ldi	r20, 0x20	; 32
    1dac:	51 e4       	ldi	r21, 0x41	; 65
    1dae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1db2:	dc 01       	movw	r26, r24
    1db4:	cb 01       	movw	r24, r22
    1db6:	bc 01       	movw	r22, r24
    1db8:	cd 01       	movw	r24, r26
    1dba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dbe:	dc 01       	movw	r26, r24
    1dc0:	cb 01       	movw	r24, r22
    1dc2:	9c 8b       	std	Y+20, r25	; 0x14
    1dc4:	8b 8b       	std	Y+19, r24	; 0x13
    1dc6:	0f c0       	rjmp	.+30     	; 0x1de6 <Lcd_vidInit+0x20e>
    1dc8:	88 ec       	ldi	r24, 0xC8	; 200
    1dca:	90 e0       	ldi	r25, 0x00	; 0
    1dcc:	9a 8b       	std	Y+18, r25	; 0x12
    1dce:	89 8b       	std	Y+17, r24	; 0x11
    1dd0:	89 89       	ldd	r24, Y+17	; 0x11
    1dd2:	9a 89       	ldd	r25, Y+18	; 0x12
    1dd4:	01 97       	sbiw	r24, 0x01	; 1
    1dd6:	f1 f7       	brne	.-4      	; 0x1dd4 <Lcd_vidInit+0x1fc>
    1dd8:	9a 8b       	std	Y+18, r25	; 0x12
    1dda:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ddc:	8b 89       	ldd	r24, Y+19	; 0x13
    1dde:	9c 89       	ldd	r25, Y+20	; 0x14
    1de0:	01 97       	sbiw	r24, 0x01	; 1
    1de2:	9c 8b       	std	Y+20, r25	; 0x14
    1de4:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1de6:	8b 89       	ldd	r24, Y+19	; 0x13
    1de8:	9c 89       	ldd	r25, Y+20	; 0x14
    1dea:	00 97       	sbiw	r24, 0x00	; 0
    1dec:	69 f7       	brne	.-38     	; 0x1dc8 <Lcd_vidInit+0x1f0>
    1dee:	14 c0       	rjmp	.+40     	; 0x1e18 <Lcd_vidInit+0x240>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1df0:	6d 89       	ldd	r22, Y+21	; 0x15
    1df2:	7e 89       	ldd	r23, Y+22	; 0x16
    1df4:	8f 89       	ldd	r24, Y+23	; 0x17
    1df6:	98 8d       	ldd	r25, Y+24	; 0x18
    1df8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dfc:	dc 01       	movw	r26, r24
    1dfe:	cb 01       	movw	r24, r22
    1e00:	9c 8b       	std	Y+20, r25	; 0x14
    1e02:	8b 8b       	std	Y+19, r24	; 0x13
    1e04:	8b 89       	ldd	r24, Y+19	; 0x13
    1e06:	9c 89       	ldd	r25, Y+20	; 0x14
    1e08:	98 8b       	std	Y+16, r25	; 0x10
    1e0a:	8f 87       	std	Y+15, r24	; 0x0f
    1e0c:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e0e:	98 89       	ldd	r25, Y+16	; 0x10
    1e10:	01 97       	sbiw	r24, 0x01	; 1
    1e12:	f1 f7       	brne	.-4      	; 0x1e10 <Lcd_vidInit+0x238>
    1e14:	98 8b       	std	Y+16, r25	; 0x10
    1e16:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	Lcd_vidSendCommand(LCD_u8CMD_CLR_Display);
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <Lcd_vidSendCommand>
    1e1e:	80 e0       	ldi	r24, 0x00	; 0
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	a0 e0       	ldi	r26, 0x00	; 0
    1e24:	b0 e4       	ldi	r27, 0x40	; 64
    1e26:	8b 87       	std	Y+11, r24	; 0x0b
    1e28:	9c 87       	std	Y+12, r25	; 0x0c
    1e2a:	ad 87       	std	Y+13, r26	; 0x0d
    1e2c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1e2e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1e30:	7c 85       	ldd	r23, Y+12	; 0x0c
    1e32:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e34:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e36:	20 e0       	ldi	r18, 0x00	; 0
    1e38:	30 e0       	ldi	r19, 0x00	; 0
    1e3a:	4a ef       	ldi	r20, 0xFA	; 250
    1e3c:	54 e4       	ldi	r21, 0x44	; 68
    1e3e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e42:	dc 01       	movw	r26, r24
    1e44:	cb 01       	movw	r24, r22
    1e46:	8f 83       	std	Y+7, r24	; 0x07
    1e48:	98 87       	std	Y+8, r25	; 0x08
    1e4a:	a9 87       	std	Y+9, r26	; 0x09
    1e4c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1e4e:	6f 81       	ldd	r22, Y+7	; 0x07
    1e50:	78 85       	ldd	r23, Y+8	; 0x08
    1e52:	89 85       	ldd	r24, Y+9	; 0x09
    1e54:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e56:	20 e0       	ldi	r18, 0x00	; 0
    1e58:	30 e0       	ldi	r19, 0x00	; 0
    1e5a:	40 e8       	ldi	r20, 0x80	; 128
    1e5c:	5f e3       	ldi	r21, 0x3F	; 63
    1e5e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1e62:	88 23       	and	r24, r24
    1e64:	2c f4       	brge	.+10     	; 0x1e70 <Lcd_vidInit+0x298>
		__ticks = 1;
    1e66:	81 e0       	ldi	r24, 0x01	; 1
    1e68:	90 e0       	ldi	r25, 0x00	; 0
    1e6a:	9e 83       	std	Y+6, r25	; 0x06
    1e6c:	8d 83       	std	Y+5, r24	; 0x05
    1e6e:	3f c0       	rjmp	.+126    	; 0x1eee <Lcd_vidInit+0x316>
	else if (__tmp > 65535)
    1e70:	6f 81       	ldd	r22, Y+7	; 0x07
    1e72:	78 85       	ldd	r23, Y+8	; 0x08
    1e74:	89 85       	ldd	r24, Y+9	; 0x09
    1e76:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e78:	20 e0       	ldi	r18, 0x00	; 0
    1e7a:	3f ef       	ldi	r19, 0xFF	; 255
    1e7c:	4f e7       	ldi	r20, 0x7F	; 127
    1e7e:	57 e4       	ldi	r21, 0x47	; 71
    1e80:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1e84:	18 16       	cp	r1, r24
    1e86:	4c f5       	brge	.+82     	; 0x1eda <Lcd_vidInit+0x302>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e88:	6b 85       	ldd	r22, Y+11	; 0x0b
    1e8a:	7c 85       	ldd	r23, Y+12	; 0x0c
    1e8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e90:	20 e0       	ldi	r18, 0x00	; 0
    1e92:	30 e0       	ldi	r19, 0x00	; 0
    1e94:	40 e2       	ldi	r20, 0x20	; 32
    1e96:	51 e4       	ldi	r21, 0x41	; 65
    1e98:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e9c:	dc 01       	movw	r26, r24
    1e9e:	cb 01       	movw	r24, r22
    1ea0:	bc 01       	movw	r22, r24
    1ea2:	cd 01       	movw	r24, r26
    1ea4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ea8:	dc 01       	movw	r26, r24
    1eaa:	cb 01       	movw	r24, r22
    1eac:	9e 83       	std	Y+6, r25	; 0x06
    1eae:	8d 83       	std	Y+5, r24	; 0x05
    1eb0:	0f c0       	rjmp	.+30     	; 0x1ed0 <Lcd_vidInit+0x2f8>
    1eb2:	88 ec       	ldi	r24, 0xC8	; 200
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	9c 83       	std	Y+4, r25	; 0x04
    1eb8:	8b 83       	std	Y+3, r24	; 0x03
    1eba:	8b 81       	ldd	r24, Y+3	; 0x03
    1ebc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ebe:	01 97       	sbiw	r24, 0x01	; 1
    1ec0:	f1 f7       	brne	.-4      	; 0x1ebe <Lcd_vidInit+0x2e6>
    1ec2:	9c 83       	std	Y+4, r25	; 0x04
    1ec4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ec6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ec8:	9e 81       	ldd	r25, Y+6	; 0x06
    1eca:	01 97       	sbiw	r24, 0x01	; 1
    1ecc:	9e 83       	std	Y+6, r25	; 0x06
    1ece:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ed0:	8d 81       	ldd	r24, Y+5	; 0x05
    1ed2:	9e 81       	ldd	r25, Y+6	; 0x06
    1ed4:	00 97       	sbiw	r24, 0x00	; 0
    1ed6:	69 f7       	brne	.-38     	; 0x1eb2 <Lcd_vidInit+0x2da>
    1ed8:	14 c0       	rjmp	.+40     	; 0x1f02 <Lcd_vidInit+0x32a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1eda:	6f 81       	ldd	r22, Y+7	; 0x07
    1edc:	78 85       	ldd	r23, Y+8	; 0x08
    1ede:	89 85       	ldd	r24, Y+9	; 0x09
    1ee0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ee2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ee6:	dc 01       	movw	r26, r24
    1ee8:	cb 01       	movw	r24, r22
    1eea:	9e 83       	std	Y+6, r25	; 0x06
    1eec:	8d 83       	std	Y+5, r24	; 0x05
    1eee:	8d 81       	ldd	r24, Y+5	; 0x05
    1ef0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ef2:	9a 83       	std	Y+2, r25	; 0x02
    1ef4:	89 83       	std	Y+1, r24	; 0x01
    1ef6:	89 81       	ldd	r24, Y+1	; 0x01
    1ef8:	9a 81       	ldd	r25, Y+2	; 0x02
    1efa:	01 97       	sbiw	r24, 0x01	; 1
    1efc:	f1 f7       	brne	.-4      	; 0x1efa <Lcd_vidInit+0x322>
    1efe:	9a 83       	std	Y+2, r25	; 0x02
    1f00:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);

}
    1f02:	aa 96       	adiw	r28, 0x2a	; 42
    1f04:	0f b6       	in	r0, 0x3f	; 63
    1f06:	f8 94       	cli
    1f08:	de bf       	out	0x3e, r29	; 62
    1f0a:	0f be       	out	0x3f, r0	; 63
    1f0c:	cd bf       	out	0x3d, r28	; 61
    1f0e:	cf 91       	pop	r28
    1f10:	df 91       	pop	r29
    1f12:	08 95       	ret

00001f14 <Lcd_vidWriteChar>:

void Lcd_vidWriteChar(u8 Char)

{
    1f14:	df 93       	push	r29
    1f16:	cf 93       	push	r28
    1f18:	cd b7       	in	r28, 0x3d	; 61
    1f1a:	de b7       	in	r29, 0x3e	; 62
    1f1c:	2f 97       	sbiw	r28, 0x0f	; 15
    1f1e:	0f b6       	in	r0, 0x3f	; 63
    1f20:	f8 94       	cli
    1f22:	de bf       	out	0x3e, r29	; 62
    1f24:	0f be       	out	0x3f, r0	; 63
    1f26:	cd bf       	out	0x3d, r28	; 61
    1f28:	8f 87       	std	Y+15, r24	; 0x0f
	Dio_vidSetPinVal(LCD_u8RS_PIN , DIO_u8HIGH);  //RS
    1f2a:	80 e0       	ldi	r24, 0x00	; 0
    1f2c:	61 e0       	ldi	r22, 0x01	; 1
    1f2e:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8RW_PIN , DIO_u8LOW);  //RW
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	60 e0       	ldi	r22, 0x00	; 0
    1f36:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8EN_PIN , DIO_u8HIGH);  //EN
    1f3a:	82 e0       	ldi	r24, 0x02	; 2
    1f3c:	61 e0       	ldi	r22, 0x01	; 1
    1f3e:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>

	Dio_vidSetPinVal(LCD_u8D0_PIN , GET_BIT(Char,0));
    1f42:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f44:	98 2f       	mov	r25, r24
    1f46:	91 70       	andi	r25, 0x01	; 1
    1f48:	88 e1       	ldi	r24, 0x18	; 24
    1f4a:	69 2f       	mov	r22, r25
    1f4c:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D1_PIN , GET_BIT(Char,1));
    1f50:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f52:	86 95       	lsr	r24
    1f54:	98 2f       	mov	r25, r24
    1f56:	91 70       	andi	r25, 0x01	; 1
    1f58:	89 e1       	ldi	r24, 0x19	; 25
    1f5a:	69 2f       	mov	r22, r25
    1f5c:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D2_PIN , GET_BIT(Char,2));
    1f60:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f62:	86 95       	lsr	r24
    1f64:	86 95       	lsr	r24
    1f66:	98 2f       	mov	r25, r24
    1f68:	91 70       	andi	r25, 0x01	; 1
    1f6a:	83 e0       	ldi	r24, 0x03	; 3
    1f6c:	69 2f       	mov	r22, r25
    1f6e:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D3_PIN , GET_BIT(Char,3));
    1f72:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f74:	86 95       	lsr	r24
    1f76:	86 95       	lsr	r24
    1f78:	86 95       	lsr	r24
    1f7a:	98 2f       	mov	r25, r24
    1f7c:	91 70       	andi	r25, 0x01	; 1
    1f7e:	8b e1       	ldi	r24, 0x1B	; 27
    1f80:	69 2f       	mov	r22, r25
    1f82:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D4_PIN , GET_BIT(Char,4));
    1f86:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f88:	82 95       	swap	r24
    1f8a:	8f 70       	andi	r24, 0x0F	; 15
    1f8c:	98 2f       	mov	r25, r24
    1f8e:	91 70       	andi	r25, 0x01	; 1
    1f90:	8c e1       	ldi	r24, 0x1C	; 28
    1f92:	69 2f       	mov	r22, r25
    1f94:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D5_PIN , GET_BIT(Char,5));
    1f98:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f9a:	82 95       	swap	r24
    1f9c:	86 95       	lsr	r24
    1f9e:	87 70       	andi	r24, 0x07	; 7
    1fa0:	98 2f       	mov	r25, r24
    1fa2:	91 70       	andi	r25, 0x01	; 1
    1fa4:	8d e1       	ldi	r24, 0x1D	; 29
    1fa6:	69 2f       	mov	r22, r25
    1fa8:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D6_PIN , GET_BIT(Char,6));
    1fac:	8f 85       	ldd	r24, Y+15	; 0x0f
    1fae:	82 95       	swap	r24
    1fb0:	86 95       	lsr	r24
    1fb2:	86 95       	lsr	r24
    1fb4:	83 70       	andi	r24, 0x03	; 3
    1fb6:	98 2f       	mov	r25, r24
    1fb8:	91 70       	andi	r25, 0x01	; 1
    1fba:	8e e1       	ldi	r24, 0x1E	; 30
    1fbc:	69 2f       	mov	r22, r25
    1fbe:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
	Dio_vidSetPinVal(LCD_u8D7_PIN , GET_BIT(Char,7));
    1fc2:	8f 85       	ldd	r24, Y+15	; 0x0f
    1fc4:	98 2f       	mov	r25, r24
    1fc6:	99 1f       	adc	r25, r25
    1fc8:	99 27       	eor	r25, r25
    1fca:	99 1f       	adc	r25, r25
    1fcc:	8f e1       	ldi	r24, 0x1F	; 31
    1fce:	69 2f       	mov	r22, r25
    1fd0:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
    1fd4:	80 e0       	ldi	r24, 0x00	; 0
    1fd6:	90 e0       	ldi	r25, 0x00	; 0
    1fd8:	a0 e0       	ldi	r26, 0x00	; 0
    1fda:	b0 e4       	ldi	r27, 0x40	; 64
    1fdc:	8b 87       	std	Y+11, r24	; 0x0b
    1fde:	9c 87       	std	Y+12, r25	; 0x0c
    1fe0:	ad 87       	std	Y+13, r26	; 0x0d
    1fe2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1fe4:	6b 85       	ldd	r22, Y+11	; 0x0b
    1fe6:	7c 85       	ldd	r23, Y+12	; 0x0c
    1fe8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fea:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fec:	20 e0       	ldi	r18, 0x00	; 0
    1fee:	30 e0       	ldi	r19, 0x00	; 0
    1ff0:	4a ef       	ldi	r20, 0xFA	; 250
    1ff2:	54 e4       	ldi	r21, 0x44	; 68
    1ff4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ff8:	dc 01       	movw	r26, r24
    1ffa:	cb 01       	movw	r24, r22
    1ffc:	8f 83       	std	Y+7, r24	; 0x07
    1ffe:	98 87       	std	Y+8, r25	; 0x08
    2000:	a9 87       	std	Y+9, r26	; 0x09
    2002:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2004:	6f 81       	ldd	r22, Y+7	; 0x07
    2006:	78 85       	ldd	r23, Y+8	; 0x08
    2008:	89 85       	ldd	r24, Y+9	; 0x09
    200a:	9a 85       	ldd	r25, Y+10	; 0x0a
    200c:	20 e0       	ldi	r18, 0x00	; 0
    200e:	30 e0       	ldi	r19, 0x00	; 0
    2010:	40 e8       	ldi	r20, 0x80	; 128
    2012:	5f e3       	ldi	r21, 0x3F	; 63
    2014:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2018:	88 23       	and	r24, r24
    201a:	2c f4       	brge	.+10     	; 0x2026 <Lcd_vidWriteChar+0x112>
		__ticks = 1;
    201c:	81 e0       	ldi	r24, 0x01	; 1
    201e:	90 e0       	ldi	r25, 0x00	; 0
    2020:	9e 83       	std	Y+6, r25	; 0x06
    2022:	8d 83       	std	Y+5, r24	; 0x05
    2024:	3f c0       	rjmp	.+126    	; 0x20a4 <Lcd_vidWriteChar+0x190>
	else if (__tmp > 65535)
    2026:	6f 81       	ldd	r22, Y+7	; 0x07
    2028:	78 85       	ldd	r23, Y+8	; 0x08
    202a:	89 85       	ldd	r24, Y+9	; 0x09
    202c:	9a 85       	ldd	r25, Y+10	; 0x0a
    202e:	20 e0       	ldi	r18, 0x00	; 0
    2030:	3f ef       	ldi	r19, 0xFF	; 255
    2032:	4f e7       	ldi	r20, 0x7F	; 127
    2034:	57 e4       	ldi	r21, 0x47	; 71
    2036:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    203a:	18 16       	cp	r1, r24
    203c:	4c f5       	brge	.+82     	; 0x2090 <Lcd_vidWriteChar+0x17c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    203e:	6b 85       	ldd	r22, Y+11	; 0x0b
    2040:	7c 85       	ldd	r23, Y+12	; 0x0c
    2042:	8d 85       	ldd	r24, Y+13	; 0x0d
    2044:	9e 85       	ldd	r25, Y+14	; 0x0e
    2046:	20 e0       	ldi	r18, 0x00	; 0
    2048:	30 e0       	ldi	r19, 0x00	; 0
    204a:	40 e2       	ldi	r20, 0x20	; 32
    204c:	51 e4       	ldi	r21, 0x41	; 65
    204e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2052:	dc 01       	movw	r26, r24
    2054:	cb 01       	movw	r24, r22
    2056:	bc 01       	movw	r22, r24
    2058:	cd 01       	movw	r24, r26
    205a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    205e:	dc 01       	movw	r26, r24
    2060:	cb 01       	movw	r24, r22
    2062:	9e 83       	std	Y+6, r25	; 0x06
    2064:	8d 83       	std	Y+5, r24	; 0x05
    2066:	0f c0       	rjmp	.+30     	; 0x2086 <Lcd_vidWriteChar+0x172>
    2068:	88 ec       	ldi	r24, 0xC8	; 200
    206a:	90 e0       	ldi	r25, 0x00	; 0
    206c:	9c 83       	std	Y+4, r25	; 0x04
    206e:	8b 83       	std	Y+3, r24	; 0x03
    2070:	8b 81       	ldd	r24, Y+3	; 0x03
    2072:	9c 81       	ldd	r25, Y+4	; 0x04
    2074:	01 97       	sbiw	r24, 0x01	; 1
    2076:	f1 f7       	brne	.-4      	; 0x2074 <Lcd_vidWriteChar+0x160>
    2078:	9c 83       	std	Y+4, r25	; 0x04
    207a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    207c:	8d 81       	ldd	r24, Y+5	; 0x05
    207e:	9e 81       	ldd	r25, Y+6	; 0x06
    2080:	01 97       	sbiw	r24, 0x01	; 1
    2082:	9e 83       	std	Y+6, r25	; 0x06
    2084:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2086:	8d 81       	ldd	r24, Y+5	; 0x05
    2088:	9e 81       	ldd	r25, Y+6	; 0x06
    208a:	00 97       	sbiw	r24, 0x00	; 0
    208c:	69 f7       	brne	.-38     	; 0x2068 <Lcd_vidWriteChar+0x154>
    208e:	14 c0       	rjmp	.+40     	; 0x20b8 <Lcd_vidWriteChar+0x1a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2090:	6f 81       	ldd	r22, Y+7	; 0x07
    2092:	78 85       	ldd	r23, Y+8	; 0x08
    2094:	89 85       	ldd	r24, Y+9	; 0x09
    2096:	9a 85       	ldd	r25, Y+10	; 0x0a
    2098:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    209c:	dc 01       	movw	r26, r24
    209e:	cb 01       	movw	r24, r22
    20a0:	9e 83       	std	Y+6, r25	; 0x06
    20a2:	8d 83       	std	Y+5, r24	; 0x05
    20a4:	8d 81       	ldd	r24, Y+5	; 0x05
    20a6:	9e 81       	ldd	r25, Y+6	; 0x06
    20a8:	9a 83       	std	Y+2, r25	; 0x02
    20aa:	89 83       	std	Y+1, r24	; 0x01
    20ac:	89 81       	ldd	r24, Y+1	; 0x01
    20ae:	9a 81       	ldd	r25, Y+2	; 0x02
    20b0:	01 97       	sbiw	r24, 0x01	; 1
    20b2:	f1 f7       	brne	.-4      	; 0x20b0 <Lcd_vidWriteChar+0x19c>
    20b4:	9a 83       	std	Y+2, r25	; 0x02
    20b6:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(2);

	Dio_vidSetPinVal(LCD_u8EN_PIN , DIO_u8LOW);  //EN
    20b8:	82 e0       	ldi	r24, 0x02	; 2
    20ba:	60 e0       	ldi	r22, 0x00	; 0
    20bc:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>
}
    20c0:	2f 96       	adiw	r28, 0x0f	; 15
    20c2:	0f b6       	in	r0, 0x3f	; 63
    20c4:	f8 94       	cli
    20c6:	de bf       	out	0x3e, r29	; 62
    20c8:	0f be       	out	0x3f, r0	; 63
    20ca:	cd bf       	out	0x3d, r28	; 61
    20cc:	cf 91       	pop	r28
    20ce:	df 91       	pop	r29
    20d0:	08 95       	ret

000020d2 <Lcd_vidWriteStr>:

void Lcd_vidWriteStr(u8 *Str){
    20d2:	df 93       	push	r29
    20d4:	cf 93       	push	r28
    20d6:	00 d0       	rcall	.+0      	; 0x20d8 <Lcd_vidWriteStr+0x6>
    20d8:	cd b7       	in	r28, 0x3d	; 61
    20da:	de b7       	in	r29, 0x3e	; 62
    20dc:	9a 83       	std	Y+2, r25	; 0x02
    20de:	89 83       	std	Y+1, r24	; 0x01
    20e0:	0a c0       	rjmp	.+20     	; 0x20f6 <Lcd_vidWriteStr+0x24>

	while(* Str != '\0')
	{
		Lcd_vidWriteChar(* Str);
    20e2:	e9 81       	ldd	r30, Y+1	; 0x01
    20e4:	fa 81       	ldd	r31, Y+2	; 0x02
    20e6:	80 81       	ld	r24, Z
    20e8:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <Lcd_vidWriteChar>
		Str++;
    20ec:	89 81       	ldd	r24, Y+1	; 0x01
    20ee:	9a 81       	ldd	r25, Y+2	; 0x02
    20f0:	01 96       	adiw	r24, 0x01	; 1
    20f2:	9a 83       	std	Y+2, r25	; 0x02
    20f4:	89 83       	std	Y+1, r24	; 0x01
	Dio_vidSetPinVal(LCD_u8EN_PIN , DIO_u8LOW);  //EN
}

void Lcd_vidWriteStr(u8 *Str){

	while(* Str != '\0')
    20f6:	e9 81       	ldd	r30, Y+1	; 0x01
    20f8:	fa 81       	ldd	r31, Y+2	; 0x02
    20fa:	80 81       	ld	r24, Z
    20fc:	88 23       	and	r24, r24
    20fe:	89 f7       	brne	.-30     	; 0x20e2 <Lcd_vidWriteStr+0x10>
	{
		Lcd_vidWriteChar(* Str);
		Str++;
	}
}
    2100:	0f 90       	pop	r0
    2102:	0f 90       	pop	r0
    2104:	cf 91       	pop	r28
    2106:	df 91       	pop	r29
    2108:	08 95       	ret

0000210a <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    210a:	df 93       	push	r29
    210c:	cf 93       	push	r28
    210e:	00 d0       	rcall	.+0      	; 0x2110 <xEventGroupCreate+0x6>
    2110:	cd b7       	in	r28, 0x3d	; 61
    2112:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    2114:	8b e0       	ldi	r24, 0x0B	; 11
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	0e 94 ca 13 	call	0x2794	; 0x2794 <pvPortMalloc>
    211c:	9a 83       	std	Y+2, r25	; 0x02
    211e:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    2120:	89 81       	ldd	r24, Y+1	; 0x01
    2122:	9a 81       	ldd	r25, Y+2	; 0x02
    2124:	00 97       	sbiw	r24, 0x00	; 0
    2126:	49 f0       	breq	.+18     	; 0x213a <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
    2128:	e9 81       	ldd	r30, Y+1	; 0x01
    212a:	fa 81       	ldd	r31, Y+2	; 0x02
    212c:	11 82       	std	Z+1, r1	; 0x01
    212e:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    2130:	89 81       	ldd	r24, Y+1	; 0x01
    2132:	9a 81       	ldd	r25, Y+2	; 0x02
    2134:	02 96       	adiw	r24, 0x02	; 2
    2136:	0e 94 46 14 	call	0x288c	; 0x288c <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    213a:	89 81       	ldd	r24, Y+1	; 0x01
    213c:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    213e:	0f 90       	pop	r0
    2140:	0f 90       	pop	r0
    2142:	cf 91       	pop	r28
    2144:	df 91       	pop	r29
    2146:	08 95       	ret

00002148 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    2148:	df 93       	push	r29
    214a:	cf 93       	push	r28
    214c:	cd b7       	in	r28, 0x3d	; 61
    214e:	de b7       	in	r29, 0x3e	; 62
    2150:	60 97       	sbiw	r28, 0x10	; 16
    2152:	0f b6       	in	r0, 0x3f	; 63
    2154:	f8 94       	cli
    2156:	de bf       	out	0x3e, r29	; 62
    2158:	0f be       	out	0x3f, r0	; 63
    215a:	cd bf       	out	0x3d, r28	; 61
    215c:	9a 87       	std	Y+10, r25	; 0x0a
    215e:	89 87       	std	Y+9, r24	; 0x09
    2160:	7c 87       	std	Y+12, r23	; 0x0c
    2162:	6b 87       	std	Y+11, r22	; 0x0b
    2164:	5e 87       	std	Y+14, r21	; 0x0e
    2166:	4d 87       	std	Y+13, r20	; 0x0d
    2168:	38 8b       	std	Y+16, r19	; 0x10
    216a:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    216c:	89 85       	ldd	r24, Y+9	; 0x09
    216e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2170:	9c 83       	std	Y+4, r25	; 0x04
    2172:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2174:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2176:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    217a:	eb 81       	ldd	r30, Y+3	; 0x03
    217c:	fc 81       	ldd	r31, Y+4	; 0x04
    217e:	80 81       	ld	r24, Z
    2180:	91 81       	ldd	r25, Z+1	; 0x01
    2182:	98 87       	std	Y+8, r25	; 0x08
    2184:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    2186:	89 85       	ldd	r24, Y+9	; 0x09
    2188:	9a 85       	ldd	r25, Y+10	; 0x0a
    218a:	2b 85       	ldd	r18, Y+11	; 0x0b
    218c:	3c 85       	ldd	r19, Y+12	; 0x0c
    218e:	b9 01       	movw	r22, r18
    2190:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2194:	2f 81       	ldd	r18, Y+7	; 0x07
    2196:	38 85       	ldd	r19, Y+8	; 0x08
    2198:	8b 85       	ldd	r24, Y+11	; 0x0b
    219a:	9c 85       	ldd	r25, Y+12	; 0x0c
    219c:	28 2b       	or	r18, r24
    219e:	39 2b       	or	r19, r25
    21a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    21a2:	9e 85       	ldd	r25, Y+14	; 0x0e
    21a4:	28 23       	and	r18, r24
    21a6:	39 23       	and	r19, r25
    21a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    21aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    21ac:	28 17       	cp	r18, r24
    21ae:	39 07       	cpc	r19, r25
    21b0:	c9 f4       	brne	.+50     	; 0x21e4 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    21b2:	2f 81       	ldd	r18, Y+7	; 0x07
    21b4:	38 85       	ldd	r19, Y+8	; 0x08
    21b6:	8b 85       	ldd	r24, Y+11	; 0x0b
    21b8:	9c 85       	ldd	r25, Y+12	; 0x0c
    21ba:	82 2b       	or	r24, r18
    21bc:	93 2b       	or	r25, r19
    21be:	9e 83       	std	Y+6, r25	; 0x06
    21c0:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    21c2:	eb 81       	ldd	r30, Y+3	; 0x03
    21c4:	fc 81       	ldd	r31, Y+4	; 0x04
    21c6:	20 81       	ld	r18, Z
    21c8:	31 81       	ldd	r19, Z+1	; 0x01
    21ca:	8d 85       	ldd	r24, Y+13	; 0x0d
    21cc:	9e 85       	ldd	r25, Y+14	; 0x0e
    21ce:	80 95       	com	r24
    21d0:	90 95       	com	r25
    21d2:	82 23       	and	r24, r18
    21d4:	93 23       	and	r25, r19
    21d6:	eb 81       	ldd	r30, Y+3	; 0x03
    21d8:	fc 81       	ldd	r31, Y+4	; 0x04
    21da:	91 83       	std	Z+1, r25	; 0x01
    21dc:	80 83       	st	Z, r24

			xTicksToWait = 0;
    21de:	18 8a       	std	Y+16, r1	; 0x10
    21e0:	1f 86       	std	Y+15, r1	; 0x0f
    21e2:	1e c0       	rjmp	.+60     	; 0x2220 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    21e4:	8f 85       	ldd	r24, Y+15	; 0x0f
    21e6:	98 89       	ldd	r25, Y+16	; 0x10
    21e8:	00 97       	sbiw	r24, 0x00	; 0
    21ea:	91 f0       	breq	.+36     	; 0x2210 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    21ec:	8b 81       	ldd	r24, Y+3	; 0x03
    21ee:	9c 81       	ldd	r25, Y+4	; 0x04
    21f0:	bc 01       	movw	r22, r24
    21f2:	6e 5f       	subi	r22, 0xFE	; 254
    21f4:	7f 4f       	sbci	r23, 0xFF	; 255
    21f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    21f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    21fa:	9c 01       	movw	r18, r24
    21fc:	35 60       	ori	r19, 0x05	; 5
    21fe:	4f 85       	ldd	r20, Y+15	; 0x0f
    2200:	58 89       	ldd	r21, Y+16	; 0x10
    2202:	cb 01       	movw	r24, r22
    2204:	b9 01       	movw	r22, r18
    2206:	0e 94 75 2e 	call	0x5cea	; 0x5cea <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    220a:	1e 82       	std	Y+6, r1	; 0x06
    220c:	1d 82       	std	Y+5, r1	; 0x05
    220e:	08 c0       	rjmp	.+16     	; 0x2220 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2210:	eb 81       	ldd	r30, Y+3	; 0x03
    2212:	fc 81       	ldd	r31, Y+4	; 0x04
    2214:	80 81       	ld	r24, Z
    2216:	91 81       	ldd	r25, Z+1	; 0x01
    2218:	9e 83       	std	Y+6, r25	; 0x06
    221a:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
    221c:	81 e0       	ldi	r24, 0x01	; 1
    221e:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2220:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    2224:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    2226:	8f 85       	ldd	r24, Y+15	; 0x0f
    2228:	98 89       	ldd	r25, Y+16	; 0x10
    222a:	00 97       	sbiw	r24, 0x00	; 0
    222c:	09 f4       	brne	.+2      	; 0x2230 <xEventGroupSync+0xe8>
    222e:	3a c0       	rjmp	.+116    	; 0x22a4 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
    2230:	8a 81       	ldd	r24, Y+2	; 0x02
    2232:	88 23       	and	r24, r24
    2234:	11 f4       	brne	.+4      	; 0x223a <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
    2236:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    223a:	0e 94 e8 30 	call	0x61d0	; 0x61d0 <uxTaskResetEventItemValue>
    223e:	9e 83       	std	Y+6, r25	; 0x06
    2240:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2242:	8d 81       	ldd	r24, Y+5	; 0x05
    2244:	9e 81       	ldd	r25, Y+6	; 0x06
    2246:	80 70       	andi	r24, 0x00	; 0
    2248:	92 70       	andi	r25, 0x02	; 2
    224a:	00 97       	sbiw	r24, 0x00	; 0
    224c:	31 f5       	brne	.+76     	; 0x229a <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    224e:	0f b6       	in	r0, 0x3f	; 63
    2250:	f8 94       	cli
    2252:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    2254:	eb 81       	ldd	r30, Y+3	; 0x03
    2256:	fc 81       	ldd	r31, Y+4	; 0x04
    2258:	80 81       	ld	r24, Z
    225a:	91 81       	ldd	r25, Z+1	; 0x01
    225c:	9e 83       	std	Y+6, r25	; 0x06
    225e:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2260:	2d 81       	ldd	r18, Y+5	; 0x05
    2262:	3e 81       	ldd	r19, Y+6	; 0x06
    2264:	8d 85       	ldd	r24, Y+13	; 0x0d
    2266:	9e 85       	ldd	r25, Y+14	; 0x0e
    2268:	28 23       	and	r18, r24
    226a:	39 23       	and	r19, r25
    226c:	8d 85       	ldd	r24, Y+13	; 0x0d
    226e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2270:	28 17       	cp	r18, r24
    2272:	39 07       	cpc	r19, r25
    2274:	71 f4       	brne	.+28     	; 0x2292 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2276:	eb 81       	ldd	r30, Y+3	; 0x03
    2278:	fc 81       	ldd	r31, Y+4	; 0x04
    227a:	20 81       	ld	r18, Z
    227c:	31 81       	ldd	r19, Z+1	; 0x01
    227e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2280:	9e 85       	ldd	r25, Y+14	; 0x0e
    2282:	80 95       	com	r24
    2284:	90 95       	com	r25
    2286:	82 23       	and	r24, r18
    2288:	93 23       	and	r25, r19
    228a:	eb 81       	ldd	r30, Y+3	; 0x03
    228c:	fc 81       	ldd	r31, Y+4	; 0x04
    228e:	91 83       	std	Z+1, r25	; 0x01
    2290:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2292:	0f 90       	pop	r0
    2294:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    2296:	81 e0       	ldi	r24, 0x01	; 1
    2298:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    229a:	8d 81       	ldd	r24, Y+5	; 0x05
    229c:	9e 81       	ldd	r25, Y+6	; 0x06
    229e:	90 70       	andi	r25, 0x00	; 0
    22a0:	9e 83       	std	Y+6, r25	; 0x06
    22a2:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    22a4:	8d 81       	ldd	r24, Y+5	; 0x05
    22a6:	9e 81       	ldd	r25, Y+6	; 0x06
}
    22a8:	60 96       	adiw	r28, 0x10	; 16
    22aa:	0f b6       	in	r0, 0x3f	; 63
    22ac:	f8 94       	cli
    22ae:	de bf       	out	0x3e, r29	; 62
    22b0:	0f be       	out	0x3f, r0	; 63
    22b2:	cd bf       	out	0x3d, r28	; 61
    22b4:	cf 91       	pop	r28
    22b6:	df 91       	pop	r29
    22b8:	08 95       	ret

000022ba <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    22ba:	0f 93       	push	r16
    22bc:	1f 93       	push	r17
    22be:	df 93       	push	r29
    22c0:	cf 93       	push	r28
    22c2:	cd b7       	in	r28, 0x3d	; 61
    22c4:	de b7       	in	r29, 0x3e	; 62
    22c6:	63 97       	sbiw	r28, 0x13	; 19
    22c8:	0f b6       	in	r0, 0x3f	; 63
    22ca:	f8 94       	cli
    22cc:	de bf       	out	0x3e, r29	; 62
    22ce:	0f be       	out	0x3f, r0	; 63
    22d0:	cd bf       	out	0x3d, r28	; 61
    22d2:	9d 87       	std	Y+13, r25	; 0x0d
    22d4:	8c 87       	std	Y+12, r24	; 0x0c
    22d6:	7f 87       	std	Y+15, r23	; 0x0f
    22d8:	6e 87       	std	Y+14, r22	; 0x0e
    22da:	48 8b       	std	Y+16, r20	; 0x10
    22dc:	29 8b       	std	Y+17, r18	; 0x11
    22de:	1b 8b       	std	Y+19, r17	; 0x13
    22e0:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    22e2:	8c 85       	ldd	r24, Y+12	; 0x0c
    22e4:	9d 85       	ldd	r25, Y+13	; 0x0d
    22e6:	9b 87       	std	Y+11, r25	; 0x0b
    22e8:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    22ea:	1f 82       	std	Y+7, r1	; 0x07
    22ec:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    22ee:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    22f0:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    22f4:	ea 85       	ldd	r30, Y+10	; 0x0a
    22f6:	fb 85       	ldd	r31, Y+11	; 0x0b
    22f8:	80 81       	ld	r24, Z
    22fa:	91 81       	ldd	r25, Z+1	; 0x01
    22fc:	9a 83       	std	Y+2, r25	; 0x02
    22fe:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2300:	89 81       	ldd	r24, Y+1	; 0x01
    2302:	9a 81       	ldd	r25, Y+2	; 0x02
    2304:	2e 85       	ldd	r18, Y+14	; 0x0e
    2306:	3f 85       	ldd	r19, Y+15	; 0x0f
    2308:	b9 01       	movw	r22, r18
    230a:	49 89       	ldd	r20, Y+17	; 0x11
    230c:	0e 94 98 13 	call	0x2730	; 0x2730 <prvTestWaitCondition>
    2310:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    2312:	8d 81       	ldd	r24, Y+5	; 0x05
    2314:	88 23       	and	r24, r24
    2316:	c1 f0       	breq	.+48     	; 0x2348 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    2318:	89 81       	ldd	r24, Y+1	; 0x01
    231a:	9a 81       	ldd	r25, Y+2	; 0x02
    231c:	99 87       	std	Y+9, r25	; 0x09
    231e:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    2320:	1b 8a       	std	Y+19, r1	; 0x13
    2322:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    2324:	88 89       	ldd	r24, Y+16	; 0x10
    2326:	88 23       	and	r24, r24
    2328:	e9 f1       	breq	.+122    	; 0x23a4 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    232a:	ea 85       	ldd	r30, Y+10	; 0x0a
    232c:	fb 85       	ldd	r31, Y+11	; 0x0b
    232e:	20 81       	ld	r18, Z
    2330:	31 81       	ldd	r19, Z+1	; 0x01
    2332:	8e 85       	ldd	r24, Y+14	; 0x0e
    2334:	9f 85       	ldd	r25, Y+15	; 0x0f
    2336:	80 95       	com	r24
    2338:	90 95       	com	r25
    233a:	82 23       	and	r24, r18
    233c:	93 23       	and	r25, r19
    233e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2340:	fb 85       	ldd	r31, Y+11	; 0x0b
    2342:	91 83       	std	Z+1, r25	; 0x01
    2344:	80 83       	st	Z, r24
    2346:	2e c0       	rjmp	.+92     	; 0x23a4 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    2348:	8a 89       	ldd	r24, Y+18	; 0x12
    234a:	9b 89       	ldd	r25, Y+19	; 0x13
    234c:	00 97       	sbiw	r24, 0x00	; 0
    234e:	39 f4       	brne	.+14     	; 0x235e <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    2350:	89 81       	ldd	r24, Y+1	; 0x01
    2352:	9a 81       	ldd	r25, Y+2	; 0x02
    2354:	99 87       	std	Y+9, r25	; 0x09
    2356:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
    2358:	81 e0       	ldi	r24, 0x01	; 1
    235a:	8b 83       	std	Y+3, r24	; 0x03
    235c:	23 c0       	rjmp	.+70     	; 0x23a4 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    235e:	88 89       	ldd	r24, Y+16	; 0x10
    2360:	88 23       	and	r24, r24
    2362:	29 f0       	breq	.+10     	; 0x236e <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2364:	8e 81       	ldd	r24, Y+6	; 0x06
    2366:	9f 81       	ldd	r25, Y+7	; 0x07
    2368:	91 60       	ori	r25, 0x01	; 1
    236a:	9f 83       	std	Y+7, r25	; 0x07
    236c:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    236e:	89 89       	ldd	r24, Y+17	; 0x11
    2370:	88 23       	and	r24, r24
    2372:	29 f0       	breq	.+10     	; 0x237e <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2374:	8e 81       	ldd	r24, Y+6	; 0x06
    2376:	9f 81       	ldd	r25, Y+7	; 0x07
    2378:	94 60       	ori	r25, 0x04	; 4
    237a:	9f 83       	std	Y+7, r25	; 0x07
    237c:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    237e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2380:	9b 85       	ldd	r25, Y+11	; 0x0b
    2382:	bc 01       	movw	r22, r24
    2384:	6e 5f       	subi	r22, 0xFE	; 254
    2386:	7f 4f       	sbci	r23, 0xFF	; 255
    2388:	2e 85       	ldd	r18, Y+14	; 0x0e
    238a:	3f 85       	ldd	r19, Y+15	; 0x0f
    238c:	8e 81       	ldd	r24, Y+6	; 0x06
    238e:	9f 81       	ldd	r25, Y+7	; 0x07
    2390:	28 2b       	or	r18, r24
    2392:	39 2b       	or	r19, r25
    2394:	4a 89       	ldd	r20, Y+18	; 0x12
    2396:	5b 89       	ldd	r21, Y+19	; 0x13
    2398:	cb 01       	movw	r24, r22
    239a:	b9 01       	movw	r22, r18
    239c:	0e 94 75 2e 	call	0x5cea	; 0x5cea <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    23a0:	19 86       	std	Y+9, r1	; 0x09
    23a2:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    23a4:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    23a8:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    23aa:	8a 89       	ldd	r24, Y+18	; 0x12
    23ac:	9b 89       	ldd	r25, Y+19	; 0x13
    23ae:	00 97       	sbiw	r24, 0x00	; 0
    23b0:	09 f4       	brne	.+2      	; 0x23b4 <xEventGroupWaitBits+0xfa>
    23b2:	3c c0       	rjmp	.+120    	; 0x242c <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    23b4:	8c 81       	ldd	r24, Y+4	; 0x04
    23b6:	88 23       	and	r24, r24
    23b8:	11 f4       	brne	.+4      	; 0x23be <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    23ba:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    23be:	0e 94 e8 30 	call	0x61d0	; 0x61d0 <uxTaskResetEventItemValue>
    23c2:	99 87       	std	Y+9, r25	; 0x09
    23c4:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    23c6:	88 85       	ldd	r24, Y+8	; 0x08
    23c8:	99 85       	ldd	r25, Y+9	; 0x09
    23ca:	80 70       	andi	r24, 0x00	; 0
    23cc:	92 70       	andi	r25, 0x02	; 2
    23ce:	00 97       	sbiw	r24, 0x00	; 0
    23d0:	41 f5       	brne	.+80     	; 0x2422 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    23d2:	0f b6       	in	r0, 0x3f	; 63
    23d4:	f8 94       	cli
    23d6:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    23d8:	ea 85       	ldd	r30, Y+10	; 0x0a
    23da:	fb 85       	ldd	r31, Y+11	; 0x0b
    23dc:	80 81       	ld	r24, Z
    23de:	91 81       	ldd	r25, Z+1	; 0x01
    23e0:	99 87       	std	Y+9, r25	; 0x09
    23e2:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    23e4:	88 85       	ldd	r24, Y+8	; 0x08
    23e6:	99 85       	ldd	r25, Y+9	; 0x09
    23e8:	2e 85       	ldd	r18, Y+14	; 0x0e
    23ea:	3f 85       	ldd	r19, Y+15	; 0x0f
    23ec:	b9 01       	movw	r22, r18
    23ee:	49 89       	ldd	r20, Y+17	; 0x11
    23f0:	0e 94 98 13 	call	0x2730	; 0x2730 <prvTestWaitCondition>
    23f4:	88 23       	and	r24, r24
    23f6:	89 f0       	breq	.+34     	; 0x241a <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    23f8:	88 89       	ldd	r24, Y+16	; 0x10
    23fa:	88 23       	and	r24, r24
    23fc:	71 f0       	breq	.+28     	; 0x241a <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    23fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    2400:	fb 85       	ldd	r31, Y+11	; 0x0b
    2402:	20 81       	ld	r18, Z
    2404:	31 81       	ldd	r19, Z+1	; 0x01
    2406:	8e 85       	ldd	r24, Y+14	; 0x0e
    2408:	9f 85       	ldd	r25, Y+15	; 0x0f
    240a:	80 95       	com	r24
    240c:	90 95       	com	r25
    240e:	82 23       	and	r24, r18
    2410:	93 23       	and	r25, r19
    2412:	ea 85       	ldd	r30, Y+10	; 0x0a
    2414:	fb 85       	ldd	r31, Y+11	; 0x0b
    2416:	91 83       	std	Z+1, r25	; 0x01
    2418:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    241a:	81 e0       	ldi	r24, 0x01	; 1
    241c:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    241e:	0f 90       	pop	r0
    2420:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2422:	88 85       	ldd	r24, Y+8	; 0x08
    2424:	99 85       	ldd	r25, Y+9	; 0x09
    2426:	90 70       	andi	r25, 0x00	; 0
    2428:	99 87       	std	Y+9, r25	; 0x09
    242a:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    242c:	88 85       	ldd	r24, Y+8	; 0x08
    242e:	99 85       	ldd	r25, Y+9	; 0x09
}
    2430:	63 96       	adiw	r28, 0x13	; 19
    2432:	0f b6       	in	r0, 0x3f	; 63
    2434:	f8 94       	cli
    2436:	de bf       	out	0x3e, r29	; 62
    2438:	0f be       	out	0x3f, r0	; 63
    243a:	cd bf       	out	0x3d, r28	; 61
    243c:	cf 91       	pop	r28
    243e:	df 91       	pop	r29
    2440:	1f 91       	pop	r17
    2442:	0f 91       	pop	r16
    2444:	08 95       	ret

00002446 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    2446:	df 93       	push	r29
    2448:	cf 93       	push	r28
    244a:	cd b7       	in	r28, 0x3d	; 61
    244c:	de b7       	in	r29, 0x3e	; 62
    244e:	28 97       	sbiw	r28, 0x08	; 8
    2450:	0f b6       	in	r0, 0x3f	; 63
    2452:	f8 94       	cli
    2454:	de bf       	out	0x3e, r29	; 62
    2456:	0f be       	out	0x3f, r0	; 63
    2458:	cd bf       	out	0x3d, r28	; 61
    245a:	9e 83       	std	Y+6, r25	; 0x06
    245c:	8d 83       	std	Y+5, r24	; 0x05
    245e:	78 87       	std	Y+8, r23	; 0x08
    2460:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    2462:	8d 81       	ldd	r24, Y+5	; 0x05
    2464:	9e 81       	ldd	r25, Y+6	; 0x06
    2466:	9c 83       	std	Y+4, r25	; 0x04
    2468:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    246a:	0f b6       	in	r0, 0x3f	; 63
    246c:	f8 94       	cli
    246e:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2470:	eb 81       	ldd	r30, Y+3	; 0x03
    2472:	fc 81       	ldd	r31, Y+4	; 0x04
    2474:	80 81       	ld	r24, Z
    2476:	91 81       	ldd	r25, Z+1	; 0x01
    2478:	9a 83       	std	Y+2, r25	; 0x02
    247a:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    247c:	eb 81       	ldd	r30, Y+3	; 0x03
    247e:	fc 81       	ldd	r31, Y+4	; 0x04
    2480:	20 81       	ld	r18, Z
    2482:	31 81       	ldd	r19, Z+1	; 0x01
    2484:	8f 81       	ldd	r24, Y+7	; 0x07
    2486:	98 85       	ldd	r25, Y+8	; 0x08
    2488:	80 95       	com	r24
    248a:	90 95       	com	r25
    248c:	82 23       	and	r24, r18
    248e:	93 23       	and	r25, r19
    2490:	eb 81       	ldd	r30, Y+3	; 0x03
    2492:	fc 81       	ldd	r31, Y+4	; 0x04
    2494:	91 83       	std	Z+1, r25	; 0x01
    2496:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    2498:	0f 90       	pop	r0
    249a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    249c:	89 81       	ldd	r24, Y+1	; 0x01
    249e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    24a0:	28 96       	adiw	r28, 0x08	; 8
    24a2:	0f b6       	in	r0, 0x3f	; 63
    24a4:	f8 94       	cli
    24a6:	de bf       	out	0x3e, r29	; 62
    24a8:	0f be       	out	0x3f, r0	; 63
    24aa:	cd bf       	out	0x3d, r28	; 61
    24ac:	cf 91       	pop	r28
    24ae:	df 91       	pop	r29
    24b0:	08 95       	ret

000024b2 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    24b2:	df 93       	push	r29
    24b4:	cf 93       	push	r28
    24b6:	cd b7       	in	r28, 0x3d	; 61
    24b8:	de b7       	in	r29, 0x3e	; 62
    24ba:	27 97       	sbiw	r28, 0x07	; 7
    24bc:	0f b6       	in	r0, 0x3f	; 63
    24be:	f8 94       	cli
    24c0:	de bf       	out	0x3e, r29	; 62
    24c2:	0f be       	out	0x3f, r0	; 63
    24c4:	cd bf       	out	0x3d, r28	; 61
    24c6:	9f 83       	std	Y+7, r25	; 0x07
    24c8:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    24ca:	8e 81       	ldd	r24, Y+6	; 0x06
    24cc:	9f 81       	ldd	r25, Y+7	; 0x07
    24ce:	9c 83       	std	Y+4, r25	; 0x04
    24d0:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    24d2:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    24d4:	eb 81       	ldd	r30, Y+3	; 0x03
    24d6:	fc 81       	ldd	r31, Y+4	; 0x04
    24d8:	80 81       	ld	r24, Z
    24da:	91 81       	ldd	r25, Z+1	; 0x01
    24dc:	9a 83       	std	Y+2, r25	; 0x02
    24de:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    24e0:	89 81       	ldd	r24, Y+1	; 0x01
    24e2:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    24e4:	27 96       	adiw	r28, 0x07	; 7
    24e6:	0f b6       	in	r0, 0x3f	; 63
    24e8:	f8 94       	cli
    24ea:	de bf       	out	0x3e, r29	; 62
    24ec:	0f be       	out	0x3f, r0	; 63
    24ee:	cd bf       	out	0x3d, r28	; 61
    24f0:	cf 91       	pop	r28
    24f2:	df 91       	pop	r29
    24f4:	08 95       	ret

000024f6 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    24f6:	df 93       	push	r29
    24f8:	cf 93       	push	r28
    24fa:	cd b7       	in	r28, 0x3d	; 61
    24fc:	de b7       	in	r29, 0x3e	; 62
    24fe:	65 97       	sbiw	r28, 0x15	; 21
    2500:	0f b6       	in	r0, 0x3f	; 63
    2502:	f8 94       	cli
    2504:	de bf       	out	0x3e, r29	; 62
    2506:	0f be       	out	0x3f, r0	; 63
    2508:	cd bf       	out	0x3d, r28	; 61
    250a:	9b 8b       	std	Y+19, r25	; 0x13
    250c:	8a 8b       	std	Y+18, r24	; 0x12
    250e:	7d 8b       	std	Y+21, r23	; 0x15
    2510:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2512:	19 86       	std	Y+9, r1	; 0x09
    2514:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    2516:	8a 89       	ldd	r24, Y+18	; 0x12
    2518:	9b 89       	ldd	r25, Y+19	; 0x13
    251a:	9b 83       	std	Y+3, r25	; 0x03
    251c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    251e:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    2520:	8a 81       	ldd	r24, Y+2	; 0x02
    2522:	9b 81       	ldd	r25, Y+3	; 0x03
    2524:	02 96       	adiw	r24, 0x02	; 2
    2526:	9b 87       	std	Y+11, r25	; 0x0b
    2528:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    252a:	8a 85       	ldd	r24, Y+10	; 0x0a
    252c:	9b 85       	ldd	r25, Y+11	; 0x0b
    252e:	03 96       	adiw	r24, 0x03	; 3
    2530:	9d 87       	std	Y+13, r25	; 0x0d
    2532:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    2534:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2538:	ea 85       	ldd	r30, Y+10	; 0x0a
    253a:	fb 85       	ldd	r31, Y+11	; 0x0b
    253c:	85 81       	ldd	r24, Z+5	; 0x05
    253e:	96 81       	ldd	r25, Z+6	; 0x06
    2540:	99 8b       	std	Y+17, r25	; 0x11
    2542:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    2544:	ea 81       	ldd	r30, Y+2	; 0x02
    2546:	fb 81       	ldd	r31, Y+3	; 0x03
    2548:	20 81       	ld	r18, Z
    254a:	31 81       	ldd	r19, Z+1	; 0x01
    254c:	8c 89       	ldd	r24, Y+20	; 0x14
    254e:	9d 89       	ldd	r25, Y+21	; 0x15
    2550:	82 2b       	or	r24, r18
    2552:	93 2b       	or	r25, r19
    2554:	ea 81       	ldd	r30, Y+2	; 0x02
    2556:	fb 81       	ldd	r31, Y+3	; 0x03
    2558:	91 83       	std	Z+1, r25	; 0x01
    255a:	80 83       	st	Z, r24
    255c:	59 c0       	rjmp	.+178    	; 0x2610 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    255e:	e8 89       	ldd	r30, Y+16	; 0x10
    2560:	f9 89       	ldd	r31, Y+17	; 0x11
    2562:	82 81       	ldd	r24, Z+2	; 0x02
    2564:	93 81       	ldd	r25, Z+3	; 0x03
    2566:	9f 87       	std	Y+15, r25	; 0x0f
    2568:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    256a:	e8 89       	ldd	r30, Y+16	; 0x10
    256c:	f9 89       	ldd	r31, Y+17	; 0x11
    256e:	80 81       	ld	r24, Z
    2570:	91 81       	ldd	r25, Z+1	; 0x01
    2572:	9f 83       	std	Y+7, r25	; 0x07
    2574:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    2576:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2578:	8e 81       	ldd	r24, Y+6	; 0x06
    257a:	9f 81       	ldd	r25, Y+7	; 0x07
    257c:	80 70       	andi	r24, 0x00	; 0
    257e:	9d 83       	std	Y+5, r25	; 0x05
    2580:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    2582:	8e 81       	ldd	r24, Y+6	; 0x06
    2584:	9f 81       	ldd	r25, Y+7	; 0x07
    2586:	90 70       	andi	r25, 0x00	; 0
    2588:	9f 83       	std	Y+7, r25	; 0x07
    258a:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    258c:	8c 81       	ldd	r24, Y+4	; 0x04
    258e:	9d 81       	ldd	r25, Y+5	; 0x05
    2590:	80 70       	andi	r24, 0x00	; 0
    2592:	94 70       	andi	r25, 0x04	; 4
    2594:	00 97       	sbiw	r24, 0x00	; 0
    2596:	69 f4       	brne	.+26     	; 0x25b2 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2598:	ea 81       	ldd	r30, Y+2	; 0x02
    259a:	fb 81       	ldd	r31, Y+3	; 0x03
    259c:	20 81       	ld	r18, Z
    259e:	31 81       	ldd	r19, Z+1	; 0x01
    25a0:	8e 81       	ldd	r24, Y+6	; 0x06
    25a2:	9f 81       	ldd	r25, Y+7	; 0x07
    25a4:	82 23       	and	r24, r18
    25a6:	93 23       	and	r25, r19
    25a8:	00 97       	sbiw	r24, 0x00	; 0
    25aa:	91 f0       	breq	.+36     	; 0x25d0 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    25ac:	81 e0       	ldi	r24, 0x01	; 1
    25ae:	89 83       	std	Y+1, r24	; 0x01
    25b0:	0f c0       	rjmp	.+30     	; 0x25d0 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    25b2:	ea 81       	ldd	r30, Y+2	; 0x02
    25b4:	fb 81       	ldd	r31, Y+3	; 0x03
    25b6:	20 81       	ld	r18, Z
    25b8:	31 81       	ldd	r19, Z+1	; 0x01
    25ba:	8e 81       	ldd	r24, Y+6	; 0x06
    25bc:	9f 81       	ldd	r25, Y+7	; 0x07
    25be:	28 23       	and	r18, r24
    25c0:	39 23       	and	r19, r25
    25c2:	8e 81       	ldd	r24, Y+6	; 0x06
    25c4:	9f 81       	ldd	r25, Y+7	; 0x07
    25c6:	28 17       	cp	r18, r24
    25c8:	39 07       	cpc	r19, r25
    25ca:	11 f4       	brne	.+4      	; 0x25d0 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    25cc:	81 e0       	ldi	r24, 0x01	; 1
    25ce:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    25d0:	89 81       	ldd	r24, Y+1	; 0x01
    25d2:	88 23       	and	r24, r24
    25d4:	c9 f0       	breq	.+50     	; 0x2608 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    25d6:	8c 81       	ldd	r24, Y+4	; 0x04
    25d8:	9d 81       	ldd	r25, Y+5	; 0x05
    25da:	80 70       	andi	r24, 0x00	; 0
    25dc:	91 70       	andi	r25, 0x01	; 1
    25de:	00 97       	sbiw	r24, 0x00	; 0
    25e0:	41 f0       	breq	.+16     	; 0x25f2 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    25e2:	88 85       	ldd	r24, Y+8	; 0x08
    25e4:	99 85       	ldd	r25, Y+9	; 0x09
    25e6:	2e 81       	ldd	r18, Y+6	; 0x06
    25e8:	3f 81       	ldd	r19, Y+7	; 0x07
    25ea:	82 2b       	or	r24, r18
    25ec:	93 2b       	or	r25, r19
    25ee:	99 87       	std	Y+9, r25	; 0x09
    25f0:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    25f2:	ea 81       	ldd	r30, Y+2	; 0x02
    25f4:	fb 81       	ldd	r31, Y+3	; 0x03
    25f6:	80 81       	ld	r24, Z
    25f8:	91 81       	ldd	r25, Z+1	; 0x01
    25fa:	9c 01       	movw	r18, r24
    25fc:	32 60       	ori	r19, 0x02	; 2
    25fe:	88 89       	ldd	r24, Y+16	; 0x10
    2600:	99 89       	ldd	r25, Y+17	; 0x11
    2602:	b9 01       	movw	r22, r18
    2604:	0e 94 10 2f 	call	0x5e20	; 0x5e20 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    2608:	8e 85       	ldd	r24, Y+14	; 0x0e
    260a:	9f 85       	ldd	r25, Y+15	; 0x0f
    260c:	99 8b       	std	Y+17, r25	; 0x11
    260e:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2610:	28 89       	ldd	r18, Y+16	; 0x10
    2612:	39 89       	ldd	r19, Y+17	; 0x11
    2614:	8c 85       	ldd	r24, Y+12	; 0x0c
    2616:	9d 85       	ldd	r25, Y+13	; 0x0d
    2618:	28 17       	cp	r18, r24
    261a:	39 07       	cpc	r19, r25
    261c:	09 f0       	breq	.+2      	; 0x2620 <xEventGroupSetBits+0x12a>
    261e:	9f cf       	rjmp	.-194    	; 0x255e <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2620:	ea 81       	ldd	r30, Y+2	; 0x02
    2622:	fb 81       	ldd	r31, Y+3	; 0x03
    2624:	20 81       	ld	r18, Z
    2626:	31 81       	ldd	r19, Z+1	; 0x01
    2628:	88 85       	ldd	r24, Y+8	; 0x08
    262a:	99 85       	ldd	r25, Y+9	; 0x09
    262c:	80 95       	com	r24
    262e:	90 95       	com	r25
    2630:	82 23       	and	r24, r18
    2632:	93 23       	and	r25, r19
    2634:	ea 81       	ldd	r30, Y+2	; 0x02
    2636:	fb 81       	ldd	r31, Y+3	; 0x03
    2638:	91 83       	std	Z+1, r25	; 0x01
    263a:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    263c:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    2640:	ea 81       	ldd	r30, Y+2	; 0x02
    2642:	fb 81       	ldd	r31, Y+3	; 0x03
    2644:	80 81       	ld	r24, Z
    2646:	91 81       	ldd	r25, Z+1	; 0x01
}
    2648:	65 96       	adiw	r28, 0x15	; 21
    264a:	0f b6       	in	r0, 0x3f	; 63
    264c:	f8 94       	cli
    264e:	de bf       	out	0x3e, r29	; 62
    2650:	0f be       	out	0x3f, r0	; 63
    2652:	cd bf       	out	0x3d, r28	; 61
    2654:	cf 91       	pop	r28
    2656:	df 91       	pop	r29
    2658:	08 95       	ret

0000265a <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    265a:	df 93       	push	r29
    265c:	cf 93       	push	r28
    265e:	00 d0       	rcall	.+0      	; 0x2660 <vEventGroupDelete+0x6>
    2660:	00 d0       	rcall	.+0      	; 0x2662 <vEventGroupDelete+0x8>
    2662:	00 d0       	rcall	.+0      	; 0x2664 <vEventGroupDelete+0xa>
    2664:	cd b7       	in	r28, 0x3d	; 61
    2666:	de b7       	in	r29, 0x3e	; 62
    2668:	9e 83       	std	Y+6, r25	; 0x06
    266a:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    266c:	8d 81       	ldd	r24, Y+5	; 0x05
    266e:	9e 81       	ldd	r25, Y+6	; 0x06
    2670:	9c 83       	std	Y+4, r25	; 0x04
    2672:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2674:	8b 81       	ldd	r24, Y+3	; 0x03
    2676:	9c 81       	ldd	r25, Y+4	; 0x04
    2678:	02 96       	adiw	r24, 0x02	; 2
    267a:	9a 83       	std	Y+2, r25	; 0x02
    267c:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    267e:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
    2682:	08 c0       	rjmp	.+16     	; 0x2694 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2684:	e9 81       	ldd	r30, Y+1	; 0x01
    2686:	fa 81       	ldd	r31, Y+2	; 0x02
    2688:	85 81       	ldd	r24, Z+5	; 0x05
    268a:	96 81       	ldd	r25, Z+6	; 0x06
    268c:	60 e0       	ldi	r22, 0x00	; 0
    268e:	72 e0       	ldi	r23, 0x02	; 2
    2690:	0e 94 10 2f 	call	0x5e20	; 0x5e20 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2694:	e9 81       	ldd	r30, Y+1	; 0x01
    2696:	fa 81       	ldd	r31, Y+2	; 0x02
    2698:	80 81       	ld	r24, Z
    269a:	88 23       	and	r24, r24
    269c:	99 f7       	brne	.-26     	; 0x2684 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    269e:	8b 81       	ldd	r24, Y+3	; 0x03
    26a0:	9c 81       	ldd	r25, Y+4	; 0x04
    26a2:	0e 94 20 14 	call	0x2840	; 0x2840 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    26a6:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
}
    26aa:	26 96       	adiw	r28, 0x06	; 6
    26ac:	0f b6       	in	r0, 0x3f	; 63
    26ae:	f8 94       	cli
    26b0:	de bf       	out	0x3e, r29	; 62
    26b2:	0f be       	out	0x3f, r0	; 63
    26b4:	cd bf       	out	0x3d, r28	; 61
    26b6:	cf 91       	pop	r28
    26b8:	df 91       	pop	r29
    26ba:	08 95       	ret

000026bc <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    26bc:	df 93       	push	r29
    26be:	cf 93       	push	r28
    26c0:	00 d0       	rcall	.+0      	; 0x26c2 <vEventGroupSetBitsCallback+0x6>
    26c2:	00 d0       	rcall	.+0      	; 0x26c4 <vEventGroupSetBitsCallback+0x8>
    26c4:	00 d0       	rcall	.+0      	; 0x26c6 <vEventGroupSetBitsCallback+0xa>
    26c6:	cd b7       	in	r28, 0x3d	; 61
    26c8:	de b7       	in	r29, 0x3e	; 62
    26ca:	9a 83       	std	Y+2, r25	; 0x02
    26cc:	89 83       	std	Y+1, r24	; 0x01
    26ce:	4b 83       	std	Y+3, r20	; 0x03
    26d0:	5c 83       	std	Y+4, r21	; 0x04
    26d2:	6d 83       	std	Y+5, r22	; 0x05
    26d4:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    26d6:	89 81       	ldd	r24, Y+1	; 0x01
    26d8:	9a 81       	ldd	r25, Y+2	; 0x02
    26da:	2b 81       	ldd	r18, Y+3	; 0x03
    26dc:	3c 81       	ldd	r19, Y+4	; 0x04
    26de:	b9 01       	movw	r22, r18
    26e0:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <xEventGroupSetBits>
}
    26e4:	26 96       	adiw	r28, 0x06	; 6
    26e6:	0f b6       	in	r0, 0x3f	; 63
    26e8:	f8 94       	cli
    26ea:	de bf       	out	0x3e, r29	; 62
    26ec:	0f be       	out	0x3f, r0	; 63
    26ee:	cd bf       	out	0x3d, r28	; 61
    26f0:	cf 91       	pop	r28
    26f2:	df 91       	pop	r29
    26f4:	08 95       	ret

000026f6 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    26f6:	df 93       	push	r29
    26f8:	cf 93       	push	r28
    26fa:	00 d0       	rcall	.+0      	; 0x26fc <vEventGroupClearBitsCallback+0x6>
    26fc:	00 d0       	rcall	.+0      	; 0x26fe <vEventGroupClearBitsCallback+0x8>
    26fe:	00 d0       	rcall	.+0      	; 0x2700 <vEventGroupClearBitsCallback+0xa>
    2700:	cd b7       	in	r28, 0x3d	; 61
    2702:	de b7       	in	r29, 0x3e	; 62
    2704:	9a 83       	std	Y+2, r25	; 0x02
    2706:	89 83       	std	Y+1, r24	; 0x01
    2708:	4b 83       	std	Y+3, r20	; 0x03
    270a:	5c 83       	std	Y+4, r21	; 0x04
    270c:	6d 83       	std	Y+5, r22	; 0x05
    270e:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2710:	89 81       	ldd	r24, Y+1	; 0x01
    2712:	9a 81       	ldd	r25, Y+2	; 0x02
    2714:	2b 81       	ldd	r18, Y+3	; 0x03
    2716:	3c 81       	ldd	r19, Y+4	; 0x04
    2718:	b9 01       	movw	r22, r18
    271a:	0e 94 23 12 	call	0x2446	; 0x2446 <xEventGroupClearBits>
}
    271e:	26 96       	adiw	r28, 0x06	; 6
    2720:	0f b6       	in	r0, 0x3f	; 63
    2722:	f8 94       	cli
    2724:	de bf       	out	0x3e, r29	; 62
    2726:	0f be       	out	0x3f, r0	; 63
    2728:	cd bf       	out	0x3d, r28	; 61
    272a:	cf 91       	pop	r28
    272c:	df 91       	pop	r29
    272e:	08 95       	ret

00002730 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    2730:	df 93       	push	r29
    2732:	cf 93       	push	r28
    2734:	00 d0       	rcall	.+0      	; 0x2736 <prvTestWaitCondition+0x6>
    2736:	00 d0       	rcall	.+0      	; 0x2738 <prvTestWaitCondition+0x8>
    2738:	00 d0       	rcall	.+0      	; 0x273a <prvTestWaitCondition+0xa>
    273a:	cd b7       	in	r28, 0x3d	; 61
    273c:	de b7       	in	r29, 0x3e	; 62
    273e:	9b 83       	std	Y+3, r25	; 0x03
    2740:	8a 83       	std	Y+2, r24	; 0x02
    2742:	7d 83       	std	Y+5, r23	; 0x05
    2744:	6c 83       	std	Y+4, r22	; 0x04
    2746:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    2748:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    274a:	8e 81       	ldd	r24, Y+6	; 0x06
    274c:	88 23       	and	r24, r24
    274e:	59 f4       	brne	.+22     	; 0x2766 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2750:	8a 81       	ldd	r24, Y+2	; 0x02
    2752:	9b 81       	ldd	r25, Y+3	; 0x03
    2754:	2c 81       	ldd	r18, Y+4	; 0x04
    2756:	3d 81       	ldd	r19, Y+5	; 0x05
    2758:	82 23       	and	r24, r18
    275a:	93 23       	and	r25, r19
    275c:	00 97       	sbiw	r24, 0x00	; 0
    275e:	81 f0       	breq	.+32     	; 0x2780 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    2760:	81 e0       	ldi	r24, 0x01	; 1
    2762:	89 83       	std	Y+1, r24	; 0x01
    2764:	0d c0       	rjmp	.+26     	; 0x2780 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2766:	2a 81       	ldd	r18, Y+2	; 0x02
    2768:	3b 81       	ldd	r19, Y+3	; 0x03
    276a:	8c 81       	ldd	r24, Y+4	; 0x04
    276c:	9d 81       	ldd	r25, Y+5	; 0x05
    276e:	28 23       	and	r18, r24
    2770:	39 23       	and	r19, r25
    2772:	8c 81       	ldd	r24, Y+4	; 0x04
    2774:	9d 81       	ldd	r25, Y+5	; 0x05
    2776:	28 17       	cp	r18, r24
    2778:	39 07       	cpc	r19, r25
    277a:	11 f4       	brne	.+4      	; 0x2780 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    277c:	81 e0       	ldi	r24, 0x01	; 1
    277e:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    2780:	89 81       	ldd	r24, Y+1	; 0x01
}
    2782:	26 96       	adiw	r28, 0x06	; 6
    2784:	0f b6       	in	r0, 0x3f	; 63
    2786:	f8 94       	cli
    2788:	de bf       	out	0x3e, r29	; 62
    278a:	0f be       	out	0x3f, r0	; 63
    278c:	cd bf       	out	0x3d, r28	; 61
    278e:	cf 91       	pop	r28
    2790:	df 91       	pop	r29
    2792:	08 95       	ret

00002794 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2794:	df 93       	push	r29
    2796:	cf 93       	push	r28
    2798:	00 d0       	rcall	.+0      	; 0x279a <pvPortMalloc+0x6>
    279a:	00 d0       	rcall	.+0      	; 0x279c <pvPortMalloc+0x8>
    279c:	cd b7       	in	r28, 0x3d	; 61
    279e:	de b7       	in	r29, 0x3e	; 62
    27a0:	9c 83       	std	Y+4, r25	; 0x04
    27a2:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    27a4:	1a 82       	std	Y+2, r1	; 0x02
    27a6:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    27a8:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    27ac:	80 91 86 00 	lds	r24, 0x0086
    27b0:	90 91 87 00 	lds	r25, 0x0087
    27b4:	00 97       	sbiw	r24, 0x00	; 0
    27b6:	31 f4       	brne	.+12     	; 0x27c4 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    27b8:	89 e8       	ldi	r24, 0x89	; 137
    27ba:	90 e0       	ldi	r25, 0x00	; 0
    27bc:	90 93 87 00 	sts	0x0087, r25
    27c0:	80 93 86 00 	sts	0x0086, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    27c4:	80 91 84 00 	lds	r24, 0x0084
    27c8:	90 91 85 00 	lds	r25, 0x0085
    27cc:	2b 81       	ldd	r18, Y+3	; 0x03
    27ce:	3c 81       	ldd	r19, Y+4	; 0x04
    27d0:	82 0f       	add	r24, r18
    27d2:	93 1f       	adc	r25, r19
    27d4:	25 e0       	ldi	r18, 0x05	; 5
    27d6:	8b 3d       	cpi	r24, 0xDB	; 219
    27d8:	92 07       	cpc	r25, r18
    27da:	38 f5       	brcc	.+78     	; 0x282a <pvPortMalloc+0x96>
    27dc:	20 91 84 00 	lds	r18, 0x0084
    27e0:	30 91 85 00 	lds	r19, 0x0085
    27e4:	8b 81       	ldd	r24, Y+3	; 0x03
    27e6:	9c 81       	ldd	r25, Y+4	; 0x04
    27e8:	28 0f       	add	r18, r24
    27ea:	39 1f       	adc	r19, r25
    27ec:	80 91 84 00 	lds	r24, 0x0084
    27f0:	90 91 85 00 	lds	r25, 0x0085
    27f4:	82 17       	cp	r24, r18
    27f6:	93 07       	cpc	r25, r19
    27f8:	c0 f4       	brcc	.+48     	; 0x282a <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    27fa:	20 91 86 00 	lds	r18, 0x0086
    27fe:	30 91 87 00 	lds	r19, 0x0087
    2802:	80 91 84 00 	lds	r24, 0x0084
    2806:	90 91 85 00 	lds	r25, 0x0085
    280a:	82 0f       	add	r24, r18
    280c:	93 1f       	adc	r25, r19
    280e:	9a 83       	std	Y+2, r25	; 0x02
    2810:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2812:	20 91 84 00 	lds	r18, 0x0084
    2816:	30 91 85 00 	lds	r19, 0x0085
    281a:	8b 81       	ldd	r24, Y+3	; 0x03
    281c:	9c 81       	ldd	r25, Y+4	; 0x04
    281e:	82 0f       	add	r24, r18
    2820:	93 1f       	adc	r25, r19
    2822:	90 93 85 00 	sts	0x0085, r25
    2826:	80 93 84 00 	sts	0x0084, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    282a:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    282e:	89 81       	ldd	r24, Y+1	; 0x01
    2830:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2832:	0f 90       	pop	r0
    2834:	0f 90       	pop	r0
    2836:	0f 90       	pop	r0
    2838:	0f 90       	pop	r0
    283a:	cf 91       	pop	r28
    283c:	df 91       	pop	r29
    283e:	08 95       	ret

00002840 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2840:	df 93       	push	r29
    2842:	cf 93       	push	r28
    2844:	00 d0       	rcall	.+0      	; 0x2846 <vPortFree+0x6>
    2846:	cd b7       	in	r28, 0x3d	; 61
    2848:	de b7       	in	r29, 0x3e	; 62
    284a:	9a 83       	std	Y+2, r25	; 0x02
    284c:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    284e:	0f 90       	pop	r0
    2850:	0f 90       	pop	r0
    2852:	cf 91       	pop	r28
    2854:	df 91       	pop	r29
    2856:	08 95       	ret

00002858 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2858:	df 93       	push	r29
    285a:	cf 93       	push	r28
    285c:	cd b7       	in	r28, 0x3d	; 61
    285e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2860:	10 92 85 00 	sts	0x0085, r1
    2864:	10 92 84 00 	sts	0x0084, r1
}
    2868:	cf 91       	pop	r28
    286a:	df 91       	pop	r29
    286c:	08 95       	ret

0000286e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    286e:	df 93       	push	r29
    2870:	cf 93       	push	r28
    2872:	cd b7       	in	r28, 0x3d	; 61
    2874:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2876:	20 91 84 00 	lds	r18, 0x0084
    287a:	30 91 85 00 	lds	r19, 0x0085
    287e:	8b ed       	ldi	r24, 0xDB	; 219
    2880:	95 e0       	ldi	r25, 0x05	; 5
    2882:	82 1b       	sub	r24, r18
    2884:	93 0b       	sbc	r25, r19
}
    2886:	cf 91       	pop	r28
    2888:	df 91       	pop	r29
    288a:	08 95       	ret

0000288c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    288c:	df 93       	push	r29
    288e:	cf 93       	push	r28
    2890:	00 d0       	rcall	.+0      	; 0x2892 <vListInitialise+0x6>
    2892:	cd b7       	in	r28, 0x3d	; 61
    2894:	de b7       	in	r29, 0x3e	; 62
    2896:	9a 83       	std	Y+2, r25	; 0x02
    2898:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    289a:	89 81       	ldd	r24, Y+1	; 0x01
    289c:	9a 81       	ldd	r25, Y+2	; 0x02
    289e:	03 96       	adiw	r24, 0x03	; 3
    28a0:	e9 81       	ldd	r30, Y+1	; 0x01
    28a2:	fa 81       	ldd	r31, Y+2	; 0x02
    28a4:	92 83       	std	Z+2, r25	; 0x02
    28a6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    28a8:	e9 81       	ldd	r30, Y+1	; 0x01
    28aa:	fa 81       	ldd	r31, Y+2	; 0x02
    28ac:	8f ef       	ldi	r24, 0xFF	; 255
    28ae:	9f ef       	ldi	r25, 0xFF	; 255
    28b0:	94 83       	std	Z+4, r25	; 0x04
    28b2:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    28b4:	89 81       	ldd	r24, Y+1	; 0x01
    28b6:	9a 81       	ldd	r25, Y+2	; 0x02
    28b8:	03 96       	adiw	r24, 0x03	; 3
    28ba:	e9 81       	ldd	r30, Y+1	; 0x01
    28bc:	fa 81       	ldd	r31, Y+2	; 0x02
    28be:	96 83       	std	Z+6, r25	; 0x06
    28c0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    28c2:	89 81       	ldd	r24, Y+1	; 0x01
    28c4:	9a 81       	ldd	r25, Y+2	; 0x02
    28c6:	03 96       	adiw	r24, 0x03	; 3
    28c8:	e9 81       	ldd	r30, Y+1	; 0x01
    28ca:	fa 81       	ldd	r31, Y+2	; 0x02
    28cc:	90 87       	std	Z+8, r25	; 0x08
    28ce:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    28d0:	e9 81       	ldd	r30, Y+1	; 0x01
    28d2:	fa 81       	ldd	r31, Y+2	; 0x02
    28d4:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    28d6:	0f 90       	pop	r0
    28d8:	0f 90       	pop	r0
    28da:	cf 91       	pop	r28
    28dc:	df 91       	pop	r29
    28de:	08 95       	ret

000028e0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    28e0:	df 93       	push	r29
    28e2:	cf 93       	push	r28
    28e4:	00 d0       	rcall	.+0      	; 0x28e6 <vListInitialiseItem+0x6>
    28e6:	cd b7       	in	r28, 0x3d	; 61
    28e8:	de b7       	in	r29, 0x3e	; 62
    28ea:	9a 83       	std	Y+2, r25	; 0x02
    28ec:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    28ee:	e9 81       	ldd	r30, Y+1	; 0x01
    28f0:	fa 81       	ldd	r31, Y+2	; 0x02
    28f2:	11 86       	std	Z+9, r1	; 0x09
    28f4:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    28f6:	0f 90       	pop	r0
    28f8:	0f 90       	pop	r0
    28fa:	cf 91       	pop	r28
    28fc:	df 91       	pop	r29
    28fe:	08 95       	ret

00002900 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2900:	df 93       	push	r29
    2902:	cf 93       	push	r28
    2904:	00 d0       	rcall	.+0      	; 0x2906 <vListInsertEnd+0x6>
    2906:	00 d0       	rcall	.+0      	; 0x2908 <vListInsertEnd+0x8>
    2908:	00 d0       	rcall	.+0      	; 0x290a <vListInsertEnd+0xa>
    290a:	cd b7       	in	r28, 0x3d	; 61
    290c:	de b7       	in	r29, 0x3e	; 62
    290e:	9c 83       	std	Y+4, r25	; 0x04
    2910:	8b 83       	std	Y+3, r24	; 0x03
    2912:	7e 83       	std	Y+6, r23	; 0x06
    2914:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    2916:	eb 81       	ldd	r30, Y+3	; 0x03
    2918:	fc 81       	ldd	r31, Y+4	; 0x04
    291a:	81 81       	ldd	r24, Z+1	; 0x01
    291c:	92 81       	ldd	r25, Z+2	; 0x02
    291e:	9a 83       	std	Y+2, r25	; 0x02
    2920:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2922:	ed 81       	ldd	r30, Y+5	; 0x05
    2924:	fe 81       	ldd	r31, Y+6	; 0x06
    2926:	89 81       	ldd	r24, Y+1	; 0x01
    2928:	9a 81       	ldd	r25, Y+2	; 0x02
    292a:	93 83       	std	Z+3, r25	; 0x03
    292c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    292e:	e9 81       	ldd	r30, Y+1	; 0x01
    2930:	fa 81       	ldd	r31, Y+2	; 0x02
    2932:	84 81       	ldd	r24, Z+4	; 0x04
    2934:	95 81       	ldd	r25, Z+5	; 0x05
    2936:	ed 81       	ldd	r30, Y+5	; 0x05
    2938:	fe 81       	ldd	r31, Y+6	; 0x06
    293a:	95 83       	std	Z+5, r25	; 0x05
    293c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    293e:	e9 81       	ldd	r30, Y+1	; 0x01
    2940:	fa 81       	ldd	r31, Y+2	; 0x02
    2942:	04 80       	ldd	r0, Z+4	; 0x04
    2944:	f5 81       	ldd	r31, Z+5	; 0x05
    2946:	e0 2d       	mov	r30, r0
    2948:	8d 81       	ldd	r24, Y+5	; 0x05
    294a:	9e 81       	ldd	r25, Y+6	; 0x06
    294c:	93 83       	std	Z+3, r25	; 0x03
    294e:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    2950:	e9 81       	ldd	r30, Y+1	; 0x01
    2952:	fa 81       	ldd	r31, Y+2	; 0x02
    2954:	8d 81       	ldd	r24, Y+5	; 0x05
    2956:	9e 81       	ldd	r25, Y+6	; 0x06
    2958:	95 83       	std	Z+5, r25	; 0x05
    295a:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    295c:	ed 81       	ldd	r30, Y+5	; 0x05
    295e:	fe 81       	ldd	r31, Y+6	; 0x06
    2960:	8b 81       	ldd	r24, Y+3	; 0x03
    2962:	9c 81       	ldd	r25, Y+4	; 0x04
    2964:	91 87       	std	Z+9, r25	; 0x09
    2966:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2968:	eb 81       	ldd	r30, Y+3	; 0x03
    296a:	fc 81       	ldd	r31, Y+4	; 0x04
    296c:	80 81       	ld	r24, Z
    296e:	8f 5f       	subi	r24, 0xFF	; 255
    2970:	eb 81       	ldd	r30, Y+3	; 0x03
    2972:	fc 81       	ldd	r31, Y+4	; 0x04
    2974:	80 83       	st	Z, r24
}
    2976:	26 96       	adiw	r28, 0x06	; 6
    2978:	0f b6       	in	r0, 0x3f	; 63
    297a:	f8 94       	cli
    297c:	de bf       	out	0x3e, r29	; 62
    297e:	0f be       	out	0x3f, r0	; 63
    2980:	cd bf       	out	0x3d, r28	; 61
    2982:	cf 91       	pop	r28
    2984:	df 91       	pop	r29
    2986:	08 95       	ret

00002988 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2988:	df 93       	push	r29
    298a:	cf 93       	push	r28
    298c:	cd b7       	in	r28, 0x3d	; 61
    298e:	de b7       	in	r29, 0x3e	; 62
    2990:	28 97       	sbiw	r28, 0x08	; 8
    2992:	0f b6       	in	r0, 0x3f	; 63
    2994:	f8 94       	cli
    2996:	de bf       	out	0x3e, r29	; 62
    2998:	0f be       	out	0x3f, r0	; 63
    299a:	cd bf       	out	0x3d, r28	; 61
    299c:	9e 83       	std	Y+6, r25	; 0x06
    299e:	8d 83       	std	Y+5, r24	; 0x05
    29a0:	78 87       	std	Y+8, r23	; 0x08
    29a2:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    29a4:	ef 81       	ldd	r30, Y+7	; 0x07
    29a6:	f8 85       	ldd	r31, Y+8	; 0x08
    29a8:	80 81       	ld	r24, Z
    29aa:	91 81       	ldd	r25, Z+1	; 0x01
    29ac:	9a 83       	std	Y+2, r25	; 0x02
    29ae:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    29b0:	89 81       	ldd	r24, Y+1	; 0x01
    29b2:	9a 81       	ldd	r25, Y+2	; 0x02
    29b4:	2f ef       	ldi	r18, 0xFF	; 255
    29b6:	8f 3f       	cpi	r24, 0xFF	; 255
    29b8:	92 07       	cpc	r25, r18
    29ba:	39 f4       	brne	.+14     	; 0x29ca <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    29bc:	ed 81       	ldd	r30, Y+5	; 0x05
    29be:	fe 81       	ldd	r31, Y+6	; 0x06
    29c0:	87 81       	ldd	r24, Z+7	; 0x07
    29c2:	90 85       	ldd	r25, Z+8	; 0x08
    29c4:	9c 83       	std	Y+4, r25	; 0x04
    29c6:	8b 83       	std	Y+3, r24	; 0x03
    29c8:	18 c0       	rjmp	.+48     	; 0x29fa <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    29ca:	8d 81       	ldd	r24, Y+5	; 0x05
    29cc:	9e 81       	ldd	r25, Y+6	; 0x06
    29ce:	03 96       	adiw	r24, 0x03	; 3
    29d0:	9c 83       	std	Y+4, r25	; 0x04
    29d2:	8b 83       	std	Y+3, r24	; 0x03
    29d4:	06 c0       	rjmp	.+12     	; 0x29e2 <vListInsert+0x5a>
    29d6:	eb 81       	ldd	r30, Y+3	; 0x03
    29d8:	fc 81       	ldd	r31, Y+4	; 0x04
    29da:	82 81       	ldd	r24, Z+2	; 0x02
    29dc:	93 81       	ldd	r25, Z+3	; 0x03
    29de:	9c 83       	std	Y+4, r25	; 0x04
    29e0:	8b 83       	std	Y+3, r24	; 0x03
    29e2:	eb 81       	ldd	r30, Y+3	; 0x03
    29e4:	fc 81       	ldd	r31, Y+4	; 0x04
    29e6:	02 80       	ldd	r0, Z+2	; 0x02
    29e8:	f3 81       	ldd	r31, Z+3	; 0x03
    29ea:	e0 2d       	mov	r30, r0
    29ec:	20 81       	ld	r18, Z
    29ee:	31 81       	ldd	r19, Z+1	; 0x01
    29f0:	89 81       	ldd	r24, Y+1	; 0x01
    29f2:	9a 81       	ldd	r25, Y+2	; 0x02
    29f4:	82 17       	cp	r24, r18
    29f6:	93 07       	cpc	r25, r19
    29f8:	70 f7       	brcc	.-36     	; 0x29d6 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    29fa:	eb 81       	ldd	r30, Y+3	; 0x03
    29fc:	fc 81       	ldd	r31, Y+4	; 0x04
    29fe:	82 81       	ldd	r24, Z+2	; 0x02
    2a00:	93 81       	ldd	r25, Z+3	; 0x03
    2a02:	ef 81       	ldd	r30, Y+7	; 0x07
    2a04:	f8 85       	ldd	r31, Y+8	; 0x08
    2a06:	93 83       	std	Z+3, r25	; 0x03
    2a08:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2a0a:	ef 81       	ldd	r30, Y+7	; 0x07
    2a0c:	f8 85       	ldd	r31, Y+8	; 0x08
    2a0e:	02 80       	ldd	r0, Z+2	; 0x02
    2a10:	f3 81       	ldd	r31, Z+3	; 0x03
    2a12:	e0 2d       	mov	r30, r0
    2a14:	8f 81       	ldd	r24, Y+7	; 0x07
    2a16:	98 85       	ldd	r25, Y+8	; 0x08
    2a18:	95 83       	std	Z+5, r25	; 0x05
    2a1a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2a1c:	ef 81       	ldd	r30, Y+7	; 0x07
    2a1e:	f8 85       	ldd	r31, Y+8	; 0x08
    2a20:	8b 81       	ldd	r24, Y+3	; 0x03
    2a22:	9c 81       	ldd	r25, Y+4	; 0x04
    2a24:	95 83       	std	Z+5, r25	; 0x05
    2a26:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2a28:	eb 81       	ldd	r30, Y+3	; 0x03
    2a2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a2c:	8f 81       	ldd	r24, Y+7	; 0x07
    2a2e:	98 85       	ldd	r25, Y+8	; 0x08
    2a30:	93 83       	std	Z+3, r25	; 0x03
    2a32:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2a34:	ef 81       	ldd	r30, Y+7	; 0x07
    2a36:	f8 85       	ldd	r31, Y+8	; 0x08
    2a38:	8d 81       	ldd	r24, Y+5	; 0x05
    2a3a:	9e 81       	ldd	r25, Y+6	; 0x06
    2a3c:	91 87       	std	Z+9, r25	; 0x09
    2a3e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2a40:	ed 81       	ldd	r30, Y+5	; 0x05
    2a42:	fe 81       	ldd	r31, Y+6	; 0x06
    2a44:	80 81       	ld	r24, Z
    2a46:	8f 5f       	subi	r24, 0xFF	; 255
    2a48:	ed 81       	ldd	r30, Y+5	; 0x05
    2a4a:	fe 81       	ldd	r31, Y+6	; 0x06
    2a4c:	80 83       	st	Z, r24
}
    2a4e:	28 96       	adiw	r28, 0x08	; 8
    2a50:	0f b6       	in	r0, 0x3f	; 63
    2a52:	f8 94       	cli
    2a54:	de bf       	out	0x3e, r29	; 62
    2a56:	0f be       	out	0x3f, r0	; 63
    2a58:	cd bf       	out	0x3d, r28	; 61
    2a5a:	cf 91       	pop	r28
    2a5c:	df 91       	pop	r29
    2a5e:	08 95       	ret

00002a60 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2a60:	df 93       	push	r29
    2a62:	cf 93       	push	r28
    2a64:	00 d0       	rcall	.+0      	; 0x2a66 <uxListRemove+0x6>
    2a66:	00 d0       	rcall	.+0      	; 0x2a68 <uxListRemove+0x8>
    2a68:	cd b7       	in	r28, 0x3d	; 61
    2a6a:	de b7       	in	r29, 0x3e	; 62
    2a6c:	9c 83       	std	Y+4, r25	; 0x04
    2a6e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2a70:	eb 81       	ldd	r30, Y+3	; 0x03
    2a72:	fc 81       	ldd	r31, Y+4	; 0x04
    2a74:	80 85       	ldd	r24, Z+8	; 0x08
    2a76:	91 85       	ldd	r25, Z+9	; 0x09
    2a78:	9a 83       	std	Y+2, r25	; 0x02
    2a7a:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a80:	a2 81       	ldd	r26, Z+2	; 0x02
    2a82:	b3 81       	ldd	r27, Z+3	; 0x03
    2a84:	eb 81       	ldd	r30, Y+3	; 0x03
    2a86:	fc 81       	ldd	r31, Y+4	; 0x04
    2a88:	84 81       	ldd	r24, Z+4	; 0x04
    2a8a:	95 81       	ldd	r25, Z+5	; 0x05
    2a8c:	15 96       	adiw	r26, 0x05	; 5
    2a8e:	9c 93       	st	X, r25
    2a90:	8e 93       	st	-X, r24
    2a92:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2a94:	eb 81       	ldd	r30, Y+3	; 0x03
    2a96:	fc 81       	ldd	r31, Y+4	; 0x04
    2a98:	a4 81       	ldd	r26, Z+4	; 0x04
    2a9a:	b5 81       	ldd	r27, Z+5	; 0x05
    2a9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2aa0:	82 81       	ldd	r24, Z+2	; 0x02
    2aa2:	93 81       	ldd	r25, Z+3	; 0x03
    2aa4:	13 96       	adiw	r26, 0x03	; 3
    2aa6:	9c 93       	st	X, r25
    2aa8:	8e 93       	st	-X, r24
    2aaa:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2aac:	e9 81       	ldd	r30, Y+1	; 0x01
    2aae:	fa 81       	ldd	r31, Y+2	; 0x02
    2ab0:	21 81       	ldd	r18, Z+1	; 0x01
    2ab2:	32 81       	ldd	r19, Z+2	; 0x02
    2ab4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab8:	28 17       	cp	r18, r24
    2aba:	39 07       	cpc	r19, r25
    2abc:	41 f4       	brne	.+16     	; 0x2ace <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2abe:	eb 81       	ldd	r30, Y+3	; 0x03
    2ac0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac2:	84 81       	ldd	r24, Z+4	; 0x04
    2ac4:	95 81       	ldd	r25, Z+5	; 0x05
    2ac6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ac8:	fa 81       	ldd	r31, Y+2	; 0x02
    2aca:	92 83       	std	Z+2, r25	; 0x02
    2acc:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2ace:	eb 81       	ldd	r30, Y+3	; 0x03
    2ad0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad2:	11 86       	std	Z+9, r1	; 0x09
    2ad4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2ad6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ad8:	fa 81       	ldd	r31, Y+2	; 0x02
    2ada:	80 81       	ld	r24, Z
    2adc:	81 50       	subi	r24, 0x01	; 1
    2ade:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae2:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    2ae4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae8:	80 81       	ld	r24, Z
}
    2aea:	0f 90       	pop	r0
    2aec:	0f 90       	pop	r0
    2aee:	0f 90       	pop	r0
    2af0:	0f 90       	pop	r0
    2af2:	cf 91       	pop	r28
    2af4:	df 91       	pop	r29
    2af6:	08 95       	ret

00002af8 <main>:

/*define a semaphore handle*/
xSemaphoreHandle  Task_Count_Sem;

int main(void)
{
    2af8:	ef 92       	push	r14
    2afa:	ff 92       	push	r15
    2afc:	0f 93       	push	r16
    2afe:	df 93       	push	r29
    2b00:	cf 93       	push	r28
    2b02:	cd b7       	in	r28, 0x3d	; 61
    2b04:	de b7       	in	r29, 0x3e	; 62
	/* Initialize INT0 PIN */
	Dio_vidSetPinDir( DIO_u8PIN_26 , DIO_u8INPUT);
    2b06:	8a e1       	ldi	r24, 0x1A	; 26
    2b08:	60 e0       	ldi	r22, 0x00	; 0
    2b0a:	0e 94 a3 05 	call	0xb46	; 0xb46 <Dio_vidSetPinDir>
	Dio_vidSetPinVal( DIO_u8PIN_26 , DIO_u8HIGH );
    2b0e:	8a e1       	ldi	r24, 0x1A	; 26
    2b10:	61 e0       	ldi	r22, 0x01	; 1
    2b12:	0e 94 09 09 	call	0x1212	; 0x1212 <Dio_vidSetPinVal>

	/* Initialize LCD */
	Lcd_vidInit();
    2b16:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <Lcd_vidInit>

	/* Initialize Interrupt */
	INT_vidInit();
    2b1a:	0e 94 6f 0c 	call	0x18de	; 0x18de <INT_vidInit>

	/* Initialize Interrupt CallBack Function */
	INT0_vidSetCB( INT0_Function );
    2b1e:	89 ed       	ldi	r24, 0xD9	; 217
    2b20:	95 e1       	ldi	r25, 0x15	; 21
    2b22:	0e 94 8f 0c 	call	0x191e	; 0x191e <INT0_vidSetCB>

	/*Create Task */
	xTaskCreate( Task1_Func , "TASK_1" , 200 , NULL , 2 , NULL);
    2b26:	8c ea       	ldi	r24, 0xAC	; 172
    2b28:	95 e1       	ldi	r25, 0x15	; 21
    2b2a:	20 e6       	ldi	r18, 0x60	; 96
    2b2c:	30 e0       	ldi	r19, 0x00	; 0
    2b2e:	b9 01       	movw	r22, r18
    2b30:	48 ec       	ldi	r20, 0xC8	; 200
    2b32:	50 e0       	ldi	r21, 0x00	; 0
    2b34:	20 e0       	ldi	r18, 0x00	; 0
    2b36:	30 e0       	ldi	r19, 0x00	; 0
    2b38:	02 e0       	ldi	r16, 0x02	; 2
    2b3a:	ee 24       	eor	r14, r14
    2b3c:	ff 24       	eor	r15, r15
    2b3e:	0e 94 a8 27 	call	0x4f50	; 0x4f50 <xTaskCreate>

	/*Create Counting semaphore with initial value 0 because we used it for sync. between INTERRUPT and TASK*/
	Task_Count_Sem = xSemaphoreCreateCounting(1,0);
    2b42:	81 e0       	ldi	r24, 0x01	; 1
    2b44:	60 e0       	ldi	r22, 0x00	; 0
    2b46:	0e 94 e4 19 	call	0x33c8	; 0x33c8 <xQueueCreateCountingSemaphore>
    2b4a:	90 93 d0 06 	sts	0x06D0, r25
    2b4e:	80 93 cf 06 	sts	0x06CF, r24

	/*Start OS "Scheduler " */
	vTaskStartScheduler();
    2b52:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskStartScheduler>
    2b56:	ff cf       	rjmp	.-2      	; 0x2b56 <main+0x5e>

00002b58 <Task1_Func>:
	return 0;
}


void Task1_Func( void *pvParameter )
{
    2b58:	df 93       	push	r29
    2b5a:	cf 93       	push	r28
    2b5c:	00 d0       	rcall	.+0      	; 0x2b5e <Task1_Func+0x6>
    2b5e:	0f 92       	push	r0
    2b60:	cd b7       	in	r28, 0x3d	; 61
    2b62:	de b7       	in	r29, 0x3e	; 62
    2b64:	9b 83       	std	Y+3, r25	; 0x03
    2b66:	8a 83       	std	Y+2, r24	; 0x02
	u8 Ret;

	while(1)
	{
		Ret =0 ;
    2b68:	19 82       	std	Y+1, r1	; 0x01
		/*pend for semaphore until it released from ISR */
		xSemaphoreTake( Task_Count_Sem , portMAX_DELAY );
    2b6a:	80 91 cf 06 	lds	r24, 0x06CF
    2b6e:	90 91 d0 06 	lds	r25, 0x06D0
    2b72:	6f ef       	ldi	r22, 0xFF	; 255
    2b74:	7f ef       	ldi	r23, 0xFF	; 255
    2b76:	0e 94 04 1c 	call	0x3808	; 0x3808 <xQueueSemaphoreTake>
		Ret = xSemaphoreTake( Task_Count_Sem , portMAX_DELAY );
    2b7a:	80 91 cf 06 	lds	r24, 0x06CF
    2b7e:	90 91 d0 06 	lds	r25, 0x06D0
    2b82:	6f ef       	ldi	r22, 0xFF	; 255
    2b84:	7f ef       	ldi	r23, 0xFF	; 255
    2b86:	0e 94 04 1c 	call	0x3808	; 0x3808 <xQueueSemaphoreTake>
    2b8a:	89 83       	std	Y+1, r24	; 0x01
		if( Ret == 1 )
    2b8c:	89 81       	ldd	r24, Y+1	; 0x01
    2b8e:	81 30       	cpi	r24, 0x01	; 1
    2b90:	59 f7       	brne	.-42     	; 0x2b68 <Task1_Func+0x10>
		{
		/*print if semaphore released*/
		Lcd_vidWriteStr("Button Pressed");
    2b92:	87 e6       	ldi	r24, 0x67	; 103
    2b94:	90 e0       	ldi	r25, 0x00	; 0
    2b96:	0e 94 69 10 	call	0x20d2	; 0x20d2 <Lcd_vidWriteStr>
		vTaskDelay(500);
    2b9a:	84 ef       	ldi	r24, 0xF4	; 244
    2b9c:	91 e0       	ldi	r25, 0x01	; 1
    2b9e:	0e 94 38 2a 	call	0x5470	; 0x5470 <vTaskDelay>
		Lcd_vidSendCommand(LCD_u8CMD_CLR_Display);
    2ba2:	81 e0       	ldi	r24, 0x01	; 1
    2ba4:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <Lcd_vidSendCommand>
		vTaskDelay(500);
    2ba8:	84 ef       	ldi	r24, 0xF4	; 244
    2baa:	91 e0       	ldi	r25, 0x01	; 1
    2bac:	0e 94 38 2a 	call	0x5470	; 0x5470 <vTaskDelay>
    2bb0:	db cf       	rjmp	.-74     	; 0x2b68 <Task1_Func+0x10>

00002bb2 <INT0_Function>:
	}
}


void INT0_Function(void)
{
    2bb2:	df 93       	push	r29
    2bb4:	cf 93       	push	r28
    2bb6:	cd b7       	in	r28, 0x3d	; 61
    2bb8:	de b7       	in	r29, 0x3e	; 62
	if( flag == 0)
    2bba:	80 91 64 06 	lds	r24, 0x0664
    2bbe:	88 23       	and	r24, r24
    2bc0:	61 f4       	brne	.+24     	; 0x2bda <INT0_Function+0x28>
	{
		/*release semaphore */
			xSemaphoreGiveFromISR( Task_Count_Sem , NULL );
    2bc2:	80 91 cf 06 	lds	r24, 0x06CF
    2bc6:	90 91 d0 06 	lds	r25, 0x06D0
    2bca:	60 e0       	ldi	r22, 0x00	; 0
    2bcc:	70 e0       	ldi	r23, 0x00	; 0
    2bce:	0e 94 08 1b 	call	0x3610	; 0x3610 <xQueueGiveFromISR>
			flag = 1 ;
    2bd2:	81 e0       	ldi	r24, 0x01	; 1
    2bd4:	80 93 64 06 	sts	0x0664, r24
    2bd8:	0e c0       	rjmp	.+28     	; 0x2bf6 <INT0_Function+0x44>
	}
	else if( flag == 1)
    2bda:	80 91 64 06 	lds	r24, 0x0664
    2bde:	81 30       	cpi	r24, 0x01	; 1
    2be0:	51 f4       	brne	.+20     	; 0x2bf6 <INT0_Function+0x44>
	{
		/*release semaphore */
			xSemaphoreGiveFromISR( Task_Count_Sem , NULL );
    2be2:	80 91 cf 06 	lds	r24, 0x06CF
    2be6:	90 91 d0 06 	lds	r25, 0x06D0
    2bea:	60 e0       	ldi	r22, 0x00	; 0
    2bec:	70 e0       	ldi	r23, 0x00	; 0
    2bee:	0e 94 08 1b 	call	0x3610	; 0x3610 <xQueueGiveFromISR>
			flag = 0 ;
    2bf2:	10 92 64 06 	sts	0x0664, r1
	}

}
    2bf6:	cf 91       	pop	r28
    2bf8:	df 91       	pop	r29
    2bfa:	08 95       	ret

00002bfc <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2bfc:	df 93       	push	r29
    2bfe:	cf 93       	push	r28
    2c00:	cd b7       	in	r28, 0x3d	; 61
    2c02:	de b7       	in	r29, 0x3e	; 62
    2c04:	28 97       	sbiw	r28, 0x08	; 8
    2c06:	0f b6       	in	r0, 0x3f	; 63
    2c08:	f8 94       	cli
    2c0a:	de bf       	out	0x3e, r29	; 62
    2c0c:	0f be       	out	0x3f, r0	; 63
    2c0e:	cd bf       	out	0x3d, r28	; 61
    2c10:	9c 83       	std	Y+4, r25	; 0x04
    2c12:	8b 83       	std	Y+3, r24	; 0x03
    2c14:	7e 83       	std	Y+6, r23	; 0x06
    2c16:	6d 83       	std	Y+5, r22	; 0x05
    2c18:	58 87       	std	Y+8, r21	; 0x08
    2c1a:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2c1c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c1e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c20:	81 e1       	ldi	r24, 0x11	; 17
    2c22:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c24:	8b 81       	ldd	r24, Y+3	; 0x03
    2c26:	9c 81       	ldd	r25, Y+4	; 0x04
    2c28:	01 97       	sbiw	r24, 0x01	; 1
    2c2a:	9c 83       	std	Y+4, r25	; 0x04
    2c2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2c2e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c30:	fc 81       	ldd	r31, Y+4	; 0x04
    2c32:	82 e2       	ldi	r24, 0x22	; 34
    2c34:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c36:	8b 81       	ldd	r24, Y+3	; 0x03
    2c38:	9c 81       	ldd	r25, Y+4	; 0x04
    2c3a:	01 97       	sbiw	r24, 0x01	; 1
    2c3c:	9c 83       	std	Y+4, r25	; 0x04
    2c3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2c40:	eb 81       	ldd	r30, Y+3	; 0x03
    2c42:	fc 81       	ldd	r31, Y+4	; 0x04
    2c44:	83 e3       	ldi	r24, 0x33	; 51
    2c46:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c48:	8b 81       	ldd	r24, Y+3	; 0x03
    2c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c4c:	01 97       	sbiw	r24, 0x01	; 1
    2c4e:	9c 83       	std	Y+4, r25	; 0x04
    2c50:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    2c52:	8d 81       	ldd	r24, Y+5	; 0x05
    2c54:	9e 81       	ldd	r25, Y+6	; 0x06
    2c56:	9a 83       	std	Y+2, r25	; 0x02
    2c58:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c5a:	89 81       	ldd	r24, Y+1	; 0x01
    2c5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c60:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c62:	8b 81       	ldd	r24, Y+3	; 0x03
    2c64:	9c 81       	ldd	r25, Y+4	; 0x04
    2c66:	01 97       	sbiw	r24, 0x01	; 1
    2c68:	9c 83       	std	Y+4, r25	; 0x04
    2c6a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2c6c:	89 81       	ldd	r24, Y+1	; 0x01
    2c6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c70:	89 2f       	mov	r24, r25
    2c72:	99 27       	eor	r25, r25
    2c74:	9a 83       	std	Y+2, r25	; 0x02
    2c76:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2c78:	89 81       	ldd	r24, Y+1	; 0x01
    2c7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c7e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2c80:	8b 81       	ldd	r24, Y+3	; 0x03
    2c82:	9c 81       	ldd	r25, Y+4	; 0x04
    2c84:	01 97       	sbiw	r24, 0x01	; 1
    2c86:	9c 83       	std	Y+4, r25	; 0x04
    2c88:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2c8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c8e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2c90:	8b 81       	ldd	r24, Y+3	; 0x03
    2c92:	9c 81       	ldd	r25, Y+4	; 0x04
    2c94:	01 97       	sbiw	r24, 0x01	; 1
    2c96:	9c 83       	std	Y+4, r25	; 0x04
    2c98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2c9a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c9c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c9e:	80 e8       	ldi	r24, 0x80	; 128
    2ca0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ca2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ca6:	01 97       	sbiw	r24, 0x01	; 1
    2ca8:	9c 83       	std	Y+4, r25	; 0x04
    2caa:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2cac:	eb 81       	ldd	r30, Y+3	; 0x03
    2cae:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb0:	10 82       	st	Z, r1
	pxTopOfStack--;
    2cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb6:	01 97       	sbiw	r24, 0x01	; 1
    2cb8:	9c 83       	std	Y+4, r25	; 0x04
    2cba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2cbc:	eb 81       	ldd	r30, Y+3	; 0x03
    2cbe:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc0:	82 e0       	ldi	r24, 0x02	; 2
    2cc2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2cc4:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc6:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc8:	01 97       	sbiw	r24, 0x01	; 1
    2cca:	9c 83       	std	Y+4, r25	; 0x04
    2ccc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2cce:	eb 81       	ldd	r30, Y+3	; 0x03
    2cd0:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd2:	83 e0       	ldi	r24, 0x03	; 3
    2cd4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cda:	01 97       	sbiw	r24, 0x01	; 1
    2cdc:	9c 83       	std	Y+4, r25	; 0x04
    2cde:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2ce0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ce4:	84 e0       	ldi	r24, 0x04	; 4
    2ce6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ce8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cea:	9c 81       	ldd	r25, Y+4	; 0x04
    2cec:	01 97       	sbiw	r24, 0x01	; 1
    2cee:	9c 83       	std	Y+4, r25	; 0x04
    2cf0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2cf2:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf4:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf6:	85 e0       	ldi	r24, 0x05	; 5
    2cf8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2cfa:	8b 81       	ldd	r24, Y+3	; 0x03
    2cfc:	9c 81       	ldd	r25, Y+4	; 0x04
    2cfe:	01 97       	sbiw	r24, 0x01	; 1
    2d00:	9c 83       	std	Y+4, r25	; 0x04
    2d02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2d04:	eb 81       	ldd	r30, Y+3	; 0x03
    2d06:	fc 81       	ldd	r31, Y+4	; 0x04
    2d08:	86 e0       	ldi	r24, 0x06	; 6
    2d0a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d10:	01 97       	sbiw	r24, 0x01	; 1
    2d12:	9c 83       	std	Y+4, r25	; 0x04
    2d14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2d16:	eb 81       	ldd	r30, Y+3	; 0x03
    2d18:	fc 81       	ldd	r31, Y+4	; 0x04
    2d1a:	87 e0       	ldi	r24, 0x07	; 7
    2d1c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d20:	9c 81       	ldd	r25, Y+4	; 0x04
    2d22:	01 97       	sbiw	r24, 0x01	; 1
    2d24:	9c 83       	std	Y+4, r25	; 0x04
    2d26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2d28:	eb 81       	ldd	r30, Y+3	; 0x03
    2d2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d2c:	88 e0       	ldi	r24, 0x08	; 8
    2d2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d30:	8b 81       	ldd	r24, Y+3	; 0x03
    2d32:	9c 81       	ldd	r25, Y+4	; 0x04
    2d34:	01 97       	sbiw	r24, 0x01	; 1
    2d36:	9c 83       	std	Y+4, r25	; 0x04
    2d38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2d3a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d3c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d3e:	89 e0       	ldi	r24, 0x09	; 9
    2d40:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d42:	8b 81       	ldd	r24, Y+3	; 0x03
    2d44:	9c 81       	ldd	r25, Y+4	; 0x04
    2d46:	01 97       	sbiw	r24, 0x01	; 1
    2d48:	9c 83       	std	Y+4, r25	; 0x04
    2d4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2d4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2d4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2d50:	80 e1       	ldi	r24, 0x10	; 16
    2d52:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d54:	8b 81       	ldd	r24, Y+3	; 0x03
    2d56:	9c 81       	ldd	r25, Y+4	; 0x04
    2d58:	01 97       	sbiw	r24, 0x01	; 1
    2d5a:	9c 83       	std	Y+4, r25	; 0x04
    2d5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2d5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2d60:	fc 81       	ldd	r31, Y+4	; 0x04
    2d62:	81 e1       	ldi	r24, 0x11	; 17
    2d64:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d66:	8b 81       	ldd	r24, Y+3	; 0x03
    2d68:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6a:	01 97       	sbiw	r24, 0x01	; 1
    2d6c:	9c 83       	std	Y+4, r25	; 0x04
    2d6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2d70:	eb 81       	ldd	r30, Y+3	; 0x03
    2d72:	fc 81       	ldd	r31, Y+4	; 0x04
    2d74:	82 e1       	ldi	r24, 0x12	; 18
    2d76:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d78:	8b 81       	ldd	r24, Y+3	; 0x03
    2d7a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d7c:	01 97       	sbiw	r24, 0x01	; 1
    2d7e:	9c 83       	std	Y+4, r25	; 0x04
    2d80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2d82:	eb 81       	ldd	r30, Y+3	; 0x03
    2d84:	fc 81       	ldd	r31, Y+4	; 0x04
    2d86:	83 e1       	ldi	r24, 0x13	; 19
    2d88:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d8e:	01 97       	sbiw	r24, 0x01	; 1
    2d90:	9c 83       	std	Y+4, r25	; 0x04
    2d92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2d94:	eb 81       	ldd	r30, Y+3	; 0x03
    2d96:	fc 81       	ldd	r31, Y+4	; 0x04
    2d98:	84 e1       	ldi	r24, 0x14	; 20
    2d9a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2d9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2da0:	01 97       	sbiw	r24, 0x01	; 1
    2da2:	9c 83       	std	Y+4, r25	; 0x04
    2da4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2da6:	eb 81       	ldd	r30, Y+3	; 0x03
    2da8:	fc 81       	ldd	r31, Y+4	; 0x04
    2daa:	85 e1       	ldi	r24, 0x15	; 21
    2dac:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dae:	8b 81       	ldd	r24, Y+3	; 0x03
    2db0:	9c 81       	ldd	r25, Y+4	; 0x04
    2db2:	01 97       	sbiw	r24, 0x01	; 1
    2db4:	9c 83       	std	Y+4, r25	; 0x04
    2db6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2db8:	eb 81       	ldd	r30, Y+3	; 0x03
    2dba:	fc 81       	ldd	r31, Y+4	; 0x04
    2dbc:	86 e1       	ldi	r24, 0x16	; 22
    2dbe:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc2:	9c 81       	ldd	r25, Y+4	; 0x04
    2dc4:	01 97       	sbiw	r24, 0x01	; 1
    2dc6:	9c 83       	std	Y+4, r25	; 0x04
    2dc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2dca:	eb 81       	ldd	r30, Y+3	; 0x03
    2dcc:	fc 81       	ldd	r31, Y+4	; 0x04
    2dce:	87 e1       	ldi	r24, 0x17	; 23
    2dd0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd4:	9c 81       	ldd	r25, Y+4	; 0x04
    2dd6:	01 97       	sbiw	r24, 0x01	; 1
    2dd8:	9c 83       	std	Y+4, r25	; 0x04
    2dda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2ddc:	eb 81       	ldd	r30, Y+3	; 0x03
    2dde:	fc 81       	ldd	r31, Y+4	; 0x04
    2de0:	88 e1       	ldi	r24, 0x18	; 24
    2de2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2de4:	8b 81       	ldd	r24, Y+3	; 0x03
    2de6:	9c 81       	ldd	r25, Y+4	; 0x04
    2de8:	01 97       	sbiw	r24, 0x01	; 1
    2dea:	9c 83       	std	Y+4, r25	; 0x04
    2dec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2dee:	eb 81       	ldd	r30, Y+3	; 0x03
    2df0:	fc 81       	ldd	r31, Y+4	; 0x04
    2df2:	89 e1       	ldi	r24, 0x19	; 25
    2df4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2df6:	8b 81       	ldd	r24, Y+3	; 0x03
    2df8:	9c 81       	ldd	r25, Y+4	; 0x04
    2dfa:	01 97       	sbiw	r24, 0x01	; 1
    2dfc:	9c 83       	std	Y+4, r25	; 0x04
    2dfe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2e00:	eb 81       	ldd	r30, Y+3	; 0x03
    2e02:	fc 81       	ldd	r31, Y+4	; 0x04
    2e04:	80 e2       	ldi	r24, 0x20	; 32
    2e06:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e08:	8b 81       	ldd	r24, Y+3	; 0x03
    2e0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0c:	01 97       	sbiw	r24, 0x01	; 1
    2e0e:	9c 83       	std	Y+4, r25	; 0x04
    2e10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2e12:	eb 81       	ldd	r30, Y+3	; 0x03
    2e14:	fc 81       	ldd	r31, Y+4	; 0x04
    2e16:	81 e2       	ldi	r24, 0x21	; 33
    2e18:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e1e:	01 97       	sbiw	r24, 0x01	; 1
    2e20:	9c 83       	std	Y+4, r25	; 0x04
    2e22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2e24:	eb 81       	ldd	r30, Y+3	; 0x03
    2e26:	fc 81       	ldd	r31, Y+4	; 0x04
    2e28:	82 e2       	ldi	r24, 0x22	; 34
    2e2a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e30:	01 97       	sbiw	r24, 0x01	; 1
    2e32:	9c 83       	std	Y+4, r25	; 0x04
    2e34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2e36:	eb 81       	ldd	r30, Y+3	; 0x03
    2e38:	fc 81       	ldd	r31, Y+4	; 0x04
    2e3a:	83 e2       	ldi	r24, 0x23	; 35
    2e3c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e40:	9c 81       	ldd	r25, Y+4	; 0x04
    2e42:	01 97       	sbiw	r24, 0x01	; 1
    2e44:	9c 83       	std	Y+4, r25	; 0x04
    2e46:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2e48:	8f 81       	ldd	r24, Y+7	; 0x07
    2e4a:	98 85       	ldd	r25, Y+8	; 0x08
    2e4c:	9a 83       	std	Y+2, r25	; 0x02
    2e4e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2e50:	89 81       	ldd	r24, Y+1	; 0x01
    2e52:	eb 81       	ldd	r30, Y+3	; 0x03
    2e54:	fc 81       	ldd	r31, Y+4	; 0x04
    2e56:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e58:	8b 81       	ldd	r24, Y+3	; 0x03
    2e5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e5c:	01 97       	sbiw	r24, 0x01	; 1
    2e5e:	9c 83       	std	Y+4, r25	; 0x04
    2e60:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2e62:	89 81       	ldd	r24, Y+1	; 0x01
    2e64:	9a 81       	ldd	r25, Y+2	; 0x02
    2e66:	89 2f       	mov	r24, r25
    2e68:	99 27       	eor	r25, r25
    2e6a:	9a 83       	std	Y+2, r25	; 0x02
    2e6c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2e6e:	89 81       	ldd	r24, Y+1	; 0x01
    2e70:	eb 81       	ldd	r30, Y+3	; 0x03
    2e72:	fc 81       	ldd	r31, Y+4	; 0x04
    2e74:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e76:	8b 81       	ldd	r24, Y+3	; 0x03
    2e78:	9c 81       	ldd	r25, Y+4	; 0x04
    2e7a:	01 97       	sbiw	r24, 0x01	; 1
    2e7c:	9c 83       	std	Y+4, r25	; 0x04
    2e7e:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2e80:	eb 81       	ldd	r30, Y+3	; 0x03
    2e82:	fc 81       	ldd	r31, Y+4	; 0x04
    2e84:	86 e2       	ldi	r24, 0x26	; 38
    2e86:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e88:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8c:	01 97       	sbiw	r24, 0x01	; 1
    2e8e:	9c 83       	std	Y+4, r25	; 0x04
    2e90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2e92:	eb 81       	ldd	r30, Y+3	; 0x03
    2e94:	fc 81       	ldd	r31, Y+4	; 0x04
    2e96:	87 e2       	ldi	r24, 0x27	; 39
    2e98:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e9e:	01 97       	sbiw	r24, 0x01	; 1
    2ea0:	9c 83       	std	Y+4, r25	; 0x04
    2ea2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2ea4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ea6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ea8:	88 e2       	ldi	r24, 0x28	; 40
    2eaa:	80 83       	st	Z, r24
	pxTopOfStack--;
    2eac:	8b 81       	ldd	r24, Y+3	; 0x03
    2eae:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb0:	01 97       	sbiw	r24, 0x01	; 1
    2eb2:	9c 83       	std	Y+4, r25	; 0x04
    2eb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2eb6:	eb 81       	ldd	r30, Y+3	; 0x03
    2eb8:	fc 81       	ldd	r31, Y+4	; 0x04
    2eba:	89 e2       	ldi	r24, 0x29	; 41
    2ebc:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec2:	01 97       	sbiw	r24, 0x01	; 1
    2ec4:	9c 83       	std	Y+4, r25	; 0x04
    2ec6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2ec8:	eb 81       	ldd	r30, Y+3	; 0x03
    2eca:	fc 81       	ldd	r31, Y+4	; 0x04
    2ecc:	80 e3       	ldi	r24, 0x30	; 48
    2ece:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed4:	01 97       	sbiw	r24, 0x01	; 1
    2ed6:	9c 83       	std	Y+4, r25	; 0x04
    2ed8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2eda:	eb 81       	ldd	r30, Y+3	; 0x03
    2edc:	fc 81       	ldd	r31, Y+4	; 0x04
    2ede:	81 e3       	ldi	r24, 0x31	; 49
    2ee0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee6:	01 97       	sbiw	r24, 0x01	; 1
    2ee8:	9c 83       	std	Y+4, r25	; 0x04
    2eea:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2eec:	8b 81       	ldd	r24, Y+3	; 0x03
    2eee:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2ef0:	28 96       	adiw	r28, 0x08	; 8
    2ef2:	0f b6       	in	r0, 0x3f	; 63
    2ef4:	f8 94       	cli
    2ef6:	de bf       	out	0x3e, r29	; 62
    2ef8:	0f be       	out	0x3f, r0	; 63
    2efa:	cd bf       	out	0x3d, r28	; 61
    2efc:	cf 91       	pop	r28
    2efe:	df 91       	pop	r29
    2f00:	08 95       	ret

00002f02 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2f02:	df 93       	push	r29
    2f04:	cf 93       	push	r28
    2f06:	cd b7       	in	r28, 0x3d	; 61
    2f08:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2f0a:	0e 94 73 18 	call	0x30e6	; 0x30e6 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2f0e:	a0 91 65 06 	lds	r26, 0x0665
    2f12:	b0 91 66 06 	lds	r27, 0x0666
    2f16:	cd 91       	ld	r28, X+
    2f18:	cd bf       	out	0x3d, r28	; 61
    2f1a:	dd 91       	ld	r29, X+
    2f1c:	de bf       	out	0x3e, r29	; 62
    2f1e:	ff 91       	pop	r31
    2f20:	ef 91       	pop	r30
    2f22:	df 91       	pop	r29
    2f24:	cf 91       	pop	r28
    2f26:	bf 91       	pop	r27
    2f28:	af 91       	pop	r26
    2f2a:	9f 91       	pop	r25
    2f2c:	8f 91       	pop	r24
    2f2e:	7f 91       	pop	r23
    2f30:	6f 91       	pop	r22
    2f32:	5f 91       	pop	r21
    2f34:	4f 91       	pop	r20
    2f36:	3f 91       	pop	r19
    2f38:	2f 91       	pop	r18
    2f3a:	1f 91       	pop	r17
    2f3c:	0f 91       	pop	r16
    2f3e:	ff 90       	pop	r15
    2f40:	ef 90       	pop	r14
    2f42:	df 90       	pop	r13
    2f44:	cf 90       	pop	r12
    2f46:	bf 90       	pop	r11
    2f48:	af 90       	pop	r10
    2f4a:	9f 90       	pop	r9
    2f4c:	8f 90       	pop	r8
    2f4e:	7f 90       	pop	r7
    2f50:	6f 90       	pop	r6
    2f52:	5f 90       	pop	r5
    2f54:	4f 90       	pop	r4
    2f56:	3f 90       	pop	r3
    2f58:	2f 90       	pop	r2
    2f5a:	1f 90       	pop	r1
    2f5c:	0f 90       	pop	r0
    2f5e:	0f be       	out	0x3f, r0	; 63
    2f60:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2f62:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2f64:	81 e0       	ldi	r24, 0x01	; 1
}
    2f66:	cf 91       	pop	r28
    2f68:	df 91       	pop	r29
    2f6a:	08 95       	ret

00002f6c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2f6c:	df 93       	push	r29
    2f6e:	cf 93       	push	r28
    2f70:	cd b7       	in	r28, 0x3d	; 61
    2f72:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2f74:	cf 91       	pop	r28
    2f76:	df 91       	pop	r29
    2f78:	08 95       	ret

00002f7a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2f7a:	0f 92       	push	r0
    2f7c:	0f b6       	in	r0, 0x3f	; 63
    2f7e:	f8 94       	cli
    2f80:	0f 92       	push	r0
    2f82:	1f 92       	push	r1
    2f84:	11 24       	eor	r1, r1
    2f86:	2f 92       	push	r2
    2f88:	3f 92       	push	r3
    2f8a:	4f 92       	push	r4
    2f8c:	5f 92       	push	r5
    2f8e:	6f 92       	push	r6
    2f90:	7f 92       	push	r7
    2f92:	8f 92       	push	r8
    2f94:	9f 92       	push	r9
    2f96:	af 92       	push	r10
    2f98:	bf 92       	push	r11
    2f9a:	cf 92       	push	r12
    2f9c:	df 92       	push	r13
    2f9e:	ef 92       	push	r14
    2fa0:	ff 92       	push	r15
    2fa2:	0f 93       	push	r16
    2fa4:	1f 93       	push	r17
    2fa6:	2f 93       	push	r18
    2fa8:	3f 93       	push	r19
    2faa:	4f 93       	push	r20
    2fac:	5f 93       	push	r21
    2fae:	6f 93       	push	r22
    2fb0:	7f 93       	push	r23
    2fb2:	8f 93       	push	r24
    2fb4:	9f 93       	push	r25
    2fb6:	af 93       	push	r26
    2fb8:	bf 93       	push	r27
    2fba:	cf 93       	push	r28
    2fbc:	df 93       	push	r29
    2fbe:	ef 93       	push	r30
    2fc0:	ff 93       	push	r31
    2fc2:	a0 91 65 06 	lds	r26, 0x0665
    2fc6:	b0 91 66 06 	lds	r27, 0x0666
    2fca:	0d b6       	in	r0, 0x3d	; 61
    2fcc:	0d 92       	st	X+, r0
    2fce:	0e b6       	in	r0, 0x3e	; 62
    2fd0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2fd2:	0e 94 e6 2d 	call	0x5bcc	; 0x5bcc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2fd6:	a0 91 65 06 	lds	r26, 0x0665
    2fda:	b0 91 66 06 	lds	r27, 0x0666
    2fde:	cd 91       	ld	r28, X+
    2fe0:	cd bf       	out	0x3d, r28	; 61
    2fe2:	dd 91       	ld	r29, X+
    2fe4:	de bf       	out	0x3e, r29	; 62
    2fe6:	ff 91       	pop	r31
    2fe8:	ef 91       	pop	r30
    2fea:	df 91       	pop	r29
    2fec:	cf 91       	pop	r28
    2fee:	bf 91       	pop	r27
    2ff0:	af 91       	pop	r26
    2ff2:	9f 91       	pop	r25
    2ff4:	8f 91       	pop	r24
    2ff6:	7f 91       	pop	r23
    2ff8:	6f 91       	pop	r22
    2ffa:	5f 91       	pop	r21
    2ffc:	4f 91       	pop	r20
    2ffe:	3f 91       	pop	r19
    3000:	2f 91       	pop	r18
    3002:	1f 91       	pop	r17
    3004:	0f 91       	pop	r16
    3006:	ff 90       	pop	r15
    3008:	ef 90       	pop	r14
    300a:	df 90       	pop	r13
    300c:	cf 90       	pop	r12
    300e:	bf 90       	pop	r11
    3010:	af 90       	pop	r10
    3012:	9f 90       	pop	r9
    3014:	8f 90       	pop	r8
    3016:	7f 90       	pop	r7
    3018:	6f 90       	pop	r6
    301a:	5f 90       	pop	r5
    301c:	4f 90       	pop	r4
    301e:	3f 90       	pop	r3
    3020:	2f 90       	pop	r2
    3022:	1f 90       	pop	r1
    3024:	0f 90       	pop	r0
    3026:	0f be       	out	0x3f, r0	; 63
    3028:	0f 90       	pop	r0

	asm volatile ( "ret" );
    302a:	08 95       	ret

0000302c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    302c:	0f 92       	push	r0
    302e:	0f b6       	in	r0, 0x3f	; 63
    3030:	f8 94       	cli
    3032:	0f 92       	push	r0
    3034:	1f 92       	push	r1
    3036:	11 24       	eor	r1, r1
    3038:	2f 92       	push	r2
    303a:	3f 92       	push	r3
    303c:	4f 92       	push	r4
    303e:	5f 92       	push	r5
    3040:	6f 92       	push	r6
    3042:	7f 92       	push	r7
    3044:	8f 92       	push	r8
    3046:	9f 92       	push	r9
    3048:	af 92       	push	r10
    304a:	bf 92       	push	r11
    304c:	cf 92       	push	r12
    304e:	df 92       	push	r13
    3050:	ef 92       	push	r14
    3052:	ff 92       	push	r15
    3054:	0f 93       	push	r16
    3056:	1f 93       	push	r17
    3058:	2f 93       	push	r18
    305a:	3f 93       	push	r19
    305c:	4f 93       	push	r20
    305e:	5f 93       	push	r21
    3060:	6f 93       	push	r22
    3062:	7f 93       	push	r23
    3064:	8f 93       	push	r24
    3066:	9f 93       	push	r25
    3068:	af 93       	push	r26
    306a:	bf 93       	push	r27
    306c:	cf 93       	push	r28
    306e:	df 93       	push	r29
    3070:	ef 93       	push	r30
    3072:	ff 93       	push	r31
    3074:	a0 91 65 06 	lds	r26, 0x0665
    3078:	b0 91 66 06 	lds	r27, 0x0666
    307c:	0d b6       	in	r0, 0x3d	; 61
    307e:	0d 92       	st	X+, r0
    3080:	0e b6       	in	r0, 0x3e	; 62
    3082:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    3084:	0e 94 01 2d 	call	0x5a02	; 0x5a02 <xTaskIncrementTick>
    3088:	88 23       	and	r24, r24
    308a:	11 f0       	breq	.+4      	; 0x3090 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    308c:	0e 94 e6 2d 	call	0x5bcc	; 0x5bcc <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    3090:	a0 91 65 06 	lds	r26, 0x0665
    3094:	b0 91 66 06 	lds	r27, 0x0666
    3098:	cd 91       	ld	r28, X+
    309a:	cd bf       	out	0x3d, r28	; 61
    309c:	dd 91       	ld	r29, X+
    309e:	de bf       	out	0x3e, r29	; 62
    30a0:	ff 91       	pop	r31
    30a2:	ef 91       	pop	r30
    30a4:	df 91       	pop	r29
    30a6:	cf 91       	pop	r28
    30a8:	bf 91       	pop	r27
    30aa:	af 91       	pop	r26
    30ac:	9f 91       	pop	r25
    30ae:	8f 91       	pop	r24
    30b0:	7f 91       	pop	r23
    30b2:	6f 91       	pop	r22
    30b4:	5f 91       	pop	r21
    30b6:	4f 91       	pop	r20
    30b8:	3f 91       	pop	r19
    30ba:	2f 91       	pop	r18
    30bc:	1f 91       	pop	r17
    30be:	0f 91       	pop	r16
    30c0:	ff 90       	pop	r15
    30c2:	ef 90       	pop	r14
    30c4:	df 90       	pop	r13
    30c6:	cf 90       	pop	r12
    30c8:	bf 90       	pop	r11
    30ca:	af 90       	pop	r10
    30cc:	9f 90       	pop	r9
    30ce:	8f 90       	pop	r8
    30d0:	7f 90       	pop	r7
    30d2:	6f 90       	pop	r6
    30d4:	5f 90       	pop	r5
    30d6:	4f 90       	pop	r4
    30d8:	3f 90       	pop	r3
    30da:	2f 90       	pop	r2
    30dc:	1f 90       	pop	r1
    30de:	0f 90       	pop	r0
    30e0:	0f be       	out	0x3f, r0	; 63
    30e2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    30e4:	08 95       	ret

000030e6 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    30e6:	df 93       	push	r29
    30e8:	cf 93       	push	r28
    30ea:	00 d0       	rcall	.+0      	; 0x30ec <prvSetupTimerInterrupt+0x6>
    30ec:	00 d0       	rcall	.+0      	; 0x30ee <prvSetupTimerInterrupt+0x8>
    30ee:	00 d0       	rcall	.+0      	; 0x30f0 <prvSetupTimerInterrupt+0xa>
    30f0:	cd b7       	in	r28, 0x3d	; 61
    30f2:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    30f4:	80 e4       	ldi	r24, 0x40	; 64
    30f6:	9f e1       	ldi	r25, 0x1F	; 31
    30f8:	a0 e0       	ldi	r26, 0x00	; 0
    30fa:	b0 e0       	ldi	r27, 0x00	; 0
    30fc:	8b 83       	std	Y+3, r24	; 0x03
    30fe:	9c 83       	std	Y+4, r25	; 0x04
    3100:	ad 83       	std	Y+5, r26	; 0x05
    3102:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3104:	8b 81       	ldd	r24, Y+3	; 0x03
    3106:	9c 81       	ldd	r25, Y+4	; 0x04
    3108:	ad 81       	ldd	r26, Y+5	; 0x05
    310a:	be 81       	ldd	r27, Y+6	; 0x06
    310c:	68 94       	set
    310e:	15 f8       	bld	r1, 5
    3110:	b6 95       	lsr	r27
    3112:	a7 95       	ror	r26
    3114:	97 95       	ror	r25
    3116:	87 95       	ror	r24
    3118:	16 94       	lsr	r1
    311a:	d1 f7       	brne	.-12     	; 0x3110 <prvSetupTimerInterrupt+0x2a>
    311c:	8b 83       	std	Y+3, r24	; 0x03
    311e:	9c 83       	std	Y+4, r25	; 0x04
    3120:	ad 83       	std	Y+5, r26	; 0x05
    3122:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    3124:	8b 81       	ldd	r24, Y+3	; 0x03
    3126:	9c 81       	ldd	r25, Y+4	; 0x04
    3128:	ad 81       	ldd	r26, Y+5	; 0x05
    312a:	be 81       	ldd	r27, Y+6	; 0x06
    312c:	01 97       	sbiw	r24, 0x01	; 1
    312e:	a1 09       	sbc	r26, r1
    3130:	b1 09       	sbc	r27, r1
    3132:	8b 83       	std	Y+3, r24	; 0x03
    3134:	9c 83       	std	Y+4, r25	; 0x04
    3136:	ad 83       	std	Y+5, r26	; 0x05
    3138:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    313a:	8b 81       	ldd	r24, Y+3	; 0x03
    313c:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    313e:	8b 81       	ldd	r24, Y+3	; 0x03
    3140:	9c 81       	ldd	r25, Y+4	; 0x04
    3142:	ad 81       	ldd	r26, Y+5	; 0x05
    3144:	be 81       	ldd	r27, Y+6	; 0x06
    3146:	89 2f       	mov	r24, r25
    3148:	9a 2f       	mov	r25, r26
    314a:	ab 2f       	mov	r26, r27
    314c:	bb 27       	eor	r27, r27
    314e:	8b 83       	std	Y+3, r24	; 0x03
    3150:	9c 83       	std	Y+4, r25	; 0x04
    3152:	ad 83       	std	Y+5, r26	; 0x05
    3154:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3156:	8b 81       	ldd	r24, Y+3	; 0x03
    3158:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    315a:	eb e4       	ldi	r30, 0x4B	; 75
    315c:	f0 e0       	ldi	r31, 0x00	; 0
    315e:	8a 81       	ldd	r24, Y+2	; 0x02
    3160:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3162:	ea e4       	ldi	r30, 0x4A	; 74
    3164:	f0 e0       	ldi	r31, 0x00	; 0
    3166:	89 81       	ldd	r24, Y+1	; 0x01
    3168:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    316a:	8b e0       	ldi	r24, 0x0B	; 11
    316c:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    316e:	ee e4       	ldi	r30, 0x4E	; 78
    3170:	f0 e0       	ldi	r31, 0x00	; 0
    3172:	89 81       	ldd	r24, Y+1	; 0x01
    3174:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3176:	e9 e5       	ldi	r30, 0x59	; 89
    3178:	f0 e0       	ldi	r31, 0x00	; 0
    317a:	80 81       	ld	r24, Z
    317c:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    317e:	89 81       	ldd	r24, Y+1	; 0x01
    3180:	80 61       	ori	r24, 0x10	; 16
    3182:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3184:	e9 e5       	ldi	r30, 0x59	; 89
    3186:	f0 e0       	ldi	r31, 0x00	; 0
    3188:	89 81       	ldd	r24, Y+1	; 0x01
    318a:	80 83       	st	Z, r24
}
    318c:	26 96       	adiw	r28, 0x06	; 6
    318e:	0f b6       	in	r0, 0x3f	; 63
    3190:	f8 94       	cli
    3192:	de bf       	out	0x3e, r29	; 62
    3194:	0f be       	out	0x3f, r0	; 63
    3196:	cd bf       	out	0x3d, r28	; 61
    3198:	cf 91       	pop	r28
    319a:	df 91       	pop	r29
    319c:	08 95       	ret

0000319e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    319e:	0e 94 16 18 	call	0x302c	; 0x302c <vPortYieldFromTick>
		asm volatile ( "reti" );
    31a2:	18 95       	reti

000031a4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    31a4:	df 93       	push	r29
    31a6:	cf 93       	push	r28
    31a8:	00 d0       	rcall	.+0      	; 0x31aa <xQueueGenericReset+0x6>
    31aa:	00 d0       	rcall	.+0      	; 0x31ac <xQueueGenericReset+0x8>
    31ac:	0f 92       	push	r0
    31ae:	cd b7       	in	r28, 0x3d	; 61
    31b0:	de b7       	in	r29, 0x3e	; 62
    31b2:	9c 83       	std	Y+4, r25	; 0x04
    31b4:	8b 83       	std	Y+3, r24	; 0x03
    31b6:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    31b8:	8b 81       	ldd	r24, Y+3	; 0x03
    31ba:	9c 81       	ldd	r25, Y+4	; 0x04
    31bc:	9a 83       	std	Y+2, r25	; 0x02
    31be:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    31c0:	0f b6       	in	r0, 0x3f	; 63
    31c2:	f8 94       	cli
    31c4:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    31c6:	e9 81       	ldd	r30, Y+1	; 0x01
    31c8:	fa 81       	ldd	r31, Y+2	; 0x02
    31ca:	40 81       	ld	r20, Z
    31cc:	51 81       	ldd	r21, Z+1	; 0x01
    31ce:	e9 81       	ldd	r30, Y+1	; 0x01
    31d0:	fa 81       	ldd	r31, Y+2	; 0x02
    31d2:	83 8d       	ldd	r24, Z+27	; 0x1b
    31d4:	28 2f       	mov	r18, r24
    31d6:	30 e0       	ldi	r19, 0x00	; 0
    31d8:	e9 81       	ldd	r30, Y+1	; 0x01
    31da:	fa 81       	ldd	r31, Y+2	; 0x02
    31dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    31de:	88 2f       	mov	r24, r24
    31e0:	90 e0       	ldi	r25, 0x00	; 0
    31e2:	bc 01       	movw	r22, r24
    31e4:	26 9f       	mul	r18, r22
    31e6:	c0 01       	movw	r24, r0
    31e8:	27 9f       	mul	r18, r23
    31ea:	90 0d       	add	r25, r0
    31ec:	36 9f       	mul	r19, r22
    31ee:	90 0d       	add	r25, r0
    31f0:	11 24       	eor	r1, r1
    31f2:	84 0f       	add	r24, r20
    31f4:	95 1f       	adc	r25, r21
    31f6:	e9 81       	ldd	r30, Y+1	; 0x01
    31f8:	fa 81       	ldd	r31, Y+2	; 0x02
    31fa:	95 83       	std	Z+5, r25	; 0x05
    31fc:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    31fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3200:	fa 81       	ldd	r31, Y+2	; 0x02
    3202:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    3204:	e9 81       	ldd	r30, Y+1	; 0x01
    3206:	fa 81       	ldd	r31, Y+2	; 0x02
    3208:	80 81       	ld	r24, Z
    320a:	91 81       	ldd	r25, Z+1	; 0x01
    320c:	e9 81       	ldd	r30, Y+1	; 0x01
    320e:	fa 81       	ldd	r31, Y+2	; 0x02
    3210:	93 83       	std	Z+3, r25	; 0x03
    3212:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3214:	e9 81       	ldd	r30, Y+1	; 0x01
    3216:	fa 81       	ldd	r31, Y+2	; 0x02
    3218:	40 81       	ld	r20, Z
    321a:	51 81       	ldd	r21, Z+1	; 0x01
    321c:	e9 81       	ldd	r30, Y+1	; 0x01
    321e:	fa 81       	ldd	r31, Y+2	; 0x02
    3220:	83 8d       	ldd	r24, Z+27	; 0x1b
    3222:	88 2f       	mov	r24, r24
    3224:	90 e0       	ldi	r25, 0x00	; 0
    3226:	9c 01       	movw	r18, r24
    3228:	21 50       	subi	r18, 0x01	; 1
    322a:	30 40       	sbci	r19, 0x00	; 0
    322c:	e9 81       	ldd	r30, Y+1	; 0x01
    322e:	fa 81       	ldd	r31, Y+2	; 0x02
    3230:	84 8d       	ldd	r24, Z+28	; 0x1c
    3232:	88 2f       	mov	r24, r24
    3234:	90 e0       	ldi	r25, 0x00	; 0
    3236:	bc 01       	movw	r22, r24
    3238:	26 9f       	mul	r18, r22
    323a:	c0 01       	movw	r24, r0
    323c:	27 9f       	mul	r18, r23
    323e:	90 0d       	add	r25, r0
    3240:	36 9f       	mul	r19, r22
    3242:	90 0d       	add	r25, r0
    3244:	11 24       	eor	r1, r1
    3246:	84 0f       	add	r24, r20
    3248:	95 1f       	adc	r25, r21
    324a:	e9 81       	ldd	r30, Y+1	; 0x01
    324c:	fa 81       	ldd	r31, Y+2	; 0x02
    324e:	97 83       	std	Z+7, r25	; 0x07
    3250:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    3252:	e9 81       	ldd	r30, Y+1	; 0x01
    3254:	fa 81       	ldd	r31, Y+2	; 0x02
    3256:	8f ef       	ldi	r24, 0xFF	; 255
    3258:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    325a:	e9 81       	ldd	r30, Y+1	; 0x01
    325c:	fa 81       	ldd	r31, Y+2	; 0x02
    325e:	8f ef       	ldi	r24, 0xFF	; 255
    3260:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    3262:	8d 81       	ldd	r24, Y+5	; 0x05
    3264:	88 23       	and	r24, r24
    3266:	79 f4       	brne	.+30     	; 0x3286 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3268:	e9 81       	ldd	r30, Y+1	; 0x01
    326a:	fa 81       	ldd	r31, Y+2	; 0x02
    326c:	80 85       	ldd	r24, Z+8	; 0x08
    326e:	88 23       	and	r24, r24
    3270:	a1 f0       	breq	.+40     	; 0x329a <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3272:	89 81       	ldd	r24, Y+1	; 0x01
    3274:	9a 81       	ldd	r25, Y+2	; 0x02
    3276:	08 96       	adiw	r24, 0x08	; 8
    3278:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <xTaskRemoveFromEventList>
    327c:	88 23       	and	r24, r24
    327e:	69 f0       	breq	.+26     	; 0x329a <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    3280:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
    3284:	0a c0       	rjmp	.+20     	; 0x329a <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3286:	89 81       	ldd	r24, Y+1	; 0x01
    3288:	9a 81       	ldd	r25, Y+2	; 0x02
    328a:	08 96       	adiw	r24, 0x08	; 8
    328c:	0e 94 46 14 	call	0x288c	; 0x288c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3290:	89 81       	ldd	r24, Y+1	; 0x01
    3292:	9a 81       	ldd	r25, Y+2	; 0x02
    3294:	41 96       	adiw	r24, 0x11	; 17
    3296:	0e 94 46 14 	call	0x288c	; 0x288c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    329a:	0f 90       	pop	r0
    329c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    329e:	81 e0       	ldi	r24, 0x01	; 1
}
    32a0:	0f 90       	pop	r0
    32a2:	0f 90       	pop	r0
    32a4:	0f 90       	pop	r0
    32a6:	0f 90       	pop	r0
    32a8:	0f 90       	pop	r0
    32aa:	cf 91       	pop	r28
    32ac:	df 91       	pop	r29
    32ae:	08 95       	ret

000032b0 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    32b0:	0f 93       	push	r16
    32b2:	1f 93       	push	r17
    32b4:	df 93       	push	r29
    32b6:	cf 93       	push	r28
    32b8:	cd b7       	in	r28, 0x3d	; 61
    32ba:	de b7       	in	r29, 0x3e	; 62
    32bc:	29 97       	sbiw	r28, 0x09	; 9
    32be:	0f b6       	in	r0, 0x3f	; 63
    32c0:	f8 94       	cli
    32c2:	de bf       	out	0x3e, r29	; 62
    32c4:	0f be       	out	0x3f, r0	; 63
    32c6:	cd bf       	out	0x3d, r28	; 61
    32c8:	8f 83       	std	Y+7, r24	; 0x07
    32ca:	68 87       	std	Y+8, r22	; 0x08
    32cc:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    32ce:	88 85       	ldd	r24, Y+8	; 0x08
    32d0:	88 23       	and	r24, r24
    32d2:	19 f4       	brne	.+6      	; 0x32da <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    32d4:	1c 82       	std	Y+4, r1	; 0x04
    32d6:	1b 82       	std	Y+3, r1	; 0x03
    32d8:	10 c0       	rjmp	.+32     	; 0x32fa <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    32da:	8f 81       	ldd	r24, Y+7	; 0x07
    32dc:	28 2f       	mov	r18, r24
    32de:	30 e0       	ldi	r19, 0x00	; 0
    32e0:	88 85       	ldd	r24, Y+8	; 0x08
    32e2:	88 2f       	mov	r24, r24
    32e4:	90 e0       	ldi	r25, 0x00	; 0
    32e6:	ac 01       	movw	r20, r24
    32e8:	24 9f       	mul	r18, r20
    32ea:	c0 01       	movw	r24, r0
    32ec:	25 9f       	mul	r18, r21
    32ee:	90 0d       	add	r25, r0
    32f0:	34 9f       	mul	r19, r20
    32f2:	90 0d       	add	r25, r0
    32f4:	11 24       	eor	r1, r1
    32f6:	9c 83       	std	Y+4, r25	; 0x04
    32f8:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    32fa:	8b 81       	ldd	r24, Y+3	; 0x03
    32fc:	9c 81       	ldd	r25, Y+4	; 0x04
    32fe:	4f 96       	adiw	r24, 0x1f	; 31
    3300:	0e 94 ca 13 	call	0x2794	; 0x2794 <pvPortMalloc>
    3304:	9e 83       	std	Y+6, r25	; 0x06
    3306:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    3308:	8d 81       	ldd	r24, Y+5	; 0x05
    330a:	9e 81       	ldd	r25, Y+6	; 0x06
    330c:	00 97       	sbiw	r24, 0x00	; 0
    330e:	a1 f0       	breq	.+40     	; 0x3338 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    3310:	8d 81       	ldd	r24, Y+5	; 0x05
    3312:	9e 81       	ldd	r25, Y+6	; 0x06
    3314:	9a 83       	std	Y+2, r25	; 0x02
    3316:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3318:	89 81       	ldd	r24, Y+1	; 0x01
    331a:	9a 81       	ldd	r25, Y+2	; 0x02
    331c:	4f 96       	adiw	r24, 0x1f	; 31
    331e:	9a 83       	std	Y+2, r25	; 0x02
    3320:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    3322:	29 81       	ldd	r18, Y+1	; 0x01
    3324:	3a 81       	ldd	r19, Y+2	; 0x02
    3326:	ed 81       	ldd	r30, Y+5	; 0x05
    3328:	fe 81       	ldd	r31, Y+6	; 0x06
    332a:	8f 81       	ldd	r24, Y+7	; 0x07
    332c:	68 85       	ldd	r22, Y+8	; 0x08
    332e:	a9 01       	movw	r20, r18
    3330:	29 85       	ldd	r18, Y+9	; 0x09
    3332:	8f 01       	movw	r16, r30
    3334:	0e 94 a9 19 	call	0x3352	; 0x3352 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    3338:	8d 81       	ldd	r24, Y+5	; 0x05
    333a:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    333c:	29 96       	adiw	r28, 0x09	; 9
    333e:	0f b6       	in	r0, 0x3f	; 63
    3340:	f8 94       	cli
    3342:	de bf       	out	0x3e, r29	; 62
    3344:	0f be       	out	0x3f, r0	; 63
    3346:	cd bf       	out	0x3d, r28	; 61
    3348:	cf 91       	pop	r28
    334a:	df 91       	pop	r29
    334c:	1f 91       	pop	r17
    334e:	0f 91       	pop	r16
    3350:	08 95       	ret

00003352 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    3352:	0f 93       	push	r16
    3354:	1f 93       	push	r17
    3356:	df 93       	push	r29
    3358:	cf 93       	push	r28
    335a:	cd b7       	in	r28, 0x3d	; 61
    335c:	de b7       	in	r29, 0x3e	; 62
    335e:	27 97       	sbiw	r28, 0x07	; 7
    3360:	0f b6       	in	r0, 0x3f	; 63
    3362:	f8 94       	cli
    3364:	de bf       	out	0x3e, r29	; 62
    3366:	0f be       	out	0x3f, r0	; 63
    3368:	cd bf       	out	0x3d, r28	; 61
    336a:	89 83       	std	Y+1, r24	; 0x01
    336c:	6a 83       	std	Y+2, r22	; 0x02
    336e:	5c 83       	std	Y+4, r21	; 0x04
    3370:	4b 83       	std	Y+3, r20	; 0x03
    3372:	2d 83       	std	Y+5, r18	; 0x05
    3374:	1f 83       	std	Y+7, r17	; 0x07
    3376:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    3378:	8a 81       	ldd	r24, Y+2	; 0x02
    337a:	88 23       	and	r24, r24
    337c:	39 f4       	brne	.+14     	; 0x338c <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    337e:	8e 81       	ldd	r24, Y+6	; 0x06
    3380:	9f 81       	ldd	r25, Y+7	; 0x07
    3382:	ee 81       	ldd	r30, Y+6	; 0x06
    3384:	ff 81       	ldd	r31, Y+7	; 0x07
    3386:	91 83       	std	Z+1, r25	; 0x01
    3388:	80 83       	st	Z, r24
    338a:	06 c0       	rjmp	.+12     	; 0x3398 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    338c:	8b 81       	ldd	r24, Y+3	; 0x03
    338e:	9c 81       	ldd	r25, Y+4	; 0x04
    3390:	ee 81       	ldd	r30, Y+6	; 0x06
    3392:	ff 81       	ldd	r31, Y+7	; 0x07
    3394:	91 83       	std	Z+1, r25	; 0x01
    3396:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    3398:	ee 81       	ldd	r30, Y+6	; 0x06
    339a:	ff 81       	ldd	r31, Y+7	; 0x07
    339c:	89 81       	ldd	r24, Y+1	; 0x01
    339e:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    33a0:	ee 81       	ldd	r30, Y+6	; 0x06
    33a2:	ff 81       	ldd	r31, Y+7	; 0x07
    33a4:	8a 81       	ldd	r24, Y+2	; 0x02
    33a6:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    33a8:	8e 81       	ldd	r24, Y+6	; 0x06
    33aa:	9f 81       	ldd	r25, Y+7	; 0x07
    33ac:	61 e0       	ldi	r22, 0x01	; 1
    33ae:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    33b2:	27 96       	adiw	r28, 0x07	; 7
    33b4:	0f b6       	in	r0, 0x3f	; 63
    33b6:	f8 94       	cli
    33b8:	de bf       	out	0x3e, r29	; 62
    33ba:	0f be       	out	0x3f, r0	; 63
    33bc:	cd bf       	out	0x3d, r28	; 61
    33be:	cf 91       	pop	r28
    33c0:	df 91       	pop	r29
    33c2:	1f 91       	pop	r17
    33c4:	0f 91       	pop	r16
    33c6:	08 95       	ret

000033c8 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    33c8:	df 93       	push	r29
    33ca:	cf 93       	push	r28
    33cc:	00 d0       	rcall	.+0      	; 0x33ce <xQueueCreateCountingSemaphore+0x6>
    33ce:	00 d0       	rcall	.+0      	; 0x33d0 <xQueueCreateCountingSemaphore+0x8>
    33d0:	cd b7       	in	r28, 0x3d	; 61
    33d2:	de b7       	in	r29, 0x3e	; 62
    33d4:	8b 83       	std	Y+3, r24	; 0x03
    33d6:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    33d8:	8b 81       	ldd	r24, Y+3	; 0x03
    33da:	60 e0       	ldi	r22, 0x00	; 0
    33dc:	42 e0       	ldi	r20, 0x02	; 2
    33de:	0e 94 58 19 	call	0x32b0	; 0x32b0 <xQueueGenericCreate>
    33e2:	9a 83       	std	Y+2, r25	; 0x02
    33e4:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    33e6:	89 81       	ldd	r24, Y+1	; 0x01
    33e8:	9a 81       	ldd	r25, Y+2	; 0x02
    33ea:	00 97       	sbiw	r24, 0x00	; 0
    33ec:	21 f0       	breq	.+8      	; 0x33f6 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    33ee:	e9 81       	ldd	r30, Y+1	; 0x01
    33f0:	fa 81       	ldd	r31, Y+2	; 0x02
    33f2:	8c 81       	ldd	r24, Y+4	; 0x04
    33f4:	82 8f       	std	Z+26, r24	; 0x1a
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
    33f6:	89 81       	ldd	r24, Y+1	; 0x01
    33f8:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    33fa:	0f 90       	pop	r0
    33fc:	0f 90       	pop	r0
    33fe:	0f 90       	pop	r0
    3400:	0f 90       	pop	r0
    3402:	cf 91       	pop	r28
    3404:	df 91       	pop	r29
    3406:	08 95       	ret

00003408 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    3408:	df 93       	push	r29
    340a:	cf 93       	push	r28
    340c:	cd b7       	in	r28, 0x3d	; 61
    340e:	de b7       	in	r29, 0x3e	; 62
    3410:	2f 97       	sbiw	r28, 0x0f	; 15
    3412:	0f b6       	in	r0, 0x3f	; 63
    3414:	f8 94       	cli
    3416:	de bf       	out	0x3e, r29	; 62
    3418:	0f be       	out	0x3f, r0	; 63
    341a:	cd bf       	out	0x3d, r28	; 61
    341c:	99 87       	std	Y+9, r25	; 0x09
    341e:	88 87       	std	Y+8, r24	; 0x08
    3420:	7b 87       	std	Y+11, r23	; 0x0b
    3422:	6a 87       	std	Y+10, r22	; 0x0a
    3424:	5d 87       	std	Y+13, r21	; 0x0d
    3426:	4c 87       	std	Y+12, r20	; 0x0c
    3428:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    342a:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    342c:	88 85       	ldd	r24, Y+8	; 0x08
    342e:	99 85       	ldd	r25, Y+9	; 0x09
    3430:	9a 83       	std	Y+2, r25	; 0x02
    3432:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3434:	0f b6       	in	r0, 0x3f	; 63
    3436:	f8 94       	cli
    3438:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    343a:	e9 81       	ldd	r30, Y+1	; 0x01
    343c:	fa 81       	ldd	r31, Y+2	; 0x02
    343e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3440:	e9 81       	ldd	r30, Y+1	; 0x01
    3442:	fa 81       	ldd	r31, Y+2	; 0x02
    3444:	83 8d       	ldd	r24, Z+27	; 0x1b
    3446:	98 17       	cp	r25, r24
    3448:	18 f0       	brcs	.+6      	; 0x3450 <xQueueGenericSend+0x48>
    344a:	8e 85       	ldd	r24, Y+14	; 0x0e
    344c:	82 30       	cpi	r24, 0x02	; 2
    344e:	11 f5       	brne	.+68     	; 0x3494 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3450:	89 81       	ldd	r24, Y+1	; 0x01
    3452:	9a 81       	ldd	r25, Y+2	; 0x02
    3454:	2a 85       	ldd	r18, Y+10	; 0x0a
    3456:	3b 85       	ldd	r19, Y+11	; 0x0b
    3458:	b9 01       	movw	r22, r18
    345a:	4e 85       	ldd	r20, Y+14	; 0x0e
    345c:	0e 94 56 1e 	call	0x3cac	; 0x3cac <prvCopyDataToQueue>
    3460:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3462:	e9 81       	ldd	r30, Y+1	; 0x01
    3464:	fa 81       	ldd	r31, Y+2	; 0x02
    3466:	81 89       	ldd	r24, Z+17	; 0x11
    3468:	88 23       	and	r24, r24
    346a:	51 f0       	breq	.+20     	; 0x3480 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    346c:	89 81       	ldd	r24, Y+1	; 0x01
    346e:	9a 81       	ldd	r25, Y+2	; 0x02
    3470:	41 96       	adiw	r24, 0x11	; 17
    3472:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <xTaskRemoveFromEventList>
    3476:	88 23       	and	r24, r24
    3478:	41 f0       	breq	.+16     	; 0x348a <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    347a:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
    347e:	05 c0       	rjmp	.+10     	; 0x348a <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    3480:	8b 81       	ldd	r24, Y+3	; 0x03
    3482:	88 23       	and	r24, r24
    3484:	11 f0       	breq	.+4      	; 0x348a <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    3486:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    348a:	0f 90       	pop	r0
    348c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    348e:	81 e0       	ldi	r24, 0x01	; 1
    3490:	8f 87       	std	Y+15, r24	; 0x0f
    3492:	5c c0       	rjmp	.+184    	; 0x354c <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3494:	8c 85       	ldd	r24, Y+12	; 0x0c
    3496:	9d 85       	ldd	r25, Y+13	; 0x0d
    3498:	00 97       	sbiw	r24, 0x00	; 0
    349a:	21 f4       	brne	.+8      	; 0x34a4 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    349c:	0f 90       	pop	r0
    349e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    34a0:	1f 86       	std	Y+15, r1	; 0x0f
    34a2:	54 c0       	rjmp	.+168    	; 0x354c <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    34a4:	8c 81       	ldd	r24, Y+4	; 0x04
    34a6:	88 23       	and	r24, r24
    34a8:	31 f4       	brne	.+12     	; 0x34b6 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    34aa:	ce 01       	movw	r24, r28
    34ac:	05 96       	adiw	r24, 0x05	; 5
    34ae:	0e 94 8b 2f 	call	0x5f16	; 0x5f16 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    34b2:	81 e0       	ldi	r24, 0x01	; 1
    34b4:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    34b6:	0f 90       	pop	r0
    34b8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    34ba:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    34be:	0f b6       	in	r0, 0x3f	; 63
    34c0:	f8 94       	cli
    34c2:	0f 92       	push	r0
    34c4:	e9 81       	ldd	r30, Y+1	; 0x01
    34c6:	fa 81       	ldd	r31, Y+2	; 0x02
    34c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    34ca:	8f 3f       	cpi	r24, 0xFF	; 255
    34cc:	19 f4       	brne	.+6      	; 0x34d4 <xQueueGenericSend+0xcc>
    34ce:	e9 81       	ldd	r30, Y+1	; 0x01
    34d0:	fa 81       	ldd	r31, Y+2	; 0x02
    34d2:	15 8e       	std	Z+29, r1	; 0x1d
    34d4:	e9 81       	ldd	r30, Y+1	; 0x01
    34d6:	fa 81       	ldd	r31, Y+2	; 0x02
    34d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    34da:	8f 3f       	cpi	r24, 0xFF	; 255
    34dc:	19 f4       	brne	.+6      	; 0x34e4 <xQueueGenericSend+0xdc>
    34de:	e9 81       	ldd	r30, Y+1	; 0x01
    34e0:	fa 81       	ldd	r31, Y+2	; 0x02
    34e2:	16 8e       	std	Z+30, r1	; 0x1e
    34e4:	0f 90       	pop	r0
    34e6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    34e8:	ce 01       	movw	r24, r28
    34ea:	05 96       	adiw	r24, 0x05	; 5
    34ec:	9e 01       	movw	r18, r28
    34ee:	24 5f       	subi	r18, 0xF4	; 244
    34f0:	3f 4f       	sbci	r19, 0xFF	; 255
    34f2:	b9 01       	movw	r22, r18
    34f4:	0e 94 a4 2f 	call	0x5f48	; 0x5f48 <xTaskCheckForTimeOut>
    34f8:	88 23       	and	r24, r24
    34fa:	09 f5       	brne	.+66     	; 0x353e <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    34fc:	89 81       	ldd	r24, Y+1	; 0x01
    34fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3500:	0e 94 d2 1f 	call	0x3fa4	; 0x3fa4 <prvIsQueueFull>
    3504:	88 23       	and	r24, r24
    3506:	a1 f0       	breq	.+40     	; 0x3530 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3508:	89 81       	ldd	r24, Y+1	; 0x01
    350a:	9a 81       	ldd	r25, Y+2	; 0x02
    350c:	08 96       	adiw	r24, 0x08	; 8
    350e:	2c 85       	ldd	r18, Y+12	; 0x0c
    3510:	3d 85       	ldd	r19, Y+13	; 0x0d
    3512:	b9 01       	movw	r22, r18
    3514:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3518:	89 81       	ldd	r24, Y+1	; 0x01
    351a:	9a 81       	ldd	r25, Y+2	; 0x02
    351c:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3520:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    3524:	88 23       	and	r24, r24
    3526:	09 f0       	breq	.+2      	; 0x352a <xQueueGenericSend+0x122>
    3528:	85 cf       	rjmp	.-246    	; 0x3434 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    352a:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
    352e:	82 cf       	rjmp	.-252    	; 0x3434 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3530:	89 81       	ldd	r24, Y+1	; 0x01
    3532:	9a 81       	ldd	r25, Y+2	; 0x02
    3534:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3538:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    353c:	7b cf       	rjmp	.-266    	; 0x3434 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    353e:	89 81       	ldd	r24, Y+1	; 0x01
    3540:	9a 81       	ldd	r25, Y+2	; 0x02
    3542:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3546:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    354a:	1f 86       	std	Y+15, r1	; 0x0f
    354c:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    354e:	2f 96       	adiw	r28, 0x0f	; 15
    3550:	0f b6       	in	r0, 0x3f	; 63
    3552:	f8 94       	cli
    3554:	de bf       	out	0x3e, r29	; 62
    3556:	0f be       	out	0x3f, r0	; 63
    3558:	cd bf       	out	0x3d, r28	; 61
    355a:	cf 91       	pop	r28
    355c:	df 91       	pop	r29
    355e:	08 95       	ret

00003560 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    3560:	df 93       	push	r29
    3562:	cf 93       	push	r28
    3564:	cd b7       	in	r28, 0x3d	; 61
    3566:	de b7       	in	r29, 0x3e	; 62
    3568:	2c 97       	sbiw	r28, 0x0c	; 12
    356a:	0f b6       	in	r0, 0x3f	; 63
    356c:	f8 94       	cli
    356e:	de bf       	out	0x3e, r29	; 62
    3570:	0f be       	out	0x3f, r0	; 63
    3572:	cd bf       	out	0x3d, r28	; 61
    3574:	9f 83       	std	Y+7, r25	; 0x07
    3576:	8e 83       	std	Y+6, r24	; 0x06
    3578:	79 87       	std	Y+9, r23	; 0x09
    357a:	68 87       	std	Y+8, r22	; 0x08
    357c:	5b 87       	std	Y+11, r21	; 0x0b
    357e:	4a 87       	std	Y+10, r20	; 0x0a
    3580:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3582:	8e 81       	ldd	r24, Y+6	; 0x06
    3584:	9f 81       	ldd	r25, Y+7	; 0x07
    3586:	9b 83       	std	Y+3, r25	; 0x03
    3588:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    358a:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    358c:	ea 81       	ldd	r30, Y+2	; 0x02
    358e:	fb 81       	ldd	r31, Y+3	; 0x03
    3590:	92 8d       	ldd	r25, Z+26	; 0x1a
    3592:	ea 81       	ldd	r30, Y+2	; 0x02
    3594:	fb 81       	ldd	r31, Y+3	; 0x03
    3596:	83 8d       	ldd	r24, Z+27	; 0x1b
    3598:	98 17       	cp	r25, r24
    359a:	18 f0       	brcs	.+6      	; 0x35a2 <xQueueGenericSendFromISR+0x42>
    359c:	8c 85       	ldd	r24, Y+12	; 0x0c
    359e:	82 30       	cpi	r24, 0x02	; 2
    35a0:	61 f5       	brne	.+88     	; 0x35fa <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    35a2:	ea 81       	ldd	r30, Y+2	; 0x02
    35a4:	fb 81       	ldd	r31, Y+3	; 0x03
    35a6:	86 8d       	ldd	r24, Z+30	; 0x1e
    35a8:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    35aa:	8a 81       	ldd	r24, Y+2	; 0x02
    35ac:	9b 81       	ldd	r25, Y+3	; 0x03
    35ae:	28 85       	ldd	r18, Y+8	; 0x08
    35b0:	39 85       	ldd	r19, Y+9	; 0x09
    35b2:	b9 01       	movw	r22, r18
    35b4:	4c 85       	ldd	r20, Y+12	; 0x0c
    35b6:	0e 94 56 1e 	call	0x3cac	; 0x3cac <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    35ba:	89 81       	ldd	r24, Y+1	; 0x01
    35bc:	8f 3f       	cpi	r24, 0xFF	; 255
    35be:	a9 f4       	brne	.+42     	; 0x35ea <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    35c0:	ea 81       	ldd	r30, Y+2	; 0x02
    35c2:	fb 81       	ldd	r31, Y+3	; 0x03
    35c4:	81 89       	ldd	r24, Z+17	; 0x11
    35c6:	88 23       	and	r24, r24
    35c8:	a9 f0       	breq	.+42     	; 0x35f4 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    35ca:	8a 81       	ldd	r24, Y+2	; 0x02
    35cc:	9b 81       	ldd	r25, Y+3	; 0x03
    35ce:	41 96       	adiw	r24, 0x11	; 17
    35d0:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <xTaskRemoveFromEventList>
    35d4:	88 23       	and	r24, r24
    35d6:	71 f0       	breq	.+28     	; 0x35f4 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    35d8:	8a 85       	ldd	r24, Y+10	; 0x0a
    35da:	9b 85       	ldd	r25, Y+11	; 0x0b
    35dc:	00 97       	sbiw	r24, 0x00	; 0
    35de:	51 f0       	breq	.+20     	; 0x35f4 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    35e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    35e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    35e4:	81 e0       	ldi	r24, 0x01	; 1
    35e6:	80 83       	st	Z, r24
    35e8:	05 c0       	rjmp	.+10     	; 0x35f4 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    35ea:	89 81       	ldd	r24, Y+1	; 0x01
    35ec:	8f 5f       	subi	r24, 0xFF	; 255
    35ee:	ea 81       	ldd	r30, Y+2	; 0x02
    35f0:	fb 81       	ldd	r31, Y+3	; 0x03
    35f2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    35f4:	81 e0       	ldi	r24, 0x01	; 1
    35f6:	8d 83       	std	Y+5, r24	; 0x05
    35f8:	01 c0       	rjmp	.+2      	; 0x35fc <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    35fa:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    35fc:	8d 81       	ldd	r24, Y+5	; 0x05
}
    35fe:	2c 96       	adiw	r28, 0x0c	; 12
    3600:	0f b6       	in	r0, 0x3f	; 63
    3602:	f8 94       	cli
    3604:	de bf       	out	0x3e, r29	; 62
    3606:	0f be       	out	0x3f, r0	; 63
    3608:	cd bf       	out	0x3d, r28	; 61
    360a:	cf 91       	pop	r28
    360c:	df 91       	pop	r29
    360e:	08 95       	ret

00003610 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3610:	df 93       	push	r29
    3612:	cf 93       	push	r28
    3614:	cd b7       	in	r28, 0x3d	; 61
    3616:	de b7       	in	r29, 0x3e	; 62
    3618:	2a 97       	sbiw	r28, 0x0a	; 10
    361a:	0f b6       	in	r0, 0x3f	; 63
    361c:	f8 94       	cli
    361e:	de bf       	out	0x3e, r29	; 62
    3620:	0f be       	out	0x3f, r0	; 63
    3622:	cd bf       	out	0x3d, r28	; 61
    3624:	98 87       	std	Y+8, r25	; 0x08
    3626:	8f 83       	std	Y+7, r24	; 0x07
    3628:	7a 87       	std	Y+10, r23	; 0x0a
    362a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    362c:	8f 81       	ldd	r24, Y+7	; 0x07
    362e:	98 85       	ldd	r25, Y+8	; 0x08
    3630:	9c 83       	std	Y+4, r25	; 0x04
    3632:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3634:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3636:	eb 81       	ldd	r30, Y+3	; 0x03
    3638:	fc 81       	ldd	r31, Y+4	; 0x04
    363a:	82 8d       	ldd	r24, Z+26	; 0x1a
    363c:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    363e:	eb 81       	ldd	r30, Y+3	; 0x03
    3640:	fc 81       	ldd	r31, Y+4	; 0x04
    3642:	93 8d       	ldd	r25, Z+27	; 0x1b
    3644:	8a 81       	ldd	r24, Y+2	; 0x02
    3646:	89 17       	cp	r24, r25
    3648:	48 f5       	brcc	.+82     	; 0x369c <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    364a:	eb 81       	ldd	r30, Y+3	; 0x03
    364c:	fc 81       	ldd	r31, Y+4	; 0x04
    364e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3650:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3652:	8a 81       	ldd	r24, Y+2	; 0x02
    3654:	8f 5f       	subi	r24, 0xFF	; 255
    3656:	eb 81       	ldd	r30, Y+3	; 0x03
    3658:	fc 81       	ldd	r31, Y+4	; 0x04
    365a:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    365c:	89 81       	ldd	r24, Y+1	; 0x01
    365e:	8f 3f       	cpi	r24, 0xFF	; 255
    3660:	a9 f4       	brne	.+42     	; 0x368c <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3662:	eb 81       	ldd	r30, Y+3	; 0x03
    3664:	fc 81       	ldd	r31, Y+4	; 0x04
    3666:	81 89       	ldd	r24, Z+17	; 0x11
    3668:	88 23       	and	r24, r24
    366a:	a9 f0       	breq	.+42     	; 0x3696 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    366c:	8b 81       	ldd	r24, Y+3	; 0x03
    366e:	9c 81       	ldd	r25, Y+4	; 0x04
    3670:	41 96       	adiw	r24, 0x11	; 17
    3672:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <xTaskRemoveFromEventList>
    3676:	88 23       	and	r24, r24
    3678:	71 f0       	breq	.+28     	; 0x3696 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    367a:	89 85       	ldd	r24, Y+9	; 0x09
    367c:	9a 85       	ldd	r25, Y+10	; 0x0a
    367e:	00 97       	sbiw	r24, 0x00	; 0
    3680:	51 f0       	breq	.+20     	; 0x3696 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3682:	e9 85       	ldd	r30, Y+9	; 0x09
    3684:	fa 85       	ldd	r31, Y+10	; 0x0a
    3686:	81 e0       	ldi	r24, 0x01	; 1
    3688:	80 83       	st	Z, r24
    368a:	05 c0       	rjmp	.+10     	; 0x3696 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    368c:	89 81       	ldd	r24, Y+1	; 0x01
    368e:	8f 5f       	subi	r24, 0xFF	; 255
    3690:	eb 81       	ldd	r30, Y+3	; 0x03
    3692:	fc 81       	ldd	r31, Y+4	; 0x04
    3694:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3696:	81 e0       	ldi	r24, 0x01	; 1
    3698:	8e 83       	std	Y+6, r24	; 0x06
    369a:	01 c0       	rjmp	.+2      	; 0x369e <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    369c:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    369e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    36a0:	2a 96       	adiw	r28, 0x0a	; 10
    36a2:	0f b6       	in	r0, 0x3f	; 63
    36a4:	f8 94       	cli
    36a6:	de bf       	out	0x3e, r29	; 62
    36a8:	0f be       	out	0x3f, r0	; 63
    36aa:	cd bf       	out	0x3d, r28	; 61
    36ac:	cf 91       	pop	r28
    36ae:	df 91       	pop	r29
    36b0:	08 95       	ret

000036b2 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    36b2:	df 93       	push	r29
    36b4:	cf 93       	push	r28
    36b6:	cd b7       	in	r28, 0x3d	; 61
    36b8:	de b7       	in	r29, 0x3e	; 62
    36ba:	2e 97       	sbiw	r28, 0x0e	; 14
    36bc:	0f b6       	in	r0, 0x3f	; 63
    36be:	f8 94       	cli
    36c0:	de bf       	out	0x3e, r29	; 62
    36c2:	0f be       	out	0x3f, r0	; 63
    36c4:	cd bf       	out	0x3d, r28	; 61
    36c6:	99 87       	std	Y+9, r25	; 0x09
    36c8:	88 87       	std	Y+8, r24	; 0x08
    36ca:	7b 87       	std	Y+11, r23	; 0x0b
    36cc:	6a 87       	std	Y+10, r22	; 0x0a
    36ce:	5d 87       	std	Y+13, r21	; 0x0d
    36d0:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    36d2:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    36d4:	88 85       	ldd	r24, Y+8	; 0x08
    36d6:	99 85       	ldd	r25, Y+9	; 0x09
    36d8:	9b 83       	std	Y+3, r25	; 0x03
    36da:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    36dc:	0f b6       	in	r0, 0x3f	; 63
    36de:	f8 94       	cli
    36e0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    36e2:	ea 81       	ldd	r30, Y+2	; 0x02
    36e4:	fb 81       	ldd	r31, Y+3	; 0x03
    36e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    36e8:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    36ea:	89 81       	ldd	r24, Y+1	; 0x01
    36ec:	88 23       	and	r24, r24
    36ee:	f9 f0       	breq	.+62     	; 0x372e <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    36f0:	8a 81       	ldd	r24, Y+2	; 0x02
    36f2:	9b 81       	ldd	r25, Y+3	; 0x03
    36f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    36f6:	3b 85       	ldd	r19, Y+11	; 0x0b
    36f8:	b9 01       	movw	r22, r18
    36fa:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    36fe:	89 81       	ldd	r24, Y+1	; 0x01
    3700:	81 50       	subi	r24, 0x01	; 1
    3702:	ea 81       	ldd	r30, Y+2	; 0x02
    3704:	fb 81       	ldd	r31, Y+3	; 0x03
    3706:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3708:	ea 81       	ldd	r30, Y+2	; 0x02
    370a:	fb 81       	ldd	r31, Y+3	; 0x03
    370c:	80 85       	ldd	r24, Z+8	; 0x08
    370e:	88 23       	and	r24, r24
    3710:	49 f0       	breq	.+18     	; 0x3724 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3712:	8a 81       	ldd	r24, Y+2	; 0x02
    3714:	9b 81       	ldd	r25, Y+3	; 0x03
    3716:	08 96       	adiw	r24, 0x08	; 8
    3718:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <xTaskRemoveFromEventList>
    371c:	88 23       	and	r24, r24
    371e:	11 f0       	breq	.+4      	; 0x3724 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    3720:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3724:	0f 90       	pop	r0
    3726:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3728:	81 e0       	ldi	r24, 0x01	; 1
    372a:	8e 87       	std	Y+14, r24	; 0x0e
    372c:	63 c0       	rjmp	.+198    	; 0x37f4 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    372e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3730:	9d 85       	ldd	r25, Y+13	; 0x0d
    3732:	00 97       	sbiw	r24, 0x00	; 0
    3734:	21 f4       	brne	.+8      	; 0x373e <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3736:	0f 90       	pop	r0
    3738:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    373a:	1e 86       	std	Y+14, r1	; 0x0e
    373c:	5b c0       	rjmp	.+182    	; 0x37f4 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    373e:	8c 81       	ldd	r24, Y+4	; 0x04
    3740:	88 23       	and	r24, r24
    3742:	31 f4       	brne	.+12     	; 0x3750 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3744:	ce 01       	movw	r24, r28
    3746:	05 96       	adiw	r24, 0x05	; 5
    3748:	0e 94 8b 2f 	call	0x5f16	; 0x5f16 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    374c:	81 e0       	ldi	r24, 0x01	; 1
    374e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3750:	0f 90       	pop	r0
    3752:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3754:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3758:	0f b6       	in	r0, 0x3f	; 63
    375a:	f8 94       	cli
    375c:	0f 92       	push	r0
    375e:	ea 81       	ldd	r30, Y+2	; 0x02
    3760:	fb 81       	ldd	r31, Y+3	; 0x03
    3762:	85 8d       	ldd	r24, Z+29	; 0x1d
    3764:	8f 3f       	cpi	r24, 0xFF	; 255
    3766:	19 f4       	brne	.+6      	; 0x376e <xQueueReceive+0xbc>
    3768:	ea 81       	ldd	r30, Y+2	; 0x02
    376a:	fb 81       	ldd	r31, Y+3	; 0x03
    376c:	15 8e       	std	Z+29, r1	; 0x1d
    376e:	ea 81       	ldd	r30, Y+2	; 0x02
    3770:	fb 81       	ldd	r31, Y+3	; 0x03
    3772:	86 8d       	ldd	r24, Z+30	; 0x1e
    3774:	8f 3f       	cpi	r24, 0xFF	; 255
    3776:	19 f4       	brne	.+6      	; 0x377e <xQueueReceive+0xcc>
    3778:	ea 81       	ldd	r30, Y+2	; 0x02
    377a:	fb 81       	ldd	r31, Y+3	; 0x03
    377c:	16 8e       	std	Z+30, r1	; 0x1e
    377e:	0f 90       	pop	r0
    3780:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3782:	ce 01       	movw	r24, r28
    3784:	05 96       	adiw	r24, 0x05	; 5
    3786:	9e 01       	movw	r18, r28
    3788:	24 5f       	subi	r18, 0xF4	; 244
    378a:	3f 4f       	sbci	r19, 0xFF	; 255
    378c:	b9 01       	movw	r22, r18
    378e:	0e 94 a4 2f 	call	0x5f48	; 0x5f48 <xTaskCheckForTimeOut>
    3792:	88 23       	and	r24, r24
    3794:	09 f5       	brne	.+66     	; 0x37d8 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3796:	8a 81       	ldd	r24, Y+2	; 0x02
    3798:	9b 81       	ldd	r25, Y+3	; 0x03
    379a:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <prvIsQueueEmpty>
    379e:	88 23       	and	r24, r24
    37a0:	a1 f0       	breq	.+40     	; 0x37ca <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    37a2:	8a 81       	ldd	r24, Y+2	; 0x02
    37a4:	9b 81       	ldd	r25, Y+3	; 0x03
    37a6:	41 96       	adiw	r24, 0x11	; 17
    37a8:	2c 85       	ldd	r18, Y+12	; 0x0c
    37aa:	3d 85       	ldd	r19, Y+13	; 0x0d
    37ac:	b9 01       	movw	r22, r18
    37ae:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    37b2:	8a 81       	ldd	r24, Y+2	; 0x02
    37b4:	9b 81       	ldd	r25, Y+3	; 0x03
    37b6:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    37ba:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    37be:	88 23       	and	r24, r24
    37c0:	09 f0       	breq	.+2      	; 0x37c4 <xQueueReceive+0x112>
    37c2:	8c cf       	rjmp	.-232    	; 0x36dc <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    37c4:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
    37c8:	89 cf       	rjmp	.-238    	; 0x36dc <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    37ca:	8a 81       	ldd	r24, Y+2	; 0x02
    37cc:	9b 81       	ldd	r25, Y+3	; 0x03
    37ce:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    37d2:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    37d6:	82 cf       	rjmp	.-252    	; 0x36dc <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    37d8:	8a 81       	ldd	r24, Y+2	; 0x02
    37da:	9b 81       	ldd	r25, Y+3	; 0x03
    37dc:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    37e0:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    37e4:	8a 81       	ldd	r24, Y+2	; 0x02
    37e6:	9b 81       	ldd	r25, Y+3	; 0x03
    37e8:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <prvIsQueueEmpty>
    37ec:	88 23       	and	r24, r24
    37ee:	09 f4       	brne	.+2      	; 0x37f2 <xQueueReceive+0x140>
    37f0:	75 cf       	rjmp	.-278    	; 0x36dc <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    37f2:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    37f4:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    37f6:	2e 96       	adiw	r28, 0x0e	; 14
    37f8:	0f b6       	in	r0, 0x3f	; 63
    37fa:	f8 94       	cli
    37fc:	de bf       	out	0x3e, r29	; 62
    37fe:	0f be       	out	0x3f, r0	; 63
    3800:	cd bf       	out	0x3d, r28	; 61
    3802:	cf 91       	pop	r28
    3804:	df 91       	pop	r29
    3806:	08 95       	ret

00003808 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    3808:	df 93       	push	r29
    380a:	cf 93       	push	r28
    380c:	cd b7       	in	r28, 0x3d	; 61
    380e:	de b7       	in	r29, 0x3e	; 62
    3810:	2c 97       	sbiw	r28, 0x0c	; 12
    3812:	0f b6       	in	r0, 0x3f	; 63
    3814:	f8 94       	cli
    3816:	de bf       	out	0x3e, r29	; 62
    3818:	0f be       	out	0x3f, r0	; 63
    381a:	cd bf       	out	0x3d, r28	; 61
    381c:	99 87       	std	Y+9, r25	; 0x09
    381e:	88 87       	std	Y+8, r24	; 0x08
    3820:	7b 87       	std	Y+11, r23	; 0x0b
    3822:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    3824:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3826:	88 85       	ldd	r24, Y+8	; 0x08
    3828:	99 85       	ldd	r25, Y+9	; 0x09
    382a:	9b 83       	std	Y+3, r25	; 0x03
    382c:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    382e:	0f b6       	in	r0, 0x3f	; 63
    3830:	f8 94       	cli
    3832:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3834:	ea 81       	ldd	r30, Y+2	; 0x02
    3836:	fb 81       	ldd	r31, Y+3	; 0x03
    3838:	82 8d       	ldd	r24, Z+26	; 0x1a
    383a:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    383c:	89 81       	ldd	r24, Y+1	; 0x01
    383e:	88 23       	and	r24, r24
    3840:	c1 f0       	breq	.+48     	; 0x3872 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3842:	89 81       	ldd	r24, Y+1	; 0x01
    3844:	81 50       	subi	r24, 0x01	; 1
    3846:	ea 81       	ldd	r30, Y+2	; 0x02
    3848:	fb 81       	ldd	r31, Y+3	; 0x03
    384a:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    384c:	ea 81       	ldd	r30, Y+2	; 0x02
    384e:	fb 81       	ldd	r31, Y+3	; 0x03
    3850:	80 85       	ldd	r24, Z+8	; 0x08
    3852:	88 23       	and	r24, r24
    3854:	49 f0       	breq	.+18     	; 0x3868 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3856:	8a 81       	ldd	r24, Y+2	; 0x02
    3858:	9b 81       	ldd	r25, Y+3	; 0x03
    385a:	08 96       	adiw	r24, 0x08	; 8
    385c:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <xTaskRemoveFromEventList>
    3860:	88 23       	and	r24, r24
    3862:	11 f0       	breq	.+4      	; 0x3868 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    3864:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3868:	0f 90       	pop	r0
    386a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    386c:	81 e0       	ldi	r24, 0x01	; 1
    386e:	8c 87       	std	Y+12, r24	; 0x0c
    3870:	63 c0       	rjmp	.+198    	; 0x3938 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3872:	8a 85       	ldd	r24, Y+10	; 0x0a
    3874:	9b 85       	ldd	r25, Y+11	; 0x0b
    3876:	00 97       	sbiw	r24, 0x00	; 0
    3878:	21 f4       	brne	.+8      	; 0x3882 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    387a:	0f 90       	pop	r0
    387c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    387e:	1c 86       	std	Y+12, r1	; 0x0c
    3880:	5b c0       	rjmp	.+182    	; 0x3938 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    3882:	8c 81       	ldd	r24, Y+4	; 0x04
    3884:	88 23       	and	r24, r24
    3886:	31 f4       	brne	.+12     	; 0x3894 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3888:	ce 01       	movw	r24, r28
    388a:	05 96       	adiw	r24, 0x05	; 5
    388c:	0e 94 8b 2f 	call	0x5f16	; 0x5f16 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3890:	81 e0       	ldi	r24, 0x01	; 1
    3892:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3894:	0f 90       	pop	r0
    3896:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    3898:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    389c:	0f b6       	in	r0, 0x3f	; 63
    389e:	f8 94       	cli
    38a0:	0f 92       	push	r0
    38a2:	ea 81       	ldd	r30, Y+2	; 0x02
    38a4:	fb 81       	ldd	r31, Y+3	; 0x03
    38a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    38a8:	8f 3f       	cpi	r24, 0xFF	; 255
    38aa:	19 f4       	brne	.+6      	; 0x38b2 <xQueueSemaphoreTake+0xaa>
    38ac:	ea 81       	ldd	r30, Y+2	; 0x02
    38ae:	fb 81       	ldd	r31, Y+3	; 0x03
    38b0:	15 8e       	std	Z+29, r1	; 0x1d
    38b2:	ea 81       	ldd	r30, Y+2	; 0x02
    38b4:	fb 81       	ldd	r31, Y+3	; 0x03
    38b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    38b8:	8f 3f       	cpi	r24, 0xFF	; 255
    38ba:	19 f4       	brne	.+6      	; 0x38c2 <xQueueSemaphoreTake+0xba>
    38bc:	ea 81       	ldd	r30, Y+2	; 0x02
    38be:	fb 81       	ldd	r31, Y+3	; 0x03
    38c0:	16 8e       	std	Z+30, r1	; 0x1e
    38c2:	0f 90       	pop	r0
    38c4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    38c6:	ce 01       	movw	r24, r28
    38c8:	05 96       	adiw	r24, 0x05	; 5
    38ca:	9e 01       	movw	r18, r28
    38cc:	26 5f       	subi	r18, 0xF6	; 246
    38ce:	3f 4f       	sbci	r19, 0xFF	; 255
    38d0:	b9 01       	movw	r22, r18
    38d2:	0e 94 a4 2f 	call	0x5f48	; 0x5f48 <xTaskCheckForTimeOut>
    38d6:	88 23       	and	r24, r24
    38d8:	09 f5       	brne	.+66     	; 0x391c <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    38da:	8a 81       	ldd	r24, Y+2	; 0x02
    38dc:	9b 81       	ldd	r25, Y+3	; 0x03
    38de:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <prvIsQueueEmpty>
    38e2:	88 23       	and	r24, r24
    38e4:	a1 f0       	breq	.+40     	; 0x390e <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    38e6:	8a 81       	ldd	r24, Y+2	; 0x02
    38e8:	9b 81       	ldd	r25, Y+3	; 0x03
    38ea:	41 96       	adiw	r24, 0x11	; 17
    38ec:	2a 85       	ldd	r18, Y+10	; 0x0a
    38ee:	3b 85       	ldd	r19, Y+11	; 0x0b
    38f0:	b9 01       	movw	r22, r18
    38f2:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    38f6:	8a 81       	ldd	r24, Y+2	; 0x02
    38f8:	9b 81       	ldd	r25, Y+3	; 0x03
    38fa:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    38fe:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    3902:	88 23       	and	r24, r24
    3904:	09 f0       	breq	.+2      	; 0x3908 <xQueueSemaphoreTake+0x100>
    3906:	93 cf       	rjmp	.-218    	; 0x382e <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    3908:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
    390c:	90 cf       	rjmp	.-224    	; 0x382e <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    390e:	8a 81       	ldd	r24, Y+2	; 0x02
    3910:	9b 81       	ldd	r25, Y+3	; 0x03
    3912:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3916:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    391a:	89 cf       	rjmp	.-238    	; 0x382e <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    391c:	8a 81       	ldd	r24, Y+2	; 0x02
    391e:	9b 81       	ldd	r25, Y+3	; 0x03
    3920:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3924:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3928:	8a 81       	ldd	r24, Y+2	; 0x02
    392a:	9b 81       	ldd	r25, Y+3	; 0x03
    392c:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <prvIsQueueEmpty>
    3930:	88 23       	and	r24, r24
    3932:	09 f4       	brne	.+2      	; 0x3936 <xQueueSemaphoreTake+0x12e>
    3934:	7c cf       	rjmp	.-264    	; 0x382e <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3936:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    3938:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    393a:	2c 96       	adiw	r28, 0x0c	; 12
    393c:	0f b6       	in	r0, 0x3f	; 63
    393e:	f8 94       	cli
    3940:	de bf       	out	0x3e, r29	; 62
    3942:	0f be       	out	0x3f, r0	; 63
    3944:	cd bf       	out	0x3d, r28	; 61
    3946:	cf 91       	pop	r28
    3948:	df 91       	pop	r29
    394a:	08 95       	ret

0000394c <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    394c:	df 93       	push	r29
    394e:	cf 93       	push	r28
    3950:	cd b7       	in	r28, 0x3d	; 61
    3952:	de b7       	in	r29, 0x3e	; 62
    3954:	60 97       	sbiw	r28, 0x10	; 16
    3956:	0f b6       	in	r0, 0x3f	; 63
    3958:	f8 94       	cli
    395a:	de bf       	out	0x3e, r29	; 62
    395c:	0f be       	out	0x3f, r0	; 63
    395e:	cd bf       	out	0x3d, r28	; 61
    3960:	9b 87       	std	Y+11, r25	; 0x0b
    3962:	8a 87       	std	Y+10, r24	; 0x0a
    3964:	7d 87       	std	Y+13, r23	; 0x0d
    3966:	6c 87       	std	Y+12, r22	; 0x0c
    3968:	5f 87       	std	Y+15, r21	; 0x0f
    396a:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    396c:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    396e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3970:	9b 85       	ldd	r25, Y+11	; 0x0b
    3972:	9b 83       	std	Y+3, r25	; 0x03
    3974:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3976:	0f b6       	in	r0, 0x3f	; 63
    3978:	f8 94       	cli
    397a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    397c:	ea 81       	ldd	r30, Y+2	; 0x02
    397e:	fb 81       	ldd	r31, Y+3	; 0x03
    3980:	82 8d       	ldd	r24, Z+26	; 0x1a
    3982:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3984:	89 81       	ldd	r24, Y+1	; 0x01
    3986:	88 23       	and	r24, r24
    3988:	31 f1       	breq	.+76     	; 0x39d6 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    398a:	ea 81       	ldd	r30, Y+2	; 0x02
    398c:	fb 81       	ldd	r31, Y+3	; 0x03
    398e:	86 81       	ldd	r24, Z+6	; 0x06
    3990:	97 81       	ldd	r25, Z+7	; 0x07
    3992:	9d 83       	std	Y+5, r25	; 0x05
    3994:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3996:	8a 81       	ldd	r24, Y+2	; 0x02
    3998:	9b 81       	ldd	r25, Y+3	; 0x03
    399a:	2c 85       	ldd	r18, Y+12	; 0x0c
    399c:	3d 85       	ldd	r19, Y+13	; 0x0d
    399e:	b9 01       	movw	r22, r18
    39a0:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    39a4:	ea 81       	ldd	r30, Y+2	; 0x02
    39a6:	fb 81       	ldd	r31, Y+3	; 0x03
    39a8:	8c 81       	ldd	r24, Y+4	; 0x04
    39aa:	9d 81       	ldd	r25, Y+5	; 0x05
    39ac:	97 83       	std	Z+7, r25	; 0x07
    39ae:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    39b0:	ea 81       	ldd	r30, Y+2	; 0x02
    39b2:	fb 81       	ldd	r31, Y+3	; 0x03
    39b4:	81 89       	ldd	r24, Z+17	; 0x11
    39b6:	88 23       	and	r24, r24
    39b8:	49 f0       	breq	.+18     	; 0x39cc <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    39ba:	8a 81       	ldd	r24, Y+2	; 0x02
    39bc:	9b 81       	ldd	r25, Y+3	; 0x03
    39be:	41 96       	adiw	r24, 0x11	; 17
    39c0:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <xTaskRemoveFromEventList>
    39c4:	88 23       	and	r24, r24
    39c6:	11 f0       	breq	.+4      	; 0x39cc <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    39c8:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    39cc:	0f 90       	pop	r0
    39ce:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    39d0:	81 e0       	ldi	r24, 0x01	; 1
    39d2:	88 8b       	std	Y+16, r24	; 0x10
    39d4:	63 c0       	rjmp	.+198    	; 0x3a9c <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    39d6:	8e 85       	ldd	r24, Y+14	; 0x0e
    39d8:	9f 85       	ldd	r25, Y+15	; 0x0f
    39da:	00 97       	sbiw	r24, 0x00	; 0
    39dc:	21 f4       	brne	.+8      	; 0x39e6 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    39de:	0f 90       	pop	r0
    39e0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    39e2:	18 8a       	std	Y+16, r1	; 0x10
    39e4:	5b c0       	rjmp	.+182    	; 0x3a9c <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    39e6:	8e 81       	ldd	r24, Y+6	; 0x06
    39e8:	88 23       	and	r24, r24
    39ea:	31 f4       	brne	.+12     	; 0x39f8 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    39ec:	ce 01       	movw	r24, r28
    39ee:	07 96       	adiw	r24, 0x07	; 7
    39f0:	0e 94 8b 2f 	call	0x5f16	; 0x5f16 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    39f4:	81 e0       	ldi	r24, 0x01	; 1
    39f6:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    39f8:	0f 90       	pop	r0
    39fa:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    39fc:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3a00:	0f b6       	in	r0, 0x3f	; 63
    3a02:	f8 94       	cli
    3a04:	0f 92       	push	r0
    3a06:	ea 81       	ldd	r30, Y+2	; 0x02
    3a08:	fb 81       	ldd	r31, Y+3	; 0x03
    3a0a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a0c:	8f 3f       	cpi	r24, 0xFF	; 255
    3a0e:	19 f4       	brne	.+6      	; 0x3a16 <xQueuePeek+0xca>
    3a10:	ea 81       	ldd	r30, Y+2	; 0x02
    3a12:	fb 81       	ldd	r31, Y+3	; 0x03
    3a14:	15 8e       	std	Z+29, r1	; 0x1d
    3a16:	ea 81       	ldd	r30, Y+2	; 0x02
    3a18:	fb 81       	ldd	r31, Y+3	; 0x03
    3a1a:	86 8d       	ldd	r24, Z+30	; 0x1e
    3a1c:	8f 3f       	cpi	r24, 0xFF	; 255
    3a1e:	19 f4       	brne	.+6      	; 0x3a26 <xQueuePeek+0xda>
    3a20:	ea 81       	ldd	r30, Y+2	; 0x02
    3a22:	fb 81       	ldd	r31, Y+3	; 0x03
    3a24:	16 8e       	std	Z+30, r1	; 0x1e
    3a26:	0f 90       	pop	r0
    3a28:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3a2a:	ce 01       	movw	r24, r28
    3a2c:	07 96       	adiw	r24, 0x07	; 7
    3a2e:	9e 01       	movw	r18, r28
    3a30:	22 5f       	subi	r18, 0xF2	; 242
    3a32:	3f 4f       	sbci	r19, 0xFF	; 255
    3a34:	b9 01       	movw	r22, r18
    3a36:	0e 94 a4 2f 	call	0x5f48	; 0x5f48 <xTaskCheckForTimeOut>
    3a3a:	88 23       	and	r24, r24
    3a3c:	09 f5       	brne	.+66     	; 0x3a80 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3a3e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a40:	9b 81       	ldd	r25, Y+3	; 0x03
    3a42:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <prvIsQueueEmpty>
    3a46:	88 23       	and	r24, r24
    3a48:	a1 f0       	breq	.+40     	; 0x3a72 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3a4a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a4c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a4e:	41 96       	adiw	r24, 0x11	; 17
    3a50:	2e 85       	ldd	r18, Y+14	; 0x0e
    3a52:	3f 85       	ldd	r19, Y+15	; 0x0f
    3a54:	b9 01       	movw	r22, r18
    3a56:	0e 94 53 2e 	call	0x5ca6	; 0x5ca6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a5e:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3a62:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    3a66:	88 23       	and	r24, r24
    3a68:	09 f0       	breq	.+2      	; 0x3a6c <xQueuePeek+0x120>
    3a6a:	85 cf       	rjmp	.-246    	; 0x3976 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    3a6c:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
    3a70:	82 cf       	rjmp	.-252    	; 0x3976 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    3a72:	8a 81       	ldd	r24, Y+2	; 0x02
    3a74:	9b 81       	ldd	r25, Y+3	; 0x03
    3a76:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3a7a:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    3a7e:	7b cf       	rjmp	.-266    	; 0x3976 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    3a80:	8a 81       	ldd	r24, Y+2	; 0x02
    3a82:	9b 81       	ldd	r25, Y+3	; 0x03
    3a84:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3a88:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3a8c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a8e:	9b 81       	ldd	r25, Y+3	; 0x03
    3a90:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <prvIsQueueEmpty>
    3a94:	88 23       	and	r24, r24
    3a96:	09 f4       	brne	.+2      	; 0x3a9a <xQueuePeek+0x14e>
    3a98:	6e cf       	rjmp	.-292    	; 0x3976 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3a9a:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    3a9c:	88 89       	ldd	r24, Y+16	; 0x10
}
    3a9e:	60 96       	adiw	r28, 0x10	; 16
    3aa0:	0f b6       	in	r0, 0x3f	; 63
    3aa2:	f8 94       	cli
    3aa4:	de bf       	out	0x3e, r29	; 62
    3aa6:	0f be       	out	0x3f, r0	; 63
    3aa8:	cd bf       	out	0x3d, r28	; 61
    3aaa:	cf 91       	pop	r28
    3aac:	df 91       	pop	r29
    3aae:	08 95       	ret

00003ab0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3ab0:	df 93       	push	r29
    3ab2:	cf 93       	push	r28
    3ab4:	cd b7       	in	r28, 0x3d	; 61
    3ab6:	de b7       	in	r29, 0x3e	; 62
    3ab8:	2c 97       	sbiw	r28, 0x0c	; 12
    3aba:	0f b6       	in	r0, 0x3f	; 63
    3abc:	f8 94       	cli
    3abe:	de bf       	out	0x3e, r29	; 62
    3ac0:	0f be       	out	0x3f, r0	; 63
    3ac2:	cd bf       	out	0x3d, r28	; 61
    3ac4:	98 87       	std	Y+8, r25	; 0x08
    3ac6:	8f 83       	std	Y+7, r24	; 0x07
    3ac8:	7a 87       	std	Y+10, r23	; 0x0a
    3aca:	69 87       	std	Y+9, r22	; 0x09
    3acc:	5c 87       	std	Y+12, r21	; 0x0c
    3ace:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3ad0:	8f 81       	ldd	r24, Y+7	; 0x07
    3ad2:	98 85       	ldd	r25, Y+8	; 0x08
    3ad4:	9c 83       	std	Y+4, r25	; 0x04
    3ad6:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3ad8:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3ada:	eb 81       	ldd	r30, Y+3	; 0x03
    3adc:	fc 81       	ldd	r31, Y+4	; 0x04
    3ade:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ae0:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3ae2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ae4:	88 23       	and	r24, r24
    3ae6:	81 f1       	breq	.+96     	; 0x3b48 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    3ae8:	eb 81       	ldd	r30, Y+3	; 0x03
    3aea:	fc 81       	ldd	r31, Y+4	; 0x04
    3aec:	85 8d       	ldd	r24, Z+29	; 0x1d
    3aee:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3af0:	8b 81       	ldd	r24, Y+3	; 0x03
    3af2:	9c 81       	ldd	r25, Y+4	; 0x04
    3af4:	29 85       	ldd	r18, Y+9	; 0x09
    3af6:	3a 85       	ldd	r19, Y+10	; 0x0a
    3af8:	b9 01       	movw	r22, r18
    3afa:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3afe:	8a 81       	ldd	r24, Y+2	; 0x02
    3b00:	81 50       	subi	r24, 0x01	; 1
    3b02:	eb 81       	ldd	r30, Y+3	; 0x03
    3b04:	fc 81       	ldd	r31, Y+4	; 0x04
    3b06:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    3b08:	89 81       	ldd	r24, Y+1	; 0x01
    3b0a:	8f 3f       	cpi	r24, 0xFF	; 255
    3b0c:	a9 f4       	brne	.+42     	; 0x3b38 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3b0e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b10:	fc 81       	ldd	r31, Y+4	; 0x04
    3b12:	80 85       	ldd	r24, Z+8	; 0x08
    3b14:	88 23       	and	r24, r24
    3b16:	a9 f0       	breq	.+42     	; 0x3b42 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3b18:	8b 81       	ldd	r24, Y+3	; 0x03
    3b1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3b1c:	08 96       	adiw	r24, 0x08	; 8
    3b1e:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <xTaskRemoveFromEventList>
    3b22:	88 23       	and	r24, r24
    3b24:	71 f0       	breq	.+28     	; 0x3b42 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3b26:	8b 85       	ldd	r24, Y+11	; 0x0b
    3b28:	9c 85       	ldd	r25, Y+12	; 0x0c
    3b2a:	00 97       	sbiw	r24, 0x00	; 0
    3b2c:	51 f0       	breq	.+20     	; 0x3b42 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3b2e:	eb 85       	ldd	r30, Y+11	; 0x0b
    3b30:	fc 85       	ldd	r31, Y+12	; 0x0c
    3b32:	81 e0       	ldi	r24, 0x01	; 1
    3b34:	80 83       	st	Z, r24
    3b36:	05 c0       	rjmp	.+10     	; 0x3b42 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    3b38:	89 81       	ldd	r24, Y+1	; 0x01
    3b3a:	8f 5f       	subi	r24, 0xFF	; 255
    3b3c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b3e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b40:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3b42:	81 e0       	ldi	r24, 0x01	; 1
    3b44:	8e 83       	std	Y+6, r24	; 0x06
    3b46:	01 c0       	rjmp	.+2      	; 0x3b4a <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    3b48:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3b4a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3b4c:	2c 96       	adiw	r28, 0x0c	; 12
    3b4e:	0f b6       	in	r0, 0x3f	; 63
    3b50:	f8 94       	cli
    3b52:	de bf       	out	0x3e, r29	; 62
    3b54:	0f be       	out	0x3f, r0	; 63
    3b56:	cd bf       	out	0x3d, r28	; 61
    3b58:	cf 91       	pop	r28
    3b5a:	df 91       	pop	r29
    3b5c:	08 95       	ret

00003b5e <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3b5e:	df 93       	push	r29
    3b60:	cf 93       	push	r28
    3b62:	cd b7       	in	r28, 0x3d	; 61
    3b64:	de b7       	in	r29, 0x3e	; 62
    3b66:	2a 97       	sbiw	r28, 0x0a	; 10
    3b68:	0f b6       	in	r0, 0x3f	; 63
    3b6a:	f8 94       	cli
    3b6c:	de bf       	out	0x3e, r29	; 62
    3b6e:	0f be       	out	0x3f, r0	; 63
    3b70:	cd bf       	out	0x3d, r28	; 61
    3b72:	98 87       	std	Y+8, r25	; 0x08
    3b74:	8f 83       	std	Y+7, r24	; 0x07
    3b76:	7a 87       	std	Y+10, r23	; 0x0a
    3b78:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    3b7a:	8f 81       	ldd	r24, Y+7	; 0x07
    3b7c:	98 85       	ldd	r25, Y+8	; 0x08
    3b7e:	9a 83       	std	Y+2, r25	; 0x02
    3b80:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3b82:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3b84:	e9 81       	ldd	r30, Y+1	; 0x01
    3b86:	fa 81       	ldd	r31, Y+2	; 0x02
    3b88:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b8a:	88 23       	and	r24, r24
    3b8c:	b1 f0       	breq	.+44     	; 0x3bba <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    3b90:	fa 81       	ldd	r31, Y+2	; 0x02
    3b92:	86 81       	ldd	r24, Z+6	; 0x06
    3b94:	97 81       	ldd	r25, Z+7	; 0x07
    3b96:	9c 83       	std	Y+4, r25	; 0x04
    3b98:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3b9a:	89 81       	ldd	r24, Y+1	; 0x01
    3b9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b9e:	29 85       	ldd	r18, Y+9	; 0x09
    3ba0:	3a 85       	ldd	r19, Y+10	; 0x0a
    3ba2:	b9 01       	movw	r22, r18
    3ba4:	0e 94 fc 1e 	call	0x3df8	; 0x3df8 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3ba8:	e9 81       	ldd	r30, Y+1	; 0x01
    3baa:	fa 81       	ldd	r31, Y+2	; 0x02
    3bac:	8b 81       	ldd	r24, Y+3	; 0x03
    3bae:	9c 81       	ldd	r25, Y+4	; 0x04
    3bb0:	97 83       	std	Z+7, r25	; 0x07
    3bb2:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    3bb4:	81 e0       	ldi	r24, 0x01	; 1
    3bb6:	8e 83       	std	Y+6, r24	; 0x06
    3bb8:	01 c0       	rjmp	.+2      	; 0x3bbc <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    3bba:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3bbc:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3bbe:	2a 96       	adiw	r28, 0x0a	; 10
    3bc0:	0f b6       	in	r0, 0x3f	; 63
    3bc2:	f8 94       	cli
    3bc4:	de bf       	out	0x3e, r29	; 62
    3bc6:	0f be       	out	0x3f, r0	; 63
    3bc8:	cd bf       	out	0x3d, r28	; 61
    3bca:	cf 91       	pop	r28
    3bcc:	df 91       	pop	r29
    3bce:	08 95       	ret

00003bd0 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3bd0:	df 93       	push	r29
    3bd2:	cf 93       	push	r28
    3bd4:	00 d0       	rcall	.+0      	; 0x3bd6 <uxQueueMessagesWaiting+0x6>
    3bd6:	0f 92       	push	r0
    3bd8:	cd b7       	in	r28, 0x3d	; 61
    3bda:	de b7       	in	r29, 0x3e	; 62
    3bdc:	9b 83       	std	Y+3, r25	; 0x03
    3bde:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3be0:	0f b6       	in	r0, 0x3f	; 63
    3be2:	f8 94       	cli
    3be4:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3be6:	ea 81       	ldd	r30, Y+2	; 0x02
    3be8:	fb 81       	ldd	r31, Y+3	; 0x03
    3bea:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bec:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3bee:	0f 90       	pop	r0
    3bf0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3bf2:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3bf4:	0f 90       	pop	r0
    3bf6:	0f 90       	pop	r0
    3bf8:	0f 90       	pop	r0
    3bfa:	cf 91       	pop	r28
    3bfc:	df 91       	pop	r29
    3bfe:	08 95       	ret

00003c00 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3c00:	df 93       	push	r29
    3c02:	cf 93       	push	r28
    3c04:	00 d0       	rcall	.+0      	; 0x3c06 <uxQueueSpacesAvailable+0x6>
    3c06:	00 d0       	rcall	.+0      	; 0x3c08 <uxQueueSpacesAvailable+0x8>
    3c08:	0f 92       	push	r0
    3c0a:	cd b7       	in	r28, 0x3d	; 61
    3c0c:	de b7       	in	r29, 0x3e	; 62
    3c0e:	9d 83       	std	Y+5, r25	; 0x05
    3c10:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3c12:	8c 81       	ldd	r24, Y+4	; 0x04
    3c14:	9d 81       	ldd	r25, Y+5	; 0x05
    3c16:	9a 83       	std	Y+2, r25	; 0x02
    3c18:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3c1a:	0f b6       	in	r0, 0x3f	; 63
    3c1c:	f8 94       	cli
    3c1e:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3c20:	e9 81       	ldd	r30, Y+1	; 0x01
    3c22:	fa 81       	ldd	r31, Y+2	; 0x02
    3c24:	93 8d       	ldd	r25, Z+27	; 0x1b
    3c26:	e9 81       	ldd	r30, Y+1	; 0x01
    3c28:	fa 81       	ldd	r31, Y+2	; 0x02
    3c2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c2c:	29 2f       	mov	r18, r25
    3c2e:	28 1b       	sub	r18, r24
    3c30:	82 2f       	mov	r24, r18
    3c32:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3c34:	0f 90       	pop	r0
    3c36:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3c38:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3c3a:	0f 90       	pop	r0
    3c3c:	0f 90       	pop	r0
    3c3e:	0f 90       	pop	r0
    3c40:	0f 90       	pop	r0
    3c42:	0f 90       	pop	r0
    3c44:	cf 91       	pop	r28
    3c46:	df 91       	pop	r29
    3c48:	08 95       	ret

00003c4a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3c4a:	df 93       	push	r29
    3c4c:	cf 93       	push	r28
    3c4e:	00 d0       	rcall	.+0      	; 0x3c50 <uxQueueMessagesWaitingFromISR+0x6>
    3c50:	00 d0       	rcall	.+0      	; 0x3c52 <uxQueueMessagesWaitingFromISR+0x8>
    3c52:	0f 92       	push	r0
    3c54:	cd b7       	in	r28, 0x3d	; 61
    3c56:	de b7       	in	r29, 0x3e	; 62
    3c58:	9d 83       	std	Y+5, r25	; 0x05
    3c5a:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3c5c:	8c 81       	ldd	r24, Y+4	; 0x04
    3c5e:	9d 81       	ldd	r25, Y+5	; 0x05
    3c60:	9a 83       	std	Y+2, r25	; 0x02
    3c62:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    3c64:	e9 81       	ldd	r30, Y+1	; 0x01
    3c66:	fa 81       	ldd	r31, Y+2	; 0x02
    3c68:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c6a:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    3c6c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3c6e:	0f 90       	pop	r0
    3c70:	0f 90       	pop	r0
    3c72:	0f 90       	pop	r0
    3c74:	0f 90       	pop	r0
    3c76:	0f 90       	pop	r0
    3c78:	cf 91       	pop	r28
    3c7a:	df 91       	pop	r29
    3c7c:	08 95       	ret

00003c7e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3c7e:	df 93       	push	r29
    3c80:	cf 93       	push	r28
    3c82:	00 d0       	rcall	.+0      	; 0x3c84 <vQueueDelete+0x6>
    3c84:	00 d0       	rcall	.+0      	; 0x3c86 <vQueueDelete+0x8>
    3c86:	cd b7       	in	r28, 0x3d	; 61
    3c88:	de b7       	in	r29, 0x3e	; 62
    3c8a:	9c 83       	std	Y+4, r25	; 0x04
    3c8c:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    3c8e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c90:	9c 81       	ldd	r25, Y+4	; 0x04
    3c92:	9a 83       	std	Y+2, r25	; 0x02
    3c94:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    3c96:	89 81       	ldd	r24, Y+1	; 0x01
    3c98:	9a 81       	ldd	r25, Y+2	; 0x02
    3c9a:	0e 94 20 14 	call	0x2840	; 0x2840 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3c9e:	0f 90       	pop	r0
    3ca0:	0f 90       	pop	r0
    3ca2:	0f 90       	pop	r0
    3ca4:	0f 90       	pop	r0
    3ca6:	cf 91       	pop	r28
    3ca8:	df 91       	pop	r29
    3caa:	08 95       	ret

00003cac <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3cac:	df 93       	push	r29
    3cae:	cf 93       	push	r28
    3cb0:	cd b7       	in	r28, 0x3d	; 61
    3cb2:	de b7       	in	r29, 0x3e	; 62
    3cb4:	27 97       	sbiw	r28, 0x07	; 7
    3cb6:	0f b6       	in	r0, 0x3f	; 63
    3cb8:	f8 94       	cli
    3cba:	de bf       	out	0x3e, r29	; 62
    3cbc:	0f be       	out	0x3f, r0	; 63
    3cbe:	cd bf       	out	0x3d, r28	; 61
    3cc0:	9c 83       	std	Y+4, r25	; 0x04
    3cc2:	8b 83       	std	Y+3, r24	; 0x03
    3cc4:	7e 83       	std	Y+6, r23	; 0x06
    3cc6:	6d 83       	std	Y+5, r22	; 0x05
    3cc8:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    3cca:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3ccc:	eb 81       	ldd	r30, Y+3	; 0x03
    3cce:	fc 81       	ldd	r31, Y+4	; 0x04
    3cd0:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cd2:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3cd4:	eb 81       	ldd	r30, Y+3	; 0x03
    3cd6:	fc 81       	ldd	r31, Y+4	; 0x04
    3cd8:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cda:	88 23       	and	r24, r24
    3cdc:	09 f4       	brne	.+2      	; 0x3ce0 <prvCopyDataToQueue+0x34>
    3cde:	7d c0       	rjmp	.+250    	; 0x3dda <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3ce0:	8f 81       	ldd	r24, Y+7	; 0x07
    3ce2:	88 23       	and	r24, r24
    3ce4:	99 f5       	brne	.+102    	; 0x3d4c <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3ce6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ce8:	fc 81       	ldd	r31, Y+4	; 0x04
    3cea:	62 81       	ldd	r22, Z+2	; 0x02
    3cec:	73 81       	ldd	r23, Z+3	; 0x03
    3cee:	eb 81       	ldd	r30, Y+3	; 0x03
    3cf0:	fc 81       	ldd	r31, Y+4	; 0x04
    3cf2:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cf4:	48 2f       	mov	r20, r24
    3cf6:	50 e0       	ldi	r21, 0x00	; 0
    3cf8:	2d 81       	ldd	r18, Y+5	; 0x05
    3cfa:	3e 81       	ldd	r19, Y+6	; 0x06
    3cfc:	cb 01       	movw	r24, r22
    3cfe:	b9 01       	movw	r22, r18
    3d00:	0e 94 6a 35 	call	0x6ad4	; 0x6ad4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3d04:	eb 81       	ldd	r30, Y+3	; 0x03
    3d06:	fc 81       	ldd	r31, Y+4	; 0x04
    3d08:	22 81       	ldd	r18, Z+2	; 0x02
    3d0a:	33 81       	ldd	r19, Z+3	; 0x03
    3d0c:	eb 81       	ldd	r30, Y+3	; 0x03
    3d0e:	fc 81       	ldd	r31, Y+4	; 0x04
    3d10:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d12:	88 2f       	mov	r24, r24
    3d14:	90 e0       	ldi	r25, 0x00	; 0
    3d16:	82 0f       	add	r24, r18
    3d18:	93 1f       	adc	r25, r19
    3d1a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d1c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d1e:	93 83       	std	Z+3, r25	; 0x03
    3d20:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3d22:	eb 81       	ldd	r30, Y+3	; 0x03
    3d24:	fc 81       	ldd	r31, Y+4	; 0x04
    3d26:	22 81       	ldd	r18, Z+2	; 0x02
    3d28:	33 81       	ldd	r19, Z+3	; 0x03
    3d2a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d2c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d2e:	84 81       	ldd	r24, Z+4	; 0x04
    3d30:	95 81       	ldd	r25, Z+5	; 0x05
    3d32:	28 17       	cp	r18, r24
    3d34:	39 07       	cpc	r19, r25
    3d36:	08 f4       	brcc	.+2      	; 0x3d3a <prvCopyDataToQueue+0x8e>
    3d38:	50 c0       	rjmp	.+160    	; 0x3dda <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3d3a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d3c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d3e:	80 81       	ld	r24, Z
    3d40:	91 81       	ldd	r25, Z+1	; 0x01
    3d42:	eb 81       	ldd	r30, Y+3	; 0x03
    3d44:	fc 81       	ldd	r31, Y+4	; 0x04
    3d46:	93 83       	std	Z+3, r25	; 0x03
    3d48:	82 83       	std	Z+2, r24	; 0x02
    3d4a:	47 c0       	rjmp	.+142    	; 0x3dda <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3d4c:	eb 81       	ldd	r30, Y+3	; 0x03
    3d4e:	fc 81       	ldd	r31, Y+4	; 0x04
    3d50:	66 81       	ldd	r22, Z+6	; 0x06
    3d52:	77 81       	ldd	r23, Z+7	; 0x07
    3d54:	eb 81       	ldd	r30, Y+3	; 0x03
    3d56:	fc 81       	ldd	r31, Y+4	; 0x04
    3d58:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d5a:	48 2f       	mov	r20, r24
    3d5c:	50 e0       	ldi	r21, 0x00	; 0
    3d5e:	2d 81       	ldd	r18, Y+5	; 0x05
    3d60:	3e 81       	ldd	r19, Y+6	; 0x06
    3d62:	cb 01       	movw	r24, r22
    3d64:	b9 01       	movw	r22, r18
    3d66:	0e 94 6a 35 	call	0x6ad4	; 0x6ad4 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    3d6a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d6c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d6e:	26 81       	ldd	r18, Z+6	; 0x06
    3d70:	37 81       	ldd	r19, Z+7	; 0x07
    3d72:	eb 81       	ldd	r30, Y+3	; 0x03
    3d74:	fc 81       	ldd	r31, Y+4	; 0x04
    3d76:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d78:	88 2f       	mov	r24, r24
    3d7a:	90 e0       	ldi	r25, 0x00	; 0
    3d7c:	90 95       	com	r25
    3d7e:	81 95       	neg	r24
    3d80:	9f 4f       	sbci	r25, 0xFF	; 255
    3d82:	82 0f       	add	r24, r18
    3d84:	93 1f       	adc	r25, r19
    3d86:	eb 81       	ldd	r30, Y+3	; 0x03
    3d88:	fc 81       	ldd	r31, Y+4	; 0x04
    3d8a:	97 83       	std	Z+7, r25	; 0x07
    3d8c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3d8e:	eb 81       	ldd	r30, Y+3	; 0x03
    3d90:	fc 81       	ldd	r31, Y+4	; 0x04
    3d92:	26 81       	ldd	r18, Z+6	; 0x06
    3d94:	37 81       	ldd	r19, Z+7	; 0x07
    3d96:	eb 81       	ldd	r30, Y+3	; 0x03
    3d98:	fc 81       	ldd	r31, Y+4	; 0x04
    3d9a:	80 81       	ld	r24, Z
    3d9c:	91 81       	ldd	r25, Z+1	; 0x01
    3d9e:	28 17       	cp	r18, r24
    3da0:	39 07       	cpc	r19, r25
    3da2:	90 f4       	brcc	.+36     	; 0x3dc8 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3da4:	eb 81       	ldd	r30, Y+3	; 0x03
    3da6:	fc 81       	ldd	r31, Y+4	; 0x04
    3da8:	24 81       	ldd	r18, Z+4	; 0x04
    3daa:	35 81       	ldd	r19, Z+5	; 0x05
    3dac:	eb 81       	ldd	r30, Y+3	; 0x03
    3dae:	fc 81       	ldd	r31, Y+4	; 0x04
    3db0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3db2:	88 2f       	mov	r24, r24
    3db4:	90 e0       	ldi	r25, 0x00	; 0
    3db6:	90 95       	com	r25
    3db8:	81 95       	neg	r24
    3dba:	9f 4f       	sbci	r25, 0xFF	; 255
    3dbc:	82 0f       	add	r24, r18
    3dbe:	93 1f       	adc	r25, r19
    3dc0:	eb 81       	ldd	r30, Y+3	; 0x03
    3dc2:	fc 81       	ldd	r31, Y+4	; 0x04
    3dc4:	97 83       	std	Z+7, r25	; 0x07
    3dc6:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3dc8:	8f 81       	ldd	r24, Y+7	; 0x07
    3dca:	82 30       	cpi	r24, 0x02	; 2
    3dcc:	31 f4       	brne	.+12     	; 0x3dda <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3dce:	89 81       	ldd	r24, Y+1	; 0x01
    3dd0:	88 23       	and	r24, r24
    3dd2:	19 f0       	breq	.+6      	; 0x3dda <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3dd4:	89 81       	ldd	r24, Y+1	; 0x01
    3dd6:	81 50       	subi	r24, 0x01	; 1
    3dd8:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3dda:	89 81       	ldd	r24, Y+1	; 0x01
    3ddc:	8f 5f       	subi	r24, 0xFF	; 255
    3dde:	eb 81       	ldd	r30, Y+3	; 0x03
    3de0:	fc 81       	ldd	r31, Y+4	; 0x04
    3de2:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    3de4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3de6:	27 96       	adiw	r28, 0x07	; 7
    3de8:	0f b6       	in	r0, 0x3f	; 63
    3dea:	f8 94       	cli
    3dec:	de bf       	out	0x3e, r29	; 62
    3dee:	0f be       	out	0x3f, r0	; 63
    3df0:	cd bf       	out	0x3d, r28	; 61
    3df2:	cf 91       	pop	r28
    3df4:	df 91       	pop	r29
    3df6:	08 95       	ret

00003df8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3df8:	df 93       	push	r29
    3dfa:	cf 93       	push	r28
    3dfc:	00 d0       	rcall	.+0      	; 0x3dfe <prvCopyDataFromQueue+0x6>
    3dfe:	00 d0       	rcall	.+0      	; 0x3e00 <prvCopyDataFromQueue+0x8>
    3e00:	cd b7       	in	r28, 0x3d	; 61
    3e02:	de b7       	in	r29, 0x3e	; 62
    3e04:	9a 83       	std	Y+2, r25	; 0x02
    3e06:	89 83       	std	Y+1, r24	; 0x01
    3e08:	7c 83       	std	Y+4, r23	; 0x04
    3e0a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e10:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e12:	88 23       	and	r24, r24
    3e14:	89 f1       	breq	.+98     	; 0x3e78 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3e16:	e9 81       	ldd	r30, Y+1	; 0x01
    3e18:	fa 81       	ldd	r31, Y+2	; 0x02
    3e1a:	26 81       	ldd	r18, Z+6	; 0x06
    3e1c:	37 81       	ldd	r19, Z+7	; 0x07
    3e1e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e20:	fa 81       	ldd	r31, Y+2	; 0x02
    3e22:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e24:	88 2f       	mov	r24, r24
    3e26:	90 e0       	ldi	r25, 0x00	; 0
    3e28:	82 0f       	add	r24, r18
    3e2a:	93 1f       	adc	r25, r19
    3e2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e30:	97 83       	std	Z+7, r25	; 0x07
    3e32:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3e34:	e9 81       	ldd	r30, Y+1	; 0x01
    3e36:	fa 81       	ldd	r31, Y+2	; 0x02
    3e38:	26 81       	ldd	r18, Z+6	; 0x06
    3e3a:	37 81       	ldd	r19, Z+7	; 0x07
    3e3c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e3e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e40:	84 81       	ldd	r24, Z+4	; 0x04
    3e42:	95 81       	ldd	r25, Z+5	; 0x05
    3e44:	28 17       	cp	r18, r24
    3e46:	39 07       	cpc	r19, r25
    3e48:	40 f0       	brcs	.+16     	; 0x3e5a <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3e4a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e4c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e4e:	80 81       	ld	r24, Z
    3e50:	91 81       	ldd	r25, Z+1	; 0x01
    3e52:	e9 81       	ldd	r30, Y+1	; 0x01
    3e54:	fa 81       	ldd	r31, Y+2	; 0x02
    3e56:	97 83       	std	Z+7, r25	; 0x07
    3e58:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3e5a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e5c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e5e:	46 81       	ldd	r20, Z+6	; 0x06
    3e60:	57 81       	ldd	r21, Z+7	; 0x07
    3e62:	e9 81       	ldd	r30, Y+1	; 0x01
    3e64:	fa 81       	ldd	r31, Y+2	; 0x02
    3e66:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e68:	28 2f       	mov	r18, r24
    3e6a:	30 e0       	ldi	r19, 0x00	; 0
    3e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3e70:	ba 01       	movw	r22, r20
    3e72:	a9 01       	movw	r20, r18
    3e74:	0e 94 6a 35 	call	0x6ad4	; 0x6ad4 <memcpy>
	}
}
    3e78:	0f 90       	pop	r0
    3e7a:	0f 90       	pop	r0
    3e7c:	0f 90       	pop	r0
    3e7e:	0f 90       	pop	r0
    3e80:	cf 91       	pop	r28
    3e82:	df 91       	pop	r29
    3e84:	08 95       	ret

00003e86 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3e86:	df 93       	push	r29
    3e88:	cf 93       	push	r28
    3e8a:	00 d0       	rcall	.+0      	; 0x3e8c <prvUnlockQueue+0x6>
    3e8c:	00 d0       	rcall	.+0      	; 0x3e8e <prvUnlockQueue+0x8>
    3e8e:	cd b7       	in	r28, 0x3d	; 61
    3e90:	de b7       	in	r29, 0x3e	; 62
    3e92:	9c 83       	std	Y+4, r25	; 0x04
    3e94:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3e96:	0f b6       	in	r0, 0x3f	; 63
    3e98:	f8 94       	cli
    3e9a:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3e9c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e9e:	fc 81       	ldd	r31, Y+4	; 0x04
    3ea0:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ea2:	8a 83       	std	Y+2, r24	; 0x02
    3ea4:	11 c0       	rjmp	.+34     	; 0x3ec8 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ea6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ea8:	fc 81       	ldd	r31, Y+4	; 0x04
    3eaa:	81 89       	ldd	r24, Z+17	; 0x11
    3eac:	88 23       	and	r24, r24
    3eae:	79 f0       	breq	.+30     	; 0x3ece <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    3eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    3eb4:	41 96       	adiw	r24, 0x11	; 17
    3eb6:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <xTaskRemoveFromEventList>
    3eba:	88 23       	and	r24, r24
    3ebc:	11 f0       	breq	.+4      	; 0x3ec2 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    3ebe:	0e 94 11 30 	call	0x6022	; 0x6022 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3ec2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ec4:	81 50       	subi	r24, 0x01	; 1
    3ec6:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    3eca:	18 16       	cp	r1, r24
    3ecc:	64 f3       	brlt	.-40     	; 0x3ea6 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3ece:	eb 81       	ldd	r30, Y+3	; 0x03
    3ed0:	fc 81       	ldd	r31, Y+4	; 0x04
    3ed2:	8f ef       	ldi	r24, 0xFF	; 255
    3ed4:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3ed6:	0f 90       	pop	r0
    3ed8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3eda:	0f b6       	in	r0, 0x3f	; 63
    3edc:	f8 94       	cli
    3ede:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3ee0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ee2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ee4:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ee6:	89 83       	std	Y+1, r24	; 0x01
    3ee8:	11 c0       	rjmp	.+34     	; 0x3f0c <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3eea:	eb 81       	ldd	r30, Y+3	; 0x03
    3eec:	fc 81       	ldd	r31, Y+4	; 0x04
    3eee:	80 85       	ldd	r24, Z+8	; 0x08
    3ef0:	88 23       	and	r24, r24
    3ef2:	79 f0       	breq	.+30     	; 0x3f12 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3ef4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ef6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ef8:	08 96       	adiw	r24, 0x08	; 8
    3efa:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <xTaskRemoveFromEventList>
    3efe:	88 23       	and	r24, r24
    3f00:	11 f0       	breq	.+4      	; 0x3f06 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    3f02:	0e 94 11 30 	call	0x6022	; 0x6022 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3f06:	89 81       	ldd	r24, Y+1	; 0x01
    3f08:	81 50       	subi	r24, 0x01	; 1
    3f0a:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3f0c:	89 81       	ldd	r24, Y+1	; 0x01
    3f0e:	18 16       	cp	r1, r24
    3f10:	64 f3       	brlt	.-40     	; 0x3eea <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3f12:	eb 81       	ldd	r30, Y+3	; 0x03
    3f14:	fc 81       	ldd	r31, Y+4	; 0x04
    3f16:	8f ef       	ldi	r24, 0xFF	; 255
    3f18:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3f1a:	0f 90       	pop	r0
    3f1c:	0f be       	out	0x3f, r0	; 63
}
    3f1e:	0f 90       	pop	r0
    3f20:	0f 90       	pop	r0
    3f22:	0f 90       	pop	r0
    3f24:	0f 90       	pop	r0
    3f26:	cf 91       	pop	r28
    3f28:	df 91       	pop	r29
    3f2a:	08 95       	ret

00003f2c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3f2c:	df 93       	push	r29
    3f2e:	cf 93       	push	r28
    3f30:	00 d0       	rcall	.+0      	; 0x3f32 <prvIsQueueEmpty+0x6>
    3f32:	0f 92       	push	r0
    3f34:	cd b7       	in	r28, 0x3d	; 61
    3f36:	de b7       	in	r29, 0x3e	; 62
    3f38:	9b 83       	std	Y+3, r25	; 0x03
    3f3a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3f3c:	0f b6       	in	r0, 0x3f	; 63
    3f3e:	f8 94       	cli
    3f40:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3f42:	ea 81       	ldd	r30, Y+2	; 0x02
    3f44:	fb 81       	ldd	r31, Y+3	; 0x03
    3f46:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f48:	88 23       	and	r24, r24
    3f4a:	19 f4       	brne	.+6      	; 0x3f52 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    3f4c:	81 e0       	ldi	r24, 0x01	; 1
    3f4e:	89 83       	std	Y+1, r24	; 0x01
    3f50:	01 c0       	rjmp	.+2      	; 0x3f54 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    3f52:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3f54:	0f 90       	pop	r0
    3f56:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3f58:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f5a:	0f 90       	pop	r0
    3f5c:	0f 90       	pop	r0
    3f5e:	0f 90       	pop	r0
    3f60:	cf 91       	pop	r28
    3f62:	df 91       	pop	r29
    3f64:	08 95       	ret

00003f66 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3f66:	df 93       	push	r29
    3f68:	cf 93       	push	r28
    3f6a:	00 d0       	rcall	.+0      	; 0x3f6c <xQueueIsQueueEmptyFromISR+0x6>
    3f6c:	00 d0       	rcall	.+0      	; 0x3f6e <xQueueIsQueueEmptyFromISR+0x8>
    3f6e:	0f 92       	push	r0
    3f70:	cd b7       	in	r28, 0x3d	; 61
    3f72:	de b7       	in	r29, 0x3e	; 62
    3f74:	9d 83       	std	Y+5, r25	; 0x05
    3f76:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3f78:	8c 81       	ldd	r24, Y+4	; 0x04
    3f7a:	9d 81       	ldd	r25, Y+5	; 0x05
    3f7c:	9a 83       	std	Y+2, r25	; 0x02
    3f7e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3f80:	e9 81       	ldd	r30, Y+1	; 0x01
    3f82:	fa 81       	ldd	r31, Y+2	; 0x02
    3f84:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f86:	88 23       	and	r24, r24
    3f88:	19 f4       	brne	.+6      	; 0x3f90 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    3f8a:	81 e0       	ldi	r24, 0x01	; 1
    3f8c:	8b 83       	std	Y+3, r24	; 0x03
    3f8e:	01 c0       	rjmp	.+2      	; 0x3f92 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    3f90:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3f92:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3f94:	0f 90       	pop	r0
    3f96:	0f 90       	pop	r0
    3f98:	0f 90       	pop	r0
    3f9a:	0f 90       	pop	r0
    3f9c:	0f 90       	pop	r0
    3f9e:	cf 91       	pop	r28
    3fa0:	df 91       	pop	r29
    3fa2:	08 95       	ret

00003fa4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3fa4:	df 93       	push	r29
    3fa6:	cf 93       	push	r28
    3fa8:	00 d0       	rcall	.+0      	; 0x3faa <prvIsQueueFull+0x6>
    3faa:	0f 92       	push	r0
    3fac:	cd b7       	in	r28, 0x3d	; 61
    3fae:	de b7       	in	r29, 0x3e	; 62
    3fb0:	9b 83       	std	Y+3, r25	; 0x03
    3fb2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3fb4:	0f b6       	in	r0, 0x3f	; 63
    3fb6:	f8 94       	cli
    3fb8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3fba:	ea 81       	ldd	r30, Y+2	; 0x02
    3fbc:	fb 81       	ldd	r31, Y+3	; 0x03
    3fbe:	92 8d       	ldd	r25, Z+26	; 0x1a
    3fc0:	ea 81       	ldd	r30, Y+2	; 0x02
    3fc2:	fb 81       	ldd	r31, Y+3	; 0x03
    3fc4:	83 8d       	ldd	r24, Z+27	; 0x1b
    3fc6:	98 17       	cp	r25, r24
    3fc8:	19 f4       	brne	.+6      	; 0x3fd0 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    3fca:	81 e0       	ldi	r24, 0x01	; 1
    3fcc:	89 83       	std	Y+1, r24	; 0x01
    3fce:	01 c0       	rjmp	.+2      	; 0x3fd2 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    3fd0:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3fd2:	0f 90       	pop	r0
    3fd4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3fd6:	89 81       	ldd	r24, Y+1	; 0x01
}
    3fd8:	0f 90       	pop	r0
    3fda:	0f 90       	pop	r0
    3fdc:	0f 90       	pop	r0
    3fde:	cf 91       	pop	r28
    3fe0:	df 91       	pop	r29
    3fe2:	08 95       	ret

00003fe4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3fe4:	df 93       	push	r29
    3fe6:	cf 93       	push	r28
    3fe8:	00 d0       	rcall	.+0      	; 0x3fea <xQueueIsQueueFullFromISR+0x6>
    3fea:	00 d0       	rcall	.+0      	; 0x3fec <xQueueIsQueueFullFromISR+0x8>
    3fec:	0f 92       	push	r0
    3fee:	cd b7       	in	r28, 0x3d	; 61
    3ff0:	de b7       	in	r29, 0x3e	; 62
    3ff2:	9d 83       	std	Y+5, r25	; 0x05
    3ff4:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3ff6:	8c 81       	ldd	r24, Y+4	; 0x04
    3ff8:	9d 81       	ldd	r25, Y+5	; 0x05
    3ffa:	9a 83       	std	Y+2, r25	; 0x02
    3ffc:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3ffe:	e9 81       	ldd	r30, Y+1	; 0x01
    4000:	fa 81       	ldd	r31, Y+2	; 0x02
    4002:	92 8d       	ldd	r25, Z+26	; 0x1a
    4004:	e9 81       	ldd	r30, Y+1	; 0x01
    4006:	fa 81       	ldd	r31, Y+2	; 0x02
    4008:	83 8d       	ldd	r24, Z+27	; 0x1b
    400a:	98 17       	cp	r25, r24
    400c:	19 f4       	brne	.+6      	; 0x4014 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    400e:	81 e0       	ldi	r24, 0x01	; 1
    4010:	8b 83       	std	Y+3, r24	; 0x03
    4012:	01 c0       	rjmp	.+2      	; 0x4016 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    4014:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    4016:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4018:	0f 90       	pop	r0
    401a:	0f 90       	pop	r0
    401c:	0f 90       	pop	r0
    401e:	0f 90       	pop	r0
    4020:	0f 90       	pop	r0
    4022:	cf 91       	pop	r28
    4024:	df 91       	pop	r29
    4026:	08 95       	ret

00004028 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    4028:	0f 93       	push	r16
    402a:	df 93       	push	r29
    402c:	cf 93       	push	r28
    402e:	cd b7       	in	r28, 0x3d	; 61
    4030:	de b7       	in	r29, 0x3e	; 62
    4032:	28 97       	sbiw	r28, 0x08	; 8
    4034:	0f b6       	in	r0, 0x3f	; 63
    4036:	f8 94       	cli
    4038:	de bf       	out	0x3e, r29	; 62
    403a:	0f be       	out	0x3f, r0	; 63
    403c:	cd bf       	out	0x3d, r28	; 61
    403e:	9d 83       	std	Y+5, r25	; 0x05
    4040:	8c 83       	std	Y+4, r24	; 0x04
    4042:	7f 83       	std	Y+7, r23	; 0x07
    4044:	6e 83       	std	Y+6, r22	; 0x06
    4046:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    4048:	88 85       	ldd	r24, Y+8	; 0x08
    404a:	81 30       	cpi	r24, 0x01	; 1
    404c:	19 f4       	brne	.+6      	; 0x4054 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    404e:	81 e0       	ldi	r24, 0x01	; 1
    4050:	89 83       	std	Y+1, r24	; 0x01
    4052:	01 c0       	rjmp	.+2      	; 0x4056 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    4054:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    4056:	8e 81       	ldd	r24, Y+6	; 0x06
    4058:	9f 81       	ldd	r25, Y+7	; 0x07
    405a:	00 97       	sbiw	r24, 0x00	; 0
    405c:	21 f4       	brne	.+8      	; 0x4066 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    405e:	81 e0       	ldi	r24, 0x01	; 1
    4060:	90 e0       	ldi	r25, 0x00	; 0
    4062:	9f 83       	std	Y+7, r25	; 0x07
    4064:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    4066:	8c 81       	ldd	r24, Y+4	; 0x04
    4068:	9d 81       	ldd	r25, Y+5	; 0x05
    406a:	01 96       	adiw	r24, 0x01	; 1
    406c:	9d 83       	std	Y+5, r25	; 0x05
    406e:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    4070:	8c 81       	ldd	r24, Y+4	; 0x04
    4072:	9d 81       	ldd	r25, Y+5	; 0x05
    4074:	0f 96       	adiw	r24, 0x0f	; 15
    4076:	0e 94 ca 13 	call	0x2794	; 0x2794 <pvPortMalloc>
    407a:	9b 83       	std	Y+3, r25	; 0x03
    407c:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    407e:	8a 81       	ldd	r24, Y+2	; 0x02
    4080:	9b 81       	ldd	r25, Y+3	; 0x03
    4082:	00 97       	sbiw	r24, 0x00	; 0
    4084:	89 f0       	breq	.+34     	; 0x40a8 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    4086:	6a 81       	ldd	r22, Y+2	; 0x02
    4088:	7b 81       	ldd	r23, Y+3	; 0x03
    408a:	8a 81       	ldd	r24, Y+2	; 0x02
    408c:	9b 81       	ldd	r25, Y+3	; 0x03
    408e:	9c 01       	movw	r18, r24
    4090:	21 5f       	subi	r18, 0xF1	; 241
    4092:	3f 4f       	sbci	r19, 0xFF	; 255
    4094:	4c 81       	ldd	r20, Y+4	; 0x04
    4096:	5d 81       	ldd	r21, Y+5	; 0x05
    4098:	ee 81       	ldd	r30, Y+6	; 0x06
    409a:	ff 81       	ldd	r31, Y+7	; 0x07
    409c:	cb 01       	movw	r24, r22
    409e:	b9 01       	movw	r22, r18
    40a0:	9f 01       	movw	r18, r30
    40a2:	09 81       	ldd	r16, Y+1	; 0x01
    40a4:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    40a8:	8a 81       	ldd	r24, Y+2	; 0x02
    40aa:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    40ac:	28 96       	adiw	r28, 0x08	; 8
    40ae:	0f b6       	in	r0, 0x3f	; 63
    40b0:	f8 94       	cli
    40b2:	de bf       	out	0x3e, r29	; 62
    40b4:	0f be       	out	0x3f, r0	; 63
    40b6:	cd bf       	out	0x3d, r28	; 61
    40b8:	cf 91       	pop	r28
    40ba:	df 91       	pop	r29
    40bc:	0f 91       	pop	r16
    40be:	08 95       	ret

000040c0 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    40c0:	df 93       	push	r29
    40c2:	cf 93       	push	r28
    40c4:	00 d0       	rcall	.+0      	; 0x40c6 <vStreamBufferDelete+0x6>
    40c6:	00 d0       	rcall	.+0      	; 0x40c8 <vStreamBufferDelete+0x8>
    40c8:	cd b7       	in	r28, 0x3d	; 61
    40ca:	de b7       	in	r29, 0x3e	; 62
    40cc:	9c 83       	std	Y+4, r25	; 0x04
    40ce:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    40d0:	8b 81       	ldd	r24, Y+3	; 0x03
    40d2:	9c 81       	ldd	r25, Y+4	; 0x04
    40d4:	9a 83       	std	Y+2, r25	; 0x02
    40d6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    40d8:	e9 81       	ldd	r30, Y+1	; 0x01
    40da:	fa 81       	ldd	r31, Y+2	; 0x02
    40dc:	86 85       	ldd	r24, Z+14	; 0x0e
    40de:	88 2f       	mov	r24, r24
    40e0:	90 e0       	ldi	r25, 0x00	; 0
    40e2:	82 70       	andi	r24, 0x02	; 2
    40e4:	90 70       	andi	r25, 0x00	; 0
    40e6:	00 97       	sbiw	r24, 0x00	; 0
    40e8:	29 f4       	brne	.+10     	; 0x40f4 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    40ea:	89 81       	ldd	r24, Y+1	; 0x01
    40ec:	9a 81       	ldd	r25, Y+2	; 0x02
    40ee:	0e 94 20 14 	call	0x2840	; 0x2840 <vPortFree>
    40f2:	08 c0       	rjmp	.+16     	; 0x4104 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    40f4:	89 81       	ldd	r24, Y+1	; 0x01
    40f6:	9a 81       	ldd	r25, Y+2	; 0x02
    40f8:	60 e0       	ldi	r22, 0x00	; 0
    40fa:	70 e0       	ldi	r23, 0x00	; 0
    40fc:	4f e0       	ldi	r20, 0x0F	; 15
    40fe:	50 e0       	ldi	r21, 0x00	; 0
    4100:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <memset>
	}
}
    4104:	0f 90       	pop	r0
    4106:	0f 90       	pop	r0
    4108:	0f 90       	pop	r0
    410a:	0f 90       	pop	r0
    410c:	cf 91       	pop	r28
    410e:	df 91       	pop	r29
    4110:	08 95       	ret

00004112 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    4112:	0f 93       	push	r16
    4114:	df 93       	push	r29
    4116:	cf 93       	push	r28
    4118:	00 d0       	rcall	.+0      	; 0x411a <xStreamBufferReset+0x8>
    411a:	00 d0       	rcall	.+0      	; 0x411c <xStreamBufferReset+0xa>
    411c:	0f 92       	push	r0
    411e:	cd b7       	in	r28, 0x3d	; 61
    4120:	de b7       	in	r29, 0x3e	; 62
    4122:	9d 83       	std	Y+5, r25	; 0x05
    4124:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4126:	8c 81       	ldd	r24, Y+4	; 0x04
    4128:	9d 81       	ldd	r25, Y+5	; 0x05
    412a:	9b 83       	std	Y+3, r25	; 0x03
    412c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    412e:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    4130:	0f b6       	in	r0, 0x3f	; 63
    4132:	f8 94       	cli
    4134:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    4136:	ea 81       	ldd	r30, Y+2	; 0x02
    4138:	fb 81       	ldd	r31, Y+3	; 0x03
    413a:	80 85       	ldd	r24, Z+8	; 0x08
    413c:	91 85       	ldd	r25, Z+9	; 0x09
    413e:	00 97       	sbiw	r24, 0x00	; 0
    4140:	f1 f4       	brne	.+60     	; 0x417e <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    4142:	ea 81       	ldd	r30, Y+2	; 0x02
    4144:	fb 81       	ldd	r31, Y+3	; 0x03
    4146:	82 85       	ldd	r24, Z+10	; 0x0a
    4148:	93 85       	ldd	r25, Z+11	; 0x0b
    414a:	00 97       	sbiw	r24, 0x00	; 0
    414c:	c1 f4       	brne	.+48     	; 0x417e <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    414e:	ea 81       	ldd	r30, Y+2	; 0x02
    4150:	fb 81       	ldd	r31, Y+3	; 0x03
    4152:	24 85       	ldd	r18, Z+12	; 0x0c
    4154:	35 85       	ldd	r19, Z+13	; 0x0d
    4156:	ea 81       	ldd	r30, Y+2	; 0x02
    4158:	fb 81       	ldd	r31, Y+3	; 0x03
    415a:	44 81       	ldd	r20, Z+4	; 0x04
    415c:	55 81       	ldd	r21, Z+5	; 0x05
    415e:	ea 81       	ldd	r30, Y+2	; 0x02
    4160:	fb 81       	ldd	r31, Y+3	; 0x03
    4162:	a6 81       	ldd	r26, Z+6	; 0x06
    4164:	b7 81       	ldd	r27, Z+7	; 0x07
    4166:	ea 81       	ldd	r30, Y+2	; 0x02
    4168:	fb 81       	ldd	r31, Y+3	; 0x03
    416a:	e6 85       	ldd	r30, Z+14	; 0x0e
    416c:	8a 81       	ldd	r24, Y+2	; 0x02
    416e:	9b 81       	ldd	r25, Y+3	; 0x03
    4170:	b9 01       	movw	r22, r18
    4172:	9d 01       	movw	r18, r26
    4174:	0e 2f       	mov	r16, r30
    4176:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    417a:	81 e0       	ldi	r24, 0x01	; 1
    417c:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    417e:	0f 90       	pop	r0
    4180:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4182:	89 81       	ldd	r24, Y+1	; 0x01
}
    4184:	0f 90       	pop	r0
    4186:	0f 90       	pop	r0
    4188:	0f 90       	pop	r0
    418a:	0f 90       	pop	r0
    418c:	0f 90       	pop	r0
    418e:	cf 91       	pop	r28
    4190:	df 91       	pop	r29
    4192:	0f 91       	pop	r16
    4194:	08 95       	ret

00004196 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    4196:	df 93       	push	r29
    4198:	cf 93       	push	r28
    419a:	cd b7       	in	r28, 0x3d	; 61
    419c:	de b7       	in	r29, 0x3e	; 62
    419e:	27 97       	sbiw	r28, 0x07	; 7
    41a0:	0f b6       	in	r0, 0x3f	; 63
    41a2:	f8 94       	cli
    41a4:	de bf       	out	0x3e, r29	; 62
    41a6:	0f be       	out	0x3f, r0	; 63
    41a8:	cd bf       	out	0x3d, r28	; 61
    41aa:	9d 83       	std	Y+5, r25	; 0x05
    41ac:	8c 83       	std	Y+4, r24	; 0x04
    41ae:	7f 83       	std	Y+7, r23	; 0x07
    41b0:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    41b2:	8c 81       	ldd	r24, Y+4	; 0x04
    41b4:	9d 81       	ldd	r25, Y+5	; 0x05
    41b6:	9b 83       	std	Y+3, r25	; 0x03
    41b8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    41ba:	8e 81       	ldd	r24, Y+6	; 0x06
    41bc:	9f 81       	ldd	r25, Y+7	; 0x07
    41be:	00 97       	sbiw	r24, 0x00	; 0
    41c0:	21 f4       	brne	.+8      	; 0x41ca <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    41c2:	81 e0       	ldi	r24, 0x01	; 1
    41c4:	90 e0       	ldi	r25, 0x00	; 0
    41c6:	9f 83       	std	Y+7, r25	; 0x07
    41c8:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    41ca:	ea 81       	ldd	r30, Y+2	; 0x02
    41cc:	fb 81       	ldd	r31, Y+3	; 0x03
    41ce:	24 81       	ldd	r18, Z+4	; 0x04
    41d0:	35 81       	ldd	r19, Z+5	; 0x05
    41d2:	8e 81       	ldd	r24, Y+6	; 0x06
    41d4:	9f 81       	ldd	r25, Y+7	; 0x07
    41d6:	28 17       	cp	r18, r24
    41d8:	39 07       	cpc	r19, r25
    41da:	48 f0       	brcs	.+18     	; 0x41ee <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    41dc:	ea 81       	ldd	r30, Y+2	; 0x02
    41de:	fb 81       	ldd	r31, Y+3	; 0x03
    41e0:	8e 81       	ldd	r24, Y+6	; 0x06
    41e2:	9f 81       	ldd	r25, Y+7	; 0x07
    41e4:	97 83       	std	Z+7, r25	; 0x07
    41e6:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    41e8:	81 e0       	ldi	r24, 0x01	; 1
    41ea:	89 83       	std	Y+1, r24	; 0x01
    41ec:	01 c0       	rjmp	.+2      	; 0x41f0 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    41ee:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    41f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    41f2:	27 96       	adiw	r28, 0x07	; 7
    41f4:	0f b6       	in	r0, 0x3f	; 63
    41f6:	f8 94       	cli
    41f8:	de bf       	out	0x3e, r29	; 62
    41fa:	0f be       	out	0x3f, r0	; 63
    41fc:	cd bf       	out	0x3d, r28	; 61
    41fe:	cf 91       	pop	r28
    4200:	df 91       	pop	r29
    4202:	08 95       	ret

00004204 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    4204:	df 93       	push	r29
    4206:	cf 93       	push	r28
    4208:	00 d0       	rcall	.+0      	; 0x420a <xStreamBufferSpacesAvailable+0x6>
    420a:	00 d0       	rcall	.+0      	; 0x420c <xStreamBufferSpacesAvailable+0x8>
    420c:	00 d0       	rcall	.+0      	; 0x420e <xStreamBufferSpacesAvailable+0xa>
    420e:	cd b7       	in	r28, 0x3d	; 61
    4210:	de b7       	in	r29, 0x3e	; 62
    4212:	9e 83       	std	Y+6, r25	; 0x06
    4214:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4216:	8d 81       	ldd	r24, Y+5	; 0x05
    4218:	9e 81       	ldd	r25, Y+6	; 0x06
    421a:	9c 83       	std	Y+4, r25	; 0x04
    421c:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    421e:	eb 81       	ldd	r30, Y+3	; 0x03
    4220:	fc 81       	ldd	r31, Y+4	; 0x04
    4222:	24 81       	ldd	r18, Z+4	; 0x04
    4224:	35 81       	ldd	r19, Z+5	; 0x05
    4226:	eb 81       	ldd	r30, Y+3	; 0x03
    4228:	fc 81       	ldd	r31, Y+4	; 0x04
    422a:	80 81       	ld	r24, Z
    422c:	91 81       	ldd	r25, Z+1	; 0x01
    422e:	82 0f       	add	r24, r18
    4230:	93 1f       	adc	r25, r19
    4232:	9a 83       	std	Y+2, r25	; 0x02
    4234:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    4236:	eb 81       	ldd	r30, Y+3	; 0x03
    4238:	fc 81       	ldd	r31, Y+4	; 0x04
    423a:	22 81       	ldd	r18, Z+2	; 0x02
    423c:	33 81       	ldd	r19, Z+3	; 0x03
    423e:	89 81       	ldd	r24, Y+1	; 0x01
    4240:	9a 81       	ldd	r25, Y+2	; 0x02
    4242:	82 1b       	sub	r24, r18
    4244:	93 0b       	sbc	r25, r19
    4246:	9a 83       	std	Y+2, r25	; 0x02
    4248:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    424a:	89 81       	ldd	r24, Y+1	; 0x01
    424c:	9a 81       	ldd	r25, Y+2	; 0x02
    424e:	01 97       	sbiw	r24, 0x01	; 1
    4250:	9a 83       	std	Y+2, r25	; 0x02
    4252:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    4254:	eb 81       	ldd	r30, Y+3	; 0x03
    4256:	fc 81       	ldd	r31, Y+4	; 0x04
    4258:	24 81       	ldd	r18, Z+4	; 0x04
    425a:	35 81       	ldd	r19, Z+5	; 0x05
    425c:	89 81       	ldd	r24, Y+1	; 0x01
    425e:	9a 81       	ldd	r25, Y+2	; 0x02
    4260:	82 17       	cp	r24, r18
    4262:	93 07       	cpc	r25, r19
    4264:	50 f0       	brcs	.+20     	; 0x427a <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    4266:	eb 81       	ldd	r30, Y+3	; 0x03
    4268:	fc 81       	ldd	r31, Y+4	; 0x04
    426a:	24 81       	ldd	r18, Z+4	; 0x04
    426c:	35 81       	ldd	r19, Z+5	; 0x05
    426e:	89 81       	ldd	r24, Y+1	; 0x01
    4270:	9a 81       	ldd	r25, Y+2	; 0x02
    4272:	82 1b       	sub	r24, r18
    4274:	93 0b       	sbc	r25, r19
    4276:	9a 83       	std	Y+2, r25	; 0x02
    4278:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    427a:	89 81       	ldd	r24, Y+1	; 0x01
    427c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    427e:	26 96       	adiw	r28, 0x06	; 6
    4280:	0f b6       	in	r0, 0x3f	; 63
    4282:	f8 94       	cli
    4284:	de bf       	out	0x3e, r29	; 62
    4286:	0f be       	out	0x3f, r0	; 63
    4288:	cd bf       	out	0x3d, r28	; 61
    428a:	cf 91       	pop	r28
    428c:	df 91       	pop	r29
    428e:	08 95       	ret

00004290 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    4290:	df 93       	push	r29
    4292:	cf 93       	push	r28
    4294:	00 d0       	rcall	.+0      	; 0x4296 <xStreamBufferBytesAvailable+0x6>
    4296:	00 d0       	rcall	.+0      	; 0x4298 <xStreamBufferBytesAvailable+0x8>
    4298:	00 d0       	rcall	.+0      	; 0x429a <xStreamBufferBytesAvailable+0xa>
    429a:	cd b7       	in	r28, 0x3d	; 61
    429c:	de b7       	in	r29, 0x3e	; 62
    429e:	9e 83       	std	Y+6, r25	; 0x06
    42a0:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    42a2:	8d 81       	ldd	r24, Y+5	; 0x05
    42a4:	9e 81       	ldd	r25, Y+6	; 0x06
    42a6:	9c 83       	std	Y+4, r25	; 0x04
    42a8:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    42aa:	8b 81       	ldd	r24, Y+3	; 0x03
    42ac:	9c 81       	ldd	r25, Y+4	; 0x04
    42ae:	0e 94 32 27 	call	0x4e64	; 0x4e64 <prvBytesInBuffer>
    42b2:	9a 83       	std	Y+2, r25	; 0x02
    42b4:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    42b6:	89 81       	ldd	r24, Y+1	; 0x01
    42b8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    42ba:	26 96       	adiw	r28, 0x06	; 6
    42bc:	0f b6       	in	r0, 0x3f	; 63
    42be:	f8 94       	cli
    42c0:	de bf       	out	0x3e, r29	; 62
    42c2:	0f be       	out	0x3f, r0	; 63
    42c4:	cd bf       	out	0x3d, r28	; 61
    42c6:	cf 91       	pop	r28
    42c8:	df 91       	pop	r29
    42ca:	08 95       	ret

000042cc <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    42cc:	ef 92       	push	r14
    42ce:	ff 92       	push	r15
    42d0:	0f 93       	push	r16
    42d2:	1f 93       	push	r17
    42d4:	df 93       	push	r29
    42d6:	cf 93       	push	r28
    42d8:	cd b7       	in	r28, 0x3d	; 61
    42da:	de b7       	in	r29, 0x3e	; 62
    42dc:	63 97       	sbiw	r28, 0x13	; 19
    42de:	0f b6       	in	r0, 0x3f	; 63
    42e0:	f8 94       	cli
    42e2:	de bf       	out	0x3e, r29	; 62
    42e4:	0f be       	out	0x3f, r0	; 63
    42e6:	cd bf       	out	0x3d, r28	; 61
    42e8:	9d 87       	std	Y+13, r25	; 0x0d
    42ea:	8c 87       	std	Y+12, r24	; 0x0c
    42ec:	7f 87       	std	Y+15, r23	; 0x0f
    42ee:	6e 87       	std	Y+14, r22	; 0x0e
    42f0:	59 8b       	std	Y+17, r21	; 0x11
    42f2:	48 8b       	std	Y+16, r20	; 0x10
    42f4:	3b 8b       	std	Y+19, r19	; 0x13
    42f6:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    42f8:	8c 85       	ldd	r24, Y+12	; 0x0c
    42fa:	9d 85       	ldd	r25, Y+13	; 0x0d
    42fc:	98 87       	std	Y+8, r25	; 0x08
    42fe:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    4300:	1c 82       	std	Y+4, r1	; 0x04
    4302:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    4304:	88 89       	ldd	r24, Y+16	; 0x10
    4306:	99 89       	ldd	r25, Y+17	; 0x11
    4308:	9a 83       	std	Y+2, r25	; 0x02
    430a:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    430c:	ef 81       	ldd	r30, Y+7	; 0x07
    430e:	f8 85       	ldd	r31, Y+8	; 0x08
    4310:	86 85       	ldd	r24, Z+14	; 0x0e
    4312:	88 2f       	mov	r24, r24
    4314:	90 e0       	ldi	r25, 0x00	; 0
    4316:	81 70       	andi	r24, 0x01	; 1
    4318:	90 70       	andi	r25, 0x00	; 0
    431a:	88 23       	and	r24, r24
    431c:	29 f0       	breq	.+10     	; 0x4328 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    431e:	89 81       	ldd	r24, Y+1	; 0x01
    4320:	9a 81       	ldd	r25, Y+2	; 0x02
    4322:	02 96       	adiw	r24, 0x02	; 2
    4324:	9a 83       	std	Y+2, r25	; 0x02
    4326:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    4328:	8a 89       	ldd	r24, Y+18	; 0x12
    432a:	9b 89       	ldd	r25, Y+19	; 0x13
    432c:	00 97       	sbiw	r24, 0x00	; 0
    432e:	09 f4       	brne	.+2      	; 0x4332 <xStreamBufferSend+0x66>
    4330:	40 c0       	rjmp	.+128    	; 0x43b2 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    4332:	ce 01       	movw	r24, r28
    4334:	09 96       	adiw	r24, 0x09	; 9
    4336:	0e 94 6d 2f 	call	0x5eda	; 0x5eda <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    433a:	0f b6       	in	r0, 0x3f	; 63
    433c:	f8 94       	cli
    433e:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    4340:	8f 81       	ldd	r24, Y+7	; 0x07
    4342:	98 85       	ldd	r25, Y+8	; 0x08
    4344:	0e 94 02 21 	call	0x4204	; 0x4204 <xStreamBufferSpacesAvailable>
    4348:	9c 83       	std	Y+4, r25	; 0x04
    434a:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    434c:	2b 81       	ldd	r18, Y+3	; 0x03
    434e:	3c 81       	ldd	r19, Y+4	; 0x04
    4350:	89 81       	ldd	r24, Y+1	; 0x01
    4352:	9a 81       	ldd	r25, Y+2	; 0x02
    4354:	28 17       	cp	r18, r24
    4356:	39 07       	cpc	r19, r25
    4358:	50 f5       	brcc	.+84     	; 0x43ae <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    435a:	80 e0       	ldi	r24, 0x00	; 0
    435c:	90 e0       	ldi	r25, 0x00	; 0
    435e:	0e 94 7d 34 	call	0x68fa	; 0x68fa <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    4362:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskGetCurrentTaskHandle>
    4366:	ef 81       	ldd	r30, Y+7	; 0x07
    4368:	f8 85       	ldd	r31, Y+8	; 0x08
    436a:	93 87       	std	Z+11, r25	; 0x0b
    436c:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    436e:	0f 90       	pop	r0
    4370:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    4372:	ea 89       	ldd	r30, Y+18	; 0x12
    4374:	fb 89       	ldd	r31, Y+19	; 0x13
    4376:	60 e0       	ldi	r22, 0x00	; 0
    4378:	70 e0       	ldi	r23, 0x00	; 0
    437a:	80 e0       	ldi	r24, 0x00	; 0
    437c:	90 e0       	ldi	r25, 0x00	; 0
    437e:	20 e0       	ldi	r18, 0x00	; 0
    4380:	30 e0       	ldi	r19, 0x00	; 0
    4382:	40 e0       	ldi	r20, 0x00	; 0
    4384:	50 e0       	ldi	r21, 0x00	; 0
    4386:	00 e0       	ldi	r16, 0x00	; 0
    4388:	10 e0       	ldi	r17, 0x00	; 0
    438a:	7f 01       	movw	r14, r30
    438c:	0e 94 86 31 	call	0x630c	; 0x630c <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    4390:	ef 81       	ldd	r30, Y+7	; 0x07
    4392:	f8 85       	ldd	r31, Y+8	; 0x08
    4394:	13 86       	std	Z+11, r1	; 0x0b
    4396:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    4398:	ce 01       	movw	r24, r28
    439a:	09 96       	adiw	r24, 0x09	; 9
    439c:	9e 01       	movw	r18, r28
    439e:	2e 5e       	subi	r18, 0xEE	; 238
    43a0:	3f 4f       	sbci	r19, 0xFF	; 255
    43a2:	b9 01       	movw	r22, r18
    43a4:	0e 94 a4 2f 	call	0x5f48	; 0x5f48 <xTaskCheckForTimeOut>
    43a8:	88 23       	and	r24, r24
    43aa:	39 f2       	breq	.-114    	; 0x433a <xStreamBufferSend+0x6e>
    43ac:	02 c0       	rjmp	.+4      	; 0x43b2 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    43ae:	0f 90       	pop	r0
    43b0:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    43b2:	8b 81       	ldd	r24, Y+3	; 0x03
    43b4:	9c 81       	ldd	r25, Y+4	; 0x04
    43b6:	00 97       	sbiw	r24, 0x00	; 0
    43b8:	31 f4       	brne	.+12     	; 0x43c6 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    43ba:	8f 81       	ldd	r24, Y+7	; 0x07
    43bc:	98 85       	ldd	r25, Y+8	; 0x08
    43be:	0e 94 02 21 	call	0x4204	; 0x4204 <xStreamBufferSpacesAvailable>
    43c2:	9c 83       	std	Y+4, r25	; 0x04
    43c4:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    43c6:	8f 81       	ldd	r24, Y+7	; 0x07
    43c8:	98 85       	ldd	r25, Y+8	; 0x08
    43ca:	2e 85       	ldd	r18, Y+14	; 0x0e
    43cc:	3f 85       	ldd	r19, Y+15	; 0x0f
    43ce:	48 89       	ldd	r20, Y+16	; 0x10
    43d0:	59 89       	ldd	r21, Y+17	; 0x11
    43d2:	eb 81       	ldd	r30, Y+3	; 0x03
    43d4:	fc 81       	ldd	r31, Y+4	; 0x04
    43d6:	a9 81       	ldd	r26, Y+1	; 0x01
    43d8:	ba 81       	ldd	r27, Y+2	; 0x02
    43da:	b9 01       	movw	r22, r18
    43dc:	9f 01       	movw	r18, r30
    43de:	8d 01       	movw	r16, r26
    43e0:	0e 94 ab 22 	call	0x4556	; 0x4556 <prvWriteMessageToBuffer>
    43e4:	9e 83       	std	Y+6, r25	; 0x06
    43e6:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    43e8:	8d 81       	ldd	r24, Y+5	; 0x05
    43ea:	9e 81       	ldd	r25, Y+6	; 0x06
    43ec:	00 97       	sbiw	r24, 0x00	; 0
    43ee:	39 f1       	breq	.+78     	; 0x443e <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    43f0:	8f 81       	ldd	r24, Y+7	; 0x07
    43f2:	98 85       	ldd	r25, Y+8	; 0x08
    43f4:	0e 94 32 27 	call	0x4e64	; 0x4e64 <prvBytesInBuffer>
    43f8:	9c 01       	movw	r18, r24
    43fa:	ef 81       	ldd	r30, Y+7	; 0x07
    43fc:	f8 85       	ldd	r31, Y+8	; 0x08
    43fe:	86 81       	ldd	r24, Z+6	; 0x06
    4400:	97 81       	ldd	r25, Z+7	; 0x07
    4402:	28 17       	cp	r18, r24
    4404:	39 07       	cpc	r19, r25
    4406:	d8 f0       	brcs	.+54     	; 0x443e <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    4408:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
    440c:	ef 81       	ldd	r30, Y+7	; 0x07
    440e:	f8 85       	ldd	r31, Y+8	; 0x08
    4410:	80 85       	ldd	r24, Z+8	; 0x08
    4412:	91 85       	ldd	r25, Z+9	; 0x09
    4414:	00 97       	sbiw	r24, 0x00	; 0
    4416:	89 f0       	breq	.+34     	; 0x443a <xStreamBufferSend+0x16e>
    4418:	ef 81       	ldd	r30, Y+7	; 0x07
    441a:	f8 85       	ldd	r31, Y+8	; 0x08
    441c:	80 85       	ldd	r24, Z+8	; 0x08
    441e:	91 85       	ldd	r25, Z+9	; 0x09
    4420:	40 e0       	ldi	r20, 0x00	; 0
    4422:	50 e0       	ldi	r21, 0x00	; 0
    4424:	60 e0       	ldi	r22, 0x00	; 0
    4426:	70 e0       	ldi	r23, 0x00	; 0
    4428:	20 e0       	ldi	r18, 0x00	; 0
    442a:	00 e0       	ldi	r16, 0x00	; 0
    442c:	10 e0       	ldi	r17, 0x00	; 0
    442e:	0e 94 22 32 	call	0x6444	; 0x6444 <xTaskGenericNotify>
    4432:	ef 81       	ldd	r30, Y+7	; 0x07
    4434:	f8 85       	ldd	r31, Y+8	; 0x08
    4436:	11 86       	std	Z+9, r1	; 0x09
    4438:	10 86       	std	Z+8, r1	; 0x08
    443a:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    443e:	8d 81       	ldd	r24, Y+5	; 0x05
    4440:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4442:	63 96       	adiw	r28, 0x13	; 19
    4444:	0f b6       	in	r0, 0x3f	; 63
    4446:	f8 94       	cli
    4448:	de bf       	out	0x3e, r29	; 62
    444a:	0f be       	out	0x3f, r0	; 63
    444c:	cd bf       	out	0x3d, r28	; 61
    444e:	cf 91       	pop	r28
    4450:	df 91       	pop	r29
    4452:	1f 91       	pop	r17
    4454:	0f 91       	pop	r16
    4456:	ff 90       	pop	r15
    4458:	ef 90       	pop	r14
    445a:	08 95       	ret

0000445c <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    445c:	ef 92       	push	r14
    445e:	ff 92       	push	r15
    4460:	0f 93       	push	r16
    4462:	1f 93       	push	r17
    4464:	df 93       	push	r29
    4466:	cf 93       	push	r28
    4468:	cd b7       	in	r28, 0x3d	; 61
    446a:	de b7       	in	r29, 0x3e	; 62
    446c:	61 97       	sbiw	r28, 0x11	; 17
    446e:	0f b6       	in	r0, 0x3f	; 63
    4470:	f8 94       	cli
    4472:	de bf       	out	0x3e, r29	; 62
    4474:	0f be       	out	0x3f, r0	; 63
    4476:	cd bf       	out	0x3d, r28	; 61
    4478:	9b 87       	std	Y+11, r25	; 0x0b
    447a:	8a 87       	std	Y+10, r24	; 0x0a
    447c:	7d 87       	std	Y+13, r23	; 0x0d
    447e:	6c 87       	std	Y+12, r22	; 0x0c
    4480:	5f 87       	std	Y+15, r21	; 0x0f
    4482:	4e 87       	std	Y+14, r20	; 0x0e
    4484:	39 8b       	std	Y+17, r19	; 0x11
    4486:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4488:	8a 85       	ldd	r24, Y+10	; 0x0a
    448a:	9b 85       	ldd	r25, Y+11	; 0x0b
    448c:	99 87       	std	Y+9, r25	; 0x09
    448e:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    4490:	8e 85       	ldd	r24, Y+14	; 0x0e
    4492:	9f 85       	ldd	r25, Y+15	; 0x0f
    4494:	9b 83       	std	Y+3, r25	; 0x03
    4496:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4498:	e8 85       	ldd	r30, Y+8	; 0x08
    449a:	f9 85       	ldd	r31, Y+9	; 0x09
    449c:	86 85       	ldd	r24, Z+14	; 0x0e
    449e:	88 2f       	mov	r24, r24
    44a0:	90 e0       	ldi	r25, 0x00	; 0
    44a2:	81 70       	andi	r24, 0x01	; 1
    44a4:	90 70       	andi	r25, 0x00	; 0
    44a6:	88 23       	and	r24, r24
    44a8:	29 f0       	breq	.+10     	; 0x44b4 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    44aa:	8a 81       	ldd	r24, Y+2	; 0x02
    44ac:	9b 81       	ldd	r25, Y+3	; 0x03
    44ae:	02 96       	adiw	r24, 0x02	; 2
    44b0:	9b 83       	std	Y+3, r25	; 0x03
    44b2:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    44b4:	88 85       	ldd	r24, Y+8	; 0x08
    44b6:	99 85       	ldd	r25, Y+9	; 0x09
    44b8:	0e 94 02 21 	call	0x4204	; 0x4204 <xStreamBufferSpacesAvailable>
    44bc:	9d 83       	std	Y+5, r25	; 0x05
    44be:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    44c0:	88 85       	ldd	r24, Y+8	; 0x08
    44c2:	99 85       	ldd	r25, Y+9	; 0x09
    44c4:	2c 85       	ldd	r18, Y+12	; 0x0c
    44c6:	3d 85       	ldd	r19, Y+13	; 0x0d
    44c8:	4e 85       	ldd	r20, Y+14	; 0x0e
    44ca:	5f 85       	ldd	r21, Y+15	; 0x0f
    44cc:	ec 81       	ldd	r30, Y+4	; 0x04
    44ce:	fd 81       	ldd	r31, Y+5	; 0x05
    44d0:	aa 81       	ldd	r26, Y+2	; 0x02
    44d2:	bb 81       	ldd	r27, Y+3	; 0x03
    44d4:	b9 01       	movw	r22, r18
    44d6:	9f 01       	movw	r18, r30
    44d8:	8d 01       	movw	r16, r26
    44da:	0e 94 ab 22 	call	0x4556	; 0x4556 <prvWriteMessageToBuffer>
    44de:	9f 83       	std	Y+7, r25	; 0x07
    44e0:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    44e2:	8e 81       	ldd	r24, Y+6	; 0x06
    44e4:	9f 81       	ldd	r25, Y+7	; 0x07
    44e6:	00 97       	sbiw	r24, 0x00	; 0
    44e8:	39 f1       	breq	.+78     	; 0x4538 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    44ea:	88 85       	ldd	r24, Y+8	; 0x08
    44ec:	99 85       	ldd	r25, Y+9	; 0x09
    44ee:	0e 94 32 27 	call	0x4e64	; 0x4e64 <prvBytesInBuffer>
    44f2:	9c 01       	movw	r18, r24
    44f4:	e8 85       	ldd	r30, Y+8	; 0x08
    44f6:	f9 85       	ldd	r31, Y+9	; 0x09
    44f8:	86 81       	ldd	r24, Z+6	; 0x06
    44fa:	97 81       	ldd	r25, Z+7	; 0x07
    44fc:	28 17       	cp	r18, r24
    44fe:	39 07       	cpc	r19, r25
    4500:	d8 f0       	brcs	.+54     	; 0x4538 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    4502:	19 82       	std	Y+1, r1	; 0x01
    4504:	e8 85       	ldd	r30, Y+8	; 0x08
    4506:	f9 85       	ldd	r31, Y+9	; 0x09
    4508:	80 85       	ldd	r24, Z+8	; 0x08
    450a:	91 85       	ldd	r25, Z+9	; 0x09
    450c:	00 97       	sbiw	r24, 0x00	; 0
    450e:	a1 f0       	breq	.+40     	; 0x4538 <xStreamBufferSendFromISR+0xdc>
    4510:	e8 85       	ldd	r30, Y+8	; 0x08
    4512:	f9 85       	ldd	r31, Y+9	; 0x09
    4514:	80 85       	ldd	r24, Z+8	; 0x08
    4516:	91 85       	ldd	r25, Z+9	; 0x09
    4518:	e8 89       	ldd	r30, Y+16	; 0x10
    451a:	f9 89       	ldd	r31, Y+17	; 0x11
    451c:	40 e0       	ldi	r20, 0x00	; 0
    451e:	50 e0       	ldi	r21, 0x00	; 0
    4520:	60 e0       	ldi	r22, 0x00	; 0
    4522:	70 e0       	ldi	r23, 0x00	; 0
    4524:	20 e0       	ldi	r18, 0x00	; 0
    4526:	00 e0       	ldi	r16, 0x00	; 0
    4528:	10 e0       	ldi	r17, 0x00	; 0
    452a:	7f 01       	movw	r14, r30
    452c:	0e 94 ff 32 	call	0x65fe	; 0x65fe <xTaskGenericNotifyFromISR>
    4530:	e8 85       	ldd	r30, Y+8	; 0x08
    4532:	f9 85       	ldd	r31, Y+9	; 0x09
    4534:	11 86       	std	Z+9, r1	; 0x09
    4536:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    4538:	8e 81       	ldd	r24, Y+6	; 0x06
    453a:	9f 81       	ldd	r25, Y+7	; 0x07
}
    453c:	61 96       	adiw	r28, 0x11	; 17
    453e:	0f b6       	in	r0, 0x3f	; 63
    4540:	f8 94       	cli
    4542:	de bf       	out	0x3e, r29	; 62
    4544:	0f be       	out	0x3f, r0	; 63
    4546:	cd bf       	out	0x3d, r28	; 61
    4548:	cf 91       	pop	r28
    454a:	df 91       	pop	r29
    454c:	1f 91       	pop	r17
    454e:	0f 91       	pop	r16
    4550:	ff 90       	pop	r15
    4552:	ef 90       	pop	r14
    4554:	08 95       	ret

00004556 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    4556:	0f 93       	push	r16
    4558:	1f 93       	push	r17
    455a:	df 93       	push	r29
    455c:	cf 93       	push	r28
    455e:	cd b7       	in	r28, 0x3d	; 61
    4560:	de b7       	in	r29, 0x3e	; 62
    4562:	61 97       	sbiw	r28, 0x11	; 17
    4564:	0f b6       	in	r0, 0x3f	; 63
    4566:	f8 94       	cli
    4568:	de bf       	out	0x3e, r29	; 62
    456a:	0f be       	out	0x3f, r0	; 63
    456c:	cd bf       	out	0x3d, r28	; 61
    456e:	9d 83       	std	Y+5, r25	; 0x05
    4570:	8c 83       	std	Y+4, r24	; 0x04
    4572:	7f 83       	std	Y+7, r23	; 0x07
    4574:	6e 83       	std	Y+6, r22	; 0x06
    4576:	59 87       	std	Y+9, r21	; 0x09
    4578:	48 87       	std	Y+8, r20	; 0x08
    457a:	3b 87       	std	Y+11, r19	; 0x0b
    457c:	2a 87       	std	Y+10, r18	; 0x0a
    457e:	1d 87       	std	Y+13, r17	; 0x0d
    4580:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    4582:	8a 85       	ldd	r24, Y+10	; 0x0a
    4584:	9b 85       	ldd	r25, Y+11	; 0x0b
    4586:	00 97       	sbiw	r24, 0x00	; 0
    4588:	11 f4       	brne	.+4      	; 0x458e <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    458a:	1b 82       	std	Y+3, r1	; 0x03
    458c:	38 c0       	rjmp	.+112    	; 0x45fe <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    458e:	ec 81       	ldd	r30, Y+4	; 0x04
    4590:	fd 81       	ldd	r31, Y+5	; 0x05
    4592:	86 85       	ldd	r24, Z+14	; 0x0e
    4594:	88 2f       	mov	r24, r24
    4596:	90 e0       	ldi	r25, 0x00	; 0
    4598:	81 70       	andi	r24, 0x01	; 1
    459a:	90 70       	andi	r25, 0x00	; 0
    459c:	00 97       	sbiw	r24, 0x00	; 0
    459e:	d1 f4       	brne	.+52     	; 0x45d4 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    45a0:	81 e0       	ldi	r24, 0x01	; 1
    45a2:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    45a4:	28 85       	ldd	r18, Y+8	; 0x08
    45a6:	39 85       	ldd	r19, Y+9	; 0x09
    45a8:	39 8b       	std	Y+17, r19	; 0x11
    45aa:	28 8b       	std	Y+16, r18	; 0x10
    45ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    45ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    45b0:	9f 87       	std	Y+15, r25	; 0x0f
    45b2:	8e 87       	std	Y+14, r24	; 0x0e
    45b4:	2e 85       	ldd	r18, Y+14	; 0x0e
    45b6:	3f 85       	ldd	r19, Y+15	; 0x0f
    45b8:	88 89       	ldd	r24, Y+16	; 0x10
    45ba:	99 89       	ldd	r25, Y+17	; 0x11
    45bc:	82 17       	cp	r24, r18
    45be:	93 07       	cpc	r25, r19
    45c0:	20 f4       	brcc	.+8      	; 0x45ca <prvWriteMessageToBuffer+0x74>
    45c2:	28 89       	ldd	r18, Y+16	; 0x10
    45c4:	39 89       	ldd	r19, Y+17	; 0x11
    45c6:	3f 87       	std	Y+15, r19	; 0x0f
    45c8:	2e 87       	std	Y+14, r18	; 0x0e
    45ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    45cc:	9f 85       	ldd	r25, Y+15	; 0x0f
    45ce:	99 87       	std	Y+9, r25	; 0x09
    45d0:	88 87       	std	Y+8, r24	; 0x08
    45d2:	15 c0       	rjmp	.+42     	; 0x45fe <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    45d4:	2a 85       	ldd	r18, Y+10	; 0x0a
    45d6:	3b 85       	ldd	r19, Y+11	; 0x0b
    45d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    45da:	9d 85       	ldd	r25, Y+13	; 0x0d
    45dc:	28 17       	cp	r18, r24
    45de:	39 07       	cpc	r19, r25
    45e0:	68 f0       	brcs	.+26     	; 0x45fc <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    45e2:	81 e0       	ldi	r24, 0x01	; 1
    45e4:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    45e6:	9e 01       	movw	r18, r28
    45e8:	28 5f       	subi	r18, 0xF8	; 248
    45ea:	3f 4f       	sbci	r19, 0xFF	; 255
    45ec:	8c 81       	ldd	r24, Y+4	; 0x04
    45ee:	9d 81       	ldd	r25, Y+5	; 0x05
    45f0:	b9 01       	movw	r22, r18
    45f2:	42 e0       	ldi	r20, 0x02	; 2
    45f4:	50 e0       	ldi	r21, 0x00	; 0
    45f6:	0e 94 f8 25 	call	0x4bf0	; 0x4bf0 <prvWriteBytesToBuffer>
    45fa:	01 c0       	rjmp	.+2      	; 0x45fe <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    45fc:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    45fe:	8b 81       	ldd	r24, Y+3	; 0x03
    4600:	88 23       	and	r24, r24
    4602:	61 f0       	breq	.+24     	; 0x461c <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    4604:	2e 81       	ldd	r18, Y+6	; 0x06
    4606:	3f 81       	ldd	r19, Y+7	; 0x07
    4608:	48 85       	ldd	r20, Y+8	; 0x08
    460a:	59 85       	ldd	r21, Y+9	; 0x09
    460c:	8c 81       	ldd	r24, Y+4	; 0x04
    460e:	9d 81       	ldd	r25, Y+5	; 0x05
    4610:	b9 01       	movw	r22, r18
    4612:	0e 94 f8 25 	call	0x4bf0	; 0x4bf0 <prvWriteBytesToBuffer>
    4616:	9a 83       	std	Y+2, r25	; 0x02
    4618:	89 83       	std	Y+1, r24	; 0x01
    461a:	02 c0       	rjmp	.+4      	; 0x4620 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    461c:	1a 82       	std	Y+2, r1	; 0x02
    461e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4620:	89 81       	ldd	r24, Y+1	; 0x01
    4622:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4624:	61 96       	adiw	r28, 0x11	; 17
    4626:	0f b6       	in	r0, 0x3f	; 63
    4628:	f8 94       	cli
    462a:	de bf       	out	0x3e, r29	; 62
    462c:	0f be       	out	0x3f, r0	; 63
    462e:	cd bf       	out	0x3d, r28	; 61
    4630:	cf 91       	pop	r28
    4632:	df 91       	pop	r29
    4634:	1f 91       	pop	r17
    4636:	0f 91       	pop	r16
    4638:	08 95       	ret

0000463a <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    463a:	ef 92       	push	r14
    463c:	ff 92       	push	r15
    463e:	0f 93       	push	r16
    4640:	1f 93       	push	r17
    4642:	df 93       	push	r29
    4644:	cf 93       	push	r28
    4646:	cd b7       	in	r28, 0x3d	; 61
    4648:	de b7       	in	r29, 0x3e	; 62
    464a:	60 97       	sbiw	r28, 0x10	; 16
    464c:	0f b6       	in	r0, 0x3f	; 63
    464e:	f8 94       	cli
    4650:	de bf       	out	0x3e, r29	; 62
    4652:	0f be       	out	0x3f, r0	; 63
    4654:	cd bf       	out	0x3d, r28	; 61
    4656:	9a 87       	std	Y+10, r25	; 0x0a
    4658:	89 87       	std	Y+9, r24	; 0x09
    465a:	7c 87       	std	Y+12, r23	; 0x0c
    465c:	6b 87       	std	Y+11, r22	; 0x0b
    465e:	5e 87       	std	Y+14, r21	; 0x0e
    4660:	4d 87       	std	Y+13, r20	; 0x0d
    4662:	38 8b       	std	Y+16, r19	; 0x10
    4664:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4666:	89 85       	ldd	r24, Y+9	; 0x09
    4668:	9a 85       	ldd	r25, Y+10	; 0x0a
    466a:	98 87       	std	Y+8, r25	; 0x08
    466c:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    466e:	1e 82       	std	Y+6, r1	; 0x06
    4670:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4672:	ef 81       	ldd	r30, Y+7	; 0x07
    4674:	f8 85       	ldd	r31, Y+8	; 0x08
    4676:	86 85       	ldd	r24, Z+14	; 0x0e
    4678:	88 2f       	mov	r24, r24
    467a:	90 e0       	ldi	r25, 0x00	; 0
    467c:	81 70       	andi	r24, 0x01	; 1
    467e:	90 70       	andi	r25, 0x00	; 0
    4680:	88 23       	and	r24, r24
    4682:	29 f0       	breq	.+10     	; 0x468e <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4684:	82 e0       	ldi	r24, 0x02	; 2
    4686:	90 e0       	ldi	r25, 0x00	; 0
    4688:	9a 83       	std	Y+2, r25	; 0x02
    468a:	89 83       	std	Y+1, r24	; 0x01
    468c:	02 c0       	rjmp	.+4      	; 0x4692 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    468e:	1a 82       	std	Y+2, r1	; 0x02
    4690:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    4692:	8f 85       	ldd	r24, Y+15	; 0x0f
    4694:	98 89       	ldd	r25, Y+16	; 0x10
    4696:	00 97       	sbiw	r24, 0x00	; 0
    4698:	09 f4       	brne	.+2      	; 0x469c <xStreamBufferReceive+0x62>
    469a:	3d c0       	rjmp	.+122    	; 0x4716 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    469c:	0f b6       	in	r0, 0x3f	; 63
    469e:	f8 94       	cli
    46a0:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    46a2:	8f 81       	ldd	r24, Y+7	; 0x07
    46a4:	98 85       	ldd	r25, Y+8	; 0x08
    46a6:	0e 94 32 27 	call	0x4e64	; 0x4e64 <prvBytesInBuffer>
    46aa:	9c 83       	std	Y+4, r25	; 0x04
    46ac:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    46ae:	2b 81       	ldd	r18, Y+3	; 0x03
    46b0:	3c 81       	ldd	r19, Y+4	; 0x04
    46b2:	89 81       	ldd	r24, Y+1	; 0x01
    46b4:	9a 81       	ldd	r25, Y+2	; 0x02
    46b6:	82 17       	cp	r24, r18
    46b8:	93 07       	cpc	r25, r19
    46ba:	50 f0       	brcs	.+20     	; 0x46d0 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    46bc:	80 e0       	ldi	r24, 0x00	; 0
    46be:	90 e0       	ldi	r25, 0x00	; 0
    46c0:	0e 94 7d 34 	call	0x68fa	; 0x68fa <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    46c4:	0e 94 d6 30 	call	0x61ac	; 0x61ac <xTaskGetCurrentTaskHandle>
    46c8:	ef 81       	ldd	r30, Y+7	; 0x07
    46ca:	f8 85       	ldd	r31, Y+8	; 0x08
    46cc:	91 87       	std	Z+9, r25	; 0x09
    46ce:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    46d0:	0f 90       	pop	r0
    46d2:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    46d4:	2b 81       	ldd	r18, Y+3	; 0x03
    46d6:	3c 81       	ldd	r19, Y+4	; 0x04
    46d8:	89 81       	ldd	r24, Y+1	; 0x01
    46da:	9a 81       	ldd	r25, Y+2	; 0x02
    46dc:	82 17       	cp	r24, r18
    46de:	93 07       	cpc	r25, r19
    46e0:	00 f1       	brcs	.+64     	; 0x4722 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    46e2:	ef 85       	ldd	r30, Y+15	; 0x0f
    46e4:	f8 89       	ldd	r31, Y+16	; 0x10
    46e6:	60 e0       	ldi	r22, 0x00	; 0
    46e8:	70 e0       	ldi	r23, 0x00	; 0
    46ea:	80 e0       	ldi	r24, 0x00	; 0
    46ec:	90 e0       	ldi	r25, 0x00	; 0
    46ee:	20 e0       	ldi	r18, 0x00	; 0
    46f0:	30 e0       	ldi	r19, 0x00	; 0
    46f2:	40 e0       	ldi	r20, 0x00	; 0
    46f4:	50 e0       	ldi	r21, 0x00	; 0
    46f6:	00 e0       	ldi	r16, 0x00	; 0
    46f8:	10 e0       	ldi	r17, 0x00	; 0
    46fa:	7f 01       	movw	r14, r30
    46fc:	0e 94 86 31 	call	0x630c	; 0x630c <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    4700:	ef 81       	ldd	r30, Y+7	; 0x07
    4702:	f8 85       	ldd	r31, Y+8	; 0x08
    4704:	11 86       	std	Z+9, r1	; 0x09
    4706:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4708:	8f 81       	ldd	r24, Y+7	; 0x07
    470a:	98 85       	ldd	r25, Y+8	; 0x08
    470c:	0e 94 32 27 	call	0x4e64	; 0x4e64 <prvBytesInBuffer>
    4710:	9c 83       	std	Y+4, r25	; 0x04
    4712:	8b 83       	std	Y+3, r24	; 0x03
    4714:	06 c0       	rjmp	.+12     	; 0x4722 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4716:	8f 81       	ldd	r24, Y+7	; 0x07
    4718:	98 85       	ldd	r25, Y+8	; 0x08
    471a:	0e 94 32 27 	call	0x4e64	; 0x4e64 <prvBytesInBuffer>
    471e:	9c 83       	std	Y+4, r25	; 0x04
    4720:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    4722:	2b 81       	ldd	r18, Y+3	; 0x03
    4724:	3c 81       	ldd	r19, Y+4	; 0x04
    4726:	89 81       	ldd	r24, Y+1	; 0x01
    4728:	9a 81       	ldd	r25, Y+2	; 0x02
    472a:	82 17       	cp	r24, r18
    472c:	93 07       	cpc	r25, r19
    472e:	80 f5       	brcc	.+96     	; 0x4790 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    4730:	8f 81       	ldd	r24, Y+7	; 0x07
    4732:	98 85       	ldd	r25, Y+8	; 0x08
    4734:	2b 85       	ldd	r18, Y+11	; 0x0b
    4736:	3c 85       	ldd	r19, Y+12	; 0x0c
    4738:	4d 85       	ldd	r20, Y+13	; 0x0d
    473a:	5e 85       	ldd	r21, Y+14	; 0x0e
    473c:	eb 81       	ldd	r30, Y+3	; 0x03
    473e:	fc 81       	ldd	r31, Y+4	; 0x04
    4740:	a9 81       	ldd	r26, Y+1	; 0x01
    4742:	ba 81       	ldd	r27, Y+2	; 0x02
    4744:	b9 01       	movw	r22, r18
    4746:	9f 01       	movw	r18, r30
    4748:	8d 01       	movw	r16, r26
    474a:	0e 94 a1 24 	call	0x4942	; 0x4942 <prvReadMessageFromBuffer>
    474e:	9e 83       	std	Y+6, r25	; 0x06
    4750:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    4752:	8d 81       	ldd	r24, Y+5	; 0x05
    4754:	9e 81       	ldd	r25, Y+6	; 0x06
    4756:	00 97       	sbiw	r24, 0x00	; 0
    4758:	d9 f0       	breq	.+54     	; 0x4790 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    475a:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
    475e:	ef 81       	ldd	r30, Y+7	; 0x07
    4760:	f8 85       	ldd	r31, Y+8	; 0x08
    4762:	82 85       	ldd	r24, Z+10	; 0x0a
    4764:	93 85       	ldd	r25, Z+11	; 0x0b
    4766:	00 97       	sbiw	r24, 0x00	; 0
    4768:	89 f0       	breq	.+34     	; 0x478c <xStreamBufferReceive+0x152>
    476a:	ef 81       	ldd	r30, Y+7	; 0x07
    476c:	f8 85       	ldd	r31, Y+8	; 0x08
    476e:	82 85       	ldd	r24, Z+10	; 0x0a
    4770:	93 85       	ldd	r25, Z+11	; 0x0b
    4772:	40 e0       	ldi	r20, 0x00	; 0
    4774:	50 e0       	ldi	r21, 0x00	; 0
    4776:	60 e0       	ldi	r22, 0x00	; 0
    4778:	70 e0       	ldi	r23, 0x00	; 0
    477a:	20 e0       	ldi	r18, 0x00	; 0
    477c:	00 e0       	ldi	r16, 0x00	; 0
    477e:	10 e0       	ldi	r17, 0x00	; 0
    4780:	0e 94 22 32 	call	0x6444	; 0x6444 <xTaskGenericNotify>
    4784:	ef 81       	ldd	r30, Y+7	; 0x07
    4786:	f8 85       	ldd	r31, Y+8	; 0x08
    4788:	13 86       	std	Z+11, r1	; 0x0b
    478a:	12 86       	std	Z+10, r1	; 0x0a
    478c:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    4790:	8d 81       	ldd	r24, Y+5	; 0x05
    4792:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4794:	60 96       	adiw	r28, 0x10	; 16
    4796:	0f b6       	in	r0, 0x3f	; 63
    4798:	f8 94       	cli
    479a:	de bf       	out	0x3e, r29	; 62
    479c:	0f be       	out	0x3f, r0	; 63
    479e:	cd bf       	out	0x3d, r28	; 61
    47a0:	cf 91       	pop	r28
    47a2:	df 91       	pop	r29
    47a4:	1f 91       	pop	r17
    47a6:	0f 91       	pop	r16
    47a8:	ff 90       	pop	r15
    47aa:	ef 90       	pop	r14
    47ac:	08 95       	ret

000047ae <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    47ae:	df 93       	push	r29
    47b0:	cf 93       	push	r28
    47b2:	cd b7       	in	r28, 0x3d	; 61
    47b4:	de b7       	in	r29, 0x3e	; 62
    47b6:	2c 97       	sbiw	r28, 0x0c	; 12
    47b8:	0f b6       	in	r0, 0x3f	; 63
    47ba:	f8 94       	cli
    47bc:	de bf       	out	0x3e, r29	; 62
    47be:	0f be       	out	0x3f, r0	; 63
    47c0:	cd bf       	out	0x3d, r28	; 61
    47c2:	9c 87       	std	Y+12, r25	; 0x0c
    47c4:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    47c6:	8b 85       	ldd	r24, Y+11	; 0x0b
    47c8:	9c 85       	ldd	r25, Y+12	; 0x0c
    47ca:	98 87       	std	Y+8, r25	; 0x08
    47cc:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    47ce:	ef 81       	ldd	r30, Y+7	; 0x07
    47d0:	f8 85       	ldd	r31, Y+8	; 0x08
    47d2:	86 85       	ldd	r24, Z+14	; 0x0e
    47d4:	88 2f       	mov	r24, r24
    47d6:	90 e0       	ldi	r25, 0x00	; 0
    47d8:	81 70       	andi	r24, 0x01	; 1
    47da:	90 70       	andi	r25, 0x00	; 0
    47dc:	88 23       	and	r24, r24
    47de:	61 f1       	breq	.+88     	; 0x4838 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    47e0:	8f 81       	ldd	r24, Y+7	; 0x07
    47e2:	98 85       	ldd	r25, Y+8	; 0x08
    47e4:	0e 94 32 27 	call	0x4e64	; 0x4e64 <prvBytesInBuffer>
    47e8:	9c 83       	std	Y+4, r25	; 0x04
    47ea:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    47ec:	8b 81       	ldd	r24, Y+3	; 0x03
    47ee:	9c 81       	ldd	r25, Y+4	; 0x04
    47f0:	83 30       	cpi	r24, 0x03	; 3
    47f2:	91 05       	cpc	r25, r1
    47f4:	f0 f0       	brcs	.+60     	; 0x4832 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    47f6:	ef 81       	ldd	r30, Y+7	; 0x07
    47f8:	f8 85       	ldd	r31, Y+8	; 0x08
    47fa:	80 81       	ld	r24, Z
    47fc:	91 81       	ldd	r25, Z+1	; 0x01
    47fe:	9a 83       	std	Y+2, r25	; 0x02
    4800:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    4802:	9e 01       	movw	r18, r28
    4804:	27 5f       	subi	r18, 0xF7	; 247
    4806:	3f 4f       	sbci	r19, 0xFF	; 255
    4808:	8f 81       	ldd	r24, Y+7	; 0x07
    480a:	98 85       	ldd	r25, Y+8	; 0x08
    480c:	eb 81       	ldd	r30, Y+3	; 0x03
    480e:	fc 81       	ldd	r31, Y+4	; 0x04
    4810:	b9 01       	movw	r22, r18
    4812:	42 e0       	ldi	r20, 0x02	; 2
    4814:	50 e0       	ldi	r21, 0x00	; 0
    4816:	9f 01       	movw	r18, r30
    4818:	0e 94 85 26 	call	0x4d0a	; 0x4d0a <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    481c:	89 85       	ldd	r24, Y+9	; 0x09
    481e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4820:	9e 83       	std	Y+6, r25	; 0x06
    4822:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    4824:	ef 81       	ldd	r30, Y+7	; 0x07
    4826:	f8 85       	ldd	r31, Y+8	; 0x08
    4828:	89 81       	ldd	r24, Y+1	; 0x01
    482a:	9a 81       	ldd	r25, Y+2	; 0x02
    482c:	91 83       	std	Z+1, r25	; 0x01
    482e:	80 83       	st	Z, r24
    4830:	05 c0       	rjmp	.+10     	; 0x483c <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    4832:	1e 82       	std	Y+6, r1	; 0x06
    4834:	1d 82       	std	Y+5, r1	; 0x05
    4836:	02 c0       	rjmp	.+4      	; 0x483c <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    4838:	1e 82       	std	Y+6, r1	; 0x06
    483a:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    483c:	8d 81       	ldd	r24, Y+5	; 0x05
    483e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4840:	2c 96       	adiw	r28, 0x0c	; 12
    4842:	0f b6       	in	r0, 0x3f	; 63
    4844:	f8 94       	cli
    4846:	de bf       	out	0x3e, r29	; 62
    4848:	0f be       	out	0x3f, r0	; 63
    484a:	cd bf       	out	0x3d, r28	; 61
    484c:	cf 91       	pop	r28
    484e:	df 91       	pop	r29
    4850:	08 95       	ret

00004852 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    4852:	ef 92       	push	r14
    4854:	ff 92       	push	r15
    4856:	0f 93       	push	r16
    4858:	1f 93       	push	r17
    485a:	df 93       	push	r29
    485c:	cf 93       	push	r28
    485e:	cd b7       	in	r28, 0x3d	; 61
    4860:	de b7       	in	r29, 0x3e	; 62
    4862:	61 97       	sbiw	r28, 0x11	; 17
    4864:	0f b6       	in	r0, 0x3f	; 63
    4866:	f8 94       	cli
    4868:	de bf       	out	0x3e, r29	; 62
    486a:	0f be       	out	0x3f, r0	; 63
    486c:	cd bf       	out	0x3d, r28	; 61
    486e:	9b 87       	std	Y+11, r25	; 0x0b
    4870:	8a 87       	std	Y+10, r24	; 0x0a
    4872:	7d 87       	std	Y+13, r23	; 0x0d
    4874:	6c 87       	std	Y+12, r22	; 0x0c
    4876:	5f 87       	std	Y+15, r21	; 0x0f
    4878:	4e 87       	std	Y+14, r20	; 0x0e
    487a:	39 8b       	std	Y+17, r19	; 0x11
    487c:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    487e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4880:	9b 85       	ldd	r25, Y+11	; 0x0b
    4882:	99 87       	std	Y+9, r25	; 0x09
    4884:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    4886:	1f 82       	std	Y+7, r1	; 0x07
    4888:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    488a:	e8 85       	ldd	r30, Y+8	; 0x08
    488c:	f9 85       	ldd	r31, Y+9	; 0x09
    488e:	86 85       	ldd	r24, Z+14	; 0x0e
    4890:	88 2f       	mov	r24, r24
    4892:	90 e0       	ldi	r25, 0x00	; 0
    4894:	81 70       	andi	r24, 0x01	; 1
    4896:	90 70       	andi	r25, 0x00	; 0
    4898:	88 23       	and	r24, r24
    489a:	29 f0       	breq	.+10     	; 0x48a6 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    489c:	82 e0       	ldi	r24, 0x02	; 2
    489e:	90 e0       	ldi	r25, 0x00	; 0
    48a0:	9b 83       	std	Y+3, r25	; 0x03
    48a2:	8a 83       	std	Y+2, r24	; 0x02
    48a4:	02 c0       	rjmp	.+4      	; 0x48aa <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    48a6:	1b 82       	std	Y+3, r1	; 0x03
    48a8:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    48aa:	88 85       	ldd	r24, Y+8	; 0x08
    48ac:	99 85       	ldd	r25, Y+9	; 0x09
    48ae:	0e 94 32 27 	call	0x4e64	; 0x4e64 <prvBytesInBuffer>
    48b2:	9d 83       	std	Y+5, r25	; 0x05
    48b4:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    48b6:	2c 81       	ldd	r18, Y+4	; 0x04
    48b8:	3d 81       	ldd	r19, Y+5	; 0x05
    48ba:	8a 81       	ldd	r24, Y+2	; 0x02
    48bc:	9b 81       	ldd	r25, Y+3	; 0x03
    48be:	82 17       	cp	r24, r18
    48c0:	93 07       	cpc	r25, r19
    48c2:	80 f5       	brcc	.+96     	; 0x4924 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    48c4:	88 85       	ldd	r24, Y+8	; 0x08
    48c6:	99 85       	ldd	r25, Y+9	; 0x09
    48c8:	2c 85       	ldd	r18, Y+12	; 0x0c
    48ca:	3d 85       	ldd	r19, Y+13	; 0x0d
    48cc:	4e 85       	ldd	r20, Y+14	; 0x0e
    48ce:	5f 85       	ldd	r21, Y+15	; 0x0f
    48d0:	ec 81       	ldd	r30, Y+4	; 0x04
    48d2:	fd 81       	ldd	r31, Y+5	; 0x05
    48d4:	aa 81       	ldd	r26, Y+2	; 0x02
    48d6:	bb 81       	ldd	r27, Y+3	; 0x03
    48d8:	b9 01       	movw	r22, r18
    48da:	9f 01       	movw	r18, r30
    48dc:	8d 01       	movw	r16, r26
    48de:	0e 94 a1 24 	call	0x4942	; 0x4942 <prvReadMessageFromBuffer>
    48e2:	9f 83       	std	Y+7, r25	; 0x07
    48e4:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    48e6:	8e 81       	ldd	r24, Y+6	; 0x06
    48e8:	9f 81       	ldd	r25, Y+7	; 0x07
    48ea:	00 97       	sbiw	r24, 0x00	; 0
    48ec:	d9 f0       	breq	.+54     	; 0x4924 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    48ee:	19 82       	std	Y+1, r1	; 0x01
    48f0:	e8 85       	ldd	r30, Y+8	; 0x08
    48f2:	f9 85       	ldd	r31, Y+9	; 0x09
    48f4:	82 85       	ldd	r24, Z+10	; 0x0a
    48f6:	93 85       	ldd	r25, Z+11	; 0x0b
    48f8:	00 97       	sbiw	r24, 0x00	; 0
    48fa:	a1 f0       	breq	.+40     	; 0x4924 <xStreamBufferReceiveFromISR+0xd2>
    48fc:	e8 85       	ldd	r30, Y+8	; 0x08
    48fe:	f9 85       	ldd	r31, Y+9	; 0x09
    4900:	82 85       	ldd	r24, Z+10	; 0x0a
    4902:	93 85       	ldd	r25, Z+11	; 0x0b
    4904:	e8 89       	ldd	r30, Y+16	; 0x10
    4906:	f9 89       	ldd	r31, Y+17	; 0x11
    4908:	40 e0       	ldi	r20, 0x00	; 0
    490a:	50 e0       	ldi	r21, 0x00	; 0
    490c:	60 e0       	ldi	r22, 0x00	; 0
    490e:	70 e0       	ldi	r23, 0x00	; 0
    4910:	20 e0       	ldi	r18, 0x00	; 0
    4912:	00 e0       	ldi	r16, 0x00	; 0
    4914:	10 e0       	ldi	r17, 0x00	; 0
    4916:	7f 01       	movw	r14, r30
    4918:	0e 94 ff 32 	call	0x65fe	; 0x65fe <xTaskGenericNotifyFromISR>
    491c:	e8 85       	ldd	r30, Y+8	; 0x08
    491e:	f9 85       	ldd	r31, Y+9	; 0x09
    4920:	13 86       	std	Z+11, r1	; 0x0b
    4922:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    4924:	8e 81       	ldd	r24, Y+6	; 0x06
    4926:	9f 81       	ldd	r25, Y+7	; 0x07
}
    4928:	61 96       	adiw	r28, 0x11	; 17
    492a:	0f b6       	in	r0, 0x3f	; 63
    492c:	f8 94       	cli
    492e:	de bf       	out	0x3e, r29	; 62
    4930:	0f be       	out	0x3f, r0	; 63
    4932:	cd bf       	out	0x3d, r28	; 61
    4934:	cf 91       	pop	r28
    4936:	df 91       	pop	r29
    4938:	1f 91       	pop	r17
    493a:	0f 91       	pop	r16
    493c:	ff 90       	pop	r15
    493e:	ef 90       	pop	r14
    4940:	08 95       	ret

00004942 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    4942:	0f 93       	push	r16
    4944:	1f 93       	push	r17
    4946:	df 93       	push	r29
    4948:	cf 93       	push	r28
    494a:	cd b7       	in	r28, 0x3d	; 61
    494c:	de b7       	in	r29, 0x3e	; 62
    494e:	62 97       	sbiw	r28, 0x12	; 18
    4950:	0f b6       	in	r0, 0x3f	; 63
    4952:	f8 94       	cli
    4954:	de bf       	out	0x3e, r29	; 62
    4956:	0f be       	out	0x3f, r0	; 63
    4958:	cd bf       	out	0x3d, r28	; 61
    495a:	9a 87       	std	Y+10, r25	; 0x0a
    495c:	89 87       	std	Y+9, r24	; 0x09
    495e:	7c 87       	std	Y+12, r23	; 0x0c
    4960:	6b 87       	std	Y+11, r22	; 0x0b
    4962:	5e 87       	std	Y+14, r21	; 0x0e
    4964:	4d 87       	std	Y+13, r20	; 0x0d
    4966:	38 8b       	std	Y+16, r19	; 0x10
    4968:	2f 87       	std	Y+15, r18	; 0x0f
    496a:	1a 8b       	std	Y+18, r17	; 0x12
    496c:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    496e:	89 89       	ldd	r24, Y+17	; 0x11
    4970:	9a 89       	ldd	r25, Y+18	; 0x12
    4972:	00 97       	sbiw	r24, 0x00	; 0
    4974:	91 f1       	breq	.+100    	; 0x49da <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    4976:	e9 85       	ldd	r30, Y+9	; 0x09
    4978:	fa 85       	ldd	r31, Y+10	; 0x0a
    497a:	80 81       	ld	r24, Z
    497c:	91 81       	ldd	r25, Z+1	; 0x01
    497e:	9e 83       	std	Y+6, r25	; 0x06
    4980:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    4982:	ae 01       	movw	r20, r28
    4984:	49 5f       	subi	r20, 0xF9	; 249
    4986:	5f 4f       	sbci	r21, 0xFF	; 255
    4988:	89 85       	ldd	r24, Y+9	; 0x09
    498a:	9a 85       	ldd	r25, Y+10	; 0x0a
    498c:	29 89       	ldd	r18, Y+17	; 0x11
    498e:	3a 89       	ldd	r19, Y+18	; 0x12
    4990:	ef 85       	ldd	r30, Y+15	; 0x0f
    4992:	f8 89       	ldd	r31, Y+16	; 0x10
    4994:	ba 01       	movw	r22, r20
    4996:	a9 01       	movw	r20, r18
    4998:	9f 01       	movw	r18, r30
    499a:	0e 94 85 26 	call	0x4d0a	; 0x4d0a <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    499e:	8f 81       	ldd	r24, Y+7	; 0x07
    49a0:	98 85       	ldd	r25, Y+8	; 0x08
    49a2:	9a 83       	std	Y+2, r25	; 0x02
    49a4:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    49a6:	2f 85       	ldd	r18, Y+15	; 0x0f
    49a8:	38 89       	ldd	r19, Y+16	; 0x10
    49aa:	89 89       	ldd	r24, Y+17	; 0x11
    49ac:	9a 89       	ldd	r25, Y+18	; 0x12
    49ae:	a9 01       	movw	r20, r18
    49b0:	48 1b       	sub	r20, r24
    49b2:	59 0b       	sbc	r21, r25
    49b4:	ca 01       	movw	r24, r20
    49b6:	98 8b       	std	Y+16, r25	; 0x10
    49b8:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    49ba:	29 81       	ldd	r18, Y+1	; 0x01
    49bc:	3a 81       	ldd	r19, Y+2	; 0x02
    49be:	8d 85       	ldd	r24, Y+13	; 0x0d
    49c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    49c2:	82 17       	cp	r24, r18
    49c4:	93 07       	cpc	r25, r19
    49c6:	68 f4       	brcc	.+26     	; 0x49e2 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    49c8:	e9 85       	ldd	r30, Y+9	; 0x09
    49ca:	fa 85       	ldd	r31, Y+10	; 0x0a
    49cc:	8d 81       	ldd	r24, Y+5	; 0x05
    49ce:	9e 81       	ldd	r25, Y+6	; 0x06
    49d0:	91 83       	std	Z+1, r25	; 0x01
    49d2:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    49d4:	1a 82       	std	Y+2, r1	; 0x02
    49d6:	19 82       	std	Y+1, r1	; 0x01
    49d8:	04 c0       	rjmp	.+8      	; 0x49e2 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    49da:	8d 85       	ldd	r24, Y+13	; 0x0d
    49dc:	9e 85       	ldd	r25, Y+14	; 0x0e
    49de:	9a 83       	std	Y+2, r25	; 0x02
    49e0:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    49e2:	4b 85       	ldd	r20, Y+11	; 0x0b
    49e4:	5c 85       	ldd	r21, Y+12	; 0x0c
    49e6:	89 85       	ldd	r24, Y+9	; 0x09
    49e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    49ea:	29 81       	ldd	r18, Y+1	; 0x01
    49ec:	3a 81       	ldd	r19, Y+2	; 0x02
    49ee:	ef 85       	ldd	r30, Y+15	; 0x0f
    49f0:	f8 89       	ldd	r31, Y+16	; 0x10
    49f2:	ba 01       	movw	r22, r20
    49f4:	a9 01       	movw	r20, r18
    49f6:	9f 01       	movw	r18, r30
    49f8:	0e 94 85 26 	call	0x4d0a	; 0x4d0a <prvReadBytesFromBuffer>
    49fc:	9c 83       	std	Y+4, r25	; 0x04
    49fe:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    4a00:	8b 81       	ldd	r24, Y+3	; 0x03
    4a02:	9c 81       	ldd	r25, Y+4	; 0x04
}
    4a04:	62 96       	adiw	r28, 0x12	; 18
    4a06:	0f b6       	in	r0, 0x3f	; 63
    4a08:	f8 94       	cli
    4a0a:	de bf       	out	0x3e, r29	; 62
    4a0c:	0f be       	out	0x3f, r0	; 63
    4a0e:	cd bf       	out	0x3d, r28	; 61
    4a10:	cf 91       	pop	r28
    4a12:	df 91       	pop	r29
    4a14:	1f 91       	pop	r17
    4a16:	0f 91       	pop	r16
    4a18:	08 95       	ret

00004a1a <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    4a1a:	df 93       	push	r29
    4a1c:	cf 93       	push	r28
    4a1e:	cd b7       	in	r28, 0x3d	; 61
    4a20:	de b7       	in	r29, 0x3e	; 62
    4a22:	27 97       	sbiw	r28, 0x07	; 7
    4a24:	0f b6       	in	r0, 0x3f	; 63
    4a26:	f8 94       	cli
    4a28:	de bf       	out	0x3e, r29	; 62
    4a2a:	0f be       	out	0x3f, r0	; 63
    4a2c:	cd bf       	out	0x3d, r28	; 61
    4a2e:	9f 83       	std	Y+7, r25	; 0x07
    4a30:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4a32:	8e 81       	ldd	r24, Y+6	; 0x06
    4a34:	9f 81       	ldd	r25, Y+7	; 0x07
    4a36:	9d 83       	std	Y+5, r25	; 0x05
    4a38:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    4a3a:	ec 81       	ldd	r30, Y+4	; 0x04
    4a3c:	fd 81       	ldd	r31, Y+5	; 0x05
    4a3e:	80 81       	ld	r24, Z
    4a40:	91 81       	ldd	r25, Z+1	; 0x01
    4a42:	9a 83       	std	Y+2, r25	; 0x02
    4a44:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    4a46:	ec 81       	ldd	r30, Y+4	; 0x04
    4a48:	fd 81       	ldd	r31, Y+5	; 0x05
    4a4a:	22 81       	ldd	r18, Z+2	; 0x02
    4a4c:	33 81       	ldd	r19, Z+3	; 0x03
    4a4e:	89 81       	ldd	r24, Y+1	; 0x01
    4a50:	9a 81       	ldd	r25, Y+2	; 0x02
    4a52:	28 17       	cp	r18, r24
    4a54:	39 07       	cpc	r19, r25
    4a56:	19 f4       	brne	.+6      	; 0x4a5e <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    4a58:	81 e0       	ldi	r24, 0x01	; 1
    4a5a:	8b 83       	std	Y+3, r24	; 0x03
    4a5c:	01 c0       	rjmp	.+2      	; 0x4a60 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    4a5e:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    4a60:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4a62:	27 96       	adiw	r28, 0x07	; 7
    4a64:	0f b6       	in	r0, 0x3f	; 63
    4a66:	f8 94       	cli
    4a68:	de bf       	out	0x3e, r29	; 62
    4a6a:	0f be       	out	0x3f, r0	; 63
    4a6c:	cd bf       	out	0x3d, r28	; 61
    4a6e:	cf 91       	pop	r28
    4a70:	df 91       	pop	r29
    4a72:	08 95       	ret

00004a74 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    4a74:	df 93       	push	r29
    4a76:	cf 93       	push	r28
    4a78:	cd b7       	in	r28, 0x3d	; 61
    4a7a:	de b7       	in	r29, 0x3e	; 62
    4a7c:	27 97       	sbiw	r28, 0x07	; 7
    4a7e:	0f b6       	in	r0, 0x3f	; 63
    4a80:	f8 94       	cli
    4a82:	de bf       	out	0x3e, r29	; 62
    4a84:	0f be       	out	0x3f, r0	; 63
    4a86:	cd bf       	out	0x3d, r28	; 61
    4a88:	9f 83       	std	Y+7, r25	; 0x07
    4a8a:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4a8c:	8e 81       	ldd	r24, Y+6	; 0x06
    4a8e:	9f 81       	ldd	r25, Y+7	; 0x07
    4a90:	9a 83       	std	Y+2, r25	; 0x02
    4a92:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4a94:	e9 81       	ldd	r30, Y+1	; 0x01
    4a96:	fa 81       	ldd	r31, Y+2	; 0x02
    4a98:	86 85       	ldd	r24, Z+14	; 0x0e
    4a9a:	88 2f       	mov	r24, r24
    4a9c:	90 e0       	ldi	r25, 0x00	; 0
    4a9e:	81 70       	andi	r24, 0x01	; 1
    4aa0:	90 70       	andi	r25, 0x00	; 0
    4aa2:	88 23       	and	r24, r24
    4aa4:	29 f0       	breq	.+10     	; 0x4ab0 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4aa6:	82 e0       	ldi	r24, 0x02	; 2
    4aa8:	90 e0       	ldi	r25, 0x00	; 0
    4aaa:	9c 83       	std	Y+4, r25	; 0x04
    4aac:	8b 83       	std	Y+3, r24	; 0x03
    4aae:	02 c0       	rjmp	.+4      	; 0x4ab4 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    4ab0:	1c 82       	std	Y+4, r1	; 0x04
    4ab2:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    4ab4:	8e 81       	ldd	r24, Y+6	; 0x06
    4ab6:	9f 81       	ldd	r25, Y+7	; 0x07
    4ab8:	0e 94 02 21 	call	0x4204	; 0x4204 <xStreamBufferSpacesAvailable>
    4abc:	9c 01       	movw	r18, r24
    4abe:	8b 81       	ldd	r24, Y+3	; 0x03
    4ac0:	9c 81       	ldd	r25, Y+4	; 0x04
    4ac2:	82 17       	cp	r24, r18
    4ac4:	93 07       	cpc	r25, r19
    4ac6:	18 f0       	brcs	.+6      	; 0x4ace <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    4ac8:	81 e0       	ldi	r24, 0x01	; 1
    4aca:	8d 83       	std	Y+5, r24	; 0x05
    4acc:	01 c0       	rjmp	.+2      	; 0x4ad0 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    4ace:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    4ad0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4ad2:	27 96       	adiw	r28, 0x07	; 7
    4ad4:	0f b6       	in	r0, 0x3f	; 63
    4ad6:	f8 94       	cli
    4ad8:	de bf       	out	0x3e, r29	; 62
    4ada:	0f be       	out	0x3f, r0	; 63
    4adc:	cd bf       	out	0x3d, r28	; 61
    4ade:	cf 91       	pop	r28
    4ae0:	df 91       	pop	r29
    4ae2:	08 95       	ret

00004ae4 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    4ae4:	ef 92       	push	r14
    4ae6:	ff 92       	push	r15
    4ae8:	0f 93       	push	r16
    4aea:	1f 93       	push	r17
    4aec:	df 93       	push	r29
    4aee:	cf 93       	push	r28
    4af0:	cd b7       	in	r28, 0x3d	; 61
    4af2:	de b7       	in	r29, 0x3e	; 62
    4af4:	28 97       	sbiw	r28, 0x08	; 8
    4af6:	0f b6       	in	r0, 0x3f	; 63
    4af8:	f8 94       	cli
    4afa:	de bf       	out	0x3e, r29	; 62
    4afc:	0f be       	out	0x3f, r0	; 63
    4afe:	cd bf       	out	0x3d, r28	; 61
    4b00:	9e 83       	std	Y+6, r25	; 0x06
    4b02:	8d 83       	std	Y+5, r24	; 0x05
    4b04:	78 87       	std	Y+8, r23	; 0x08
    4b06:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4b08:	8d 81       	ldd	r24, Y+5	; 0x05
    4b0a:	9e 81       	ldd	r25, Y+6	; 0x06
    4b0c:	9c 83       	std	Y+4, r25	; 0x04
    4b0e:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    4b10:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    4b12:	eb 81       	ldd	r30, Y+3	; 0x03
    4b14:	fc 81       	ldd	r31, Y+4	; 0x04
    4b16:	80 85       	ldd	r24, Z+8	; 0x08
    4b18:	91 85       	ldd	r25, Z+9	; 0x09
    4b1a:	00 97       	sbiw	r24, 0x00	; 0
    4b1c:	b9 f0       	breq	.+46     	; 0x4b4c <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    4b1e:	eb 81       	ldd	r30, Y+3	; 0x03
    4b20:	fc 81       	ldd	r31, Y+4	; 0x04
    4b22:	80 85       	ldd	r24, Z+8	; 0x08
    4b24:	91 85       	ldd	r25, Z+9	; 0x09
    4b26:	ef 81       	ldd	r30, Y+7	; 0x07
    4b28:	f8 85       	ldd	r31, Y+8	; 0x08
    4b2a:	40 e0       	ldi	r20, 0x00	; 0
    4b2c:	50 e0       	ldi	r21, 0x00	; 0
    4b2e:	60 e0       	ldi	r22, 0x00	; 0
    4b30:	70 e0       	ldi	r23, 0x00	; 0
    4b32:	20 e0       	ldi	r18, 0x00	; 0
    4b34:	00 e0       	ldi	r16, 0x00	; 0
    4b36:	10 e0       	ldi	r17, 0x00	; 0
    4b38:	7f 01       	movw	r14, r30
    4b3a:	0e 94 ff 32 	call	0x65fe	; 0x65fe <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    4b3e:	eb 81       	ldd	r30, Y+3	; 0x03
    4b40:	fc 81       	ldd	r31, Y+4	; 0x04
    4b42:	11 86       	std	Z+9, r1	; 0x09
    4b44:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    4b46:	81 e0       	ldi	r24, 0x01	; 1
    4b48:	8a 83       	std	Y+2, r24	; 0x02
    4b4a:	01 c0       	rjmp	.+2      	; 0x4b4e <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    4b4c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4b4e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4b50:	28 96       	adiw	r28, 0x08	; 8
    4b52:	0f b6       	in	r0, 0x3f	; 63
    4b54:	f8 94       	cli
    4b56:	de bf       	out	0x3e, r29	; 62
    4b58:	0f be       	out	0x3f, r0	; 63
    4b5a:	cd bf       	out	0x3d, r28	; 61
    4b5c:	cf 91       	pop	r28
    4b5e:	df 91       	pop	r29
    4b60:	1f 91       	pop	r17
    4b62:	0f 91       	pop	r16
    4b64:	ff 90       	pop	r15
    4b66:	ef 90       	pop	r14
    4b68:	08 95       	ret

00004b6a <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    4b6a:	ef 92       	push	r14
    4b6c:	ff 92       	push	r15
    4b6e:	0f 93       	push	r16
    4b70:	1f 93       	push	r17
    4b72:	df 93       	push	r29
    4b74:	cf 93       	push	r28
    4b76:	cd b7       	in	r28, 0x3d	; 61
    4b78:	de b7       	in	r29, 0x3e	; 62
    4b7a:	28 97       	sbiw	r28, 0x08	; 8
    4b7c:	0f b6       	in	r0, 0x3f	; 63
    4b7e:	f8 94       	cli
    4b80:	de bf       	out	0x3e, r29	; 62
    4b82:	0f be       	out	0x3f, r0	; 63
    4b84:	cd bf       	out	0x3d, r28	; 61
    4b86:	9e 83       	std	Y+6, r25	; 0x06
    4b88:	8d 83       	std	Y+5, r24	; 0x05
    4b8a:	78 87       	std	Y+8, r23	; 0x08
    4b8c:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4b8e:	8d 81       	ldd	r24, Y+5	; 0x05
    4b90:	9e 81       	ldd	r25, Y+6	; 0x06
    4b92:	9c 83       	std	Y+4, r25	; 0x04
    4b94:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    4b96:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    4b98:	eb 81       	ldd	r30, Y+3	; 0x03
    4b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    4b9c:	82 85       	ldd	r24, Z+10	; 0x0a
    4b9e:	93 85       	ldd	r25, Z+11	; 0x0b
    4ba0:	00 97       	sbiw	r24, 0x00	; 0
    4ba2:	b9 f0       	breq	.+46     	; 0x4bd2 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    4ba4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ba6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ba8:	82 85       	ldd	r24, Z+10	; 0x0a
    4baa:	93 85       	ldd	r25, Z+11	; 0x0b
    4bac:	ef 81       	ldd	r30, Y+7	; 0x07
    4bae:	f8 85       	ldd	r31, Y+8	; 0x08
    4bb0:	40 e0       	ldi	r20, 0x00	; 0
    4bb2:	50 e0       	ldi	r21, 0x00	; 0
    4bb4:	60 e0       	ldi	r22, 0x00	; 0
    4bb6:	70 e0       	ldi	r23, 0x00	; 0
    4bb8:	20 e0       	ldi	r18, 0x00	; 0
    4bba:	00 e0       	ldi	r16, 0x00	; 0
    4bbc:	10 e0       	ldi	r17, 0x00	; 0
    4bbe:	7f 01       	movw	r14, r30
    4bc0:	0e 94 ff 32 	call	0x65fe	; 0x65fe <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    4bc4:	eb 81       	ldd	r30, Y+3	; 0x03
    4bc6:	fc 81       	ldd	r31, Y+4	; 0x04
    4bc8:	13 86       	std	Z+11, r1	; 0x0b
    4bca:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    4bcc:	81 e0       	ldi	r24, 0x01	; 1
    4bce:	8a 83       	std	Y+2, r24	; 0x02
    4bd0:	01 c0       	rjmp	.+2      	; 0x4bd4 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    4bd2:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4bd4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4bd6:	28 96       	adiw	r28, 0x08	; 8
    4bd8:	0f b6       	in	r0, 0x3f	; 63
    4bda:	f8 94       	cli
    4bdc:	de bf       	out	0x3e, r29	; 62
    4bde:	0f be       	out	0x3f, r0	; 63
    4be0:	cd bf       	out	0x3d, r28	; 61
    4be2:	cf 91       	pop	r28
    4be4:	df 91       	pop	r29
    4be6:	1f 91       	pop	r17
    4be8:	0f 91       	pop	r16
    4bea:	ff 90       	pop	r15
    4bec:	ef 90       	pop	r14
    4bee:	08 95       	ret

00004bf0 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    4bf0:	df 93       	push	r29
    4bf2:	cf 93       	push	r28
    4bf4:	cd b7       	in	r28, 0x3d	; 61
    4bf6:	de b7       	in	r29, 0x3e	; 62
    4bf8:	2e 97       	sbiw	r28, 0x0e	; 14
    4bfa:	0f b6       	in	r0, 0x3f	; 63
    4bfc:	f8 94       	cli
    4bfe:	de bf       	out	0x3e, r29	; 62
    4c00:	0f be       	out	0x3f, r0	; 63
    4c02:	cd bf       	out	0x3d, r28	; 61
    4c04:	9e 83       	std	Y+6, r25	; 0x06
    4c06:	8d 83       	std	Y+5, r24	; 0x05
    4c08:	78 87       	std	Y+8, r23	; 0x08
    4c0a:	6f 83       	std	Y+7, r22	; 0x07
    4c0c:	5a 87       	std	Y+10, r21	; 0x0a
    4c0e:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    4c10:	ed 81       	ldd	r30, Y+5	; 0x05
    4c12:	fe 81       	ldd	r31, Y+6	; 0x06
    4c14:	82 81       	ldd	r24, Z+2	; 0x02
    4c16:	93 81       	ldd	r25, Z+3	; 0x03
    4c18:	9c 83       	std	Y+4, r25	; 0x04
    4c1a:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    4c1c:	ed 81       	ldd	r30, Y+5	; 0x05
    4c1e:	fe 81       	ldd	r31, Y+6	; 0x06
    4c20:	24 81       	ldd	r18, Z+4	; 0x04
    4c22:	35 81       	ldd	r19, Z+5	; 0x05
    4c24:	8b 81       	ldd	r24, Y+3	; 0x03
    4c26:	9c 81       	ldd	r25, Y+4	; 0x04
    4c28:	a9 01       	movw	r20, r18
    4c2a:	48 1b       	sub	r20, r24
    4c2c:	59 0b       	sbc	r21, r25
    4c2e:	ca 01       	movw	r24, r20
    4c30:	29 85       	ldd	r18, Y+9	; 0x09
    4c32:	3a 85       	ldd	r19, Y+10	; 0x0a
    4c34:	3e 87       	std	Y+14, r19	; 0x0e
    4c36:	2d 87       	std	Y+13, r18	; 0x0d
    4c38:	9c 87       	std	Y+12, r25	; 0x0c
    4c3a:	8b 87       	std	Y+11, r24	; 0x0b
    4c3c:	4b 85       	ldd	r20, Y+11	; 0x0b
    4c3e:	5c 85       	ldd	r21, Y+12	; 0x0c
    4c40:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c42:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c44:	84 17       	cp	r24, r20
    4c46:	95 07       	cpc	r25, r21
    4c48:	20 f4       	brcc	.+8      	; 0x4c52 <prvWriteBytesToBuffer+0x62>
    4c4a:	2d 85       	ldd	r18, Y+13	; 0x0d
    4c4c:	3e 85       	ldd	r19, Y+14	; 0x0e
    4c4e:	3c 87       	std	Y+12, r19	; 0x0c
    4c50:	2b 87       	std	Y+11, r18	; 0x0b
    4c52:	4b 85       	ldd	r20, Y+11	; 0x0b
    4c54:	5c 85       	ldd	r21, Y+12	; 0x0c
    4c56:	5a 83       	std	Y+2, r21	; 0x02
    4c58:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4c5a:	ed 81       	ldd	r30, Y+5	; 0x05
    4c5c:	fe 81       	ldd	r31, Y+6	; 0x06
    4c5e:	24 85       	ldd	r18, Z+12	; 0x0c
    4c60:	35 85       	ldd	r19, Z+13	; 0x0d
    4c62:	8b 81       	ldd	r24, Y+3	; 0x03
    4c64:	9c 81       	ldd	r25, Y+4	; 0x04
    4c66:	82 0f       	add	r24, r18
    4c68:	93 1f       	adc	r25, r19
    4c6a:	2f 81       	ldd	r18, Y+7	; 0x07
    4c6c:	38 85       	ldd	r19, Y+8	; 0x08
    4c6e:	49 81       	ldd	r20, Y+1	; 0x01
    4c70:	5a 81       	ldd	r21, Y+2	; 0x02
    4c72:	b9 01       	movw	r22, r18
    4c74:	0e 94 6a 35 	call	0x6ad4	; 0x6ad4 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    4c78:	29 85       	ldd	r18, Y+9	; 0x09
    4c7a:	3a 85       	ldd	r19, Y+10	; 0x0a
    4c7c:	89 81       	ldd	r24, Y+1	; 0x01
    4c7e:	9a 81       	ldd	r25, Y+2	; 0x02
    4c80:	82 17       	cp	r24, r18
    4c82:	93 07       	cpc	r25, r19
    4c84:	b0 f4       	brcc	.+44     	; 0x4cb2 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4c86:	ed 81       	ldd	r30, Y+5	; 0x05
    4c88:	fe 81       	ldd	r31, Y+6	; 0x06
    4c8a:	64 85       	ldd	r22, Z+12	; 0x0c
    4c8c:	75 85       	ldd	r23, Z+13	; 0x0d
    4c8e:	2f 81       	ldd	r18, Y+7	; 0x07
    4c90:	38 85       	ldd	r19, Y+8	; 0x08
    4c92:	89 81       	ldd	r24, Y+1	; 0x01
    4c94:	9a 81       	ldd	r25, Y+2	; 0x02
    4c96:	a9 01       	movw	r20, r18
    4c98:	48 0f       	add	r20, r24
    4c9a:	59 1f       	adc	r21, r25
    4c9c:	29 85       	ldd	r18, Y+9	; 0x09
    4c9e:	3a 85       	ldd	r19, Y+10	; 0x0a
    4ca0:	89 81       	ldd	r24, Y+1	; 0x01
    4ca2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ca4:	28 1b       	sub	r18, r24
    4ca6:	39 0b       	sbc	r19, r25
    4ca8:	cb 01       	movw	r24, r22
    4caa:	ba 01       	movw	r22, r20
    4cac:	a9 01       	movw	r20, r18
    4cae:	0e 94 6a 35 	call	0x6ad4	; 0x6ad4 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    4cb2:	2b 81       	ldd	r18, Y+3	; 0x03
    4cb4:	3c 81       	ldd	r19, Y+4	; 0x04
    4cb6:	89 85       	ldd	r24, Y+9	; 0x09
    4cb8:	9a 85       	ldd	r25, Y+10	; 0x0a
    4cba:	82 0f       	add	r24, r18
    4cbc:	93 1f       	adc	r25, r19
    4cbe:	9c 83       	std	Y+4, r25	; 0x04
    4cc0:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    4cc2:	ed 81       	ldd	r30, Y+5	; 0x05
    4cc4:	fe 81       	ldd	r31, Y+6	; 0x06
    4cc6:	24 81       	ldd	r18, Z+4	; 0x04
    4cc8:	35 81       	ldd	r19, Z+5	; 0x05
    4cca:	8b 81       	ldd	r24, Y+3	; 0x03
    4ccc:	9c 81       	ldd	r25, Y+4	; 0x04
    4cce:	82 17       	cp	r24, r18
    4cd0:	93 07       	cpc	r25, r19
    4cd2:	50 f0       	brcs	.+20     	; 0x4ce8 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    4cd4:	ed 81       	ldd	r30, Y+5	; 0x05
    4cd6:	fe 81       	ldd	r31, Y+6	; 0x06
    4cd8:	24 81       	ldd	r18, Z+4	; 0x04
    4cda:	35 81       	ldd	r19, Z+5	; 0x05
    4cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    4cde:	9c 81       	ldd	r25, Y+4	; 0x04
    4ce0:	82 1b       	sub	r24, r18
    4ce2:	93 0b       	sbc	r25, r19
    4ce4:	9c 83       	std	Y+4, r25	; 0x04
    4ce6:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    4ce8:	ed 81       	ldd	r30, Y+5	; 0x05
    4cea:	fe 81       	ldd	r31, Y+6	; 0x06
    4cec:	8b 81       	ldd	r24, Y+3	; 0x03
    4cee:	9c 81       	ldd	r25, Y+4	; 0x04
    4cf0:	93 83       	std	Z+3, r25	; 0x03
    4cf2:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    4cf4:	89 85       	ldd	r24, Y+9	; 0x09
    4cf6:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    4cf8:	2e 96       	adiw	r28, 0x0e	; 14
    4cfa:	0f b6       	in	r0, 0x3f	; 63
    4cfc:	f8 94       	cli
    4cfe:	de bf       	out	0x3e, r29	; 62
    4d00:	0f be       	out	0x3f, r0	; 63
    4d02:	cd bf       	out	0x3d, r28	; 61
    4d04:	cf 91       	pop	r28
    4d06:	df 91       	pop	r29
    4d08:	08 95       	ret

00004d0a <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    4d0a:	df 93       	push	r29
    4d0c:	cf 93       	push	r28
    4d0e:	cd b7       	in	r28, 0x3d	; 61
    4d10:	de b7       	in	r29, 0x3e	; 62
    4d12:	66 97       	sbiw	r28, 0x16	; 22
    4d14:	0f b6       	in	r0, 0x3f	; 63
    4d16:	f8 94       	cli
    4d18:	de bf       	out	0x3e, r29	; 62
    4d1a:	0f be       	out	0x3f, r0	; 63
    4d1c:	cd bf       	out	0x3d, r28	; 61
    4d1e:	98 87       	std	Y+8, r25	; 0x08
    4d20:	8f 83       	std	Y+7, r24	; 0x07
    4d22:	7a 87       	std	Y+10, r23	; 0x0a
    4d24:	69 87       	std	Y+9, r22	; 0x09
    4d26:	5c 87       	std	Y+12, r21	; 0x0c
    4d28:	4b 87       	std	Y+11, r20	; 0x0b
    4d2a:	3e 87       	std	Y+14, r19	; 0x0e
    4d2c:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    4d2e:	2d 85       	ldd	r18, Y+13	; 0x0d
    4d30:	3e 85       	ldd	r19, Y+14	; 0x0e
    4d32:	3a 8b       	std	Y+18, r19	; 0x12
    4d34:	29 8b       	std	Y+17, r18	; 0x11
    4d36:	4b 85       	ldd	r20, Y+11	; 0x0b
    4d38:	5c 85       	ldd	r21, Y+12	; 0x0c
    4d3a:	58 8b       	std	Y+16, r21	; 0x10
    4d3c:	4f 87       	std	Y+15, r20	; 0x0f
    4d3e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4d40:	98 89       	ldd	r25, Y+16	; 0x10
    4d42:	29 89       	ldd	r18, Y+17	; 0x11
    4d44:	3a 89       	ldd	r19, Y+18	; 0x12
    4d46:	28 17       	cp	r18, r24
    4d48:	39 07       	cpc	r19, r25
    4d4a:	20 f4       	brcc	.+8      	; 0x4d54 <prvReadBytesFromBuffer+0x4a>
    4d4c:	49 89       	ldd	r20, Y+17	; 0x11
    4d4e:	5a 89       	ldd	r21, Y+18	; 0x12
    4d50:	58 8b       	std	Y+16, r21	; 0x10
    4d52:	4f 87       	std	Y+15, r20	; 0x0f
    4d54:	8f 85       	ldd	r24, Y+15	; 0x0f
    4d56:	98 89       	ldd	r25, Y+16	; 0x10
    4d58:	9e 83       	std	Y+6, r25	; 0x06
    4d5a:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    4d5c:	8d 81       	ldd	r24, Y+5	; 0x05
    4d5e:	9e 81       	ldd	r25, Y+6	; 0x06
    4d60:	00 97       	sbiw	r24, 0x00	; 0
    4d62:	09 f4       	brne	.+2      	; 0x4d66 <prvReadBytesFromBuffer+0x5c>
    4d64:	74 c0       	rjmp	.+232    	; 0x4e4e <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    4d66:	ef 81       	ldd	r30, Y+7	; 0x07
    4d68:	f8 85       	ldd	r31, Y+8	; 0x08
    4d6a:	80 81       	ld	r24, Z
    4d6c:	91 81       	ldd	r25, Z+1	; 0x01
    4d6e:	9a 83       	std	Y+2, r25	; 0x02
    4d70:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    4d72:	ef 81       	ldd	r30, Y+7	; 0x07
    4d74:	f8 85       	ldd	r31, Y+8	; 0x08
    4d76:	24 81       	ldd	r18, Z+4	; 0x04
    4d78:	35 81       	ldd	r19, Z+5	; 0x05
    4d7a:	89 81       	ldd	r24, Y+1	; 0x01
    4d7c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d7e:	a9 01       	movw	r20, r18
    4d80:	48 1b       	sub	r20, r24
    4d82:	59 0b       	sbc	r21, r25
    4d84:	ca 01       	movw	r24, r20
    4d86:	2d 81       	ldd	r18, Y+5	; 0x05
    4d88:	3e 81       	ldd	r19, Y+6	; 0x06
    4d8a:	3e 8b       	std	Y+22, r19	; 0x16
    4d8c:	2d 8b       	std	Y+21, r18	; 0x15
    4d8e:	9c 8b       	std	Y+20, r25	; 0x14
    4d90:	8b 8b       	std	Y+19, r24	; 0x13
    4d92:	4b 89       	ldd	r20, Y+19	; 0x13
    4d94:	5c 89       	ldd	r21, Y+20	; 0x14
    4d96:	8d 89       	ldd	r24, Y+21	; 0x15
    4d98:	9e 89       	ldd	r25, Y+22	; 0x16
    4d9a:	84 17       	cp	r24, r20
    4d9c:	95 07       	cpc	r25, r21
    4d9e:	20 f4       	brcc	.+8      	; 0x4da8 <prvReadBytesFromBuffer+0x9e>
    4da0:	2d 89       	ldd	r18, Y+21	; 0x15
    4da2:	3e 89       	ldd	r19, Y+22	; 0x16
    4da4:	3c 8b       	std	Y+20, r19	; 0x14
    4da6:	2b 8b       	std	Y+19, r18	; 0x13
    4da8:	4b 89       	ldd	r20, Y+19	; 0x13
    4daa:	5c 89       	ldd	r21, Y+20	; 0x14
    4dac:	5c 83       	std	Y+4, r21	; 0x04
    4dae:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4db0:	ef 81       	ldd	r30, Y+7	; 0x07
    4db2:	f8 85       	ldd	r31, Y+8	; 0x08
    4db4:	24 85       	ldd	r18, Z+12	; 0x0c
    4db6:	35 85       	ldd	r19, Z+13	; 0x0d
    4db8:	89 81       	ldd	r24, Y+1	; 0x01
    4dba:	9a 81       	ldd	r25, Y+2	; 0x02
    4dbc:	a9 01       	movw	r20, r18
    4dbe:	48 0f       	add	r20, r24
    4dc0:	59 1f       	adc	r21, r25
    4dc2:	89 85       	ldd	r24, Y+9	; 0x09
    4dc4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4dc6:	2b 81       	ldd	r18, Y+3	; 0x03
    4dc8:	3c 81       	ldd	r19, Y+4	; 0x04
    4dca:	ba 01       	movw	r22, r20
    4dcc:	a9 01       	movw	r20, r18
    4dce:	0e 94 6a 35 	call	0x6ad4	; 0x6ad4 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    4dd2:	2d 81       	ldd	r18, Y+5	; 0x05
    4dd4:	3e 81       	ldd	r19, Y+6	; 0x06
    4dd6:	8b 81       	ldd	r24, Y+3	; 0x03
    4dd8:	9c 81       	ldd	r25, Y+4	; 0x04
    4dda:	82 17       	cp	r24, r18
    4ddc:	93 07       	cpc	r25, r19
    4dde:	b0 f4       	brcc	.+44     	; 0x4e0c <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4de0:	29 85       	ldd	r18, Y+9	; 0x09
    4de2:	3a 85       	ldd	r19, Y+10	; 0x0a
    4de4:	8b 81       	ldd	r24, Y+3	; 0x03
    4de6:	9c 81       	ldd	r25, Y+4	; 0x04
    4de8:	b9 01       	movw	r22, r18
    4dea:	68 0f       	add	r22, r24
    4dec:	79 1f       	adc	r23, r25
    4dee:	ef 81       	ldd	r30, Y+7	; 0x07
    4df0:	f8 85       	ldd	r31, Y+8	; 0x08
    4df2:	44 85       	ldd	r20, Z+12	; 0x0c
    4df4:	55 85       	ldd	r21, Z+13	; 0x0d
    4df6:	2d 81       	ldd	r18, Y+5	; 0x05
    4df8:	3e 81       	ldd	r19, Y+6	; 0x06
    4dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    4dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    4dfe:	28 1b       	sub	r18, r24
    4e00:	39 0b       	sbc	r19, r25
    4e02:	cb 01       	movw	r24, r22
    4e04:	ba 01       	movw	r22, r20
    4e06:	a9 01       	movw	r20, r18
    4e08:	0e 94 6a 35 	call	0x6ad4	; 0x6ad4 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    4e0c:	29 81       	ldd	r18, Y+1	; 0x01
    4e0e:	3a 81       	ldd	r19, Y+2	; 0x02
    4e10:	8d 81       	ldd	r24, Y+5	; 0x05
    4e12:	9e 81       	ldd	r25, Y+6	; 0x06
    4e14:	82 0f       	add	r24, r18
    4e16:	93 1f       	adc	r25, r19
    4e18:	9a 83       	std	Y+2, r25	; 0x02
    4e1a:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    4e1c:	ef 81       	ldd	r30, Y+7	; 0x07
    4e1e:	f8 85       	ldd	r31, Y+8	; 0x08
    4e20:	24 81       	ldd	r18, Z+4	; 0x04
    4e22:	35 81       	ldd	r19, Z+5	; 0x05
    4e24:	89 81       	ldd	r24, Y+1	; 0x01
    4e26:	9a 81       	ldd	r25, Y+2	; 0x02
    4e28:	82 17       	cp	r24, r18
    4e2a:	93 07       	cpc	r25, r19
    4e2c:	50 f0       	brcs	.+20     	; 0x4e42 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    4e2e:	ef 81       	ldd	r30, Y+7	; 0x07
    4e30:	f8 85       	ldd	r31, Y+8	; 0x08
    4e32:	24 81       	ldd	r18, Z+4	; 0x04
    4e34:	35 81       	ldd	r19, Z+5	; 0x05
    4e36:	89 81       	ldd	r24, Y+1	; 0x01
    4e38:	9a 81       	ldd	r25, Y+2	; 0x02
    4e3a:	82 1b       	sub	r24, r18
    4e3c:	93 0b       	sbc	r25, r19
    4e3e:	9a 83       	std	Y+2, r25	; 0x02
    4e40:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    4e42:	ef 81       	ldd	r30, Y+7	; 0x07
    4e44:	f8 85       	ldd	r31, Y+8	; 0x08
    4e46:	89 81       	ldd	r24, Y+1	; 0x01
    4e48:	9a 81       	ldd	r25, Y+2	; 0x02
    4e4a:	91 83       	std	Z+1, r25	; 0x01
    4e4c:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    4e4e:	8d 81       	ldd	r24, Y+5	; 0x05
    4e50:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4e52:	66 96       	adiw	r28, 0x16	; 22
    4e54:	0f b6       	in	r0, 0x3f	; 63
    4e56:	f8 94       	cli
    4e58:	de bf       	out	0x3e, r29	; 62
    4e5a:	0f be       	out	0x3f, r0	; 63
    4e5c:	cd bf       	out	0x3d, r28	; 61
    4e5e:	cf 91       	pop	r28
    4e60:	df 91       	pop	r29
    4e62:	08 95       	ret

00004e64 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    4e64:	df 93       	push	r29
    4e66:	cf 93       	push	r28
    4e68:	00 d0       	rcall	.+0      	; 0x4e6a <prvBytesInBuffer+0x6>
    4e6a:	00 d0       	rcall	.+0      	; 0x4e6c <prvBytesInBuffer+0x8>
    4e6c:	cd b7       	in	r28, 0x3d	; 61
    4e6e:	de b7       	in	r29, 0x3e	; 62
    4e70:	9c 83       	std	Y+4, r25	; 0x04
    4e72:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    4e74:	eb 81       	ldd	r30, Y+3	; 0x03
    4e76:	fc 81       	ldd	r31, Y+4	; 0x04
    4e78:	24 81       	ldd	r18, Z+4	; 0x04
    4e7a:	35 81       	ldd	r19, Z+5	; 0x05
    4e7c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e7e:	fc 81       	ldd	r31, Y+4	; 0x04
    4e80:	82 81       	ldd	r24, Z+2	; 0x02
    4e82:	93 81       	ldd	r25, Z+3	; 0x03
    4e84:	82 0f       	add	r24, r18
    4e86:	93 1f       	adc	r25, r19
    4e88:	9a 83       	std	Y+2, r25	; 0x02
    4e8a:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    4e8c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e8e:	fc 81       	ldd	r31, Y+4	; 0x04
    4e90:	20 81       	ld	r18, Z
    4e92:	31 81       	ldd	r19, Z+1	; 0x01
    4e94:	89 81       	ldd	r24, Y+1	; 0x01
    4e96:	9a 81       	ldd	r25, Y+2	; 0x02
    4e98:	82 1b       	sub	r24, r18
    4e9a:	93 0b       	sbc	r25, r19
    4e9c:	9a 83       	std	Y+2, r25	; 0x02
    4e9e:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    4ea0:	eb 81       	ldd	r30, Y+3	; 0x03
    4ea2:	fc 81       	ldd	r31, Y+4	; 0x04
    4ea4:	24 81       	ldd	r18, Z+4	; 0x04
    4ea6:	35 81       	ldd	r19, Z+5	; 0x05
    4ea8:	89 81       	ldd	r24, Y+1	; 0x01
    4eaa:	9a 81       	ldd	r25, Y+2	; 0x02
    4eac:	82 17       	cp	r24, r18
    4eae:	93 07       	cpc	r25, r19
    4eb0:	50 f0       	brcs	.+20     	; 0x4ec6 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    4eb2:	eb 81       	ldd	r30, Y+3	; 0x03
    4eb4:	fc 81       	ldd	r31, Y+4	; 0x04
    4eb6:	24 81       	ldd	r18, Z+4	; 0x04
    4eb8:	35 81       	ldd	r19, Z+5	; 0x05
    4eba:	89 81       	ldd	r24, Y+1	; 0x01
    4ebc:	9a 81       	ldd	r25, Y+2	; 0x02
    4ebe:	82 1b       	sub	r24, r18
    4ec0:	93 0b       	sbc	r25, r19
    4ec2:	9a 83       	std	Y+2, r25	; 0x02
    4ec4:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    4ec6:	89 81       	ldd	r24, Y+1	; 0x01
    4ec8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4eca:	0f 90       	pop	r0
    4ecc:	0f 90       	pop	r0
    4ece:	0f 90       	pop	r0
    4ed0:	0f 90       	pop	r0
    4ed2:	cf 91       	pop	r28
    4ed4:	df 91       	pop	r29
    4ed6:	08 95       	ret

00004ed8 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    4ed8:	0f 93       	push	r16
    4eda:	df 93       	push	r29
    4edc:	cf 93       	push	r28
    4ede:	cd b7       	in	r28, 0x3d	; 61
    4ee0:	de b7       	in	r29, 0x3e	; 62
    4ee2:	29 97       	sbiw	r28, 0x09	; 9
    4ee4:	0f b6       	in	r0, 0x3f	; 63
    4ee6:	f8 94       	cli
    4ee8:	de bf       	out	0x3e, r29	; 62
    4eea:	0f be       	out	0x3f, r0	; 63
    4eec:	cd bf       	out	0x3d, r28	; 61
    4eee:	9a 83       	std	Y+2, r25	; 0x02
    4ef0:	89 83       	std	Y+1, r24	; 0x01
    4ef2:	7c 83       	std	Y+4, r23	; 0x04
    4ef4:	6b 83       	std	Y+3, r22	; 0x03
    4ef6:	5e 83       	std	Y+6, r21	; 0x06
    4ef8:	4d 83       	std	Y+5, r20	; 0x05
    4efa:	38 87       	std	Y+8, r19	; 0x08
    4efc:	2f 83       	std	Y+7, r18	; 0x07
    4efe:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    4f00:	89 81       	ldd	r24, Y+1	; 0x01
    4f02:	9a 81       	ldd	r25, Y+2	; 0x02
    4f04:	60 e0       	ldi	r22, 0x00	; 0
    4f06:	70 e0       	ldi	r23, 0x00	; 0
    4f08:	4f e0       	ldi	r20, 0x0F	; 15
    4f0a:	50 e0       	ldi	r21, 0x00	; 0
    4f0c:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    4f10:	e9 81       	ldd	r30, Y+1	; 0x01
    4f12:	fa 81       	ldd	r31, Y+2	; 0x02
    4f14:	8b 81       	ldd	r24, Y+3	; 0x03
    4f16:	9c 81       	ldd	r25, Y+4	; 0x04
    4f18:	95 87       	std	Z+13, r25	; 0x0d
    4f1a:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    4f1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4f1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4f20:	8d 81       	ldd	r24, Y+5	; 0x05
    4f22:	9e 81       	ldd	r25, Y+6	; 0x06
    4f24:	95 83       	std	Z+5, r25	; 0x05
    4f26:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    4f28:	e9 81       	ldd	r30, Y+1	; 0x01
    4f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    4f2c:	8f 81       	ldd	r24, Y+7	; 0x07
    4f2e:	98 85       	ldd	r25, Y+8	; 0x08
    4f30:	97 83       	std	Z+7, r25	; 0x07
    4f32:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    4f34:	e9 81       	ldd	r30, Y+1	; 0x01
    4f36:	fa 81       	ldd	r31, Y+2	; 0x02
    4f38:	89 85       	ldd	r24, Y+9	; 0x09
    4f3a:	86 87       	std	Z+14, r24	; 0x0e
}
    4f3c:	29 96       	adiw	r28, 0x09	; 9
    4f3e:	0f b6       	in	r0, 0x3f	; 63
    4f40:	f8 94       	cli
    4f42:	de bf       	out	0x3e, r29	; 62
    4f44:	0f be       	out	0x3f, r0	; 63
    4f46:	cd bf       	out	0x3d, r28	; 61
    4f48:	cf 91       	pop	r28
    4f4a:	df 91       	pop	r29
    4f4c:	0f 91       	pop	r16
    4f4e:	08 95       	ret

00004f50 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4f50:	8f 92       	push	r8
    4f52:	9f 92       	push	r9
    4f54:	af 92       	push	r10
    4f56:	bf 92       	push	r11
    4f58:	cf 92       	push	r12
    4f5a:	df 92       	push	r13
    4f5c:	ef 92       	push	r14
    4f5e:	ff 92       	push	r15
    4f60:	0f 93       	push	r16
    4f62:	1f 93       	push	r17
    4f64:	df 93       	push	r29
    4f66:	cf 93       	push	r28
    4f68:	cd b7       	in	r28, 0x3d	; 61
    4f6a:	de b7       	in	r29, 0x3e	; 62
    4f6c:	60 97       	sbiw	r28, 0x10	; 16
    4f6e:	0f b6       	in	r0, 0x3f	; 63
    4f70:	f8 94       	cli
    4f72:	de bf       	out	0x3e, r29	; 62
    4f74:	0f be       	out	0x3f, r0	; 63
    4f76:	cd bf       	out	0x3d, r28	; 61
    4f78:	9f 83       	std	Y+7, r25	; 0x07
    4f7a:	8e 83       	std	Y+6, r24	; 0x06
    4f7c:	79 87       	std	Y+9, r23	; 0x09
    4f7e:	68 87       	std	Y+8, r22	; 0x08
    4f80:	5b 87       	std	Y+11, r21	; 0x0b
    4f82:	4a 87       	std	Y+10, r20	; 0x0a
    4f84:	3d 87       	std	Y+13, r19	; 0x0d
    4f86:	2c 87       	std	Y+12, r18	; 0x0c
    4f88:	0e 87       	std	Y+14, r16	; 0x0e
    4f8a:	f8 8a       	std	Y+16, r15	; 0x10
    4f8c:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    4f8e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f90:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f92:	0e 94 ca 13 	call	0x2794	; 0x2794 <pvPortMalloc>
    4f96:	9a 83       	std	Y+2, r25	; 0x02
    4f98:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    4f9a:	89 81       	ldd	r24, Y+1	; 0x01
    4f9c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f9e:	00 97       	sbiw	r24, 0x00	; 0
    4fa0:	b1 f0       	breq	.+44     	; 0x4fce <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    4fa2:	86 e2       	ldi	r24, 0x26	; 38
    4fa4:	90 e0       	ldi	r25, 0x00	; 0
    4fa6:	0e 94 ca 13 	call	0x2794	; 0x2794 <pvPortMalloc>
    4faa:	9d 83       	std	Y+5, r25	; 0x05
    4fac:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    4fae:	8c 81       	ldd	r24, Y+4	; 0x04
    4fb0:	9d 81       	ldd	r25, Y+5	; 0x05
    4fb2:	00 97       	sbiw	r24, 0x00	; 0
    4fb4:	39 f0       	breq	.+14     	; 0x4fc4 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    4fb6:	ec 81       	ldd	r30, Y+4	; 0x04
    4fb8:	fd 81       	ldd	r31, Y+5	; 0x05
    4fba:	89 81       	ldd	r24, Y+1	; 0x01
    4fbc:	9a 81       	ldd	r25, Y+2	; 0x02
    4fbe:	90 8f       	std	Z+24, r25	; 0x18
    4fc0:	87 8b       	std	Z+23, r24	; 0x17
    4fc2:	07 c0       	rjmp	.+14     	; 0x4fd2 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    4fc4:	89 81       	ldd	r24, Y+1	; 0x01
    4fc6:	9a 81       	ldd	r25, Y+2	; 0x02
    4fc8:	0e 94 20 14 	call	0x2840	; 0x2840 <vPortFree>
    4fcc:	02 c0       	rjmp	.+4      	; 0x4fd2 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    4fce:	1d 82       	std	Y+5, r1	; 0x05
    4fd0:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    4fd2:	8c 81       	ldd	r24, Y+4	; 0x04
    4fd4:	9d 81       	ldd	r25, Y+5	; 0x05
    4fd6:	00 97       	sbiw	r24, 0x00	; 0
    4fd8:	e9 f0       	breq	.+58     	; 0x5014 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4fda:	8a 85       	ldd	r24, Y+10	; 0x0a
    4fdc:	9b 85       	ldd	r25, Y+11	; 0x0b
    4fde:	9c 01       	movw	r18, r24
    4fe0:	40 e0       	ldi	r20, 0x00	; 0
    4fe2:	50 e0       	ldi	r21, 0x00	; 0
    4fe4:	8e 81       	ldd	r24, Y+6	; 0x06
    4fe6:	9f 81       	ldd	r25, Y+7	; 0x07
    4fe8:	68 85       	ldd	r22, Y+8	; 0x08
    4fea:	79 85       	ldd	r23, Y+9	; 0x09
    4fec:	ec 85       	ldd	r30, Y+12	; 0x0c
    4fee:	fd 85       	ldd	r31, Y+13	; 0x0d
    4ff0:	af 85       	ldd	r26, Y+15	; 0x0f
    4ff2:	b8 89       	ldd	r27, Y+16	; 0x10
    4ff4:	ac 80       	ldd	r10, Y+4	; 0x04
    4ff6:	bd 80       	ldd	r11, Y+5	; 0x05
    4ff8:	8f 01       	movw	r16, r30
    4ffa:	ee 84       	ldd	r14, Y+14	; 0x0e
    4ffc:	6d 01       	movw	r12, r26
    4ffe:	88 24       	eor	r8, r8
    5000:	99 24       	eor	r9, r9
    5002:	0e 94 20 28 	call	0x5040	; 0x5040 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    5006:	8c 81       	ldd	r24, Y+4	; 0x04
    5008:	9d 81       	ldd	r25, Y+5	; 0x05
    500a:	0e 94 dc 28 	call	0x51b8	; 0x51b8 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    500e:	81 e0       	ldi	r24, 0x01	; 1
    5010:	8b 83       	std	Y+3, r24	; 0x03
    5012:	02 c0       	rjmp	.+4      	; 0x5018 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    5014:	8f ef       	ldi	r24, 0xFF	; 255
    5016:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    5018:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    501a:	60 96       	adiw	r28, 0x10	; 16
    501c:	0f b6       	in	r0, 0x3f	; 63
    501e:	f8 94       	cli
    5020:	de bf       	out	0x3e, r29	; 62
    5022:	0f be       	out	0x3f, r0	; 63
    5024:	cd bf       	out	0x3d, r28	; 61
    5026:	cf 91       	pop	r28
    5028:	df 91       	pop	r29
    502a:	1f 91       	pop	r17
    502c:	0f 91       	pop	r16
    502e:	ff 90       	pop	r15
    5030:	ef 90       	pop	r14
    5032:	df 90       	pop	r13
    5034:	cf 90       	pop	r12
    5036:	bf 90       	pop	r11
    5038:	af 90       	pop	r10
    503a:	9f 90       	pop	r9
    503c:	8f 90       	pop	r8
    503e:	08 95       	ret

00005040 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    5040:	8f 92       	push	r8
    5042:	9f 92       	push	r9
    5044:	af 92       	push	r10
    5046:	bf 92       	push	r11
    5048:	cf 92       	push	r12
    504a:	df 92       	push	r13
    504c:	ef 92       	push	r14
    504e:	0f 93       	push	r16
    5050:	1f 93       	push	r17
    5052:	df 93       	push	r29
    5054:	cf 93       	push	r28
    5056:	cd b7       	in	r28, 0x3d	; 61
    5058:	de b7       	in	r29, 0x3e	; 62
    505a:	64 97       	sbiw	r28, 0x14	; 20
    505c:	0f b6       	in	r0, 0x3f	; 63
    505e:	f8 94       	cli
    5060:	de bf       	out	0x3e, r29	; 62
    5062:	0f be       	out	0x3f, r0	; 63
    5064:	cd bf       	out	0x3d, r28	; 61
    5066:	9d 83       	std	Y+5, r25	; 0x05
    5068:	8c 83       	std	Y+4, r24	; 0x04
    506a:	7f 83       	std	Y+7, r23	; 0x07
    506c:	6e 83       	std	Y+6, r22	; 0x06
    506e:	28 87       	std	Y+8, r18	; 0x08
    5070:	39 87       	std	Y+9, r19	; 0x09
    5072:	4a 87       	std	Y+10, r20	; 0x0a
    5074:	5b 87       	std	Y+11, r21	; 0x0b
    5076:	1d 87       	std	Y+13, r17	; 0x0d
    5078:	0c 87       	std	Y+12, r16	; 0x0c
    507a:	ee 86       	std	Y+14, r14	; 0x0e
    507c:	d8 8a       	std	Y+16, r13	; 0x10
    507e:	cf 86       	std	Y+15, r12	; 0x0f
    5080:	ba 8a       	std	Y+18, r11	; 0x12
    5082:	a9 8a       	std	Y+17, r10	; 0x11
    5084:	9c 8a       	std	Y+20, r9	; 0x14
    5086:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    5088:	e9 89       	ldd	r30, Y+17	; 0x11
    508a:	fa 89       	ldd	r31, Y+18	; 0x12
    508c:	27 89       	ldd	r18, Z+23	; 0x17
    508e:	30 8d       	ldd	r19, Z+24	; 0x18
    5090:	88 85       	ldd	r24, Y+8	; 0x08
    5092:	99 85       	ldd	r25, Y+9	; 0x09
    5094:	01 97       	sbiw	r24, 0x01	; 1
    5096:	82 0f       	add	r24, r18
    5098:	93 1f       	adc	r25, r19
    509a:	9b 83       	std	Y+3, r25	; 0x03
    509c:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    509e:	8e 81       	ldd	r24, Y+6	; 0x06
    50a0:	9f 81       	ldd	r25, Y+7	; 0x07
    50a2:	00 97       	sbiw	r24, 0x00	; 0
    50a4:	51 f1       	breq	.+84     	; 0x50fa <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    50a6:	19 82       	std	Y+1, r1	; 0x01
    50a8:	21 c0       	rjmp	.+66     	; 0x50ec <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    50aa:	89 81       	ldd	r24, Y+1	; 0x01
    50ac:	48 2f       	mov	r20, r24
    50ae:	50 e0       	ldi	r21, 0x00	; 0
    50b0:	89 81       	ldd	r24, Y+1	; 0x01
    50b2:	28 2f       	mov	r18, r24
    50b4:	30 e0       	ldi	r19, 0x00	; 0
    50b6:	8e 81       	ldd	r24, Y+6	; 0x06
    50b8:	9f 81       	ldd	r25, Y+7	; 0x07
    50ba:	fc 01       	movw	r30, r24
    50bc:	e2 0f       	add	r30, r18
    50be:	f3 1f       	adc	r31, r19
    50c0:	20 81       	ld	r18, Z
    50c2:	89 89       	ldd	r24, Y+17	; 0x11
    50c4:	9a 89       	ldd	r25, Y+18	; 0x12
    50c6:	84 0f       	add	r24, r20
    50c8:	95 1f       	adc	r25, r21
    50ca:	fc 01       	movw	r30, r24
    50cc:	79 96       	adiw	r30, 0x19	; 25
    50ce:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    50d0:	89 81       	ldd	r24, Y+1	; 0x01
    50d2:	28 2f       	mov	r18, r24
    50d4:	30 e0       	ldi	r19, 0x00	; 0
    50d6:	8e 81       	ldd	r24, Y+6	; 0x06
    50d8:	9f 81       	ldd	r25, Y+7	; 0x07
    50da:	fc 01       	movw	r30, r24
    50dc:	e2 0f       	add	r30, r18
    50de:	f3 1f       	adc	r31, r19
    50e0:	80 81       	ld	r24, Z
    50e2:	88 23       	and	r24, r24
    50e4:	31 f0       	breq	.+12     	; 0x50f2 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    50e6:	89 81       	ldd	r24, Y+1	; 0x01
    50e8:	8f 5f       	subi	r24, 0xFF	; 255
    50ea:	89 83       	std	Y+1, r24	; 0x01
    50ec:	89 81       	ldd	r24, Y+1	; 0x01
    50ee:	88 30       	cpi	r24, 0x08	; 8
    50f0:	e0 f2       	brcs	.-72     	; 0x50aa <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    50f2:	e9 89       	ldd	r30, Y+17	; 0x11
    50f4:	fa 89       	ldd	r31, Y+18	; 0x12
    50f6:	10 a2       	std	Z+32, r1	; 0x20
    50f8:	03 c0       	rjmp	.+6      	; 0x5100 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    50fa:	e9 89       	ldd	r30, Y+17	; 0x11
    50fc:	fa 89       	ldd	r31, Y+18	; 0x12
    50fe:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    5100:	8e 85       	ldd	r24, Y+14	; 0x0e
    5102:	84 30       	cpi	r24, 0x04	; 4
    5104:	10 f0       	brcs	.+4      	; 0x510a <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5106:	83 e0       	ldi	r24, 0x03	; 3
    5108:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    510a:	e9 89       	ldd	r30, Y+17	; 0x11
    510c:	fa 89       	ldd	r31, Y+18	; 0x12
    510e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5110:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    5112:	89 89       	ldd	r24, Y+17	; 0x11
    5114:	9a 89       	ldd	r25, Y+18	; 0x12
    5116:	02 96       	adiw	r24, 0x02	; 2
    5118:	0e 94 70 14 	call	0x28e0	; 0x28e0 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    511c:	89 89       	ldd	r24, Y+17	; 0x11
    511e:	9a 89       	ldd	r25, Y+18	; 0x12
    5120:	0c 96       	adiw	r24, 0x0c	; 12
    5122:	0e 94 70 14 	call	0x28e0	; 0x28e0 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    5126:	e9 89       	ldd	r30, Y+17	; 0x11
    5128:	fa 89       	ldd	r31, Y+18	; 0x12
    512a:	89 89       	ldd	r24, Y+17	; 0x11
    512c:	9a 89       	ldd	r25, Y+18	; 0x12
    512e:	91 87       	std	Z+9, r25	; 0x09
    5130:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5132:	8e 85       	ldd	r24, Y+14	; 0x0e
    5134:	28 2f       	mov	r18, r24
    5136:	30 e0       	ldi	r19, 0x00	; 0
    5138:	84 e0       	ldi	r24, 0x04	; 4
    513a:	90 e0       	ldi	r25, 0x00	; 0
    513c:	82 1b       	sub	r24, r18
    513e:	93 0b       	sbc	r25, r19
    5140:	e9 89       	ldd	r30, Y+17	; 0x11
    5142:	fa 89       	ldd	r31, Y+18	; 0x12
    5144:	95 87       	std	Z+13, r25	; 0x0d
    5146:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    5148:	e9 89       	ldd	r30, Y+17	; 0x11
    514a:	fa 89       	ldd	r31, Y+18	; 0x12
    514c:	89 89       	ldd	r24, Y+17	; 0x11
    514e:	9a 89       	ldd	r25, Y+18	; 0x12
    5150:	93 8b       	std	Z+19, r25	; 0x13
    5152:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    5154:	e9 89       	ldd	r30, Y+17	; 0x11
    5156:	fa 89       	ldd	r31, Y+18	; 0x12
    5158:	11 a2       	std	Z+33, r1	; 0x21
    515a:	12 a2       	std	Z+34, r1	; 0x22
    515c:	13 a2       	std	Z+35, r1	; 0x23
    515e:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5160:	e9 89       	ldd	r30, Y+17	; 0x11
    5162:	fa 89       	ldd	r31, Y+18	; 0x12
    5164:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    5166:	8a 81       	ldd	r24, Y+2	; 0x02
    5168:	9b 81       	ldd	r25, Y+3	; 0x03
    516a:	2c 81       	ldd	r18, Y+4	; 0x04
    516c:	3d 81       	ldd	r19, Y+5	; 0x05
    516e:	4c 85       	ldd	r20, Y+12	; 0x0c
    5170:	5d 85       	ldd	r21, Y+13	; 0x0d
    5172:	b9 01       	movw	r22, r18
    5174:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <pxPortInitialiseStack>
    5178:	e9 89       	ldd	r30, Y+17	; 0x11
    517a:	fa 89       	ldd	r31, Y+18	; 0x12
    517c:	91 83       	std	Z+1, r25	; 0x01
    517e:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    5180:	8f 85       	ldd	r24, Y+15	; 0x0f
    5182:	98 89       	ldd	r25, Y+16	; 0x10
    5184:	00 97       	sbiw	r24, 0x00	; 0
    5186:	31 f0       	breq	.+12     	; 0x5194 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    5188:	ef 85       	ldd	r30, Y+15	; 0x0f
    518a:	f8 89       	ldd	r31, Y+16	; 0x10
    518c:	89 89       	ldd	r24, Y+17	; 0x11
    518e:	9a 89       	ldd	r25, Y+18	; 0x12
    5190:	91 83       	std	Z+1, r25	; 0x01
    5192:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    5194:	64 96       	adiw	r28, 0x14	; 20
    5196:	0f b6       	in	r0, 0x3f	; 63
    5198:	f8 94       	cli
    519a:	de bf       	out	0x3e, r29	; 62
    519c:	0f be       	out	0x3f, r0	; 63
    519e:	cd bf       	out	0x3d, r28	; 61
    51a0:	cf 91       	pop	r28
    51a2:	df 91       	pop	r29
    51a4:	1f 91       	pop	r17
    51a6:	0f 91       	pop	r16
    51a8:	ef 90       	pop	r14
    51aa:	df 90       	pop	r13
    51ac:	cf 90       	pop	r12
    51ae:	bf 90       	pop	r11
    51b0:	af 90       	pop	r10
    51b2:	9f 90       	pop	r9
    51b4:	8f 90       	pop	r8
    51b6:	08 95       	ret

000051b8 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    51b8:	df 93       	push	r29
    51ba:	cf 93       	push	r28
    51bc:	00 d0       	rcall	.+0      	; 0x51be <prvAddNewTaskToReadyList+0x6>
    51be:	cd b7       	in	r28, 0x3d	; 61
    51c0:	de b7       	in	r29, 0x3e	; 62
    51c2:	9a 83       	std	Y+2, r25	; 0x02
    51c4:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    51c6:	0f b6       	in	r0, 0x3f	; 63
    51c8:	f8 94       	cli
    51ca:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    51cc:	80 91 68 06 	lds	r24, 0x0668
    51d0:	8f 5f       	subi	r24, 0xFF	; 255
    51d2:	80 93 68 06 	sts	0x0668, r24
		if( pxCurrentTCB == NULL )
    51d6:	80 91 65 06 	lds	r24, 0x0665
    51da:	90 91 66 06 	lds	r25, 0x0666
    51de:	00 97       	sbiw	r24, 0x00	; 0
    51e0:	69 f4       	brne	.+26     	; 0x51fc <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    51e2:	89 81       	ldd	r24, Y+1	; 0x01
    51e4:	9a 81       	ldd	r25, Y+2	; 0x02
    51e6:	90 93 66 06 	sts	0x0666, r25
    51ea:	80 93 65 06 	sts	0x0665, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    51ee:	80 91 68 06 	lds	r24, 0x0668
    51f2:	81 30       	cpi	r24, 0x01	; 1
    51f4:	b9 f4       	brne	.+46     	; 0x5224 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    51f6:	0e 94 25 30 	call	0x604a	; 0x604a <prvInitialiseTaskLists>
    51fa:	14 c0       	rjmp	.+40     	; 0x5224 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    51fc:	80 91 6c 06 	lds	r24, 0x066C
    5200:	88 23       	and	r24, r24
    5202:	81 f4       	brne	.+32     	; 0x5224 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    5204:	e0 91 65 06 	lds	r30, 0x0665
    5208:	f0 91 66 06 	lds	r31, 0x0666
    520c:	96 89       	ldd	r25, Z+22	; 0x16
    520e:	e9 81       	ldd	r30, Y+1	; 0x01
    5210:	fa 81       	ldd	r31, Y+2	; 0x02
    5212:	86 89       	ldd	r24, Z+22	; 0x16
    5214:	89 17       	cp	r24, r25
    5216:	30 f0       	brcs	.+12     	; 0x5224 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    5218:	89 81       	ldd	r24, Y+1	; 0x01
    521a:	9a 81       	ldd	r25, Y+2	; 0x02
    521c:	90 93 66 06 	sts	0x0666, r25
    5220:	80 93 65 06 	sts	0x0665, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    5224:	80 91 70 06 	lds	r24, 0x0670
    5228:	8f 5f       	subi	r24, 0xFF	; 255
    522a:	80 93 70 06 	sts	0x0670, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    522e:	e9 81       	ldd	r30, Y+1	; 0x01
    5230:	fa 81       	ldd	r31, Y+2	; 0x02
    5232:	96 89       	ldd	r25, Z+22	; 0x16
    5234:	80 91 6b 06 	lds	r24, 0x066B
    5238:	89 17       	cp	r24, r25
    523a:	28 f4       	brcc	.+10     	; 0x5246 <prvAddNewTaskToReadyList+0x8e>
    523c:	e9 81       	ldd	r30, Y+1	; 0x01
    523e:	fa 81       	ldd	r31, Y+2	; 0x02
    5240:	86 89       	ldd	r24, Z+22	; 0x16
    5242:	80 93 6b 06 	sts	0x066B, r24
    5246:	e9 81       	ldd	r30, Y+1	; 0x01
    5248:	fa 81       	ldd	r31, Y+2	; 0x02
    524a:	86 89       	ldd	r24, Z+22	; 0x16
    524c:	28 2f       	mov	r18, r24
    524e:	30 e0       	ldi	r19, 0x00	; 0
    5250:	c9 01       	movw	r24, r18
    5252:	88 0f       	add	r24, r24
    5254:	99 1f       	adc	r25, r25
    5256:	88 0f       	add	r24, r24
    5258:	99 1f       	adc	r25, r25
    525a:	88 0f       	add	r24, r24
    525c:	99 1f       	adc	r25, r25
    525e:	82 0f       	add	r24, r18
    5260:	93 1f       	adc	r25, r19
    5262:	ac 01       	movw	r20, r24
    5264:	4a 58       	subi	r20, 0x8A	; 138
    5266:	59 4f       	sbci	r21, 0xF9	; 249
    5268:	89 81       	ldd	r24, Y+1	; 0x01
    526a:	9a 81       	ldd	r25, Y+2	; 0x02
    526c:	9c 01       	movw	r18, r24
    526e:	2e 5f       	subi	r18, 0xFE	; 254
    5270:	3f 4f       	sbci	r19, 0xFF	; 255
    5272:	ca 01       	movw	r24, r20
    5274:	b9 01       	movw	r22, r18
    5276:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    527a:	0f 90       	pop	r0
    527c:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    527e:	80 91 6c 06 	lds	r24, 0x066C
    5282:	88 23       	and	r24, r24
    5284:	61 f0       	breq	.+24     	; 0x529e <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    5286:	e0 91 65 06 	lds	r30, 0x0665
    528a:	f0 91 66 06 	lds	r31, 0x0666
    528e:	96 89       	ldd	r25, Z+22	; 0x16
    5290:	e9 81       	ldd	r30, Y+1	; 0x01
    5292:	fa 81       	ldd	r31, Y+2	; 0x02
    5294:	86 89       	ldd	r24, Z+22	; 0x16
    5296:	98 17       	cp	r25, r24
    5298:	10 f4       	brcc	.+4      	; 0x529e <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    529a:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    529e:	0f 90       	pop	r0
    52a0:	0f 90       	pop	r0
    52a2:	cf 91       	pop	r28
    52a4:	df 91       	pop	r29
    52a6:	08 95       	ret

000052a8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    52a8:	df 93       	push	r29
    52aa:	cf 93       	push	r28
    52ac:	00 d0       	rcall	.+0      	; 0x52ae <vTaskDelete+0x6>
    52ae:	00 d0       	rcall	.+0      	; 0x52b0 <vTaskDelete+0x8>
    52b0:	00 d0       	rcall	.+0      	; 0x52b2 <vTaskDelete+0xa>
    52b2:	cd b7       	in	r28, 0x3d	; 61
    52b4:	de b7       	in	r29, 0x3e	; 62
    52b6:	9c 83       	std	Y+4, r25	; 0x04
    52b8:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    52ba:	0f b6       	in	r0, 0x3f	; 63
    52bc:	f8 94       	cli
    52be:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    52c0:	8b 81       	ldd	r24, Y+3	; 0x03
    52c2:	9c 81       	ldd	r25, Y+4	; 0x04
    52c4:	00 97       	sbiw	r24, 0x00	; 0
    52c6:	39 f4       	brne	.+14     	; 0x52d6 <vTaskDelete+0x2e>
    52c8:	80 91 65 06 	lds	r24, 0x0665
    52cc:	90 91 66 06 	lds	r25, 0x0666
    52d0:	9e 83       	std	Y+6, r25	; 0x06
    52d2:	8d 83       	std	Y+5, r24	; 0x05
    52d4:	04 c0       	rjmp	.+8      	; 0x52de <vTaskDelete+0x36>
    52d6:	8b 81       	ldd	r24, Y+3	; 0x03
    52d8:	9c 81       	ldd	r25, Y+4	; 0x04
    52da:	9e 83       	std	Y+6, r25	; 0x06
    52dc:	8d 83       	std	Y+5, r24	; 0x05
    52de:	8d 81       	ldd	r24, Y+5	; 0x05
    52e0:	9e 81       	ldd	r25, Y+6	; 0x06
    52e2:	9a 83       	std	Y+2, r25	; 0x02
    52e4:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    52e6:	89 81       	ldd	r24, Y+1	; 0x01
    52e8:	9a 81       	ldd	r25, Y+2	; 0x02
    52ea:	02 96       	adiw	r24, 0x02	; 2
    52ec:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    52f0:	e9 81       	ldd	r30, Y+1	; 0x01
    52f2:	fa 81       	ldd	r31, Y+2	; 0x02
    52f4:	84 89       	ldd	r24, Z+20	; 0x14
    52f6:	95 89       	ldd	r25, Z+21	; 0x15
    52f8:	00 97       	sbiw	r24, 0x00	; 0
    52fa:	29 f0       	breq	.+10     	; 0x5306 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    52fc:	89 81       	ldd	r24, Y+1	; 0x01
    52fe:	9a 81       	ldd	r25, Y+2	; 0x02
    5300:	0c 96       	adiw	r24, 0x0c	; 12
    5302:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    5306:	80 91 70 06 	lds	r24, 0x0670
    530a:	8f 5f       	subi	r24, 0xFF	; 255
    530c:	80 93 70 06 	sts	0x0670, r24

			if( pxTCB == pxCurrentTCB )
    5310:	20 91 65 06 	lds	r18, 0x0665
    5314:	30 91 66 06 	lds	r19, 0x0666
    5318:	89 81       	ldd	r24, Y+1	; 0x01
    531a:	9a 81       	ldd	r25, Y+2	; 0x02
    531c:	82 17       	cp	r24, r18
    531e:	93 07       	cpc	r25, r19
    5320:	81 f4       	brne	.+32     	; 0x5342 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    5322:	89 81       	ldd	r24, Y+1	; 0x01
    5324:	9a 81       	ldd	r25, Y+2	; 0x02
    5326:	9c 01       	movw	r18, r24
    5328:	2e 5f       	subi	r18, 0xFE	; 254
    532a:	3f 4f       	sbci	r19, 0xFF	; 255
    532c:	89 eb       	ldi	r24, 0xB9	; 185
    532e:	96 e0       	ldi	r25, 0x06	; 6
    5330:	b9 01       	movw	r22, r18
    5332:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    5336:	80 91 67 06 	lds	r24, 0x0667
    533a:	8f 5f       	subi	r24, 0xFF	; 255
    533c:	80 93 67 06 	sts	0x0667, r24
    5340:	0b c0       	rjmp	.+22     	; 0x5358 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    5342:	80 91 68 06 	lds	r24, 0x0668
    5346:	81 50       	subi	r24, 0x01	; 1
    5348:	80 93 68 06 	sts	0x0668, r24
				prvDeleteTCB( pxTCB );
    534c:	89 81       	ldd	r24, Y+1	; 0x01
    534e:	9a 81       	ldd	r25, Y+2	; 0x02
    5350:	0e 94 95 30 	call	0x612a	; 0x612a <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    5354:	0e 94 ab 30 	call	0x6156	; 0x6156 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    5358:	0f 90       	pop	r0
    535a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    535c:	80 91 6c 06 	lds	r24, 0x066C
    5360:	88 23       	and	r24, r24
    5362:	59 f0       	breq	.+22     	; 0x537a <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    5364:	20 91 65 06 	lds	r18, 0x0665
    5368:	30 91 66 06 	lds	r19, 0x0666
    536c:	89 81       	ldd	r24, Y+1	; 0x01
    536e:	9a 81       	ldd	r25, Y+2	; 0x02
    5370:	82 17       	cp	r24, r18
    5372:	93 07       	cpc	r25, r19
    5374:	11 f4       	brne	.+4      	; 0x537a <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    5376:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    537a:	26 96       	adiw	r28, 0x06	; 6
    537c:	0f b6       	in	r0, 0x3f	; 63
    537e:	f8 94       	cli
    5380:	de bf       	out	0x3e, r29	; 62
    5382:	0f be       	out	0x3f, r0	; 63
    5384:	cd bf       	out	0x3d, r28	; 61
    5386:	cf 91       	pop	r28
    5388:	df 91       	pop	r29
    538a:	08 95       	ret

0000538c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    538c:	df 93       	push	r29
    538e:	cf 93       	push	r28
    5390:	cd b7       	in	r28, 0x3d	; 61
    5392:	de b7       	in	r29, 0x3e	; 62
    5394:	2a 97       	sbiw	r28, 0x0a	; 10
    5396:	0f b6       	in	r0, 0x3f	; 63
    5398:	f8 94       	cli
    539a:	de bf       	out	0x3e, r29	; 62
    539c:	0f be       	out	0x3f, r0	; 63
    539e:	cd bf       	out	0x3d, r28	; 61
    53a0:	98 87       	std	Y+8, r25	; 0x08
    53a2:	8f 83       	std	Y+7, r24	; 0x07
    53a4:	7a 87       	std	Y+10, r23	; 0x0a
    53a6:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    53a8:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    53aa:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    53ae:	80 91 69 06 	lds	r24, 0x0669
    53b2:	90 91 6a 06 	lds	r25, 0x066A
    53b6:	9a 83       	std	Y+2, r25	; 0x02
    53b8:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    53ba:	ef 81       	ldd	r30, Y+7	; 0x07
    53bc:	f8 85       	ldd	r31, Y+8	; 0x08
    53be:	20 81       	ld	r18, Z
    53c0:	31 81       	ldd	r19, Z+1	; 0x01
    53c2:	89 85       	ldd	r24, Y+9	; 0x09
    53c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    53c6:	82 0f       	add	r24, r18
    53c8:	93 1f       	adc	r25, r19
    53ca:	9e 83       	std	Y+6, r25	; 0x06
    53cc:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    53ce:	ef 81       	ldd	r30, Y+7	; 0x07
    53d0:	f8 85       	ldd	r31, Y+8	; 0x08
    53d2:	20 81       	ld	r18, Z
    53d4:	31 81       	ldd	r19, Z+1	; 0x01
    53d6:	89 81       	ldd	r24, Y+1	; 0x01
    53d8:	9a 81       	ldd	r25, Y+2	; 0x02
    53da:	82 17       	cp	r24, r18
    53dc:	93 07       	cpc	r25, r19
    53de:	98 f4       	brcc	.+38     	; 0x5406 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    53e0:	ef 81       	ldd	r30, Y+7	; 0x07
    53e2:	f8 85       	ldd	r31, Y+8	; 0x08
    53e4:	20 81       	ld	r18, Z
    53e6:	31 81       	ldd	r19, Z+1	; 0x01
    53e8:	8d 81       	ldd	r24, Y+5	; 0x05
    53ea:	9e 81       	ldd	r25, Y+6	; 0x06
    53ec:	82 17       	cp	r24, r18
    53ee:	93 07       	cpc	r25, r19
    53f0:	e0 f4       	brcc	.+56     	; 0x542a <vTaskDelayUntil+0x9e>
    53f2:	2d 81       	ldd	r18, Y+5	; 0x05
    53f4:	3e 81       	ldd	r19, Y+6	; 0x06
    53f6:	89 81       	ldd	r24, Y+1	; 0x01
    53f8:	9a 81       	ldd	r25, Y+2	; 0x02
    53fa:	82 17       	cp	r24, r18
    53fc:	93 07       	cpc	r25, r19
    53fe:	a8 f4       	brcc	.+42     	; 0x542a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    5400:	81 e0       	ldi	r24, 0x01	; 1
    5402:	8b 83       	std	Y+3, r24	; 0x03
    5404:	12 c0       	rjmp	.+36     	; 0x542a <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    5406:	ef 81       	ldd	r30, Y+7	; 0x07
    5408:	f8 85       	ldd	r31, Y+8	; 0x08
    540a:	20 81       	ld	r18, Z
    540c:	31 81       	ldd	r19, Z+1	; 0x01
    540e:	8d 81       	ldd	r24, Y+5	; 0x05
    5410:	9e 81       	ldd	r25, Y+6	; 0x06
    5412:	82 17       	cp	r24, r18
    5414:	93 07       	cpc	r25, r19
    5416:	38 f0       	brcs	.+14     	; 0x5426 <vTaskDelayUntil+0x9a>
    5418:	2d 81       	ldd	r18, Y+5	; 0x05
    541a:	3e 81       	ldd	r19, Y+6	; 0x06
    541c:	89 81       	ldd	r24, Y+1	; 0x01
    541e:	9a 81       	ldd	r25, Y+2	; 0x02
    5420:	82 17       	cp	r24, r18
    5422:	93 07       	cpc	r25, r19
    5424:	10 f4       	brcc	.+4      	; 0x542a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    5426:	81 e0       	ldi	r24, 0x01	; 1
    5428:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    542a:	ef 81       	ldd	r30, Y+7	; 0x07
    542c:	f8 85       	ldd	r31, Y+8	; 0x08
    542e:	8d 81       	ldd	r24, Y+5	; 0x05
    5430:	9e 81       	ldd	r25, Y+6	; 0x06
    5432:	91 83       	std	Z+1, r25	; 0x01
    5434:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    5436:	8b 81       	ldd	r24, Y+3	; 0x03
    5438:	88 23       	and	r24, r24
    543a:	49 f0       	breq	.+18     	; 0x544e <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    543c:	8d 81       	ldd	r24, Y+5	; 0x05
    543e:	9e 81       	ldd	r25, Y+6	; 0x06
    5440:	29 81       	ldd	r18, Y+1	; 0x01
    5442:	3a 81       	ldd	r19, Y+2	; 0x02
    5444:	82 1b       	sub	r24, r18
    5446:	93 0b       	sbc	r25, r19
    5448:	60 e0       	ldi	r22, 0x00	; 0
    544a:	0e 94 b7 34 	call	0x696e	; 0x696e <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    544e:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    5452:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5454:	8c 81       	ldd	r24, Y+4	; 0x04
    5456:	88 23       	and	r24, r24
    5458:	11 f4       	brne	.+4      	; 0x545e <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    545a:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    545e:	2a 96       	adiw	r28, 0x0a	; 10
    5460:	0f b6       	in	r0, 0x3f	; 63
    5462:	f8 94       	cli
    5464:	de bf       	out	0x3e, r29	; 62
    5466:	0f be       	out	0x3f, r0	; 63
    5468:	cd bf       	out	0x3d, r28	; 61
    546a:	cf 91       	pop	r28
    546c:	df 91       	pop	r29
    546e:	08 95       	ret

00005470 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    5470:	df 93       	push	r29
    5472:	cf 93       	push	r28
    5474:	00 d0       	rcall	.+0      	; 0x5476 <vTaskDelay+0x6>
    5476:	0f 92       	push	r0
    5478:	cd b7       	in	r28, 0x3d	; 61
    547a:	de b7       	in	r29, 0x3e	; 62
    547c:	9b 83       	std	Y+3, r25	; 0x03
    547e:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    5480:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    5482:	8a 81       	ldd	r24, Y+2	; 0x02
    5484:	9b 81       	ldd	r25, Y+3	; 0x03
    5486:	00 97       	sbiw	r24, 0x00	; 0
    5488:	51 f0       	breq	.+20     	; 0x549e <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    548a:	0e 94 05 2c 	call	0x580a	; 0x580a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    548e:	8a 81       	ldd	r24, Y+2	; 0x02
    5490:	9b 81       	ldd	r25, Y+3	; 0x03
    5492:	60 e0       	ldi	r22, 0x00	; 0
    5494:	0e 94 b7 34 	call	0x696e	; 0x696e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    5498:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskResumeAll>
    549c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    549e:	89 81       	ldd	r24, Y+1	; 0x01
    54a0:	88 23       	and	r24, r24
    54a2:	11 f4       	brne	.+4      	; 0x54a8 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    54a4:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    54a8:	0f 90       	pop	r0
    54aa:	0f 90       	pop	r0
    54ac:	0f 90       	pop	r0
    54ae:	cf 91       	pop	r28
    54b0:	df 91       	pop	r29
    54b2:	08 95       	ret

000054b4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    54b4:	df 93       	push	r29
    54b6:	cf 93       	push	r28
    54b8:	00 d0       	rcall	.+0      	; 0x54ba <vTaskSuspend+0x6>
    54ba:	00 d0       	rcall	.+0      	; 0x54bc <vTaskSuspend+0x8>
    54bc:	00 d0       	rcall	.+0      	; 0x54be <vTaskSuspend+0xa>
    54be:	cd b7       	in	r28, 0x3d	; 61
    54c0:	de b7       	in	r29, 0x3e	; 62
    54c2:	9c 83       	std	Y+4, r25	; 0x04
    54c4:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    54c6:	0f b6       	in	r0, 0x3f	; 63
    54c8:	f8 94       	cli
    54ca:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    54cc:	8b 81       	ldd	r24, Y+3	; 0x03
    54ce:	9c 81       	ldd	r25, Y+4	; 0x04
    54d0:	00 97       	sbiw	r24, 0x00	; 0
    54d2:	39 f4       	brne	.+14     	; 0x54e2 <vTaskSuspend+0x2e>
    54d4:	80 91 65 06 	lds	r24, 0x0665
    54d8:	90 91 66 06 	lds	r25, 0x0666
    54dc:	9e 83       	std	Y+6, r25	; 0x06
    54de:	8d 83       	std	Y+5, r24	; 0x05
    54e0:	04 c0       	rjmp	.+8      	; 0x54ea <vTaskSuspend+0x36>
    54e2:	8b 81       	ldd	r24, Y+3	; 0x03
    54e4:	9c 81       	ldd	r25, Y+4	; 0x04
    54e6:	9e 83       	std	Y+6, r25	; 0x06
    54e8:	8d 83       	std	Y+5, r24	; 0x05
    54ea:	8d 81       	ldd	r24, Y+5	; 0x05
    54ec:	9e 81       	ldd	r25, Y+6	; 0x06
    54ee:	9a 83       	std	Y+2, r25	; 0x02
    54f0:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    54f2:	89 81       	ldd	r24, Y+1	; 0x01
    54f4:	9a 81       	ldd	r25, Y+2	; 0x02
    54f6:	02 96       	adiw	r24, 0x02	; 2
    54f8:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    54fc:	e9 81       	ldd	r30, Y+1	; 0x01
    54fe:	fa 81       	ldd	r31, Y+2	; 0x02
    5500:	84 89       	ldd	r24, Z+20	; 0x14
    5502:	95 89       	ldd	r25, Z+21	; 0x15
    5504:	00 97       	sbiw	r24, 0x00	; 0
    5506:	29 f0       	breq	.+10     	; 0x5512 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5508:	89 81       	ldd	r24, Y+1	; 0x01
    550a:	9a 81       	ldd	r25, Y+2	; 0x02
    550c:	0c 96       	adiw	r24, 0x0c	; 12
    550e:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    5512:	89 81       	ldd	r24, Y+1	; 0x01
    5514:	9a 81       	ldd	r25, Y+2	; 0x02
    5516:	9c 01       	movw	r18, r24
    5518:	2e 5f       	subi	r18, 0xFE	; 254
    551a:	3f 4f       	sbci	r19, 0xFF	; 255
    551c:	82 ec       	ldi	r24, 0xC2	; 194
    551e:	96 e0       	ldi	r25, 0x06	; 6
    5520:	b9 01       	movw	r22, r18
    5522:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    5526:	e9 81       	ldd	r30, Y+1	; 0x01
    5528:	fa 81       	ldd	r31, Y+2	; 0x02
    552a:	85 a1       	ldd	r24, Z+37	; 0x25
    552c:	81 30       	cpi	r24, 0x01	; 1
    552e:	19 f4       	brne	.+6      	; 0x5536 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5530:	e9 81       	ldd	r30, Y+1	; 0x01
    5532:	fa 81       	ldd	r31, Y+2	; 0x02
    5534:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    5536:	0f 90       	pop	r0
    5538:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    553a:	80 91 6c 06 	lds	r24, 0x066C
    553e:	88 23       	and	r24, r24
    5540:	39 f0       	breq	.+14     	; 0x5550 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    5542:	0f b6       	in	r0, 0x3f	; 63
    5544:	f8 94       	cli
    5546:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    5548:	0e 94 ab 30 	call	0x6156	; 0x6156 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    554c:	0f 90       	pop	r0
    554e:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    5550:	20 91 65 06 	lds	r18, 0x0665
    5554:	30 91 66 06 	lds	r19, 0x0666
    5558:	89 81       	ldd	r24, Y+1	; 0x01
    555a:	9a 81       	ldd	r25, Y+2	; 0x02
    555c:	82 17       	cp	r24, r18
    555e:	93 07       	cpc	r25, r19
    5560:	a1 f4       	brne	.+40     	; 0x558a <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    5562:	80 91 6c 06 	lds	r24, 0x066C
    5566:	88 23       	and	r24, r24
    5568:	19 f0       	breq	.+6      	; 0x5570 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    556a:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
    556e:	0d c0       	rjmp	.+26     	; 0x558a <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    5570:	90 91 c2 06 	lds	r25, 0x06C2
    5574:	80 91 68 06 	lds	r24, 0x0668
    5578:	98 17       	cp	r25, r24
    557a:	29 f4       	brne	.+10     	; 0x5586 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    557c:	10 92 66 06 	sts	0x0666, r1
    5580:	10 92 65 06 	sts	0x0665, r1
    5584:	02 c0       	rjmp	.+4      	; 0x558a <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    5586:	0e 94 e6 2d 	call	0x5bcc	; 0x5bcc <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    558a:	26 96       	adiw	r28, 0x06	; 6
    558c:	0f b6       	in	r0, 0x3f	; 63
    558e:	f8 94       	cli
    5590:	de bf       	out	0x3e, r29	; 62
    5592:	0f be       	out	0x3f, r0	; 63
    5594:	cd bf       	out	0x3d, r28	; 61
    5596:	cf 91       	pop	r28
    5598:	df 91       	pop	r29
    559a:	08 95       	ret

0000559c <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    559c:	df 93       	push	r29
    559e:	cf 93       	push	r28
    55a0:	00 d0       	rcall	.+0      	; 0x55a2 <prvTaskIsTaskSuspended+0x6>
    55a2:	00 d0       	rcall	.+0      	; 0x55a4 <prvTaskIsTaskSuspended+0x8>
    55a4:	0f 92       	push	r0
    55a6:	cd b7       	in	r28, 0x3d	; 61
    55a8:	de b7       	in	r29, 0x3e	; 62
    55aa:	9d 83       	std	Y+5, r25	; 0x05
    55ac:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    55ae:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    55b0:	8c 81       	ldd	r24, Y+4	; 0x04
    55b2:	9d 81       	ldd	r25, Y+5	; 0x05
    55b4:	9a 83       	std	Y+2, r25	; 0x02
    55b6:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    55b8:	e9 81       	ldd	r30, Y+1	; 0x01
    55ba:	fa 81       	ldd	r31, Y+2	; 0x02
    55bc:	82 85       	ldd	r24, Z+10	; 0x0a
    55be:	93 85       	ldd	r25, Z+11	; 0x0b
    55c0:	26 e0       	ldi	r18, 0x06	; 6
    55c2:	82 3c       	cpi	r24, 0xC2	; 194
    55c4:	92 07       	cpc	r25, r18
    55c6:	81 f4       	brne	.+32     	; 0x55e8 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    55c8:	e9 81       	ldd	r30, Y+1	; 0x01
    55ca:	fa 81       	ldd	r31, Y+2	; 0x02
    55cc:	84 89       	ldd	r24, Z+20	; 0x14
    55ce:	95 89       	ldd	r25, Z+21	; 0x15
    55d0:	26 e0       	ldi	r18, 0x06	; 6
    55d2:	80 3b       	cpi	r24, 0xB0	; 176
    55d4:	92 07       	cpc	r25, r18
    55d6:	41 f0       	breq	.+16     	; 0x55e8 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    55d8:	e9 81       	ldd	r30, Y+1	; 0x01
    55da:	fa 81       	ldd	r31, Y+2	; 0x02
    55dc:	84 89       	ldd	r24, Z+20	; 0x14
    55de:	95 89       	ldd	r25, Z+21	; 0x15
    55e0:	00 97       	sbiw	r24, 0x00	; 0
    55e2:	11 f4       	brne	.+4      	; 0x55e8 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    55e4:	81 e0       	ldi	r24, 0x01	; 1
    55e6:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    55e8:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    55ea:	0f 90       	pop	r0
    55ec:	0f 90       	pop	r0
    55ee:	0f 90       	pop	r0
    55f0:	0f 90       	pop	r0
    55f2:	0f 90       	pop	r0
    55f4:	cf 91       	pop	r28
    55f6:	df 91       	pop	r29
    55f8:	08 95       	ret

000055fa <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    55fa:	df 93       	push	r29
    55fc:	cf 93       	push	r28
    55fe:	00 d0       	rcall	.+0      	; 0x5600 <vTaskResume+0x6>
    5600:	00 d0       	rcall	.+0      	; 0x5602 <vTaskResume+0x8>
    5602:	cd b7       	in	r28, 0x3d	; 61
    5604:	de b7       	in	r29, 0x3e	; 62
    5606:	9c 83       	std	Y+4, r25	; 0x04
    5608:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    560a:	8b 81       	ldd	r24, Y+3	; 0x03
    560c:	9c 81       	ldd	r25, Y+4	; 0x04
    560e:	9a 83       	std	Y+2, r25	; 0x02
    5610:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    5612:	20 91 65 06 	lds	r18, 0x0665
    5616:	30 91 66 06 	lds	r19, 0x0666
    561a:	89 81       	ldd	r24, Y+1	; 0x01
    561c:	9a 81       	ldd	r25, Y+2	; 0x02
    561e:	82 17       	cp	r24, r18
    5620:	93 07       	cpc	r25, r19
    5622:	09 f4       	brne	.+2      	; 0x5626 <vTaskResume+0x2c>
    5624:	47 c0       	rjmp	.+142    	; 0x56b4 <vTaskResume+0xba>
    5626:	89 81       	ldd	r24, Y+1	; 0x01
    5628:	9a 81       	ldd	r25, Y+2	; 0x02
    562a:	00 97       	sbiw	r24, 0x00	; 0
    562c:	09 f4       	brne	.+2      	; 0x5630 <vTaskResume+0x36>
    562e:	42 c0       	rjmp	.+132    	; 0x56b4 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    5630:	0f b6       	in	r0, 0x3f	; 63
    5632:	f8 94       	cli
    5634:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    5636:	89 81       	ldd	r24, Y+1	; 0x01
    5638:	9a 81       	ldd	r25, Y+2	; 0x02
    563a:	0e 94 ce 2a 	call	0x559c	; 0x559c <prvTaskIsTaskSuspended>
    563e:	88 23       	and	r24, r24
    5640:	b9 f1       	breq	.+110    	; 0x56b0 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    5642:	89 81       	ldd	r24, Y+1	; 0x01
    5644:	9a 81       	ldd	r25, Y+2	; 0x02
    5646:	02 96       	adiw	r24, 0x02	; 2
    5648:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    564c:	e9 81       	ldd	r30, Y+1	; 0x01
    564e:	fa 81       	ldd	r31, Y+2	; 0x02
    5650:	96 89       	ldd	r25, Z+22	; 0x16
    5652:	80 91 6b 06 	lds	r24, 0x066B
    5656:	89 17       	cp	r24, r25
    5658:	28 f4       	brcc	.+10     	; 0x5664 <vTaskResume+0x6a>
    565a:	e9 81       	ldd	r30, Y+1	; 0x01
    565c:	fa 81       	ldd	r31, Y+2	; 0x02
    565e:	86 89       	ldd	r24, Z+22	; 0x16
    5660:	80 93 6b 06 	sts	0x066B, r24
    5664:	e9 81       	ldd	r30, Y+1	; 0x01
    5666:	fa 81       	ldd	r31, Y+2	; 0x02
    5668:	86 89       	ldd	r24, Z+22	; 0x16
    566a:	28 2f       	mov	r18, r24
    566c:	30 e0       	ldi	r19, 0x00	; 0
    566e:	c9 01       	movw	r24, r18
    5670:	88 0f       	add	r24, r24
    5672:	99 1f       	adc	r25, r25
    5674:	88 0f       	add	r24, r24
    5676:	99 1f       	adc	r25, r25
    5678:	88 0f       	add	r24, r24
    567a:	99 1f       	adc	r25, r25
    567c:	82 0f       	add	r24, r18
    567e:	93 1f       	adc	r25, r19
    5680:	ac 01       	movw	r20, r24
    5682:	4a 58       	subi	r20, 0x8A	; 138
    5684:	59 4f       	sbci	r21, 0xF9	; 249
    5686:	89 81       	ldd	r24, Y+1	; 0x01
    5688:	9a 81       	ldd	r25, Y+2	; 0x02
    568a:	9c 01       	movw	r18, r24
    568c:	2e 5f       	subi	r18, 0xFE	; 254
    568e:	3f 4f       	sbci	r19, 0xFF	; 255
    5690:	ca 01       	movw	r24, r20
    5692:	b9 01       	movw	r22, r18
    5694:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5698:	e9 81       	ldd	r30, Y+1	; 0x01
    569a:	fa 81       	ldd	r31, Y+2	; 0x02
    569c:	96 89       	ldd	r25, Z+22	; 0x16
    569e:	e0 91 65 06 	lds	r30, 0x0665
    56a2:	f0 91 66 06 	lds	r31, 0x0666
    56a6:	86 89       	ldd	r24, Z+22	; 0x16
    56a8:	98 17       	cp	r25, r24
    56aa:	10 f0       	brcs	.+4      	; 0x56b0 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    56ac:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    56b0:	0f 90       	pop	r0
    56b2:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    56b4:	0f 90       	pop	r0
    56b6:	0f 90       	pop	r0
    56b8:	0f 90       	pop	r0
    56ba:	0f 90       	pop	r0
    56bc:	cf 91       	pop	r28
    56be:	df 91       	pop	r29
    56c0:	08 95       	ret

000056c2 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    56c2:	df 93       	push	r29
    56c4:	cf 93       	push	r28
    56c6:	00 d0       	rcall	.+0      	; 0x56c8 <xTaskResumeFromISR+0x6>
    56c8:	00 d0       	rcall	.+0      	; 0x56ca <xTaskResumeFromISR+0x8>
    56ca:	00 d0       	rcall	.+0      	; 0x56cc <xTaskResumeFromISR+0xa>
    56cc:	cd b7       	in	r28, 0x3d	; 61
    56ce:	de b7       	in	r29, 0x3e	; 62
    56d0:	9e 83       	std	Y+6, r25	; 0x06
    56d2:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    56d4:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    56d6:	8d 81       	ldd	r24, Y+5	; 0x05
    56d8:	9e 81       	ldd	r25, Y+6	; 0x06
    56da:	9b 83       	std	Y+3, r25	; 0x03
    56dc:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    56de:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    56e0:	8a 81       	ldd	r24, Y+2	; 0x02
    56e2:	9b 81       	ldd	r25, Y+3	; 0x03
    56e4:	0e 94 ce 2a 	call	0x559c	; 0x559c <prvTaskIsTaskSuspended>
    56e8:	88 23       	and	r24, r24
    56ea:	09 f4       	brne	.+2      	; 0x56ee <xTaskResumeFromISR+0x2c>
    56ec:	46 c0       	rjmp	.+140    	; 0x577a <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    56ee:	80 91 75 06 	lds	r24, 0x0675
    56f2:	88 23       	and	r24, r24
    56f4:	c1 f5       	brne	.+112    	; 0x5766 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    56f6:	ea 81       	ldd	r30, Y+2	; 0x02
    56f8:	fb 81       	ldd	r31, Y+3	; 0x03
    56fa:	96 89       	ldd	r25, Z+22	; 0x16
    56fc:	e0 91 65 06 	lds	r30, 0x0665
    5700:	f0 91 66 06 	lds	r31, 0x0666
    5704:	86 89       	ldd	r24, Z+22	; 0x16
    5706:	98 17       	cp	r25, r24
    5708:	10 f0       	brcs	.+4      	; 0x570e <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    570a:	81 e0       	ldi	r24, 0x01	; 1
    570c:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    570e:	8a 81       	ldd	r24, Y+2	; 0x02
    5710:	9b 81       	ldd	r25, Y+3	; 0x03
    5712:	02 96       	adiw	r24, 0x02	; 2
    5714:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5718:	ea 81       	ldd	r30, Y+2	; 0x02
    571a:	fb 81       	ldd	r31, Y+3	; 0x03
    571c:	96 89       	ldd	r25, Z+22	; 0x16
    571e:	80 91 6b 06 	lds	r24, 0x066B
    5722:	89 17       	cp	r24, r25
    5724:	28 f4       	brcc	.+10     	; 0x5730 <xTaskResumeFromISR+0x6e>
    5726:	ea 81       	ldd	r30, Y+2	; 0x02
    5728:	fb 81       	ldd	r31, Y+3	; 0x03
    572a:	86 89       	ldd	r24, Z+22	; 0x16
    572c:	80 93 6b 06 	sts	0x066B, r24
    5730:	ea 81       	ldd	r30, Y+2	; 0x02
    5732:	fb 81       	ldd	r31, Y+3	; 0x03
    5734:	86 89       	ldd	r24, Z+22	; 0x16
    5736:	28 2f       	mov	r18, r24
    5738:	30 e0       	ldi	r19, 0x00	; 0
    573a:	c9 01       	movw	r24, r18
    573c:	88 0f       	add	r24, r24
    573e:	99 1f       	adc	r25, r25
    5740:	88 0f       	add	r24, r24
    5742:	99 1f       	adc	r25, r25
    5744:	88 0f       	add	r24, r24
    5746:	99 1f       	adc	r25, r25
    5748:	82 0f       	add	r24, r18
    574a:	93 1f       	adc	r25, r19
    574c:	ac 01       	movw	r20, r24
    574e:	4a 58       	subi	r20, 0x8A	; 138
    5750:	59 4f       	sbci	r21, 0xF9	; 249
    5752:	8a 81       	ldd	r24, Y+2	; 0x02
    5754:	9b 81       	ldd	r25, Y+3	; 0x03
    5756:	9c 01       	movw	r18, r24
    5758:	2e 5f       	subi	r18, 0xFE	; 254
    575a:	3f 4f       	sbci	r19, 0xFF	; 255
    575c:	ca 01       	movw	r24, r20
    575e:	b9 01       	movw	r22, r18
    5760:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
    5764:	0a c0       	rjmp	.+20     	; 0x577a <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5766:	8a 81       	ldd	r24, Y+2	; 0x02
    5768:	9b 81       	ldd	r25, Y+3	; 0x03
    576a:	9c 01       	movw	r18, r24
    576c:	24 5f       	subi	r18, 0xF4	; 244
    576e:	3f 4f       	sbci	r19, 0xFF	; 255
    5770:	80 eb       	ldi	r24, 0xB0	; 176
    5772:	96 e0       	ldi	r25, 0x06	; 6
    5774:	b9 01       	movw	r22, r18
    5776:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    577a:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    577c:	26 96       	adiw	r28, 0x06	; 6
    577e:	0f b6       	in	r0, 0x3f	; 63
    5780:	f8 94       	cli
    5782:	de bf       	out	0x3e, r29	; 62
    5784:	0f be       	out	0x3f, r0	; 63
    5786:	cd bf       	out	0x3d, r28	; 61
    5788:	cf 91       	pop	r28
    578a:	df 91       	pop	r29
    578c:	08 95       	ret

0000578e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    578e:	ef 92       	push	r14
    5790:	ff 92       	push	r15
    5792:	0f 93       	push	r16
    5794:	df 93       	push	r29
    5796:	cf 93       	push	r28
    5798:	0f 92       	push	r0
    579a:	cd b7       	in	r28, 0x3d	; 61
    579c:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    579e:	8b e1       	ldi	r24, 0x1B	; 27
    57a0:	90 e3       	ldi	r25, 0x30	; 48
    57a2:	26 e7       	ldi	r18, 0x76	; 118
    57a4:	30 e0       	ldi	r19, 0x00	; 0
    57a6:	e3 e7       	ldi	r30, 0x73	; 115
    57a8:	f6 e0       	ldi	r31, 0x06	; 6
    57aa:	b9 01       	movw	r22, r18
    57ac:	45 e5       	ldi	r20, 0x55	; 85
    57ae:	50 e0       	ldi	r21, 0x00	; 0
    57b0:	20 e0       	ldi	r18, 0x00	; 0
    57b2:	30 e0       	ldi	r19, 0x00	; 0
    57b4:	00 e0       	ldi	r16, 0x00	; 0
    57b6:	7f 01       	movw	r14, r30
    57b8:	0e 94 a8 27 	call	0x4f50	; 0x4f50 <xTaskCreate>
    57bc:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    57be:	89 81       	ldd	r24, Y+1	; 0x01
    57c0:	81 30       	cpi	r24, 0x01	; 1
    57c2:	81 f4       	brne	.+32     	; 0x57e4 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    57c4:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    57c6:	8f ef       	ldi	r24, 0xFF	; 255
    57c8:	9f ef       	ldi	r25, 0xFF	; 255
    57ca:	90 93 72 06 	sts	0x0672, r25
    57ce:	80 93 71 06 	sts	0x0671, r24
		xSchedulerRunning = pdTRUE;
    57d2:	81 e0       	ldi	r24, 0x01	; 1
    57d4:	80 93 6c 06 	sts	0x066C, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    57d8:	10 92 6a 06 	sts	0x066A, r1
    57dc:	10 92 69 06 	sts	0x0669, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    57e0:	0e 94 81 17 	call	0x2f02	; 0x2f02 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    57e4:	0f 90       	pop	r0
    57e6:	cf 91       	pop	r28
    57e8:	df 91       	pop	r29
    57ea:	0f 91       	pop	r16
    57ec:	ff 90       	pop	r15
    57ee:	ef 90       	pop	r14
    57f0:	08 95       	ret

000057f2 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    57f2:	df 93       	push	r29
    57f4:	cf 93       	push	r28
    57f6:	cd b7       	in	r28, 0x3d	; 61
    57f8:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    57fa:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    57fc:	10 92 6c 06 	sts	0x066C, r1
	vPortEndScheduler();
    5800:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <vPortEndScheduler>
}
    5804:	cf 91       	pop	r28
    5806:	df 91       	pop	r29
    5808:	08 95       	ret

0000580a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    580a:	df 93       	push	r29
    580c:	cf 93       	push	r28
    580e:	cd b7       	in	r28, 0x3d	; 61
    5810:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    5812:	80 91 75 06 	lds	r24, 0x0675
    5816:	8f 5f       	subi	r24, 0xFF	; 255
    5818:	80 93 75 06 	sts	0x0675, r24
}
    581c:	cf 91       	pop	r28
    581e:	df 91       	pop	r29
    5820:	08 95       	ret

00005822 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    5822:	df 93       	push	r29
    5824:	cf 93       	push	r28
    5826:	00 d0       	rcall	.+0      	; 0x5828 <xTaskResumeAll+0x6>
    5828:	00 d0       	rcall	.+0      	; 0x582a <xTaskResumeAll+0x8>
    582a:	cd b7       	in	r28, 0x3d	; 61
    582c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    582e:	1c 82       	std	Y+4, r1	; 0x04
    5830:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    5832:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    5834:	0f b6       	in	r0, 0x3f	; 63
    5836:	f8 94       	cli
    5838:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    583a:	80 91 75 06 	lds	r24, 0x0675
    583e:	81 50       	subi	r24, 0x01	; 1
    5840:	80 93 75 06 	sts	0x0675, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5844:	80 91 75 06 	lds	r24, 0x0675
    5848:	88 23       	and	r24, r24
    584a:	09 f0       	breq	.+2      	; 0x584e <xTaskResumeAll+0x2c>
    584c:	73 c0       	rjmp	.+230    	; 0x5934 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    584e:	80 91 68 06 	lds	r24, 0x0668
    5852:	88 23       	and	r24, r24
    5854:	09 f4       	brne	.+2      	; 0x5858 <xTaskResumeAll+0x36>
    5856:	6e c0       	rjmp	.+220    	; 0x5934 <xTaskResumeAll+0x112>
    5858:	45 c0       	rjmp	.+138    	; 0x58e4 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    585a:	e0 91 b5 06 	lds	r30, 0x06B5
    585e:	f0 91 b6 06 	lds	r31, 0x06B6
    5862:	86 81       	ldd	r24, Z+6	; 0x06
    5864:	97 81       	ldd	r25, Z+7	; 0x07
    5866:	9c 83       	std	Y+4, r25	; 0x04
    5868:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    586a:	8b 81       	ldd	r24, Y+3	; 0x03
    586c:	9c 81       	ldd	r25, Y+4	; 0x04
    586e:	0c 96       	adiw	r24, 0x0c	; 12
    5870:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5874:	8b 81       	ldd	r24, Y+3	; 0x03
    5876:	9c 81       	ldd	r25, Y+4	; 0x04
    5878:	02 96       	adiw	r24, 0x02	; 2
    587a:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    587e:	eb 81       	ldd	r30, Y+3	; 0x03
    5880:	fc 81       	ldd	r31, Y+4	; 0x04
    5882:	96 89       	ldd	r25, Z+22	; 0x16
    5884:	80 91 6b 06 	lds	r24, 0x066B
    5888:	89 17       	cp	r24, r25
    588a:	28 f4       	brcc	.+10     	; 0x5896 <xTaskResumeAll+0x74>
    588c:	eb 81       	ldd	r30, Y+3	; 0x03
    588e:	fc 81       	ldd	r31, Y+4	; 0x04
    5890:	86 89       	ldd	r24, Z+22	; 0x16
    5892:	80 93 6b 06 	sts	0x066B, r24
    5896:	eb 81       	ldd	r30, Y+3	; 0x03
    5898:	fc 81       	ldd	r31, Y+4	; 0x04
    589a:	86 89       	ldd	r24, Z+22	; 0x16
    589c:	28 2f       	mov	r18, r24
    589e:	30 e0       	ldi	r19, 0x00	; 0
    58a0:	c9 01       	movw	r24, r18
    58a2:	88 0f       	add	r24, r24
    58a4:	99 1f       	adc	r25, r25
    58a6:	88 0f       	add	r24, r24
    58a8:	99 1f       	adc	r25, r25
    58aa:	88 0f       	add	r24, r24
    58ac:	99 1f       	adc	r25, r25
    58ae:	82 0f       	add	r24, r18
    58b0:	93 1f       	adc	r25, r19
    58b2:	ac 01       	movw	r20, r24
    58b4:	4a 58       	subi	r20, 0x8A	; 138
    58b6:	59 4f       	sbci	r21, 0xF9	; 249
    58b8:	8b 81       	ldd	r24, Y+3	; 0x03
    58ba:	9c 81       	ldd	r25, Y+4	; 0x04
    58bc:	9c 01       	movw	r18, r24
    58be:	2e 5f       	subi	r18, 0xFE	; 254
    58c0:	3f 4f       	sbci	r19, 0xFF	; 255
    58c2:	ca 01       	movw	r24, r20
    58c4:	b9 01       	movw	r22, r18
    58c6:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    58ca:	eb 81       	ldd	r30, Y+3	; 0x03
    58cc:	fc 81       	ldd	r31, Y+4	; 0x04
    58ce:	96 89       	ldd	r25, Z+22	; 0x16
    58d0:	e0 91 65 06 	lds	r30, 0x0665
    58d4:	f0 91 66 06 	lds	r31, 0x0666
    58d8:	86 89       	ldd	r24, Z+22	; 0x16
    58da:	98 17       	cp	r25, r24
    58dc:	18 f0       	brcs	.+6      	; 0x58e4 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    58de:	81 e0       	ldi	r24, 0x01	; 1
    58e0:	80 93 6e 06 	sts	0x066E, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    58e4:	80 91 b0 06 	lds	r24, 0x06B0
    58e8:	88 23       	and	r24, r24
    58ea:	09 f0       	breq	.+2      	; 0x58ee <xTaskResumeAll+0xcc>
    58ec:	b6 cf       	rjmp	.-148    	; 0x585a <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    58ee:	8b 81       	ldd	r24, Y+3	; 0x03
    58f0:	9c 81       	ldd	r25, Y+4	; 0x04
    58f2:	00 97       	sbiw	r24, 0x00	; 0
    58f4:	11 f0       	breq	.+4      	; 0x58fa <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    58f6:	0e 94 ab 30 	call	0x6156	; 0x6156 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    58fa:	80 91 6d 06 	lds	r24, 0x066D
    58fe:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    5900:	89 81       	ldd	r24, Y+1	; 0x01
    5902:	88 23       	and	r24, r24
    5904:	79 f0       	breq	.+30     	; 0x5924 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    5906:	0e 94 01 2d 	call	0x5a02	; 0x5a02 <xTaskIncrementTick>
    590a:	88 23       	and	r24, r24
    590c:	19 f0       	breq	.+6      	; 0x5914 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    590e:	81 e0       	ldi	r24, 0x01	; 1
    5910:	80 93 6e 06 	sts	0x066E, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    5914:	89 81       	ldd	r24, Y+1	; 0x01
    5916:	81 50       	subi	r24, 0x01	; 1
    5918:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    591a:	89 81       	ldd	r24, Y+1	; 0x01
    591c:	88 23       	and	r24, r24
    591e:	99 f7       	brne	.-26     	; 0x5906 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    5920:	10 92 6d 06 	sts	0x066D, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    5924:	80 91 6e 06 	lds	r24, 0x066E
    5928:	88 23       	and	r24, r24
    592a:	21 f0       	breq	.+8      	; 0x5934 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    592c:	81 e0       	ldi	r24, 0x01	; 1
    592e:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    5930:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    5934:	0f 90       	pop	r0
    5936:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    5938:	8a 81       	ldd	r24, Y+2	; 0x02
}
    593a:	0f 90       	pop	r0
    593c:	0f 90       	pop	r0
    593e:	0f 90       	pop	r0
    5940:	0f 90       	pop	r0
    5942:	cf 91       	pop	r28
    5944:	df 91       	pop	r29
    5946:	08 95       	ret

00005948 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    5948:	df 93       	push	r29
    594a:	cf 93       	push	r28
    594c:	00 d0       	rcall	.+0      	; 0x594e <xTaskGetTickCount+0x6>
    594e:	cd b7       	in	r28, 0x3d	; 61
    5950:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    5952:	0f b6       	in	r0, 0x3f	; 63
    5954:	f8 94       	cli
    5956:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    5958:	80 91 69 06 	lds	r24, 0x0669
    595c:	90 91 6a 06 	lds	r25, 0x066A
    5960:	9a 83       	std	Y+2, r25	; 0x02
    5962:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    5964:	0f 90       	pop	r0
    5966:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    5968:	89 81       	ldd	r24, Y+1	; 0x01
    596a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    596c:	0f 90       	pop	r0
    596e:	0f 90       	pop	r0
    5970:	cf 91       	pop	r28
    5972:	df 91       	pop	r29
    5974:	08 95       	ret

00005976 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    5976:	df 93       	push	r29
    5978:	cf 93       	push	r28
    597a:	00 d0       	rcall	.+0      	; 0x597c <xTaskGetTickCountFromISR+0x6>
    597c:	0f 92       	push	r0
    597e:	cd b7       	in	r28, 0x3d	; 61
    5980:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    5982:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    5984:	80 91 69 06 	lds	r24, 0x0669
    5988:	90 91 6a 06 	lds	r25, 0x066A
    598c:	9b 83       	std	Y+3, r25	; 0x03
    598e:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5990:	8a 81       	ldd	r24, Y+2	; 0x02
    5992:	9b 81       	ldd	r25, Y+3	; 0x03
}
    5994:	0f 90       	pop	r0
    5996:	0f 90       	pop	r0
    5998:	0f 90       	pop	r0
    599a:	cf 91       	pop	r28
    599c:	df 91       	pop	r29
    599e:	08 95       	ret

000059a0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    59a0:	df 93       	push	r29
    59a2:	cf 93       	push	r28
    59a4:	cd b7       	in	r28, 0x3d	; 61
    59a6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    59a8:	80 91 68 06 	lds	r24, 0x0668
}
    59ac:	cf 91       	pop	r28
    59ae:	df 91       	pop	r29
    59b0:	08 95       	ret

000059b2 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    59b2:	df 93       	push	r29
    59b4:	cf 93       	push	r28
    59b6:	00 d0       	rcall	.+0      	; 0x59b8 <pcTaskGetName+0x6>
    59b8:	00 d0       	rcall	.+0      	; 0x59ba <pcTaskGetName+0x8>
    59ba:	00 d0       	rcall	.+0      	; 0x59bc <pcTaskGetName+0xa>
    59bc:	cd b7       	in	r28, 0x3d	; 61
    59be:	de b7       	in	r29, 0x3e	; 62
    59c0:	9c 83       	std	Y+4, r25	; 0x04
    59c2:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    59c4:	8b 81       	ldd	r24, Y+3	; 0x03
    59c6:	9c 81       	ldd	r25, Y+4	; 0x04
    59c8:	00 97       	sbiw	r24, 0x00	; 0
    59ca:	39 f4       	brne	.+14     	; 0x59da <pcTaskGetName+0x28>
    59cc:	80 91 65 06 	lds	r24, 0x0665
    59d0:	90 91 66 06 	lds	r25, 0x0666
    59d4:	9e 83       	std	Y+6, r25	; 0x06
    59d6:	8d 83       	std	Y+5, r24	; 0x05
    59d8:	04 c0       	rjmp	.+8      	; 0x59e2 <pcTaskGetName+0x30>
    59da:	8b 81       	ldd	r24, Y+3	; 0x03
    59dc:	9c 81       	ldd	r25, Y+4	; 0x04
    59de:	9e 83       	std	Y+6, r25	; 0x06
    59e0:	8d 83       	std	Y+5, r24	; 0x05
    59e2:	8d 81       	ldd	r24, Y+5	; 0x05
    59e4:	9e 81       	ldd	r25, Y+6	; 0x06
    59e6:	9a 83       	std	Y+2, r25	; 0x02
    59e8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    59ea:	89 81       	ldd	r24, Y+1	; 0x01
    59ec:	9a 81       	ldd	r25, Y+2	; 0x02
    59ee:	49 96       	adiw	r24, 0x19	; 25
}
    59f0:	26 96       	adiw	r28, 0x06	; 6
    59f2:	0f b6       	in	r0, 0x3f	; 63
    59f4:	f8 94       	cli
    59f6:	de bf       	out	0x3e, r29	; 62
    59f8:	0f be       	out	0x3f, r0	; 63
    59fa:	cd bf       	out	0x3d, r28	; 61
    59fc:	cf 91       	pop	r28
    59fe:	df 91       	pop	r29
    5a00:	08 95       	ret

00005a02 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5a02:	df 93       	push	r29
    5a04:	cf 93       	push	r28
    5a06:	cd b7       	in	r28, 0x3d	; 61
    5a08:	de b7       	in	r29, 0x3e	; 62
    5a0a:	29 97       	sbiw	r28, 0x09	; 9
    5a0c:	0f b6       	in	r0, 0x3f	; 63
    5a0e:	f8 94       	cli
    5a10:	de bf       	out	0x3e, r29	; 62
    5a12:	0f be       	out	0x3f, r0	; 63
    5a14:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    5a16:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5a18:	80 91 75 06 	lds	r24, 0x0675
    5a1c:	88 23       	and	r24, r24
    5a1e:	09 f0       	breq	.+2      	; 0x5a22 <xTaskIncrementTick+0x20>
    5a20:	c0 c0       	rjmp	.+384    	; 0x5ba2 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    5a22:	80 91 69 06 	lds	r24, 0x0669
    5a26:	90 91 6a 06 	lds	r25, 0x066A
    5a2a:	01 96       	adiw	r24, 0x01	; 1
    5a2c:	9c 83       	std	Y+4, r25	; 0x04
    5a2e:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    5a30:	8b 81       	ldd	r24, Y+3	; 0x03
    5a32:	9c 81       	ldd	r25, Y+4	; 0x04
    5a34:	90 93 6a 06 	sts	0x066A, r25
    5a38:	80 93 69 06 	sts	0x0669, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    5a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    5a40:	00 97       	sbiw	r24, 0x00	; 0
    5a42:	d9 f4       	brne	.+54     	; 0x5a7a <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    5a44:	80 91 ac 06 	lds	r24, 0x06AC
    5a48:	90 91 ad 06 	lds	r25, 0x06AD
    5a4c:	9a 83       	std	Y+2, r25	; 0x02
    5a4e:	89 83       	std	Y+1, r24	; 0x01
    5a50:	80 91 ae 06 	lds	r24, 0x06AE
    5a54:	90 91 af 06 	lds	r25, 0x06AF
    5a58:	90 93 ad 06 	sts	0x06AD, r25
    5a5c:	80 93 ac 06 	sts	0x06AC, r24
    5a60:	89 81       	ldd	r24, Y+1	; 0x01
    5a62:	9a 81       	ldd	r25, Y+2	; 0x02
    5a64:	90 93 af 06 	sts	0x06AF, r25
    5a68:	80 93 ae 06 	sts	0x06AE, r24
    5a6c:	80 91 6f 06 	lds	r24, 0x066F
    5a70:	8f 5f       	subi	r24, 0xFF	; 255
    5a72:	80 93 6f 06 	sts	0x066F, r24
    5a76:	0e 94 ab 30 	call	0x6156	; 0x6156 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    5a7a:	20 91 71 06 	lds	r18, 0x0671
    5a7e:	30 91 72 06 	lds	r19, 0x0672
    5a82:	8b 81       	ldd	r24, Y+3	; 0x03
    5a84:	9c 81       	ldd	r25, Y+4	; 0x04
    5a86:	82 17       	cp	r24, r18
    5a88:	93 07       	cpc	r25, r19
    5a8a:	08 f4       	brcc	.+2      	; 0x5a8e <xTaskIncrementTick+0x8c>
    5a8c:	71 c0       	rjmp	.+226    	; 0x5b70 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5a8e:	e0 91 ac 06 	lds	r30, 0x06AC
    5a92:	f0 91 ad 06 	lds	r31, 0x06AD
    5a96:	80 81       	ld	r24, Z
    5a98:	88 23       	and	r24, r24
    5a9a:	39 f4       	brne	.+14     	; 0x5aaa <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5a9c:	8f ef       	ldi	r24, 0xFF	; 255
    5a9e:	9f ef       	ldi	r25, 0xFF	; 255
    5aa0:	90 93 72 06 	sts	0x0672, r25
    5aa4:	80 93 71 06 	sts	0x0671, r24
    5aa8:	63 c0       	rjmp	.+198    	; 0x5b70 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5aaa:	e0 91 ac 06 	lds	r30, 0x06AC
    5aae:	f0 91 ad 06 	lds	r31, 0x06AD
    5ab2:	05 80       	ldd	r0, Z+5	; 0x05
    5ab4:	f6 81       	ldd	r31, Z+6	; 0x06
    5ab6:	e0 2d       	mov	r30, r0
    5ab8:	86 81       	ldd	r24, Z+6	; 0x06
    5aba:	97 81       	ldd	r25, Z+7	; 0x07
    5abc:	99 87       	std	Y+9, r25	; 0x09
    5abe:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    5ac0:	e8 85       	ldd	r30, Y+8	; 0x08
    5ac2:	f9 85       	ldd	r31, Y+9	; 0x09
    5ac4:	82 81       	ldd	r24, Z+2	; 0x02
    5ac6:	93 81       	ldd	r25, Z+3	; 0x03
    5ac8:	9f 83       	std	Y+7, r25	; 0x07
    5aca:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    5acc:	2b 81       	ldd	r18, Y+3	; 0x03
    5ace:	3c 81       	ldd	r19, Y+4	; 0x04
    5ad0:	8e 81       	ldd	r24, Y+6	; 0x06
    5ad2:	9f 81       	ldd	r25, Y+7	; 0x07
    5ad4:	28 17       	cp	r18, r24
    5ad6:	39 07       	cpc	r19, r25
    5ad8:	38 f4       	brcc	.+14     	; 0x5ae8 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    5ada:	8e 81       	ldd	r24, Y+6	; 0x06
    5adc:	9f 81       	ldd	r25, Y+7	; 0x07
    5ade:	90 93 72 06 	sts	0x0672, r25
    5ae2:	80 93 71 06 	sts	0x0671, r24
    5ae6:	44 c0       	rjmp	.+136    	; 0x5b70 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5ae8:	88 85       	ldd	r24, Y+8	; 0x08
    5aea:	99 85       	ldd	r25, Y+9	; 0x09
    5aec:	02 96       	adiw	r24, 0x02	; 2
    5aee:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5af2:	e8 85       	ldd	r30, Y+8	; 0x08
    5af4:	f9 85       	ldd	r31, Y+9	; 0x09
    5af6:	84 89       	ldd	r24, Z+20	; 0x14
    5af8:	95 89       	ldd	r25, Z+21	; 0x15
    5afa:	00 97       	sbiw	r24, 0x00	; 0
    5afc:	29 f0       	breq	.+10     	; 0x5b08 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5afe:	88 85       	ldd	r24, Y+8	; 0x08
    5b00:	99 85       	ldd	r25, Y+9	; 0x09
    5b02:	0c 96       	adiw	r24, 0x0c	; 12
    5b04:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    5b08:	e8 85       	ldd	r30, Y+8	; 0x08
    5b0a:	f9 85       	ldd	r31, Y+9	; 0x09
    5b0c:	96 89       	ldd	r25, Z+22	; 0x16
    5b0e:	80 91 6b 06 	lds	r24, 0x066B
    5b12:	89 17       	cp	r24, r25
    5b14:	28 f4       	brcc	.+10     	; 0x5b20 <xTaskIncrementTick+0x11e>
    5b16:	e8 85       	ldd	r30, Y+8	; 0x08
    5b18:	f9 85       	ldd	r31, Y+9	; 0x09
    5b1a:	86 89       	ldd	r24, Z+22	; 0x16
    5b1c:	80 93 6b 06 	sts	0x066B, r24
    5b20:	e8 85       	ldd	r30, Y+8	; 0x08
    5b22:	f9 85       	ldd	r31, Y+9	; 0x09
    5b24:	86 89       	ldd	r24, Z+22	; 0x16
    5b26:	28 2f       	mov	r18, r24
    5b28:	30 e0       	ldi	r19, 0x00	; 0
    5b2a:	c9 01       	movw	r24, r18
    5b2c:	88 0f       	add	r24, r24
    5b2e:	99 1f       	adc	r25, r25
    5b30:	88 0f       	add	r24, r24
    5b32:	99 1f       	adc	r25, r25
    5b34:	88 0f       	add	r24, r24
    5b36:	99 1f       	adc	r25, r25
    5b38:	82 0f       	add	r24, r18
    5b3a:	93 1f       	adc	r25, r19
    5b3c:	ac 01       	movw	r20, r24
    5b3e:	4a 58       	subi	r20, 0x8A	; 138
    5b40:	59 4f       	sbci	r21, 0xF9	; 249
    5b42:	88 85       	ldd	r24, Y+8	; 0x08
    5b44:	99 85       	ldd	r25, Y+9	; 0x09
    5b46:	9c 01       	movw	r18, r24
    5b48:	2e 5f       	subi	r18, 0xFE	; 254
    5b4a:	3f 4f       	sbci	r19, 0xFF	; 255
    5b4c:	ca 01       	movw	r24, r20
    5b4e:	b9 01       	movw	r22, r18
    5b50:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5b54:	e8 85       	ldd	r30, Y+8	; 0x08
    5b56:	f9 85       	ldd	r31, Y+9	; 0x09
    5b58:	96 89       	ldd	r25, Z+22	; 0x16
    5b5a:	e0 91 65 06 	lds	r30, 0x0665
    5b5e:	f0 91 66 06 	lds	r31, 0x0666
    5b62:	86 89       	ldd	r24, Z+22	; 0x16
    5b64:	98 17       	cp	r25, r24
    5b66:	08 f4       	brcc	.+2      	; 0x5b6a <xTaskIncrementTick+0x168>
    5b68:	92 cf       	rjmp	.-220    	; 0x5a8e <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    5b6a:	81 e0       	ldi	r24, 0x01	; 1
    5b6c:	8d 83       	std	Y+5, r24	; 0x05
    5b6e:	8f cf       	rjmp	.-226    	; 0x5a8e <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    5b70:	e0 91 65 06 	lds	r30, 0x0665
    5b74:	f0 91 66 06 	lds	r31, 0x0666
    5b78:	86 89       	ldd	r24, Z+22	; 0x16
    5b7a:	28 2f       	mov	r18, r24
    5b7c:	30 e0       	ldi	r19, 0x00	; 0
    5b7e:	c9 01       	movw	r24, r18
    5b80:	88 0f       	add	r24, r24
    5b82:	99 1f       	adc	r25, r25
    5b84:	88 0f       	add	r24, r24
    5b86:	99 1f       	adc	r25, r25
    5b88:	88 0f       	add	r24, r24
    5b8a:	99 1f       	adc	r25, r25
    5b8c:	82 0f       	add	r24, r18
    5b8e:	93 1f       	adc	r25, r19
    5b90:	fc 01       	movw	r30, r24
    5b92:	ea 58       	subi	r30, 0x8A	; 138
    5b94:	f9 4f       	sbci	r31, 0xF9	; 249
    5b96:	80 81       	ld	r24, Z
    5b98:	82 30       	cpi	r24, 0x02	; 2
    5b9a:	40 f0       	brcs	.+16     	; 0x5bac <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    5b9c:	81 e0       	ldi	r24, 0x01	; 1
    5b9e:	8d 83       	std	Y+5, r24	; 0x05
    5ba0:	05 c0       	rjmp	.+10     	; 0x5bac <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    5ba2:	80 91 6d 06 	lds	r24, 0x066D
    5ba6:	8f 5f       	subi	r24, 0xFF	; 255
    5ba8:	80 93 6d 06 	sts	0x066D, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    5bac:	80 91 6e 06 	lds	r24, 0x066E
    5bb0:	88 23       	and	r24, r24
    5bb2:	11 f0       	breq	.+4      	; 0x5bb8 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    5bb4:	81 e0       	ldi	r24, 0x01	; 1
    5bb6:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    5bb8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5bba:	29 96       	adiw	r28, 0x09	; 9
    5bbc:	0f b6       	in	r0, 0x3f	; 63
    5bbe:	f8 94       	cli
    5bc0:	de bf       	out	0x3e, r29	; 62
    5bc2:	0f be       	out	0x3f, r0	; 63
    5bc4:	cd bf       	out	0x3d, r28	; 61
    5bc6:	cf 91       	pop	r28
    5bc8:	df 91       	pop	r29
    5bca:	08 95       	ret

00005bcc <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5bcc:	df 93       	push	r29
    5bce:	cf 93       	push	r28
    5bd0:	00 d0       	rcall	.+0      	; 0x5bd2 <vTaskSwitchContext+0x6>
    5bd2:	0f 92       	push	r0
    5bd4:	cd b7       	in	r28, 0x3d	; 61
    5bd6:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    5bd8:	80 91 75 06 	lds	r24, 0x0675
    5bdc:	88 23       	and	r24, r24
    5bde:	21 f0       	breq	.+8      	; 0x5be8 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    5be0:	81 e0       	ldi	r24, 0x01	; 1
    5be2:	80 93 6e 06 	sts	0x066E, r24
    5be6:	59 c0       	rjmp	.+178    	; 0x5c9a <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    5be8:	10 92 6e 06 	sts	0x066E, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5bec:	80 91 6b 06 	lds	r24, 0x066B
    5bf0:	8b 83       	std	Y+3, r24	; 0x03
    5bf2:	03 c0       	rjmp	.+6      	; 0x5bfa <vTaskSwitchContext+0x2e>
    5bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    5bf6:	81 50       	subi	r24, 0x01	; 1
    5bf8:	8b 83       	std	Y+3, r24	; 0x03
    5bfa:	8b 81       	ldd	r24, Y+3	; 0x03
    5bfc:	28 2f       	mov	r18, r24
    5bfe:	30 e0       	ldi	r19, 0x00	; 0
    5c00:	c9 01       	movw	r24, r18
    5c02:	88 0f       	add	r24, r24
    5c04:	99 1f       	adc	r25, r25
    5c06:	88 0f       	add	r24, r24
    5c08:	99 1f       	adc	r25, r25
    5c0a:	88 0f       	add	r24, r24
    5c0c:	99 1f       	adc	r25, r25
    5c0e:	82 0f       	add	r24, r18
    5c10:	93 1f       	adc	r25, r19
    5c12:	fc 01       	movw	r30, r24
    5c14:	ea 58       	subi	r30, 0x8A	; 138
    5c16:	f9 4f       	sbci	r31, 0xF9	; 249
    5c18:	80 81       	ld	r24, Z
    5c1a:	88 23       	and	r24, r24
    5c1c:	59 f3       	breq	.-42     	; 0x5bf4 <vTaskSwitchContext+0x28>
    5c1e:	8b 81       	ldd	r24, Y+3	; 0x03
    5c20:	28 2f       	mov	r18, r24
    5c22:	30 e0       	ldi	r19, 0x00	; 0
    5c24:	c9 01       	movw	r24, r18
    5c26:	88 0f       	add	r24, r24
    5c28:	99 1f       	adc	r25, r25
    5c2a:	88 0f       	add	r24, r24
    5c2c:	99 1f       	adc	r25, r25
    5c2e:	88 0f       	add	r24, r24
    5c30:	99 1f       	adc	r25, r25
    5c32:	82 0f       	add	r24, r18
    5c34:	93 1f       	adc	r25, r19
    5c36:	8a 58       	subi	r24, 0x8A	; 138
    5c38:	99 4f       	sbci	r25, 0xF9	; 249
    5c3a:	9a 83       	std	Y+2, r25	; 0x02
    5c3c:	89 83       	std	Y+1, r24	; 0x01
    5c3e:	e9 81       	ldd	r30, Y+1	; 0x01
    5c40:	fa 81       	ldd	r31, Y+2	; 0x02
    5c42:	01 80       	ldd	r0, Z+1	; 0x01
    5c44:	f2 81       	ldd	r31, Z+2	; 0x02
    5c46:	e0 2d       	mov	r30, r0
    5c48:	82 81       	ldd	r24, Z+2	; 0x02
    5c4a:	93 81       	ldd	r25, Z+3	; 0x03
    5c4c:	e9 81       	ldd	r30, Y+1	; 0x01
    5c4e:	fa 81       	ldd	r31, Y+2	; 0x02
    5c50:	92 83       	std	Z+2, r25	; 0x02
    5c52:	81 83       	std	Z+1, r24	; 0x01
    5c54:	e9 81       	ldd	r30, Y+1	; 0x01
    5c56:	fa 81       	ldd	r31, Y+2	; 0x02
    5c58:	21 81       	ldd	r18, Z+1	; 0x01
    5c5a:	32 81       	ldd	r19, Z+2	; 0x02
    5c5c:	89 81       	ldd	r24, Y+1	; 0x01
    5c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    5c60:	03 96       	adiw	r24, 0x03	; 3
    5c62:	28 17       	cp	r18, r24
    5c64:	39 07       	cpc	r19, r25
    5c66:	59 f4       	brne	.+22     	; 0x5c7e <vTaskSwitchContext+0xb2>
    5c68:	e9 81       	ldd	r30, Y+1	; 0x01
    5c6a:	fa 81       	ldd	r31, Y+2	; 0x02
    5c6c:	01 80       	ldd	r0, Z+1	; 0x01
    5c6e:	f2 81       	ldd	r31, Z+2	; 0x02
    5c70:	e0 2d       	mov	r30, r0
    5c72:	82 81       	ldd	r24, Z+2	; 0x02
    5c74:	93 81       	ldd	r25, Z+3	; 0x03
    5c76:	e9 81       	ldd	r30, Y+1	; 0x01
    5c78:	fa 81       	ldd	r31, Y+2	; 0x02
    5c7a:	92 83       	std	Z+2, r25	; 0x02
    5c7c:	81 83       	std	Z+1, r24	; 0x01
    5c7e:	e9 81       	ldd	r30, Y+1	; 0x01
    5c80:	fa 81       	ldd	r31, Y+2	; 0x02
    5c82:	01 80       	ldd	r0, Z+1	; 0x01
    5c84:	f2 81       	ldd	r31, Z+2	; 0x02
    5c86:	e0 2d       	mov	r30, r0
    5c88:	86 81       	ldd	r24, Z+6	; 0x06
    5c8a:	97 81       	ldd	r25, Z+7	; 0x07
    5c8c:	90 93 66 06 	sts	0x0666, r25
    5c90:	80 93 65 06 	sts	0x0665, r24
    5c94:	8b 81       	ldd	r24, Y+3	; 0x03
    5c96:	80 93 6b 06 	sts	0x066B, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    5c9a:	0f 90       	pop	r0
    5c9c:	0f 90       	pop	r0
    5c9e:	0f 90       	pop	r0
    5ca0:	cf 91       	pop	r28
    5ca2:	df 91       	pop	r29
    5ca4:	08 95       	ret

00005ca6 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    5ca6:	df 93       	push	r29
    5ca8:	cf 93       	push	r28
    5caa:	00 d0       	rcall	.+0      	; 0x5cac <vTaskPlaceOnEventList+0x6>
    5cac:	00 d0       	rcall	.+0      	; 0x5cae <vTaskPlaceOnEventList+0x8>
    5cae:	cd b7       	in	r28, 0x3d	; 61
    5cb0:	de b7       	in	r29, 0x3e	; 62
    5cb2:	9a 83       	std	Y+2, r25	; 0x02
    5cb4:	89 83       	std	Y+1, r24	; 0x01
    5cb6:	7c 83       	std	Y+4, r23	; 0x04
    5cb8:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5cba:	80 91 65 06 	lds	r24, 0x0665
    5cbe:	90 91 66 06 	lds	r25, 0x0666
    5cc2:	9c 01       	movw	r18, r24
    5cc4:	24 5f       	subi	r18, 0xF4	; 244
    5cc6:	3f 4f       	sbci	r19, 0xFF	; 255
    5cc8:	89 81       	ldd	r24, Y+1	; 0x01
    5cca:	9a 81       	ldd	r25, Y+2	; 0x02
    5ccc:	b9 01       	movw	r22, r18
    5cce:	0e 94 c4 14 	call	0x2988	; 0x2988 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    5cd4:	9c 81       	ldd	r25, Y+4	; 0x04
    5cd6:	61 e0       	ldi	r22, 0x01	; 1
    5cd8:	0e 94 b7 34 	call	0x696e	; 0x696e <prvAddCurrentTaskToDelayedList>
}
    5cdc:	0f 90       	pop	r0
    5cde:	0f 90       	pop	r0
    5ce0:	0f 90       	pop	r0
    5ce2:	0f 90       	pop	r0
    5ce4:	cf 91       	pop	r28
    5ce6:	df 91       	pop	r29
    5ce8:	08 95       	ret

00005cea <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    5cea:	df 93       	push	r29
    5cec:	cf 93       	push	r28
    5cee:	00 d0       	rcall	.+0      	; 0x5cf0 <vTaskPlaceOnUnorderedEventList+0x6>
    5cf0:	00 d0       	rcall	.+0      	; 0x5cf2 <vTaskPlaceOnUnorderedEventList+0x8>
    5cf2:	00 d0       	rcall	.+0      	; 0x5cf4 <vTaskPlaceOnUnorderedEventList+0xa>
    5cf4:	cd b7       	in	r28, 0x3d	; 61
    5cf6:	de b7       	in	r29, 0x3e	; 62
    5cf8:	9a 83       	std	Y+2, r25	; 0x02
    5cfa:	89 83       	std	Y+1, r24	; 0x01
    5cfc:	7c 83       	std	Y+4, r23	; 0x04
    5cfe:	6b 83       	std	Y+3, r22	; 0x03
    5d00:	5e 83       	std	Y+6, r21	; 0x06
    5d02:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5d04:	e0 91 65 06 	lds	r30, 0x0665
    5d08:	f0 91 66 06 	lds	r31, 0x0666
    5d0c:	8b 81       	ldd	r24, Y+3	; 0x03
    5d0e:	9c 81       	ldd	r25, Y+4	; 0x04
    5d10:	90 68       	ori	r25, 0x80	; 128
    5d12:	95 87       	std	Z+13, r25	; 0x0d
    5d14:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5d16:	80 91 65 06 	lds	r24, 0x0665
    5d1a:	90 91 66 06 	lds	r25, 0x0666
    5d1e:	9c 01       	movw	r18, r24
    5d20:	24 5f       	subi	r18, 0xF4	; 244
    5d22:	3f 4f       	sbci	r19, 0xFF	; 255
    5d24:	89 81       	ldd	r24, Y+1	; 0x01
    5d26:	9a 81       	ldd	r25, Y+2	; 0x02
    5d28:	b9 01       	movw	r22, r18
    5d2a:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5d2e:	8d 81       	ldd	r24, Y+5	; 0x05
    5d30:	9e 81       	ldd	r25, Y+6	; 0x06
    5d32:	61 e0       	ldi	r22, 0x01	; 1
    5d34:	0e 94 b7 34 	call	0x696e	; 0x696e <prvAddCurrentTaskToDelayedList>
}
    5d38:	26 96       	adiw	r28, 0x06	; 6
    5d3a:	0f b6       	in	r0, 0x3f	; 63
    5d3c:	f8 94       	cli
    5d3e:	de bf       	out	0x3e, r29	; 62
    5d40:	0f be       	out	0x3f, r0	; 63
    5d42:	cd bf       	out	0x3d, r28	; 61
    5d44:	cf 91       	pop	r28
    5d46:	df 91       	pop	r29
    5d48:	08 95       	ret

00005d4a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5d4a:	df 93       	push	r29
    5d4c:	cf 93       	push	r28
    5d4e:	00 d0       	rcall	.+0      	; 0x5d50 <xTaskRemoveFromEventList+0x6>
    5d50:	00 d0       	rcall	.+0      	; 0x5d52 <xTaskRemoveFromEventList+0x8>
    5d52:	0f 92       	push	r0
    5d54:	cd b7       	in	r28, 0x3d	; 61
    5d56:	de b7       	in	r29, 0x3e	; 62
    5d58:	9d 83       	std	Y+5, r25	; 0x05
    5d5a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5d5c:	ec 81       	ldd	r30, Y+4	; 0x04
    5d5e:	fd 81       	ldd	r31, Y+5	; 0x05
    5d60:	05 80       	ldd	r0, Z+5	; 0x05
    5d62:	f6 81       	ldd	r31, Z+6	; 0x06
    5d64:	e0 2d       	mov	r30, r0
    5d66:	86 81       	ldd	r24, Z+6	; 0x06
    5d68:	97 81       	ldd	r25, Z+7	; 0x07
    5d6a:	9b 83       	std	Y+3, r25	; 0x03
    5d6c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5d6e:	8a 81       	ldd	r24, Y+2	; 0x02
    5d70:	9b 81       	ldd	r25, Y+3	; 0x03
    5d72:	0c 96       	adiw	r24, 0x0c	; 12
    5d74:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5d78:	80 91 75 06 	lds	r24, 0x0675
    5d7c:	88 23       	and	r24, r24
    5d7e:	61 f5       	brne	.+88     	; 0x5dd8 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5d80:	8a 81       	ldd	r24, Y+2	; 0x02
    5d82:	9b 81       	ldd	r25, Y+3	; 0x03
    5d84:	02 96       	adiw	r24, 0x02	; 2
    5d86:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    5d8a:	ea 81       	ldd	r30, Y+2	; 0x02
    5d8c:	fb 81       	ldd	r31, Y+3	; 0x03
    5d8e:	96 89       	ldd	r25, Z+22	; 0x16
    5d90:	80 91 6b 06 	lds	r24, 0x066B
    5d94:	89 17       	cp	r24, r25
    5d96:	28 f4       	brcc	.+10     	; 0x5da2 <xTaskRemoveFromEventList+0x58>
    5d98:	ea 81       	ldd	r30, Y+2	; 0x02
    5d9a:	fb 81       	ldd	r31, Y+3	; 0x03
    5d9c:	86 89       	ldd	r24, Z+22	; 0x16
    5d9e:	80 93 6b 06 	sts	0x066B, r24
    5da2:	ea 81       	ldd	r30, Y+2	; 0x02
    5da4:	fb 81       	ldd	r31, Y+3	; 0x03
    5da6:	86 89       	ldd	r24, Z+22	; 0x16
    5da8:	28 2f       	mov	r18, r24
    5daa:	30 e0       	ldi	r19, 0x00	; 0
    5dac:	c9 01       	movw	r24, r18
    5dae:	88 0f       	add	r24, r24
    5db0:	99 1f       	adc	r25, r25
    5db2:	88 0f       	add	r24, r24
    5db4:	99 1f       	adc	r25, r25
    5db6:	88 0f       	add	r24, r24
    5db8:	99 1f       	adc	r25, r25
    5dba:	82 0f       	add	r24, r18
    5dbc:	93 1f       	adc	r25, r19
    5dbe:	ac 01       	movw	r20, r24
    5dc0:	4a 58       	subi	r20, 0x8A	; 138
    5dc2:	59 4f       	sbci	r21, 0xF9	; 249
    5dc4:	8a 81       	ldd	r24, Y+2	; 0x02
    5dc6:	9b 81       	ldd	r25, Y+3	; 0x03
    5dc8:	9c 01       	movw	r18, r24
    5dca:	2e 5f       	subi	r18, 0xFE	; 254
    5dcc:	3f 4f       	sbci	r19, 0xFF	; 255
    5dce:	ca 01       	movw	r24, r20
    5dd0:	b9 01       	movw	r22, r18
    5dd2:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
    5dd6:	0a c0       	rjmp	.+20     	; 0x5dec <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5dd8:	8a 81       	ldd	r24, Y+2	; 0x02
    5dda:	9b 81       	ldd	r25, Y+3	; 0x03
    5ddc:	9c 01       	movw	r18, r24
    5dde:	24 5f       	subi	r18, 0xF4	; 244
    5de0:	3f 4f       	sbci	r19, 0xFF	; 255
    5de2:	80 eb       	ldi	r24, 0xB0	; 176
    5de4:	96 e0       	ldi	r25, 0x06	; 6
    5de6:	b9 01       	movw	r22, r18
    5de8:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5dec:	ea 81       	ldd	r30, Y+2	; 0x02
    5dee:	fb 81       	ldd	r31, Y+3	; 0x03
    5df0:	96 89       	ldd	r25, Z+22	; 0x16
    5df2:	e0 91 65 06 	lds	r30, 0x0665
    5df6:	f0 91 66 06 	lds	r31, 0x0666
    5dfa:	86 89       	ldd	r24, Z+22	; 0x16
    5dfc:	89 17       	cp	r24, r25
    5dfe:	30 f4       	brcc	.+12     	; 0x5e0c <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    5e00:	81 e0       	ldi	r24, 0x01	; 1
    5e02:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5e04:	81 e0       	ldi	r24, 0x01	; 1
    5e06:	80 93 6e 06 	sts	0x066E, r24
    5e0a:	01 c0       	rjmp	.+2      	; 0x5e0e <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    5e0c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5e0e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5e10:	0f 90       	pop	r0
    5e12:	0f 90       	pop	r0
    5e14:	0f 90       	pop	r0
    5e16:	0f 90       	pop	r0
    5e18:	0f 90       	pop	r0
    5e1a:	cf 91       	pop	r28
    5e1c:	df 91       	pop	r29
    5e1e:	08 95       	ret

00005e20 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5e20:	df 93       	push	r29
    5e22:	cf 93       	push	r28
    5e24:	00 d0       	rcall	.+0      	; 0x5e26 <vTaskRemoveFromUnorderedEventList+0x6>
    5e26:	00 d0       	rcall	.+0      	; 0x5e28 <vTaskRemoveFromUnorderedEventList+0x8>
    5e28:	00 d0       	rcall	.+0      	; 0x5e2a <vTaskRemoveFromUnorderedEventList+0xa>
    5e2a:	cd b7       	in	r28, 0x3d	; 61
    5e2c:	de b7       	in	r29, 0x3e	; 62
    5e2e:	9c 83       	std	Y+4, r25	; 0x04
    5e30:	8b 83       	std	Y+3, r24	; 0x03
    5e32:	7e 83       	std	Y+6, r23	; 0x06
    5e34:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5e36:	8d 81       	ldd	r24, Y+5	; 0x05
    5e38:	9e 81       	ldd	r25, Y+6	; 0x06
    5e3a:	90 68       	ori	r25, 0x80	; 128
    5e3c:	eb 81       	ldd	r30, Y+3	; 0x03
    5e3e:	fc 81       	ldd	r31, Y+4	; 0x04
    5e40:	91 83       	std	Z+1, r25	; 0x01
    5e42:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5e44:	eb 81       	ldd	r30, Y+3	; 0x03
    5e46:	fc 81       	ldd	r31, Y+4	; 0x04
    5e48:	86 81       	ldd	r24, Z+6	; 0x06
    5e4a:	97 81       	ldd	r25, Z+7	; 0x07
    5e4c:	9a 83       	std	Y+2, r25	; 0x02
    5e4e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    5e50:	8b 81       	ldd	r24, Y+3	; 0x03
    5e52:	9c 81       	ldd	r25, Y+4	; 0x04
    5e54:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5e58:	89 81       	ldd	r24, Y+1	; 0x01
    5e5a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e5c:	02 96       	adiw	r24, 0x02	; 2
    5e5e:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5e62:	e9 81       	ldd	r30, Y+1	; 0x01
    5e64:	fa 81       	ldd	r31, Y+2	; 0x02
    5e66:	96 89       	ldd	r25, Z+22	; 0x16
    5e68:	80 91 6b 06 	lds	r24, 0x066B
    5e6c:	89 17       	cp	r24, r25
    5e6e:	28 f4       	brcc	.+10     	; 0x5e7a <vTaskRemoveFromUnorderedEventList+0x5a>
    5e70:	e9 81       	ldd	r30, Y+1	; 0x01
    5e72:	fa 81       	ldd	r31, Y+2	; 0x02
    5e74:	86 89       	ldd	r24, Z+22	; 0x16
    5e76:	80 93 6b 06 	sts	0x066B, r24
    5e7a:	e9 81       	ldd	r30, Y+1	; 0x01
    5e7c:	fa 81       	ldd	r31, Y+2	; 0x02
    5e7e:	86 89       	ldd	r24, Z+22	; 0x16
    5e80:	28 2f       	mov	r18, r24
    5e82:	30 e0       	ldi	r19, 0x00	; 0
    5e84:	c9 01       	movw	r24, r18
    5e86:	88 0f       	add	r24, r24
    5e88:	99 1f       	adc	r25, r25
    5e8a:	88 0f       	add	r24, r24
    5e8c:	99 1f       	adc	r25, r25
    5e8e:	88 0f       	add	r24, r24
    5e90:	99 1f       	adc	r25, r25
    5e92:	82 0f       	add	r24, r18
    5e94:	93 1f       	adc	r25, r19
    5e96:	ac 01       	movw	r20, r24
    5e98:	4a 58       	subi	r20, 0x8A	; 138
    5e9a:	59 4f       	sbci	r21, 0xF9	; 249
    5e9c:	89 81       	ldd	r24, Y+1	; 0x01
    5e9e:	9a 81       	ldd	r25, Y+2	; 0x02
    5ea0:	9c 01       	movw	r18, r24
    5ea2:	2e 5f       	subi	r18, 0xFE	; 254
    5ea4:	3f 4f       	sbci	r19, 0xFF	; 255
    5ea6:	ca 01       	movw	r24, r20
    5ea8:	b9 01       	movw	r22, r18
    5eaa:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5eae:	e9 81       	ldd	r30, Y+1	; 0x01
    5eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    5eb2:	96 89       	ldd	r25, Z+22	; 0x16
    5eb4:	e0 91 65 06 	lds	r30, 0x0665
    5eb8:	f0 91 66 06 	lds	r31, 0x0666
    5ebc:	86 89       	ldd	r24, Z+22	; 0x16
    5ebe:	89 17       	cp	r24, r25
    5ec0:	18 f4       	brcc	.+6      	; 0x5ec8 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    5ec2:	81 e0       	ldi	r24, 0x01	; 1
    5ec4:	80 93 6e 06 	sts	0x066E, r24
	}
}
    5ec8:	26 96       	adiw	r28, 0x06	; 6
    5eca:	0f b6       	in	r0, 0x3f	; 63
    5ecc:	f8 94       	cli
    5ece:	de bf       	out	0x3e, r29	; 62
    5ed0:	0f be       	out	0x3f, r0	; 63
    5ed2:	cd bf       	out	0x3d, r28	; 61
    5ed4:	cf 91       	pop	r28
    5ed6:	df 91       	pop	r29
    5ed8:	08 95       	ret

00005eda <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5eda:	df 93       	push	r29
    5edc:	cf 93       	push	r28
    5ede:	00 d0       	rcall	.+0      	; 0x5ee0 <vTaskSetTimeOutState+0x6>
    5ee0:	cd b7       	in	r28, 0x3d	; 61
    5ee2:	de b7       	in	r29, 0x3e	; 62
    5ee4:	9a 83       	std	Y+2, r25	; 0x02
    5ee6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    5ee8:	0f b6       	in	r0, 0x3f	; 63
    5eea:	f8 94       	cli
    5eec:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    5eee:	80 91 6f 06 	lds	r24, 0x066F
    5ef2:	e9 81       	ldd	r30, Y+1	; 0x01
    5ef4:	fa 81       	ldd	r31, Y+2	; 0x02
    5ef6:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    5ef8:	80 91 69 06 	lds	r24, 0x0669
    5efc:	90 91 6a 06 	lds	r25, 0x066A
    5f00:	e9 81       	ldd	r30, Y+1	; 0x01
    5f02:	fa 81       	ldd	r31, Y+2	; 0x02
    5f04:	92 83       	std	Z+2, r25	; 0x02
    5f06:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5f08:	0f 90       	pop	r0
    5f0a:	0f be       	out	0x3f, r0	; 63
}
    5f0c:	0f 90       	pop	r0
    5f0e:	0f 90       	pop	r0
    5f10:	cf 91       	pop	r28
    5f12:	df 91       	pop	r29
    5f14:	08 95       	ret

00005f16 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5f16:	df 93       	push	r29
    5f18:	cf 93       	push	r28
    5f1a:	00 d0       	rcall	.+0      	; 0x5f1c <vTaskInternalSetTimeOutState+0x6>
    5f1c:	cd b7       	in	r28, 0x3d	; 61
    5f1e:	de b7       	in	r29, 0x3e	; 62
    5f20:	9a 83       	std	Y+2, r25	; 0x02
    5f22:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5f24:	80 91 6f 06 	lds	r24, 0x066F
    5f28:	e9 81       	ldd	r30, Y+1	; 0x01
    5f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    5f2c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5f2e:	80 91 69 06 	lds	r24, 0x0669
    5f32:	90 91 6a 06 	lds	r25, 0x066A
    5f36:	e9 81       	ldd	r30, Y+1	; 0x01
    5f38:	fa 81       	ldd	r31, Y+2	; 0x02
    5f3a:	92 83       	std	Z+2, r25	; 0x02
    5f3c:	81 83       	std	Z+1, r24	; 0x01
}
    5f3e:	0f 90       	pop	r0
    5f40:	0f 90       	pop	r0
    5f42:	cf 91       	pop	r28
    5f44:	df 91       	pop	r29
    5f46:	08 95       	ret

00005f48 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5f48:	df 93       	push	r29
    5f4a:	cf 93       	push	r28
    5f4c:	cd b7       	in	r28, 0x3d	; 61
    5f4e:	de b7       	in	r29, 0x3e	; 62
    5f50:	29 97       	sbiw	r28, 0x09	; 9
    5f52:	0f b6       	in	r0, 0x3f	; 63
    5f54:	f8 94       	cli
    5f56:	de bf       	out	0x3e, r29	; 62
    5f58:	0f be       	out	0x3f, r0	; 63
    5f5a:	cd bf       	out	0x3d, r28	; 61
    5f5c:	9f 83       	std	Y+7, r25	; 0x07
    5f5e:	8e 83       	std	Y+6, r24	; 0x06
    5f60:	79 87       	std	Y+9, r23	; 0x09
    5f62:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5f64:	0f b6       	in	r0, 0x3f	; 63
    5f66:	f8 94       	cli
    5f68:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5f6a:	80 91 69 06 	lds	r24, 0x0669
    5f6e:	90 91 6a 06 	lds	r25, 0x066A
    5f72:	9c 83       	std	Y+4, r25	; 0x04
    5f74:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5f76:	ee 81       	ldd	r30, Y+6	; 0x06
    5f78:	ff 81       	ldd	r31, Y+7	; 0x07
    5f7a:	21 81       	ldd	r18, Z+1	; 0x01
    5f7c:	32 81       	ldd	r19, Z+2	; 0x02
    5f7e:	8b 81       	ldd	r24, Y+3	; 0x03
    5f80:	9c 81       	ldd	r25, Y+4	; 0x04
    5f82:	82 1b       	sub	r24, r18
    5f84:	93 0b       	sbc	r25, r19
    5f86:	9a 83       	std	Y+2, r25	; 0x02
    5f88:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    5f8a:	e8 85       	ldd	r30, Y+8	; 0x08
    5f8c:	f9 85       	ldd	r31, Y+9	; 0x09
    5f8e:	80 81       	ld	r24, Z
    5f90:	91 81       	ldd	r25, Z+1	; 0x01
    5f92:	2f ef       	ldi	r18, 0xFF	; 255
    5f94:	8f 3f       	cpi	r24, 0xFF	; 255
    5f96:	92 07       	cpc	r25, r18
    5f98:	11 f4       	brne	.+4      	; 0x5f9e <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5f9a:	1d 82       	std	Y+5, r1	; 0x05
    5f9c:	36 c0       	rjmp	.+108    	; 0x600a <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5f9e:	ee 81       	ldd	r30, Y+6	; 0x06
    5fa0:	ff 81       	ldd	r31, Y+7	; 0x07
    5fa2:	90 81       	ld	r25, Z
    5fa4:	80 91 6f 06 	lds	r24, 0x066F
    5fa8:	98 17       	cp	r25, r24
    5faa:	61 f0       	breq	.+24     	; 0x5fc4 <xTaskCheckForTimeOut+0x7c>
    5fac:	ee 81       	ldd	r30, Y+6	; 0x06
    5fae:	ff 81       	ldd	r31, Y+7	; 0x07
    5fb0:	21 81       	ldd	r18, Z+1	; 0x01
    5fb2:	32 81       	ldd	r19, Z+2	; 0x02
    5fb4:	8b 81       	ldd	r24, Y+3	; 0x03
    5fb6:	9c 81       	ldd	r25, Y+4	; 0x04
    5fb8:	82 17       	cp	r24, r18
    5fba:	93 07       	cpc	r25, r19
    5fbc:	18 f0       	brcs	.+6      	; 0x5fc4 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    5fbe:	81 e0       	ldi	r24, 0x01	; 1
    5fc0:	8d 83       	std	Y+5, r24	; 0x05
    5fc2:	23 c0       	rjmp	.+70     	; 0x600a <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5fc4:	e8 85       	ldd	r30, Y+8	; 0x08
    5fc6:	f9 85       	ldd	r31, Y+9	; 0x09
    5fc8:	20 81       	ld	r18, Z
    5fca:	31 81       	ldd	r19, Z+1	; 0x01
    5fcc:	89 81       	ldd	r24, Y+1	; 0x01
    5fce:	9a 81       	ldd	r25, Y+2	; 0x02
    5fd0:	82 17       	cp	r24, r18
    5fd2:	93 07       	cpc	r25, r19
    5fd4:	a0 f4       	brcc	.+40     	; 0x5ffe <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    5fd6:	e8 85       	ldd	r30, Y+8	; 0x08
    5fd8:	f9 85       	ldd	r31, Y+9	; 0x09
    5fda:	20 81       	ld	r18, Z
    5fdc:	31 81       	ldd	r19, Z+1	; 0x01
    5fde:	89 81       	ldd	r24, Y+1	; 0x01
    5fe0:	9a 81       	ldd	r25, Y+2	; 0x02
    5fe2:	a9 01       	movw	r20, r18
    5fe4:	48 1b       	sub	r20, r24
    5fe6:	59 0b       	sbc	r21, r25
    5fe8:	ca 01       	movw	r24, r20
    5fea:	e8 85       	ldd	r30, Y+8	; 0x08
    5fec:	f9 85       	ldd	r31, Y+9	; 0x09
    5fee:	91 83       	std	Z+1, r25	; 0x01
    5ff0:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    5ff2:	8e 81       	ldd	r24, Y+6	; 0x06
    5ff4:	9f 81       	ldd	r25, Y+7	; 0x07
    5ff6:	0e 94 8b 2f 	call	0x5f16	; 0x5f16 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    5ffa:	1d 82       	std	Y+5, r1	; 0x05
    5ffc:	06 c0       	rjmp	.+12     	; 0x600a <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    5ffe:	e8 85       	ldd	r30, Y+8	; 0x08
    6000:	f9 85       	ldd	r31, Y+9	; 0x09
    6002:	11 82       	std	Z+1, r1	; 0x01
    6004:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    6006:	81 e0       	ldi	r24, 0x01	; 1
    6008:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    600a:	0f 90       	pop	r0
    600c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    600e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    6010:	29 96       	adiw	r28, 0x09	; 9
    6012:	0f b6       	in	r0, 0x3f	; 63
    6014:	f8 94       	cli
    6016:	de bf       	out	0x3e, r29	; 62
    6018:	0f be       	out	0x3f, r0	; 63
    601a:	cd bf       	out	0x3d, r28	; 61
    601c:	cf 91       	pop	r28
    601e:	df 91       	pop	r29
    6020:	08 95       	ret

00006022 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    6022:	df 93       	push	r29
    6024:	cf 93       	push	r28
    6026:	cd b7       	in	r28, 0x3d	; 61
    6028:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    602a:	81 e0       	ldi	r24, 0x01	; 1
    602c:	80 93 6e 06 	sts	0x066E, r24
}
    6030:	cf 91       	pop	r28
    6032:	df 91       	pop	r29
    6034:	08 95       	ret

00006036 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    6036:	df 93       	push	r29
    6038:	cf 93       	push	r28
    603a:	00 d0       	rcall	.+0      	; 0x603c <prvIdleTask+0x6>
    603c:	cd b7       	in	r28, 0x3d	; 61
    603e:	de b7       	in	r29, 0x3e	; 62
    6040:	9a 83       	std	Y+2, r25	; 0x02
    6042:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    6044:	0e 94 66 30 	call	0x60cc	; 0x60cc <prvCheckTasksWaitingTermination>
    6048:	fd cf       	rjmp	.-6      	; 0x6044 <prvIdleTask+0xe>

0000604a <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    604a:	df 93       	push	r29
    604c:	cf 93       	push	r28
    604e:	0f 92       	push	r0
    6050:	cd b7       	in	r28, 0x3d	; 61
    6052:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    6054:	19 82       	std	Y+1, r1	; 0x01
    6056:	13 c0       	rjmp	.+38     	; 0x607e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    6058:	89 81       	ldd	r24, Y+1	; 0x01
    605a:	28 2f       	mov	r18, r24
    605c:	30 e0       	ldi	r19, 0x00	; 0
    605e:	c9 01       	movw	r24, r18
    6060:	88 0f       	add	r24, r24
    6062:	99 1f       	adc	r25, r25
    6064:	88 0f       	add	r24, r24
    6066:	99 1f       	adc	r25, r25
    6068:	88 0f       	add	r24, r24
    606a:	99 1f       	adc	r25, r25
    606c:	82 0f       	add	r24, r18
    606e:	93 1f       	adc	r25, r19
    6070:	8a 58       	subi	r24, 0x8A	; 138
    6072:	99 4f       	sbci	r25, 0xF9	; 249
    6074:	0e 94 46 14 	call	0x288c	; 0x288c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    6078:	89 81       	ldd	r24, Y+1	; 0x01
    607a:	8f 5f       	subi	r24, 0xFF	; 255
    607c:	89 83       	std	Y+1, r24	; 0x01
    607e:	89 81       	ldd	r24, Y+1	; 0x01
    6080:	84 30       	cpi	r24, 0x04	; 4
    6082:	50 f3       	brcs	.-44     	; 0x6058 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    6084:	8a e9       	ldi	r24, 0x9A	; 154
    6086:	96 e0       	ldi	r25, 0x06	; 6
    6088:	0e 94 46 14 	call	0x288c	; 0x288c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    608c:	83 ea       	ldi	r24, 0xA3	; 163
    608e:	96 e0       	ldi	r25, 0x06	; 6
    6090:	0e 94 46 14 	call	0x288c	; 0x288c <vListInitialise>
	vListInitialise( &xPendingReadyList );
    6094:	80 eb       	ldi	r24, 0xB0	; 176
    6096:	96 e0       	ldi	r25, 0x06	; 6
    6098:	0e 94 46 14 	call	0x288c	; 0x288c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    609c:	89 eb       	ldi	r24, 0xB9	; 185
    609e:	96 e0       	ldi	r25, 0x06	; 6
    60a0:	0e 94 46 14 	call	0x288c	; 0x288c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    60a4:	82 ec       	ldi	r24, 0xC2	; 194
    60a6:	96 e0       	ldi	r25, 0x06	; 6
    60a8:	0e 94 46 14 	call	0x288c	; 0x288c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    60ac:	8a e9       	ldi	r24, 0x9A	; 154
    60ae:	96 e0       	ldi	r25, 0x06	; 6
    60b0:	90 93 ad 06 	sts	0x06AD, r25
    60b4:	80 93 ac 06 	sts	0x06AC, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    60b8:	83 ea       	ldi	r24, 0xA3	; 163
    60ba:	96 e0       	ldi	r25, 0x06	; 6
    60bc:	90 93 af 06 	sts	0x06AF, r25
    60c0:	80 93 ae 06 	sts	0x06AE, r24
}
    60c4:	0f 90       	pop	r0
    60c6:	cf 91       	pop	r28
    60c8:	df 91       	pop	r29
    60ca:	08 95       	ret

000060cc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    60cc:	df 93       	push	r29
    60ce:	cf 93       	push	r28
    60d0:	00 d0       	rcall	.+0      	; 0x60d2 <prvCheckTasksWaitingTermination+0x6>
    60d2:	cd b7       	in	r28, 0x3d	; 61
    60d4:	de b7       	in	r29, 0x3e	; 62
    60d6:	20 c0       	rjmp	.+64     	; 0x6118 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    60d8:	0f b6       	in	r0, 0x3f	; 63
    60da:	f8 94       	cli
    60dc:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    60de:	e0 91 be 06 	lds	r30, 0x06BE
    60e2:	f0 91 bf 06 	lds	r31, 0x06BF
    60e6:	86 81       	ldd	r24, Z+6	; 0x06
    60e8:	97 81       	ldd	r25, Z+7	; 0x07
    60ea:	9a 83       	std	Y+2, r25	; 0x02
    60ec:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    60ee:	89 81       	ldd	r24, Y+1	; 0x01
    60f0:	9a 81       	ldd	r25, Y+2	; 0x02
    60f2:	02 96       	adiw	r24, 0x02	; 2
    60f4:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
				--uxCurrentNumberOfTasks;
    60f8:	80 91 68 06 	lds	r24, 0x0668
    60fc:	81 50       	subi	r24, 0x01	; 1
    60fe:	80 93 68 06 	sts	0x0668, r24
				--uxDeletedTasksWaitingCleanUp;
    6102:	80 91 67 06 	lds	r24, 0x0667
    6106:	81 50       	subi	r24, 0x01	; 1
    6108:	80 93 67 06 	sts	0x0667, r24
			}
			taskEXIT_CRITICAL();
    610c:	0f 90       	pop	r0
    610e:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    6110:	89 81       	ldd	r24, Y+1	; 0x01
    6112:	9a 81       	ldd	r25, Y+2	; 0x02
    6114:	0e 94 95 30 	call	0x612a	; 0x612a <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    6118:	80 91 67 06 	lds	r24, 0x0667
    611c:	88 23       	and	r24, r24
    611e:	e1 f6       	brne	.-72     	; 0x60d8 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    6120:	0f 90       	pop	r0
    6122:	0f 90       	pop	r0
    6124:	cf 91       	pop	r28
    6126:	df 91       	pop	r29
    6128:	08 95       	ret

0000612a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    612a:	df 93       	push	r29
    612c:	cf 93       	push	r28
    612e:	00 d0       	rcall	.+0      	; 0x6130 <prvDeleteTCB+0x6>
    6130:	cd b7       	in	r28, 0x3d	; 61
    6132:	de b7       	in	r29, 0x3e	; 62
    6134:	9a 83       	std	Y+2, r25	; 0x02
    6136:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    6138:	e9 81       	ldd	r30, Y+1	; 0x01
    613a:	fa 81       	ldd	r31, Y+2	; 0x02
    613c:	87 89       	ldd	r24, Z+23	; 0x17
    613e:	90 8d       	ldd	r25, Z+24	; 0x18
    6140:	0e 94 20 14 	call	0x2840	; 0x2840 <vPortFree>
			vPortFree( pxTCB );
    6144:	89 81       	ldd	r24, Y+1	; 0x01
    6146:	9a 81       	ldd	r25, Y+2	; 0x02
    6148:	0e 94 20 14 	call	0x2840	; 0x2840 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    614c:	0f 90       	pop	r0
    614e:	0f 90       	pop	r0
    6150:	cf 91       	pop	r28
    6152:	df 91       	pop	r29
    6154:	08 95       	ret

00006156 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    6156:	df 93       	push	r29
    6158:	cf 93       	push	r28
    615a:	00 d0       	rcall	.+0      	; 0x615c <prvResetNextTaskUnblockTime+0x6>
    615c:	cd b7       	in	r28, 0x3d	; 61
    615e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6160:	e0 91 ac 06 	lds	r30, 0x06AC
    6164:	f0 91 ad 06 	lds	r31, 0x06AD
    6168:	80 81       	ld	r24, Z
    616a:	88 23       	and	r24, r24
    616c:	39 f4       	brne	.+14     	; 0x617c <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    616e:	8f ef       	ldi	r24, 0xFF	; 255
    6170:	9f ef       	ldi	r25, 0xFF	; 255
    6172:	90 93 72 06 	sts	0x0672, r25
    6176:	80 93 71 06 	sts	0x0671, r24
    617a:	13 c0       	rjmp	.+38     	; 0x61a2 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    617c:	e0 91 ac 06 	lds	r30, 0x06AC
    6180:	f0 91 ad 06 	lds	r31, 0x06AD
    6184:	05 80       	ldd	r0, Z+5	; 0x05
    6186:	f6 81       	ldd	r31, Z+6	; 0x06
    6188:	e0 2d       	mov	r30, r0
    618a:	86 81       	ldd	r24, Z+6	; 0x06
    618c:	97 81       	ldd	r25, Z+7	; 0x07
    618e:	9a 83       	std	Y+2, r25	; 0x02
    6190:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    6192:	e9 81       	ldd	r30, Y+1	; 0x01
    6194:	fa 81       	ldd	r31, Y+2	; 0x02
    6196:	82 81       	ldd	r24, Z+2	; 0x02
    6198:	93 81       	ldd	r25, Z+3	; 0x03
    619a:	90 93 72 06 	sts	0x0672, r25
    619e:	80 93 71 06 	sts	0x0671, r24
	}
}
    61a2:	0f 90       	pop	r0
    61a4:	0f 90       	pop	r0
    61a6:	cf 91       	pop	r28
    61a8:	df 91       	pop	r29
    61aa:	08 95       	ret

000061ac <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    61ac:	df 93       	push	r29
    61ae:	cf 93       	push	r28
    61b0:	00 d0       	rcall	.+0      	; 0x61b2 <xTaskGetCurrentTaskHandle+0x6>
    61b2:	cd b7       	in	r28, 0x3d	; 61
    61b4:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    61b6:	80 91 65 06 	lds	r24, 0x0665
    61ba:	90 91 66 06 	lds	r25, 0x0666
    61be:	9a 83       	std	Y+2, r25	; 0x02
    61c0:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    61c2:	89 81       	ldd	r24, Y+1	; 0x01
    61c4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    61c6:	0f 90       	pop	r0
    61c8:	0f 90       	pop	r0
    61ca:	cf 91       	pop	r28
    61cc:	df 91       	pop	r29
    61ce:	08 95       	ret

000061d0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    61d0:	df 93       	push	r29
    61d2:	cf 93       	push	r28
    61d4:	00 d0       	rcall	.+0      	; 0x61d6 <uxTaskResetEventItemValue+0x6>
    61d6:	cd b7       	in	r28, 0x3d	; 61
    61d8:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    61da:	e0 91 65 06 	lds	r30, 0x0665
    61de:	f0 91 66 06 	lds	r31, 0x0666
    61e2:	84 85       	ldd	r24, Z+12	; 0x0c
    61e4:	95 85       	ldd	r25, Z+13	; 0x0d
    61e6:	9a 83       	std	Y+2, r25	; 0x02
    61e8:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    61ea:	a0 91 65 06 	lds	r26, 0x0665
    61ee:	b0 91 66 06 	lds	r27, 0x0666
    61f2:	e0 91 65 06 	lds	r30, 0x0665
    61f6:	f0 91 66 06 	lds	r31, 0x0666
    61fa:	86 89       	ldd	r24, Z+22	; 0x16
    61fc:	28 2f       	mov	r18, r24
    61fe:	30 e0       	ldi	r19, 0x00	; 0
    6200:	84 e0       	ldi	r24, 0x04	; 4
    6202:	90 e0       	ldi	r25, 0x00	; 0
    6204:	82 1b       	sub	r24, r18
    6206:	93 0b       	sbc	r25, r19
    6208:	1d 96       	adiw	r26, 0x0d	; 13
    620a:	9c 93       	st	X, r25
    620c:	8e 93       	st	-X, r24
    620e:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    6210:	89 81       	ldd	r24, Y+1	; 0x01
    6212:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6214:	0f 90       	pop	r0
    6216:	0f 90       	pop	r0
    6218:	cf 91       	pop	r28
    621a:	df 91       	pop	r29
    621c:	08 95       	ret

0000621e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    621e:	df 93       	push	r29
    6220:	cf 93       	push	r28
    6222:	cd b7       	in	r28, 0x3d	; 61
    6224:	de b7       	in	r29, 0x3e	; 62
    6226:	27 97       	sbiw	r28, 0x07	; 7
    6228:	0f b6       	in	r0, 0x3f	; 63
    622a:	f8 94       	cli
    622c:	de bf       	out	0x3e, r29	; 62
    622e:	0f be       	out	0x3f, r0	; 63
    6230:	cd bf       	out	0x3d, r28	; 61
    6232:	8d 83       	std	Y+5, r24	; 0x05
    6234:	7f 83       	std	Y+7, r23	; 0x07
    6236:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    6238:	0f b6       	in	r0, 0x3f	; 63
    623a:	f8 94       	cli
    623c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    623e:	e0 91 65 06 	lds	r30, 0x0665
    6242:	f0 91 66 06 	lds	r31, 0x0666
    6246:	81 a1       	ldd	r24, Z+33	; 0x21
    6248:	92 a1       	ldd	r25, Z+34	; 0x22
    624a:	a3 a1       	ldd	r26, Z+35	; 0x23
    624c:	b4 a1       	ldd	r27, Z+36	; 0x24
    624e:	00 97       	sbiw	r24, 0x00	; 0
    6250:	a1 05       	cpc	r26, r1
    6252:	b1 05       	cpc	r27, r1
    6254:	89 f4       	brne	.+34     	; 0x6278 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    6256:	e0 91 65 06 	lds	r30, 0x0665
    625a:	f0 91 66 06 	lds	r31, 0x0666
    625e:	81 e0       	ldi	r24, 0x01	; 1
    6260:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    6262:	8e 81       	ldd	r24, Y+6	; 0x06
    6264:	9f 81       	ldd	r25, Y+7	; 0x07
    6266:	00 97       	sbiw	r24, 0x00	; 0
    6268:	39 f0       	breq	.+14     	; 0x6278 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    626a:	8e 81       	ldd	r24, Y+6	; 0x06
    626c:	9f 81       	ldd	r25, Y+7	; 0x07
    626e:	61 e0       	ldi	r22, 0x01	; 1
    6270:	0e 94 b7 34 	call	0x696e	; 0x696e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    6274:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    6278:	0f 90       	pop	r0
    627a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    627c:	0f b6       	in	r0, 0x3f	; 63
    627e:	f8 94       	cli
    6280:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    6282:	e0 91 65 06 	lds	r30, 0x0665
    6286:	f0 91 66 06 	lds	r31, 0x0666
    628a:	81 a1       	ldd	r24, Z+33	; 0x21
    628c:	92 a1       	ldd	r25, Z+34	; 0x22
    628e:	a3 a1       	ldd	r26, Z+35	; 0x23
    6290:	b4 a1       	ldd	r27, Z+36	; 0x24
    6292:	89 83       	std	Y+1, r24	; 0x01
    6294:	9a 83       	std	Y+2, r25	; 0x02
    6296:	ab 83       	std	Y+3, r26	; 0x03
    6298:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    629a:	89 81       	ldd	r24, Y+1	; 0x01
    629c:	9a 81       	ldd	r25, Y+2	; 0x02
    629e:	ab 81       	ldd	r26, Y+3	; 0x03
    62a0:	bc 81       	ldd	r27, Y+4	; 0x04
    62a2:	00 97       	sbiw	r24, 0x00	; 0
    62a4:	a1 05       	cpc	r26, r1
    62a6:	b1 05       	cpc	r27, r1
    62a8:	d9 f0       	breq	.+54     	; 0x62e0 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    62aa:	8d 81       	ldd	r24, Y+5	; 0x05
    62ac:	88 23       	and	r24, r24
    62ae:	49 f0       	breq	.+18     	; 0x62c2 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    62b0:	e0 91 65 06 	lds	r30, 0x0665
    62b4:	f0 91 66 06 	lds	r31, 0x0666
    62b8:	11 a2       	std	Z+33, r1	; 0x21
    62ba:	12 a2       	std	Z+34, r1	; 0x22
    62bc:	13 a2       	std	Z+35, r1	; 0x23
    62be:	14 a2       	std	Z+36, r1	; 0x24
    62c0:	0f c0       	rjmp	.+30     	; 0x62e0 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    62c2:	e0 91 65 06 	lds	r30, 0x0665
    62c6:	f0 91 66 06 	lds	r31, 0x0666
    62ca:	89 81       	ldd	r24, Y+1	; 0x01
    62cc:	9a 81       	ldd	r25, Y+2	; 0x02
    62ce:	ab 81       	ldd	r26, Y+3	; 0x03
    62d0:	bc 81       	ldd	r27, Y+4	; 0x04
    62d2:	01 97       	sbiw	r24, 0x01	; 1
    62d4:	a1 09       	sbc	r26, r1
    62d6:	b1 09       	sbc	r27, r1
    62d8:	81 a3       	std	Z+33, r24	; 0x21
    62da:	92 a3       	std	Z+34, r25	; 0x22
    62dc:	a3 a3       	std	Z+35, r26	; 0x23
    62de:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    62e0:	e0 91 65 06 	lds	r30, 0x0665
    62e4:	f0 91 66 06 	lds	r31, 0x0666
    62e8:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    62ea:	0f 90       	pop	r0
    62ec:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    62ee:	89 81       	ldd	r24, Y+1	; 0x01
    62f0:	9a 81       	ldd	r25, Y+2	; 0x02
    62f2:	ab 81       	ldd	r26, Y+3	; 0x03
    62f4:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    62f6:	bc 01       	movw	r22, r24
    62f8:	cd 01       	movw	r24, r26
    62fa:	27 96       	adiw	r28, 0x07	; 7
    62fc:	0f b6       	in	r0, 0x3f	; 63
    62fe:	f8 94       	cli
    6300:	de bf       	out	0x3e, r29	; 62
    6302:	0f be       	out	0x3f, r0	; 63
    6304:	cd bf       	out	0x3d, r28	; 61
    6306:	cf 91       	pop	r28
    6308:	df 91       	pop	r29
    630a:	08 95       	ret

0000630c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    630c:	ef 92       	push	r14
    630e:	ff 92       	push	r15
    6310:	0f 93       	push	r16
    6312:	1f 93       	push	r17
    6314:	df 93       	push	r29
    6316:	cf 93       	push	r28
    6318:	cd b7       	in	r28, 0x3d	; 61
    631a:	de b7       	in	r29, 0x3e	; 62
    631c:	2d 97       	sbiw	r28, 0x0d	; 13
    631e:	0f b6       	in	r0, 0x3f	; 63
    6320:	f8 94       	cli
    6322:	de bf       	out	0x3e, r29	; 62
    6324:	0f be       	out	0x3f, r0	; 63
    6326:	cd bf       	out	0x3d, r28	; 61
    6328:	6a 83       	std	Y+2, r22	; 0x02
    632a:	7b 83       	std	Y+3, r23	; 0x03
    632c:	8c 83       	std	Y+4, r24	; 0x04
    632e:	9d 83       	std	Y+5, r25	; 0x05
    6330:	2e 83       	std	Y+6, r18	; 0x06
    6332:	3f 83       	std	Y+7, r19	; 0x07
    6334:	48 87       	std	Y+8, r20	; 0x08
    6336:	59 87       	std	Y+9, r21	; 0x09
    6338:	1b 87       	std	Y+11, r17	; 0x0b
    633a:	0a 87       	std	Y+10, r16	; 0x0a
    633c:	fd 86       	std	Y+13, r15	; 0x0d
    633e:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    6340:	0f b6       	in	r0, 0x3f	; 63
    6342:	f8 94       	cli
    6344:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    6346:	e0 91 65 06 	lds	r30, 0x0665
    634a:	f0 91 66 06 	lds	r31, 0x0666
    634e:	85 a1       	ldd	r24, Z+37	; 0x25
    6350:	82 30       	cpi	r24, 0x02	; 2
    6352:	49 f1       	breq	.+82     	; 0x63a6 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    6354:	e0 91 65 06 	lds	r30, 0x0665
    6358:	f0 91 66 06 	lds	r31, 0x0666
    635c:	21 a1       	ldd	r18, Z+33	; 0x21
    635e:	32 a1       	ldd	r19, Z+34	; 0x22
    6360:	43 a1       	ldd	r20, Z+35	; 0x23
    6362:	54 a1       	ldd	r21, Z+36	; 0x24
    6364:	8a 81       	ldd	r24, Y+2	; 0x02
    6366:	9b 81       	ldd	r25, Y+3	; 0x03
    6368:	ac 81       	ldd	r26, Y+4	; 0x04
    636a:	bd 81       	ldd	r27, Y+5	; 0x05
    636c:	80 95       	com	r24
    636e:	90 95       	com	r25
    6370:	a0 95       	com	r26
    6372:	b0 95       	com	r27
    6374:	82 23       	and	r24, r18
    6376:	93 23       	and	r25, r19
    6378:	a4 23       	and	r26, r20
    637a:	b5 23       	and	r27, r21
    637c:	81 a3       	std	Z+33, r24	; 0x21
    637e:	92 a3       	std	Z+34, r25	; 0x22
    6380:	a3 a3       	std	Z+35, r26	; 0x23
    6382:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    6384:	e0 91 65 06 	lds	r30, 0x0665
    6388:	f0 91 66 06 	lds	r31, 0x0666
    638c:	81 e0       	ldi	r24, 0x01	; 1
    638e:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    6390:	8c 85       	ldd	r24, Y+12	; 0x0c
    6392:	9d 85       	ldd	r25, Y+13	; 0x0d
    6394:	00 97       	sbiw	r24, 0x00	; 0
    6396:	39 f0       	breq	.+14     	; 0x63a6 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6398:	8c 85       	ldd	r24, Y+12	; 0x0c
    639a:	9d 85       	ldd	r25, Y+13	; 0x0d
    639c:	61 e0       	ldi	r22, 0x01	; 1
    639e:	0e 94 b7 34 	call	0x696e	; 0x696e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    63a2:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    63a6:	0f 90       	pop	r0
    63a8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    63aa:	0f b6       	in	r0, 0x3f	; 63
    63ac:	f8 94       	cli
    63ae:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    63b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    63b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    63b4:	00 97       	sbiw	r24, 0x00	; 0
    63b6:	71 f0       	breq	.+28     	; 0x63d4 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    63b8:	e0 91 65 06 	lds	r30, 0x0665
    63bc:	f0 91 66 06 	lds	r31, 0x0666
    63c0:	81 a1       	ldd	r24, Z+33	; 0x21
    63c2:	92 a1       	ldd	r25, Z+34	; 0x22
    63c4:	a3 a1       	ldd	r26, Z+35	; 0x23
    63c6:	b4 a1       	ldd	r27, Z+36	; 0x24
    63c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    63ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    63cc:	80 83       	st	Z, r24
    63ce:	91 83       	std	Z+1, r25	; 0x01
    63d0:	a2 83       	std	Z+2, r26	; 0x02
    63d2:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    63d4:	e0 91 65 06 	lds	r30, 0x0665
    63d8:	f0 91 66 06 	lds	r31, 0x0666
    63dc:	85 a1       	ldd	r24, Z+37	; 0x25
    63de:	82 30       	cpi	r24, 0x02	; 2
    63e0:	11 f0       	breq	.+4      	; 0x63e6 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    63e2:	19 82       	std	Y+1, r1	; 0x01
    63e4:	1a c0       	rjmp	.+52     	; 0x641a <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    63e6:	e0 91 65 06 	lds	r30, 0x0665
    63ea:	f0 91 66 06 	lds	r31, 0x0666
    63ee:	21 a1       	ldd	r18, Z+33	; 0x21
    63f0:	32 a1       	ldd	r19, Z+34	; 0x22
    63f2:	43 a1       	ldd	r20, Z+35	; 0x23
    63f4:	54 a1       	ldd	r21, Z+36	; 0x24
    63f6:	8e 81       	ldd	r24, Y+6	; 0x06
    63f8:	9f 81       	ldd	r25, Y+7	; 0x07
    63fa:	a8 85       	ldd	r26, Y+8	; 0x08
    63fc:	b9 85       	ldd	r27, Y+9	; 0x09
    63fe:	80 95       	com	r24
    6400:	90 95       	com	r25
    6402:	a0 95       	com	r26
    6404:	b0 95       	com	r27
    6406:	82 23       	and	r24, r18
    6408:	93 23       	and	r25, r19
    640a:	a4 23       	and	r26, r20
    640c:	b5 23       	and	r27, r21
    640e:	81 a3       	std	Z+33, r24	; 0x21
    6410:	92 a3       	std	Z+34, r25	; 0x22
    6412:	a3 a3       	std	Z+35, r26	; 0x23
    6414:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    6416:	81 e0       	ldi	r24, 0x01	; 1
    6418:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    641a:	e0 91 65 06 	lds	r30, 0x0665
    641e:	f0 91 66 06 	lds	r31, 0x0666
    6422:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    6424:	0f 90       	pop	r0
    6426:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    6428:	89 81       	ldd	r24, Y+1	; 0x01
	}
    642a:	2d 96       	adiw	r28, 0x0d	; 13
    642c:	0f b6       	in	r0, 0x3f	; 63
    642e:	f8 94       	cli
    6430:	de bf       	out	0x3e, r29	; 62
    6432:	0f be       	out	0x3f, r0	; 63
    6434:	cd bf       	out	0x3d, r28	; 61
    6436:	cf 91       	pop	r28
    6438:	df 91       	pop	r29
    643a:	1f 91       	pop	r17
    643c:	0f 91       	pop	r16
    643e:	ff 90       	pop	r15
    6440:	ef 90       	pop	r14
    6442:	08 95       	ret

00006444 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    6444:	0f 93       	push	r16
    6446:	1f 93       	push	r17
    6448:	df 93       	push	r29
    644a:	cf 93       	push	r28
    644c:	cd b7       	in	r28, 0x3d	; 61
    644e:	de b7       	in	r29, 0x3e	; 62
    6450:	2f 97       	sbiw	r28, 0x0f	; 15
    6452:	0f b6       	in	r0, 0x3f	; 63
    6454:	f8 94       	cli
    6456:	de bf       	out	0x3e, r29	; 62
    6458:	0f be       	out	0x3f, r0	; 63
    645a:	cd bf       	out	0x3d, r28	; 61
    645c:	9e 83       	std	Y+6, r25	; 0x06
    645e:	8d 83       	std	Y+5, r24	; 0x05
    6460:	4f 83       	std	Y+7, r20	; 0x07
    6462:	58 87       	std	Y+8, r21	; 0x08
    6464:	69 87       	std	Y+9, r22	; 0x09
    6466:	7a 87       	std	Y+10, r23	; 0x0a
    6468:	2b 87       	std	Y+11, r18	; 0x0b
    646a:	1d 87       	std	Y+13, r17	; 0x0d
    646c:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    646e:	81 e0       	ldi	r24, 0x01	; 1
    6470:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    6472:	8d 81       	ldd	r24, Y+5	; 0x05
    6474:	9e 81       	ldd	r25, Y+6	; 0x06
    6476:	9c 83       	std	Y+4, r25	; 0x04
    6478:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    647a:	0f b6       	in	r0, 0x3f	; 63
    647c:	f8 94       	cli
    647e:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    6480:	8c 85       	ldd	r24, Y+12	; 0x0c
    6482:	9d 85       	ldd	r25, Y+13	; 0x0d
    6484:	00 97       	sbiw	r24, 0x00	; 0
    6486:	61 f0       	breq	.+24     	; 0x64a0 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    6488:	eb 81       	ldd	r30, Y+3	; 0x03
    648a:	fc 81       	ldd	r31, Y+4	; 0x04
    648c:	81 a1       	ldd	r24, Z+33	; 0x21
    648e:	92 a1       	ldd	r25, Z+34	; 0x22
    6490:	a3 a1       	ldd	r26, Z+35	; 0x23
    6492:	b4 a1       	ldd	r27, Z+36	; 0x24
    6494:	ec 85       	ldd	r30, Y+12	; 0x0c
    6496:	fd 85       	ldd	r31, Y+13	; 0x0d
    6498:	80 83       	st	Z, r24
    649a:	91 83       	std	Z+1, r25	; 0x01
    649c:	a2 83       	std	Z+2, r26	; 0x02
    649e:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    64a0:	eb 81       	ldd	r30, Y+3	; 0x03
    64a2:	fc 81       	ldd	r31, Y+4	; 0x04
    64a4:	85 a1       	ldd	r24, Z+37	; 0x25
    64a6:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    64a8:	eb 81       	ldd	r30, Y+3	; 0x03
    64aa:	fc 81       	ldd	r31, Y+4	; 0x04
    64ac:	82 e0       	ldi	r24, 0x02	; 2
    64ae:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    64b0:	8b 85       	ldd	r24, Y+11	; 0x0b
    64b2:	28 2f       	mov	r18, r24
    64b4:	30 e0       	ldi	r19, 0x00	; 0
    64b6:	3f 87       	std	Y+15, r19	; 0x0f
    64b8:	2e 87       	std	Y+14, r18	; 0x0e
    64ba:	8e 85       	ldd	r24, Y+14	; 0x0e
    64bc:	9f 85       	ldd	r25, Y+15	; 0x0f
    64be:	82 30       	cpi	r24, 0x02	; 2
    64c0:	91 05       	cpc	r25, r1
    64c2:	59 f1       	breq	.+86     	; 0x651a <xTaskGenericNotify+0xd6>
    64c4:	2e 85       	ldd	r18, Y+14	; 0x0e
    64c6:	3f 85       	ldd	r19, Y+15	; 0x0f
    64c8:	23 30       	cpi	r18, 0x03	; 3
    64ca:	31 05       	cpc	r19, r1
    64cc:	34 f4       	brge	.+12     	; 0x64da <xTaskGenericNotify+0x96>
    64ce:	8e 85       	ldd	r24, Y+14	; 0x0e
    64d0:	9f 85       	ldd	r25, Y+15	; 0x0f
    64d2:	81 30       	cpi	r24, 0x01	; 1
    64d4:	91 05       	cpc	r25, r1
    64d6:	61 f0       	breq	.+24     	; 0x64f0 <xTaskGenericNotify+0xac>
    64d8:	4a c0       	rjmp	.+148    	; 0x656e <xTaskGenericNotify+0x12a>
    64da:	2e 85       	ldd	r18, Y+14	; 0x0e
    64dc:	3f 85       	ldd	r19, Y+15	; 0x0f
    64de:	23 30       	cpi	r18, 0x03	; 3
    64e0:	31 05       	cpc	r19, r1
    64e2:	59 f1       	breq	.+86     	; 0x653a <xTaskGenericNotify+0xf6>
    64e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    64e6:	9f 85       	ldd	r25, Y+15	; 0x0f
    64e8:	84 30       	cpi	r24, 0x04	; 4
    64ea:	91 05       	cpc	r25, r1
    64ec:	89 f1       	breq	.+98     	; 0x6550 <xTaskGenericNotify+0x10c>
    64ee:	3f c0       	rjmp	.+126    	; 0x656e <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    64f0:	eb 81       	ldd	r30, Y+3	; 0x03
    64f2:	fc 81       	ldd	r31, Y+4	; 0x04
    64f4:	21 a1       	ldd	r18, Z+33	; 0x21
    64f6:	32 a1       	ldd	r19, Z+34	; 0x22
    64f8:	43 a1       	ldd	r20, Z+35	; 0x23
    64fa:	54 a1       	ldd	r21, Z+36	; 0x24
    64fc:	8f 81       	ldd	r24, Y+7	; 0x07
    64fe:	98 85       	ldd	r25, Y+8	; 0x08
    6500:	a9 85       	ldd	r26, Y+9	; 0x09
    6502:	ba 85       	ldd	r27, Y+10	; 0x0a
    6504:	82 2b       	or	r24, r18
    6506:	93 2b       	or	r25, r19
    6508:	a4 2b       	or	r26, r20
    650a:	b5 2b       	or	r27, r21
    650c:	eb 81       	ldd	r30, Y+3	; 0x03
    650e:	fc 81       	ldd	r31, Y+4	; 0x04
    6510:	81 a3       	std	Z+33, r24	; 0x21
    6512:	92 a3       	std	Z+34, r25	; 0x22
    6514:	a3 a3       	std	Z+35, r26	; 0x23
    6516:	b4 a3       	std	Z+36, r27	; 0x24
    6518:	2a c0       	rjmp	.+84     	; 0x656e <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    651a:	eb 81       	ldd	r30, Y+3	; 0x03
    651c:	fc 81       	ldd	r31, Y+4	; 0x04
    651e:	81 a1       	ldd	r24, Z+33	; 0x21
    6520:	92 a1       	ldd	r25, Z+34	; 0x22
    6522:	a3 a1       	ldd	r26, Z+35	; 0x23
    6524:	b4 a1       	ldd	r27, Z+36	; 0x24
    6526:	01 96       	adiw	r24, 0x01	; 1
    6528:	a1 1d       	adc	r26, r1
    652a:	b1 1d       	adc	r27, r1
    652c:	eb 81       	ldd	r30, Y+3	; 0x03
    652e:	fc 81       	ldd	r31, Y+4	; 0x04
    6530:	81 a3       	std	Z+33, r24	; 0x21
    6532:	92 a3       	std	Z+34, r25	; 0x22
    6534:	a3 a3       	std	Z+35, r26	; 0x23
    6536:	b4 a3       	std	Z+36, r27	; 0x24
    6538:	1a c0       	rjmp	.+52     	; 0x656e <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    653a:	eb 81       	ldd	r30, Y+3	; 0x03
    653c:	fc 81       	ldd	r31, Y+4	; 0x04
    653e:	8f 81       	ldd	r24, Y+7	; 0x07
    6540:	98 85       	ldd	r25, Y+8	; 0x08
    6542:	a9 85       	ldd	r26, Y+9	; 0x09
    6544:	ba 85       	ldd	r27, Y+10	; 0x0a
    6546:	81 a3       	std	Z+33, r24	; 0x21
    6548:	92 a3       	std	Z+34, r25	; 0x22
    654a:	a3 a3       	std	Z+35, r26	; 0x23
    654c:	b4 a3       	std	Z+36, r27	; 0x24
    654e:	0f c0       	rjmp	.+30     	; 0x656e <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    6550:	89 81       	ldd	r24, Y+1	; 0x01
    6552:	82 30       	cpi	r24, 0x02	; 2
    6554:	59 f0       	breq	.+22     	; 0x656c <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    6556:	eb 81       	ldd	r30, Y+3	; 0x03
    6558:	fc 81       	ldd	r31, Y+4	; 0x04
    655a:	8f 81       	ldd	r24, Y+7	; 0x07
    655c:	98 85       	ldd	r25, Y+8	; 0x08
    655e:	a9 85       	ldd	r26, Y+9	; 0x09
    6560:	ba 85       	ldd	r27, Y+10	; 0x0a
    6562:	81 a3       	std	Z+33, r24	; 0x21
    6564:	92 a3       	std	Z+34, r25	; 0x22
    6566:	a3 a3       	std	Z+35, r26	; 0x23
    6568:	b4 a3       	std	Z+36, r27	; 0x24
    656a:	01 c0       	rjmp	.+2      	; 0x656e <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    656c:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    656e:	89 81       	ldd	r24, Y+1	; 0x01
    6570:	81 30       	cpi	r24, 0x01	; 1
    6572:	b9 f5       	brne	.+110    	; 0x65e2 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6574:	8b 81       	ldd	r24, Y+3	; 0x03
    6576:	9c 81       	ldd	r25, Y+4	; 0x04
    6578:	02 96       	adiw	r24, 0x02	; 2
    657a:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    657e:	eb 81       	ldd	r30, Y+3	; 0x03
    6580:	fc 81       	ldd	r31, Y+4	; 0x04
    6582:	96 89       	ldd	r25, Z+22	; 0x16
    6584:	80 91 6b 06 	lds	r24, 0x066B
    6588:	89 17       	cp	r24, r25
    658a:	28 f4       	brcc	.+10     	; 0x6596 <xTaskGenericNotify+0x152>
    658c:	eb 81       	ldd	r30, Y+3	; 0x03
    658e:	fc 81       	ldd	r31, Y+4	; 0x04
    6590:	86 89       	ldd	r24, Z+22	; 0x16
    6592:	80 93 6b 06 	sts	0x066B, r24
    6596:	eb 81       	ldd	r30, Y+3	; 0x03
    6598:	fc 81       	ldd	r31, Y+4	; 0x04
    659a:	86 89       	ldd	r24, Z+22	; 0x16
    659c:	28 2f       	mov	r18, r24
    659e:	30 e0       	ldi	r19, 0x00	; 0
    65a0:	c9 01       	movw	r24, r18
    65a2:	88 0f       	add	r24, r24
    65a4:	99 1f       	adc	r25, r25
    65a6:	88 0f       	add	r24, r24
    65a8:	99 1f       	adc	r25, r25
    65aa:	88 0f       	add	r24, r24
    65ac:	99 1f       	adc	r25, r25
    65ae:	82 0f       	add	r24, r18
    65b0:	93 1f       	adc	r25, r19
    65b2:	ac 01       	movw	r20, r24
    65b4:	4a 58       	subi	r20, 0x8A	; 138
    65b6:	59 4f       	sbci	r21, 0xF9	; 249
    65b8:	8b 81       	ldd	r24, Y+3	; 0x03
    65ba:	9c 81       	ldd	r25, Y+4	; 0x04
    65bc:	9c 01       	movw	r18, r24
    65be:	2e 5f       	subi	r18, 0xFE	; 254
    65c0:	3f 4f       	sbci	r19, 0xFF	; 255
    65c2:	ca 01       	movw	r24, r20
    65c4:	b9 01       	movw	r22, r18
    65c6:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    65ca:	eb 81       	ldd	r30, Y+3	; 0x03
    65cc:	fc 81       	ldd	r31, Y+4	; 0x04
    65ce:	96 89       	ldd	r25, Z+22	; 0x16
    65d0:	e0 91 65 06 	lds	r30, 0x0665
    65d4:	f0 91 66 06 	lds	r31, 0x0666
    65d8:	86 89       	ldd	r24, Z+22	; 0x16
    65da:	89 17       	cp	r24, r25
    65dc:	10 f4       	brcc	.+4      	; 0x65e2 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    65de:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    65e2:	0f 90       	pop	r0
    65e4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    65e6:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    65e8:	2f 96       	adiw	r28, 0x0f	; 15
    65ea:	0f b6       	in	r0, 0x3f	; 63
    65ec:	f8 94       	cli
    65ee:	de bf       	out	0x3e, r29	; 62
    65f0:	0f be       	out	0x3f, r0	; 63
    65f2:	cd bf       	out	0x3d, r28	; 61
    65f4:	cf 91       	pop	r28
    65f6:	df 91       	pop	r29
    65f8:	1f 91       	pop	r17
    65fa:	0f 91       	pop	r16
    65fc:	08 95       	ret

000065fe <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    65fe:	ef 92       	push	r14
    6600:	ff 92       	push	r15
    6602:	0f 93       	push	r16
    6604:	1f 93       	push	r17
    6606:	df 93       	push	r29
    6608:	cf 93       	push	r28
    660a:	cd b7       	in	r28, 0x3d	; 61
    660c:	de b7       	in	r29, 0x3e	; 62
    660e:	62 97       	sbiw	r28, 0x12	; 18
    6610:	0f b6       	in	r0, 0x3f	; 63
    6612:	f8 94       	cli
    6614:	de bf       	out	0x3e, r29	; 62
    6616:	0f be       	out	0x3f, r0	; 63
    6618:	cd bf       	out	0x3d, r28	; 61
    661a:	9f 83       	std	Y+7, r25	; 0x07
    661c:	8e 83       	std	Y+6, r24	; 0x06
    661e:	48 87       	std	Y+8, r20	; 0x08
    6620:	59 87       	std	Y+9, r21	; 0x09
    6622:	6a 87       	std	Y+10, r22	; 0x0a
    6624:	7b 87       	std	Y+11, r23	; 0x0b
    6626:	2c 87       	std	Y+12, r18	; 0x0c
    6628:	1e 87       	std	Y+14, r17	; 0x0e
    662a:	0d 87       	std	Y+13, r16	; 0x0d
    662c:	f8 8a       	std	Y+16, r15	; 0x10
    662e:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    6630:	81 e0       	ldi	r24, 0x01	; 1
    6632:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    6634:	8e 81       	ldd	r24, Y+6	; 0x06
    6636:	9f 81       	ldd	r25, Y+7	; 0x07
    6638:	9d 83       	std	Y+5, r25	; 0x05
    663a:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    663c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    663e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6640:	9e 85       	ldd	r25, Y+14	; 0x0e
    6642:	00 97       	sbiw	r24, 0x00	; 0
    6644:	61 f0       	breq	.+24     	; 0x665e <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    6646:	ec 81       	ldd	r30, Y+4	; 0x04
    6648:	fd 81       	ldd	r31, Y+5	; 0x05
    664a:	81 a1       	ldd	r24, Z+33	; 0x21
    664c:	92 a1       	ldd	r25, Z+34	; 0x22
    664e:	a3 a1       	ldd	r26, Z+35	; 0x23
    6650:	b4 a1       	ldd	r27, Z+36	; 0x24
    6652:	ed 85       	ldd	r30, Y+13	; 0x0d
    6654:	fe 85       	ldd	r31, Y+14	; 0x0e
    6656:	80 83       	st	Z, r24
    6658:	91 83       	std	Z+1, r25	; 0x01
    665a:	a2 83       	std	Z+2, r26	; 0x02
    665c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    665e:	ec 81       	ldd	r30, Y+4	; 0x04
    6660:	fd 81       	ldd	r31, Y+5	; 0x05
    6662:	85 a1       	ldd	r24, Z+37	; 0x25
    6664:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    6666:	ec 81       	ldd	r30, Y+4	; 0x04
    6668:	fd 81       	ldd	r31, Y+5	; 0x05
    666a:	82 e0       	ldi	r24, 0x02	; 2
    666c:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    666e:	8c 85       	ldd	r24, Y+12	; 0x0c
    6670:	28 2f       	mov	r18, r24
    6672:	30 e0       	ldi	r19, 0x00	; 0
    6674:	3a 8b       	std	Y+18, r19	; 0x12
    6676:	29 8b       	std	Y+17, r18	; 0x11
    6678:	89 89       	ldd	r24, Y+17	; 0x11
    667a:	9a 89       	ldd	r25, Y+18	; 0x12
    667c:	82 30       	cpi	r24, 0x02	; 2
    667e:	91 05       	cpc	r25, r1
    6680:	59 f1       	breq	.+86     	; 0x66d8 <xTaskGenericNotifyFromISR+0xda>
    6682:	29 89       	ldd	r18, Y+17	; 0x11
    6684:	3a 89       	ldd	r19, Y+18	; 0x12
    6686:	23 30       	cpi	r18, 0x03	; 3
    6688:	31 05       	cpc	r19, r1
    668a:	34 f4       	brge	.+12     	; 0x6698 <xTaskGenericNotifyFromISR+0x9a>
    668c:	89 89       	ldd	r24, Y+17	; 0x11
    668e:	9a 89       	ldd	r25, Y+18	; 0x12
    6690:	81 30       	cpi	r24, 0x01	; 1
    6692:	91 05       	cpc	r25, r1
    6694:	61 f0       	breq	.+24     	; 0x66ae <xTaskGenericNotifyFromISR+0xb0>
    6696:	4a c0       	rjmp	.+148    	; 0x672c <xTaskGenericNotifyFromISR+0x12e>
    6698:	29 89       	ldd	r18, Y+17	; 0x11
    669a:	3a 89       	ldd	r19, Y+18	; 0x12
    669c:	23 30       	cpi	r18, 0x03	; 3
    669e:	31 05       	cpc	r19, r1
    66a0:	59 f1       	breq	.+86     	; 0x66f8 <xTaskGenericNotifyFromISR+0xfa>
    66a2:	89 89       	ldd	r24, Y+17	; 0x11
    66a4:	9a 89       	ldd	r25, Y+18	; 0x12
    66a6:	84 30       	cpi	r24, 0x04	; 4
    66a8:	91 05       	cpc	r25, r1
    66aa:	89 f1       	breq	.+98     	; 0x670e <xTaskGenericNotifyFromISR+0x110>
    66ac:	3f c0       	rjmp	.+126    	; 0x672c <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    66ae:	ec 81       	ldd	r30, Y+4	; 0x04
    66b0:	fd 81       	ldd	r31, Y+5	; 0x05
    66b2:	21 a1       	ldd	r18, Z+33	; 0x21
    66b4:	32 a1       	ldd	r19, Z+34	; 0x22
    66b6:	43 a1       	ldd	r20, Z+35	; 0x23
    66b8:	54 a1       	ldd	r21, Z+36	; 0x24
    66ba:	88 85       	ldd	r24, Y+8	; 0x08
    66bc:	99 85       	ldd	r25, Y+9	; 0x09
    66be:	aa 85       	ldd	r26, Y+10	; 0x0a
    66c0:	bb 85       	ldd	r27, Y+11	; 0x0b
    66c2:	82 2b       	or	r24, r18
    66c4:	93 2b       	or	r25, r19
    66c6:	a4 2b       	or	r26, r20
    66c8:	b5 2b       	or	r27, r21
    66ca:	ec 81       	ldd	r30, Y+4	; 0x04
    66cc:	fd 81       	ldd	r31, Y+5	; 0x05
    66ce:	81 a3       	std	Z+33, r24	; 0x21
    66d0:	92 a3       	std	Z+34, r25	; 0x22
    66d2:	a3 a3       	std	Z+35, r26	; 0x23
    66d4:	b4 a3       	std	Z+36, r27	; 0x24
    66d6:	2a c0       	rjmp	.+84     	; 0x672c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    66d8:	ec 81       	ldd	r30, Y+4	; 0x04
    66da:	fd 81       	ldd	r31, Y+5	; 0x05
    66dc:	81 a1       	ldd	r24, Z+33	; 0x21
    66de:	92 a1       	ldd	r25, Z+34	; 0x22
    66e0:	a3 a1       	ldd	r26, Z+35	; 0x23
    66e2:	b4 a1       	ldd	r27, Z+36	; 0x24
    66e4:	01 96       	adiw	r24, 0x01	; 1
    66e6:	a1 1d       	adc	r26, r1
    66e8:	b1 1d       	adc	r27, r1
    66ea:	ec 81       	ldd	r30, Y+4	; 0x04
    66ec:	fd 81       	ldd	r31, Y+5	; 0x05
    66ee:	81 a3       	std	Z+33, r24	; 0x21
    66f0:	92 a3       	std	Z+34, r25	; 0x22
    66f2:	a3 a3       	std	Z+35, r26	; 0x23
    66f4:	b4 a3       	std	Z+36, r27	; 0x24
    66f6:	1a c0       	rjmp	.+52     	; 0x672c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    66f8:	ec 81       	ldd	r30, Y+4	; 0x04
    66fa:	fd 81       	ldd	r31, Y+5	; 0x05
    66fc:	88 85       	ldd	r24, Y+8	; 0x08
    66fe:	99 85       	ldd	r25, Y+9	; 0x09
    6700:	aa 85       	ldd	r26, Y+10	; 0x0a
    6702:	bb 85       	ldd	r27, Y+11	; 0x0b
    6704:	81 a3       	std	Z+33, r24	; 0x21
    6706:	92 a3       	std	Z+34, r25	; 0x22
    6708:	a3 a3       	std	Z+35, r26	; 0x23
    670a:	b4 a3       	std	Z+36, r27	; 0x24
    670c:	0f c0       	rjmp	.+30     	; 0x672c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    670e:	8b 81       	ldd	r24, Y+3	; 0x03
    6710:	82 30       	cpi	r24, 0x02	; 2
    6712:	59 f0       	breq	.+22     	; 0x672a <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    6714:	ec 81       	ldd	r30, Y+4	; 0x04
    6716:	fd 81       	ldd	r31, Y+5	; 0x05
    6718:	88 85       	ldd	r24, Y+8	; 0x08
    671a:	99 85       	ldd	r25, Y+9	; 0x09
    671c:	aa 85       	ldd	r26, Y+10	; 0x0a
    671e:	bb 85       	ldd	r27, Y+11	; 0x0b
    6720:	81 a3       	std	Z+33, r24	; 0x21
    6722:	92 a3       	std	Z+34, r25	; 0x22
    6724:	a3 a3       	std	Z+35, r26	; 0x23
    6726:	b4 a3       	std	Z+36, r27	; 0x24
    6728:	01 c0       	rjmp	.+2      	; 0x672c <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    672a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    672c:	8b 81       	ldd	r24, Y+3	; 0x03
    672e:	81 30       	cpi	r24, 0x01	; 1
    6730:	09 f0       	breq	.+2      	; 0x6734 <xTaskGenericNotifyFromISR+0x136>
    6732:	4f c0       	rjmp	.+158    	; 0x67d2 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6734:	80 91 75 06 	lds	r24, 0x0675
    6738:	88 23       	and	r24, r24
    673a:	61 f5       	brne	.+88     	; 0x6794 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    673c:	8c 81       	ldd	r24, Y+4	; 0x04
    673e:	9d 81       	ldd	r25, Y+5	; 0x05
    6740:	02 96       	adiw	r24, 0x02	; 2
    6742:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6746:	ec 81       	ldd	r30, Y+4	; 0x04
    6748:	fd 81       	ldd	r31, Y+5	; 0x05
    674a:	96 89       	ldd	r25, Z+22	; 0x16
    674c:	80 91 6b 06 	lds	r24, 0x066B
    6750:	89 17       	cp	r24, r25
    6752:	28 f4       	brcc	.+10     	; 0x675e <xTaskGenericNotifyFromISR+0x160>
    6754:	ec 81       	ldd	r30, Y+4	; 0x04
    6756:	fd 81       	ldd	r31, Y+5	; 0x05
    6758:	86 89       	ldd	r24, Z+22	; 0x16
    675a:	80 93 6b 06 	sts	0x066B, r24
    675e:	ec 81       	ldd	r30, Y+4	; 0x04
    6760:	fd 81       	ldd	r31, Y+5	; 0x05
    6762:	86 89       	ldd	r24, Z+22	; 0x16
    6764:	28 2f       	mov	r18, r24
    6766:	30 e0       	ldi	r19, 0x00	; 0
    6768:	c9 01       	movw	r24, r18
    676a:	88 0f       	add	r24, r24
    676c:	99 1f       	adc	r25, r25
    676e:	88 0f       	add	r24, r24
    6770:	99 1f       	adc	r25, r25
    6772:	88 0f       	add	r24, r24
    6774:	99 1f       	adc	r25, r25
    6776:	82 0f       	add	r24, r18
    6778:	93 1f       	adc	r25, r19
    677a:	ac 01       	movw	r20, r24
    677c:	4a 58       	subi	r20, 0x8A	; 138
    677e:	59 4f       	sbci	r21, 0xF9	; 249
    6780:	8c 81       	ldd	r24, Y+4	; 0x04
    6782:	9d 81       	ldd	r25, Y+5	; 0x05
    6784:	9c 01       	movw	r18, r24
    6786:	2e 5f       	subi	r18, 0xFE	; 254
    6788:	3f 4f       	sbci	r19, 0xFF	; 255
    678a:	ca 01       	movw	r24, r20
    678c:	b9 01       	movw	r22, r18
    678e:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
    6792:	0a c0       	rjmp	.+20     	; 0x67a8 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6794:	8c 81       	ldd	r24, Y+4	; 0x04
    6796:	9d 81       	ldd	r25, Y+5	; 0x05
    6798:	9c 01       	movw	r18, r24
    679a:	24 5f       	subi	r18, 0xF4	; 244
    679c:	3f 4f       	sbci	r19, 0xFF	; 255
    679e:	80 eb       	ldi	r24, 0xB0	; 176
    67a0:	96 e0       	ldi	r25, 0x06	; 6
    67a2:	b9 01       	movw	r22, r18
    67a4:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    67a8:	ec 81       	ldd	r30, Y+4	; 0x04
    67aa:	fd 81       	ldd	r31, Y+5	; 0x05
    67ac:	96 89       	ldd	r25, Z+22	; 0x16
    67ae:	e0 91 65 06 	lds	r30, 0x0665
    67b2:	f0 91 66 06 	lds	r31, 0x0666
    67b6:	86 89       	ldd	r24, Z+22	; 0x16
    67b8:	89 17       	cp	r24, r25
    67ba:	58 f4       	brcc	.+22     	; 0x67d2 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    67bc:	8f 85       	ldd	r24, Y+15	; 0x0f
    67be:	98 89       	ldd	r25, Y+16	; 0x10
    67c0:	00 97       	sbiw	r24, 0x00	; 0
    67c2:	21 f0       	breq	.+8      	; 0x67cc <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    67c4:	ef 85       	ldd	r30, Y+15	; 0x0f
    67c6:	f8 89       	ldd	r31, Y+16	; 0x10
    67c8:	81 e0       	ldi	r24, 0x01	; 1
    67ca:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    67cc:	81 e0       	ldi	r24, 0x01	; 1
    67ce:	80 93 6e 06 	sts	0x066E, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    67d2:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    67d4:	62 96       	adiw	r28, 0x12	; 18
    67d6:	0f b6       	in	r0, 0x3f	; 63
    67d8:	f8 94       	cli
    67da:	de bf       	out	0x3e, r29	; 62
    67dc:	0f be       	out	0x3f, r0	; 63
    67de:	cd bf       	out	0x3d, r28	; 61
    67e0:	cf 91       	pop	r28
    67e2:	df 91       	pop	r29
    67e4:	1f 91       	pop	r17
    67e6:	0f 91       	pop	r16
    67e8:	ff 90       	pop	r15
    67ea:	ef 90       	pop	r14
    67ec:	08 95       	ret

000067ee <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    67ee:	df 93       	push	r29
    67f0:	cf 93       	push	r28
    67f2:	cd b7       	in	r28, 0x3d	; 61
    67f4:	de b7       	in	r29, 0x3e	; 62
    67f6:	28 97       	sbiw	r28, 0x08	; 8
    67f8:	0f b6       	in	r0, 0x3f	; 63
    67fa:	f8 94       	cli
    67fc:	de bf       	out	0x3e, r29	; 62
    67fe:	0f be       	out	0x3f, r0	; 63
    6800:	cd bf       	out	0x3d, r28	; 61
    6802:	9e 83       	std	Y+6, r25	; 0x06
    6804:	8d 83       	std	Y+5, r24	; 0x05
    6806:	78 87       	std	Y+8, r23	; 0x08
    6808:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    680a:	8d 81       	ldd	r24, Y+5	; 0x05
    680c:	9e 81       	ldd	r25, Y+6	; 0x06
    680e:	9c 83       	std	Y+4, r25	; 0x04
    6810:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6812:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    6814:	eb 81       	ldd	r30, Y+3	; 0x03
    6816:	fc 81       	ldd	r31, Y+4	; 0x04
    6818:	85 a1       	ldd	r24, Z+37	; 0x25
    681a:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    681c:	eb 81       	ldd	r30, Y+3	; 0x03
    681e:	fc 81       	ldd	r31, Y+4	; 0x04
    6820:	82 e0       	ldi	r24, 0x02	; 2
    6822:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    6824:	eb 81       	ldd	r30, Y+3	; 0x03
    6826:	fc 81       	ldd	r31, Y+4	; 0x04
    6828:	81 a1       	ldd	r24, Z+33	; 0x21
    682a:	92 a1       	ldd	r25, Z+34	; 0x22
    682c:	a3 a1       	ldd	r26, Z+35	; 0x23
    682e:	b4 a1       	ldd	r27, Z+36	; 0x24
    6830:	01 96       	adiw	r24, 0x01	; 1
    6832:	a1 1d       	adc	r26, r1
    6834:	b1 1d       	adc	r27, r1
    6836:	eb 81       	ldd	r30, Y+3	; 0x03
    6838:	fc 81       	ldd	r31, Y+4	; 0x04
    683a:	81 a3       	std	Z+33, r24	; 0x21
    683c:	92 a3       	std	Z+34, r25	; 0x22
    683e:	a3 a3       	std	Z+35, r26	; 0x23
    6840:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6842:	8a 81       	ldd	r24, Y+2	; 0x02
    6844:	81 30       	cpi	r24, 0x01	; 1
    6846:	09 f0       	breq	.+2      	; 0x684a <vTaskNotifyGiveFromISR+0x5c>
    6848:	4f c0       	rjmp	.+158    	; 0x68e8 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    684a:	80 91 75 06 	lds	r24, 0x0675
    684e:	88 23       	and	r24, r24
    6850:	61 f5       	brne	.+88     	; 0x68aa <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6852:	8b 81       	ldd	r24, Y+3	; 0x03
    6854:	9c 81       	ldd	r25, Y+4	; 0x04
    6856:	02 96       	adiw	r24, 0x02	; 2
    6858:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    685c:	eb 81       	ldd	r30, Y+3	; 0x03
    685e:	fc 81       	ldd	r31, Y+4	; 0x04
    6860:	96 89       	ldd	r25, Z+22	; 0x16
    6862:	80 91 6b 06 	lds	r24, 0x066B
    6866:	89 17       	cp	r24, r25
    6868:	28 f4       	brcc	.+10     	; 0x6874 <vTaskNotifyGiveFromISR+0x86>
    686a:	eb 81       	ldd	r30, Y+3	; 0x03
    686c:	fc 81       	ldd	r31, Y+4	; 0x04
    686e:	86 89       	ldd	r24, Z+22	; 0x16
    6870:	80 93 6b 06 	sts	0x066B, r24
    6874:	eb 81       	ldd	r30, Y+3	; 0x03
    6876:	fc 81       	ldd	r31, Y+4	; 0x04
    6878:	86 89       	ldd	r24, Z+22	; 0x16
    687a:	28 2f       	mov	r18, r24
    687c:	30 e0       	ldi	r19, 0x00	; 0
    687e:	c9 01       	movw	r24, r18
    6880:	88 0f       	add	r24, r24
    6882:	99 1f       	adc	r25, r25
    6884:	88 0f       	add	r24, r24
    6886:	99 1f       	adc	r25, r25
    6888:	88 0f       	add	r24, r24
    688a:	99 1f       	adc	r25, r25
    688c:	82 0f       	add	r24, r18
    688e:	93 1f       	adc	r25, r19
    6890:	ac 01       	movw	r20, r24
    6892:	4a 58       	subi	r20, 0x8A	; 138
    6894:	59 4f       	sbci	r21, 0xF9	; 249
    6896:	8b 81       	ldd	r24, Y+3	; 0x03
    6898:	9c 81       	ldd	r25, Y+4	; 0x04
    689a:	9c 01       	movw	r18, r24
    689c:	2e 5f       	subi	r18, 0xFE	; 254
    689e:	3f 4f       	sbci	r19, 0xFF	; 255
    68a0:	ca 01       	movw	r24, r20
    68a2:	b9 01       	movw	r22, r18
    68a4:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
    68a8:	0a c0       	rjmp	.+20     	; 0x68be <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    68aa:	8b 81       	ldd	r24, Y+3	; 0x03
    68ac:	9c 81       	ldd	r25, Y+4	; 0x04
    68ae:	9c 01       	movw	r18, r24
    68b0:	24 5f       	subi	r18, 0xF4	; 244
    68b2:	3f 4f       	sbci	r19, 0xFF	; 255
    68b4:	80 eb       	ldi	r24, 0xB0	; 176
    68b6:	96 e0       	ldi	r25, 0x06	; 6
    68b8:	b9 01       	movw	r22, r18
    68ba:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    68be:	eb 81       	ldd	r30, Y+3	; 0x03
    68c0:	fc 81       	ldd	r31, Y+4	; 0x04
    68c2:	96 89       	ldd	r25, Z+22	; 0x16
    68c4:	e0 91 65 06 	lds	r30, 0x0665
    68c8:	f0 91 66 06 	lds	r31, 0x0666
    68cc:	86 89       	ldd	r24, Z+22	; 0x16
    68ce:	89 17       	cp	r24, r25
    68d0:	58 f4       	brcc	.+22     	; 0x68e8 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    68d2:	8f 81       	ldd	r24, Y+7	; 0x07
    68d4:	98 85       	ldd	r25, Y+8	; 0x08
    68d6:	00 97       	sbiw	r24, 0x00	; 0
    68d8:	21 f0       	breq	.+8      	; 0x68e2 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    68da:	ef 81       	ldd	r30, Y+7	; 0x07
    68dc:	f8 85       	ldd	r31, Y+8	; 0x08
    68de:	81 e0       	ldi	r24, 0x01	; 1
    68e0:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    68e2:	81 e0       	ldi	r24, 0x01	; 1
    68e4:	80 93 6e 06 	sts	0x066E, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    68e8:	28 96       	adiw	r28, 0x08	; 8
    68ea:	0f b6       	in	r0, 0x3f	; 63
    68ec:	f8 94       	cli
    68ee:	de bf       	out	0x3e, r29	; 62
    68f0:	0f be       	out	0x3f, r0	; 63
    68f2:	cd bf       	out	0x3d, r28	; 61
    68f4:	cf 91       	pop	r28
    68f6:	df 91       	pop	r29
    68f8:	08 95       	ret

000068fa <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    68fa:	df 93       	push	r29
    68fc:	cf 93       	push	r28
    68fe:	cd b7       	in	r28, 0x3d	; 61
    6900:	de b7       	in	r29, 0x3e	; 62
    6902:	27 97       	sbiw	r28, 0x07	; 7
    6904:	0f b6       	in	r0, 0x3f	; 63
    6906:	f8 94       	cli
    6908:	de bf       	out	0x3e, r29	; 62
    690a:	0f be       	out	0x3f, r0	; 63
    690c:	cd bf       	out	0x3d, r28	; 61
    690e:	9d 83       	std	Y+5, r25	; 0x05
    6910:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    6912:	8c 81       	ldd	r24, Y+4	; 0x04
    6914:	9d 81       	ldd	r25, Y+5	; 0x05
    6916:	00 97       	sbiw	r24, 0x00	; 0
    6918:	39 f4       	brne	.+14     	; 0x6928 <xTaskNotifyStateClear+0x2e>
    691a:	80 91 65 06 	lds	r24, 0x0665
    691e:	90 91 66 06 	lds	r25, 0x0666
    6922:	9f 83       	std	Y+7, r25	; 0x07
    6924:	8e 83       	std	Y+6, r24	; 0x06
    6926:	04 c0       	rjmp	.+8      	; 0x6930 <xTaskNotifyStateClear+0x36>
    6928:	8c 81       	ldd	r24, Y+4	; 0x04
    692a:	9d 81       	ldd	r25, Y+5	; 0x05
    692c:	9f 83       	std	Y+7, r25	; 0x07
    692e:	8e 83       	std	Y+6, r24	; 0x06
    6930:	8e 81       	ldd	r24, Y+6	; 0x06
    6932:	9f 81       	ldd	r25, Y+7	; 0x07
    6934:	9b 83       	std	Y+3, r25	; 0x03
    6936:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    6938:	0f b6       	in	r0, 0x3f	; 63
    693a:	f8 94       	cli
    693c:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    693e:	ea 81       	ldd	r30, Y+2	; 0x02
    6940:	fb 81       	ldd	r31, Y+3	; 0x03
    6942:	85 a1       	ldd	r24, Z+37	; 0x25
    6944:	82 30       	cpi	r24, 0x02	; 2
    6946:	31 f4       	brne	.+12     	; 0x6954 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    6948:	ea 81       	ldd	r30, Y+2	; 0x02
    694a:	fb 81       	ldd	r31, Y+3	; 0x03
    694c:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    694e:	81 e0       	ldi	r24, 0x01	; 1
    6950:	89 83       	std	Y+1, r24	; 0x01
    6952:	01 c0       	rjmp	.+2      	; 0x6956 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    6954:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    6956:	0f 90       	pop	r0
    6958:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    695a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    695c:	27 96       	adiw	r28, 0x07	; 7
    695e:	0f b6       	in	r0, 0x3f	; 63
    6960:	f8 94       	cli
    6962:	de bf       	out	0x3e, r29	; 62
    6964:	0f be       	out	0x3f, r0	; 63
    6966:	cd bf       	out	0x3d, r28	; 61
    6968:	cf 91       	pop	r28
    696a:	df 91       	pop	r29
    696c:	08 95       	ret

0000696e <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    696e:	df 93       	push	r29
    6970:	cf 93       	push	r28
    6972:	cd b7       	in	r28, 0x3d	; 61
    6974:	de b7       	in	r29, 0x3e	; 62
    6976:	27 97       	sbiw	r28, 0x07	; 7
    6978:	0f b6       	in	r0, 0x3f	; 63
    697a:	f8 94       	cli
    697c:	de bf       	out	0x3e, r29	; 62
    697e:	0f be       	out	0x3f, r0	; 63
    6980:	cd bf       	out	0x3d, r28	; 61
    6982:	9e 83       	std	Y+6, r25	; 0x06
    6984:	8d 83       	std	Y+5, r24	; 0x05
    6986:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    6988:	80 91 69 06 	lds	r24, 0x0669
    698c:	90 91 6a 06 	lds	r25, 0x066A
    6990:	9a 83       	std	Y+2, r25	; 0x02
    6992:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6994:	80 91 65 06 	lds	r24, 0x0665
    6998:	90 91 66 06 	lds	r25, 0x0666
    699c:	02 96       	adiw	r24, 0x02	; 2
    699e:	0e 94 30 15 	call	0x2a60	; 0x2a60 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    69a2:	8d 81       	ldd	r24, Y+5	; 0x05
    69a4:	9e 81       	ldd	r25, Y+6	; 0x06
    69a6:	2f ef       	ldi	r18, 0xFF	; 255
    69a8:	8f 3f       	cpi	r24, 0xFF	; 255
    69aa:	92 07       	cpc	r25, r18
    69ac:	81 f4       	brne	.+32     	; 0x69ce <prvAddCurrentTaskToDelayedList+0x60>
    69ae:	8f 81       	ldd	r24, Y+7	; 0x07
    69b0:	88 23       	and	r24, r24
    69b2:	69 f0       	breq	.+26     	; 0x69ce <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    69b4:	80 91 65 06 	lds	r24, 0x0665
    69b8:	90 91 66 06 	lds	r25, 0x0666
    69bc:	9c 01       	movw	r18, r24
    69be:	2e 5f       	subi	r18, 0xFE	; 254
    69c0:	3f 4f       	sbci	r19, 0xFF	; 255
    69c2:	82 ec       	ldi	r24, 0xC2	; 194
    69c4:	96 e0       	ldi	r25, 0x06	; 6
    69c6:	b9 01       	movw	r22, r18
    69c8:	0e 94 80 14 	call	0x2900	; 0x2900 <vListInsertEnd>
    69cc:	43 c0       	rjmp	.+134    	; 0x6a54 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    69ce:	29 81       	ldd	r18, Y+1	; 0x01
    69d0:	3a 81       	ldd	r19, Y+2	; 0x02
    69d2:	8d 81       	ldd	r24, Y+5	; 0x05
    69d4:	9e 81       	ldd	r25, Y+6	; 0x06
    69d6:	82 0f       	add	r24, r18
    69d8:	93 1f       	adc	r25, r19
    69da:	9c 83       	std	Y+4, r25	; 0x04
    69dc:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    69de:	e0 91 65 06 	lds	r30, 0x0665
    69e2:	f0 91 66 06 	lds	r31, 0x0666
    69e6:	8b 81       	ldd	r24, Y+3	; 0x03
    69e8:	9c 81       	ldd	r25, Y+4	; 0x04
    69ea:	93 83       	std	Z+3, r25	; 0x03
    69ec:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    69ee:	2b 81       	ldd	r18, Y+3	; 0x03
    69f0:	3c 81       	ldd	r19, Y+4	; 0x04
    69f2:	89 81       	ldd	r24, Y+1	; 0x01
    69f4:	9a 81       	ldd	r25, Y+2	; 0x02
    69f6:	28 17       	cp	r18, r24
    69f8:	39 07       	cpc	r19, r25
    69fa:	70 f4       	brcc	.+28     	; 0x6a18 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    69fc:	80 91 ae 06 	lds	r24, 0x06AE
    6a00:	90 91 af 06 	lds	r25, 0x06AF
    6a04:	20 91 65 06 	lds	r18, 0x0665
    6a08:	30 91 66 06 	lds	r19, 0x0666
    6a0c:	2e 5f       	subi	r18, 0xFE	; 254
    6a0e:	3f 4f       	sbci	r19, 0xFF	; 255
    6a10:	b9 01       	movw	r22, r18
    6a12:	0e 94 c4 14 	call	0x2988	; 0x2988 <vListInsert>
    6a16:	1e c0       	rjmp	.+60     	; 0x6a54 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6a18:	40 91 ac 06 	lds	r20, 0x06AC
    6a1c:	50 91 ad 06 	lds	r21, 0x06AD
    6a20:	80 91 65 06 	lds	r24, 0x0665
    6a24:	90 91 66 06 	lds	r25, 0x0666
    6a28:	9c 01       	movw	r18, r24
    6a2a:	2e 5f       	subi	r18, 0xFE	; 254
    6a2c:	3f 4f       	sbci	r19, 0xFF	; 255
    6a2e:	ca 01       	movw	r24, r20
    6a30:	b9 01       	movw	r22, r18
    6a32:	0e 94 c4 14 	call	0x2988	; 0x2988 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    6a36:	20 91 71 06 	lds	r18, 0x0671
    6a3a:	30 91 72 06 	lds	r19, 0x0672
    6a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a40:	9c 81       	ldd	r25, Y+4	; 0x04
    6a42:	82 17       	cp	r24, r18
    6a44:	93 07       	cpc	r25, r19
    6a46:	30 f4       	brcc	.+12     	; 0x6a54 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    6a48:	8b 81       	ldd	r24, Y+3	; 0x03
    6a4a:	9c 81       	ldd	r25, Y+4	; 0x04
    6a4c:	90 93 72 06 	sts	0x0672, r25
    6a50:	80 93 71 06 	sts	0x0671, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    6a54:	27 96       	adiw	r28, 0x07	; 7
    6a56:	0f b6       	in	r0, 0x3f	; 63
    6a58:	f8 94       	cli
    6a5a:	de bf       	out	0x3e, r29	; 62
    6a5c:	0f be       	out	0x3f, r0	; 63
    6a5e:	cd bf       	out	0x3d, r28	; 61
    6a60:	cf 91       	pop	r28
    6a62:	df 91       	pop	r29
    6a64:	08 95       	ret

00006a66 <__prologue_saves__>:
    6a66:	2f 92       	push	r2
    6a68:	3f 92       	push	r3
    6a6a:	4f 92       	push	r4
    6a6c:	5f 92       	push	r5
    6a6e:	6f 92       	push	r6
    6a70:	7f 92       	push	r7
    6a72:	8f 92       	push	r8
    6a74:	9f 92       	push	r9
    6a76:	af 92       	push	r10
    6a78:	bf 92       	push	r11
    6a7a:	cf 92       	push	r12
    6a7c:	df 92       	push	r13
    6a7e:	ef 92       	push	r14
    6a80:	ff 92       	push	r15
    6a82:	0f 93       	push	r16
    6a84:	1f 93       	push	r17
    6a86:	cf 93       	push	r28
    6a88:	df 93       	push	r29
    6a8a:	cd b7       	in	r28, 0x3d	; 61
    6a8c:	de b7       	in	r29, 0x3e	; 62
    6a8e:	ca 1b       	sub	r28, r26
    6a90:	db 0b       	sbc	r29, r27
    6a92:	0f b6       	in	r0, 0x3f	; 63
    6a94:	f8 94       	cli
    6a96:	de bf       	out	0x3e, r29	; 62
    6a98:	0f be       	out	0x3f, r0	; 63
    6a9a:	cd bf       	out	0x3d, r28	; 61
    6a9c:	09 94       	ijmp

00006a9e <__epilogue_restores__>:
    6a9e:	2a 88       	ldd	r2, Y+18	; 0x12
    6aa0:	39 88       	ldd	r3, Y+17	; 0x11
    6aa2:	48 88       	ldd	r4, Y+16	; 0x10
    6aa4:	5f 84       	ldd	r5, Y+15	; 0x0f
    6aa6:	6e 84       	ldd	r6, Y+14	; 0x0e
    6aa8:	7d 84       	ldd	r7, Y+13	; 0x0d
    6aaa:	8c 84       	ldd	r8, Y+12	; 0x0c
    6aac:	9b 84       	ldd	r9, Y+11	; 0x0b
    6aae:	aa 84       	ldd	r10, Y+10	; 0x0a
    6ab0:	b9 84       	ldd	r11, Y+9	; 0x09
    6ab2:	c8 84       	ldd	r12, Y+8	; 0x08
    6ab4:	df 80       	ldd	r13, Y+7	; 0x07
    6ab6:	ee 80       	ldd	r14, Y+6	; 0x06
    6ab8:	fd 80       	ldd	r15, Y+5	; 0x05
    6aba:	0c 81       	ldd	r16, Y+4	; 0x04
    6abc:	1b 81       	ldd	r17, Y+3	; 0x03
    6abe:	aa 81       	ldd	r26, Y+2	; 0x02
    6ac0:	b9 81       	ldd	r27, Y+1	; 0x01
    6ac2:	ce 0f       	add	r28, r30
    6ac4:	d1 1d       	adc	r29, r1
    6ac6:	0f b6       	in	r0, 0x3f	; 63
    6ac8:	f8 94       	cli
    6aca:	de bf       	out	0x3e, r29	; 62
    6acc:	0f be       	out	0x3f, r0	; 63
    6ace:	cd bf       	out	0x3d, r28	; 61
    6ad0:	ed 01       	movw	r28, r26
    6ad2:	08 95       	ret

00006ad4 <memcpy>:
    6ad4:	fb 01       	movw	r30, r22
    6ad6:	dc 01       	movw	r26, r24
    6ad8:	02 c0       	rjmp	.+4      	; 0x6ade <memcpy+0xa>
    6ada:	01 90       	ld	r0, Z+
    6adc:	0d 92       	st	X+, r0
    6ade:	41 50       	subi	r20, 0x01	; 1
    6ae0:	50 40       	sbci	r21, 0x00	; 0
    6ae2:	d8 f7       	brcc	.-10     	; 0x6ada <memcpy+0x6>
    6ae4:	08 95       	ret

00006ae6 <memset>:
    6ae6:	dc 01       	movw	r26, r24
    6ae8:	01 c0       	rjmp	.+2      	; 0x6aec <memset+0x6>
    6aea:	6d 93       	st	X+, r22
    6aec:	41 50       	subi	r20, 0x01	; 1
    6aee:	50 40       	sbci	r21, 0x00	; 0
    6af0:	e0 f7       	brcc	.-8      	; 0x6aea <memset+0x4>
    6af2:	08 95       	ret

00006af4 <_exit>:
    6af4:	f8 94       	cli

00006af6 <__stop_program>:
    6af6:	ff cf       	rjmp	.-2      	; 0x6af6 <__stop_program>
